"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[22],{11375:(h,V,i)=>{i.r(V),i.d(V,{ShaderMaterial:()=>n});var S=i(11179),l=i(11382),Y=i(11138),g=i(11220),q=i(11117),B=i(11091),J=i(11450),I=i(10984),v=i(11453),s=i(10988),t=i(11504),T=i(11501);const e={effect:null,subMesh:null};class n extends v.d{constructor(h,V,i){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(h,V,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new Y.Matrix,this._cachedWorldViewProjectionMatrix=new Y.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=i,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...S}}get shaderPath(){return this._shaderPath}set shaderPath(h){this._shaderPath=h}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(h){-1===this._options.uniforms.indexOf(h)&&this._options.uniforms.push(h)}setTexture(h,V){return-1===this._options.samplers.indexOf(h)&&this._options.samplers.push(h),this._textures[h]=V,this}removeTexture(h){delete this._textures[h]}setTextureArray(h,V){return-1===this._options.samplers.indexOf(h)&&this._options.samplers.push(h),this._checkUniform(h),this._textureArrays[h]=V,this}setExternalTexture(h,V){return-1===this._options.externalTextures.indexOf(h)&&this._options.externalTextures.push(h),this._externalTextures[h]=V,this}setFloat(h,V){return this._checkUniform(h),this._floats[h]=V,this}setInt(h,V){return this._checkUniform(h),this._ints[h]=V,this}setUInt(h,V){return this._checkUniform(h),this._uints[h]=V,this}setFloats(h,V){return this._checkUniform(h),this._floatsArrays[h]=V,this}setColor3(h,V){return this._checkUniform(h),this._colors3[h]=V,this}setColor3Array(h,V){return this._checkUniform(h),this._colors3Arrays[h]=V.reduce(((h,V)=>(h.push(V.r,V.g,V.b),h)),[]),this}setColor4(h,V){return this._checkUniform(h),this._colors4[h]=V,this}setColor4Array(h,V){return this._checkUniform(h),this._colors4Arrays[h]=V.reduce(((h,V)=>(h.push(V.r,V.g,V.b,V.a),h)),[]),this}setVector2(h,V){return this._checkUniform(h),this._vectors2[h]=V,this}setVector3(h,V){return this._checkUniform(h),this._vectors3[h]=V,this}setVector4(h,V){return this._checkUniform(h),this._vectors4[h]=V,this}setQuaternion(h,V){return this._checkUniform(h),this._quaternions[h]=V,this}setQuaternionArray(h,V){return this._checkUniform(h),this._quaternionsArrays[h]=V.reduce(((h,V)=>(V.toArray(h,h.length),h)),[]),this}setMatrix(h,V){return this._checkUniform(h),this._matrices[h]=V,this}setMatrices(h,V){this._checkUniform(h);const i=new Float32Array(16*V.length);for(let S=0;S<V.length;S++){V[S].copyToArray(i,16*S)}return this._matrixArrays[h]=i,this}setMatrix3x3(h,V){return this._checkUniform(h),this._matrices3x3[h]=V,this}setMatrix2x2(h,V){return this._checkUniform(h),this._matrices2x2[h]=V,this}setArray2(h,V){return this._checkUniform(h),this._vectors2Arrays[h]=V,this}setArray3(h,V){return this._checkUniform(h),this._vectors3Arrays[h]=V,this}setArray4(h,V){return this._checkUniform(h),this._vectors4Arrays[h]=V,this}setUniformBuffer(h,V){return-1===this._options.uniformBuffers.indexOf(h)&&this._options.uniformBuffers.push(h),this._uniformBuffers[h]=V,this}setTextureSampler(h,V){return-1===this._options.samplerObjects.indexOf(h)&&this._options.samplerObjects.push(h),this._textureSamplers[h]=V,this}setStorageBuffer(h,V){return-1===this._options.storageBuffers.indexOf(h)&&this._options.storageBuffers.push(h),this._storageBuffers[h]=V,this}setDefine(h,V){const i=h.trimEnd()+" ",S=this.options.defines.findIndex((V=>V===h||V.startsWith(i)));return S>=0&&this.options.defines.splice(S,1),("boolean"!==typeof V||V)&&this.options.defines.push(i+V),this}isReadyForSubMesh(h,V,i){return this.isReady(h,i,V)}isReady(h,V,i){var S;const Y=i&&this._storeEffectOnSubMeshes;if(this.isFrozen){const h=Y?i._drawWrapper:this._drawWrapper;if(h.effect&&h._wasPreviouslyReady&&h._wasPreviouslyUsingInstances===V)return!0}const q=this.Mh(),B=q.getEngine(),I=[],v=[];let s=null,n=this._shaderPath,c=this._options.uniforms,f=this._options.uniformBuffers,P=this._options.samplers;B.getCaps().multiview&&q.activeCamera&&q.activeCamera.outputRenderTarget&&q.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,I.push("#define MULTIVIEW"),-1!==c.indexOf("viewProjection")&&-1===c.indexOf("viewProjectionR")&&c.push("viewProjectionR"));for(let l=0;l<this._options.defines.length;l++){const h=0===this._options.defines[l].indexOf("#define")?this._options.defines[l]:`#define ${this._options.defines[l]}`;I.push(h)}for(let l=0;l<this._options.attributes.length;l++)v.push(this._options.attributes[l]);if(h&&h.isVerticesDataPresent(g.h.ColorKind)&&(-1===v.indexOf(g.h.ColorKind)&&v.push(g.h.ColorKind),I.push("#define VERTEXCOLOR")),V&&(I.push("#define INSTANCES"),(0,T.$)(v,this._materialHelperNeedsPreviousMatrices),null!==h&&void 0!==h&&h.hasThinInstances&&(I.push("#define THIN_INSTANCES"),h&&h.isVerticesDataPresent(g.h.ColorInstanceKind)&&(v.push(g.h.ColorInstanceKind),I.push("#define INSTANCESCOLOR")))),h&&h.useBones&&h.computeBonesUsingShaders&&h.skeleton){v.push(g.h.MatricesIndicesKind),v.push(g.h.MatricesWeightsKind),h.numBoneInfluencers>4&&(v.push(g.h.MatricesIndicesExtraKind),v.push(g.h.MatricesWeightsExtraKind));const V=h.skeleton;I.push("#define NUM_BONE_INFLUENCERS "+h.numBoneInfluencers),s=new J.d,s.addCPUSkinningFallback(0,h),V.isUsingTextureForMatrices?(I.push("#define BONETEXTURE"),-1===c.indexOf("boneTextureWidth")&&c.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(I.push("#define BonesPerMesh "+(V.bones.length+1)),-1===c.indexOf("mBones")&&c.push("mBones"))}else I.push("#define NUM_BONE_INFLUENCERS 0");let L=0;const U=h?h.morphTargetManager:null;if(U){const V=-1!==I.indexOf("#define UV1"),i=-1!==I.indexOf("#define UV2"),S=-1!==I.indexOf("#define TANGENT"),l=-1!==I.indexOf("#define NORMAL"),Y=-1!==I.indexOf("#define VERTEXCOLOR");L=(0,T.D)(U,I,v,h,!0,l,S,V,i,Y),U.isUsingTextureForTargets&&(-1===c.indexOf("morphTargetTextureIndices")&&c.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),L>0&&(c=c.slice(),c.push("morphTargetInfluences"),c.push("morphTargetCount"),c.push("morphTargetTextureInfo"),c.push("morphTargetTextureIndices"))}else I.push("#define NUM_MORPH_INFLUENCERS 0");if(h){const V=h.bakedVertexAnimationManager;V&&V.isEnabled&&(I.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===c.indexOf("bakedVertexAnimationSettings")&&c.push("bakedVertexAnimationSettings"),-1===c.indexOf("bakedVertexAnimationTextureSizeInverted")&&c.push("bakedVertexAnimationTextureSizeInverted"),-1===c.indexOf("bakedVertexAnimationTime")&&c.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,T.y)(v,h,I)}for(const l in this._textures)if(!this._textures[l].isReady())return!1;h&&this.needAlphaTestingForMesh(h)&&I.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,t.d)(c),(0,t.o)(this,q,I)),q.fogEnabled&&null!==h&&void 0!==h&&h.applyFog&&q.fogMode!==l.d.FOGMODE_NONE&&(I.push("#define FOG"),-1===c.indexOf("view")&&c.push("view"),-1===c.indexOf("vFogInfos")&&c.push("vFogInfos"),-1===c.indexOf("vFogColor")&&c.push("vFogColor")),this._useLogarithmicDepth&&(I.push("#define LOGARITHMICDEPTH"),-1===c.indexOf("logarithmicDepthConstant")&&c.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(c=c.slice(),f=f.slice(),P=P.slice(),n=this.customShaderNameResolve(this.name,c,f,P,I,v));const X=Y?i._getDrawWrapper(void 0,!0):this._drawWrapper,D=(null===X||void 0===X?void 0:X.effect)??null,O=(null===X||void 0===X?void 0:X.defines)??null,o=I.join("\n");let M=D;return O!==o&&(M=B.createEffect(n,{attributes:v,uniformsNames:c,uniformBuffersNames:f,samplers:P,defines:o,fallbacks:s,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:L},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},B),Y?i.setEffect(M,o,this._materialContext):X&&X.setEffect(M,o),this._onEffectCreatedObservable&&(e.effect=M,e.subMesh=i??(null===h||void 0===h?void 0:h.Gg[0])??null,this._onEffectCreatedObservable.notifyObservers(e))),X._wasPreviouslyUsingInstances=!!V,!(null===(S=M)||void 0===S||!S.isReady())&&(D!==M&&q.resetCachedMaterial(),X._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(h,V){const i=V??this.getEffect();if(!i)return;const S=this._options.uniforms;-1!==S.indexOf("world")&&i.setMatrix("world",h);const l=this.Mh();-1!==S.indexOf("worldView")&&(h.multiplyToRef(l.getViewMatrix(),this._cachedWorldViewMatrix),i.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==S.indexOf("worldViewProjection")&&(h.multiplyToRef(l.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),i.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==S.indexOf("view")&&i.setMatrix("view",l.getViewMatrix())}bindForSubMesh(h,V,i){var S;this.bind(h,V,null===(S=i._drawWrapperOverride)||void 0===S?void 0:S.effect,i)}bind(h,V,i,S){const l=S&&this._storeEffectOnSubMeshes,Y=i??(l?S.effect:this.getEffect());if(!Y)return;const g=this.Mh();this._activeEffect=Y,this.bindOnlyWorldMatrix(h,i);const q=this._options.uniformBuffers;let B=!1;if(Y&&q&&q.length>0&&g.getEngine().supportsUniformBuffers)for(let v=0;v<q.length;++v){switch(q[v]){case"Mesh":V&&(V.getMeshUniformBuffer().bindToEffect(Y,"Mesh"),V.transferToEffect(h));break;case"Scene":(0,T.o)(Y,g.getSceneUniformBuffer()),g.finalizeSceneUbo(),B=!0}}const J=V&&l?this._mustRebind(g,Y,S,V.visibility):g.getCachedMaterial()!==this;if(Y&&J){let h;for(h in B||-1===this._options.uniforms.indexOf("view")||Y.setMatrix("view",g.getViewMatrix()),B||-1===this._options.uniforms.indexOf("projection")||Y.setMatrix("projection",g.getProjectionMatrix()),B||-1===this._options.uniforms.indexOf("viewProjection")||(Y.setMatrix("viewProjection",g.getTransformMatrix()),this._multiview&&Y.setMatrix("viewProjectionR",g._transformMatrixR)),g.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&Y.setVector3("cameraPosition",g.activeCamera.globalPosition),(0,T.b)(V,Y),(0,t.g)(Y,this,g),this._useLogarithmicDepth&&(0,T.j)(l?S.materialDefines:Y.defines,Y,g),V&&(0,T.e)(g,V,Y),this._textures)Y.setTexture(h,this._textures[h]);for(h in this._textureArrays)Y.setTextureArray(h,this._textureArrays[h]);for(h in this._ints)Y.setInt(h,this._ints[h]);for(h in this._uints)Y.setUInt(h,this._uints[h]);for(h in this._floats)Y.setFloat(h,this._floats[h]);for(h in this._floatsArrays)Y.setArray(h,this._floatsArrays[h]);for(h in this._colors3)Y.setColor3(h,this._colors3[h]);for(h in this._colors3Arrays)Y.setArray3(h,this._colors3Arrays[h]);for(h in this._colors4){const V=this._colors4[h];Y.setFloat4(h,V.r,V.g,V.b,V.a)}for(h in this._colors4Arrays)Y.setArray4(h,this._colors4Arrays[h]);for(h in this._vectors2)Y.setVector2(h,this._vectors2[h]);for(h in this._vectors3)Y.setVector3(h,this._vectors3[h]);for(h in this._vectors4)Y.setVector4(h,this._vectors4[h]);for(h in this._quaternions)Y.setQuaternion(h,this._quaternions[h]);for(h in this._matrices)Y.setMatrix(h,this._matrices[h]);for(h in this._matrixArrays)Y.setMatrices(h,this._matrixArrays[h]);for(h in this._matrices3x3)Y.setMatrix3x3(h,this._matrices3x3[h]);for(h in this._matrices2x2)Y.setMatrix2x2(h,this._matrices2x2[h]);for(h in this._vectors2Arrays)Y.setArray2(h,this._vectors2Arrays[h]);for(h in this._vectors3Arrays)Y.setArray3(h,this._vectors3Arrays[h]);for(h in this._vectors4Arrays)Y.setArray4(h,this._vectors4Arrays[h]);for(h in this._quaternionsArrays)Y.setArray4(h,this._quaternionsArrays[h]);for(h in this._uniformBuffers){const V=this._uniformBuffers[h].getBuffer();V&&Y.bindUniformBuffer(V,h)}const i=g.getEngine(),q=i.setExternalTexture;if(q)for(h in this._externalTextures)q.call(i,h,this._externalTextures[h]);const J=i.setTextureSampler;if(J)for(h in this._textureSamplers)J.call(i,h,this._textureSamplers[h]);const I=i.setStorageBuffer;if(I)for(h in this._storageBuffers)I.call(i,h,this._storageBuffers[h])}if(Y&&V&&(J||!this.isFrozen)){(0,T.n)(V,Y),V.morphTargetManager&&V.morphTargetManager.isUsingTextureForTargets&&V.morphTargetManager._bind(Y);const h=V.bakedVertexAnimationManager;if(h&&h.isEnabled){var I;const h=l?S._drawWrapper:this._drawWrapper;null===(I=V.bakedVertexAnimationManager)||void 0===I||I.bind(Y,!!h._wasPreviouslyUsingInstances)}}this._afterBind(V,Y,S)}getActiveTextures(){const h=super.getActiveTextures();for(const V in this._textures)h.push(this._textures[V]);for(const V in this._textureArrays){const i=this._textureArrays[V];for(let V=0;V<i.length;V++)h.push(i[V])}return h}hasTexture(h){if(super.hasTexture(h))return!0;for(const V in this._textures)if(this._textures[V]===h)return!0;for(const V in this._textureArrays){const i=this._textureArrays[V];for(let V=0;V<i.length;V++)if(i[V]===h)return!0}return!1}clone(h){const V=S.d.Clone((()=>new n(h,this.Mh(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);V.name=h,V.id=h,"object"===typeof V._shaderPath&&(V._shaderPath={...V._shaderPath}),this._options={...this._options};const i=Object.keys(this._options);for(const S of i){const h=this._options[S];Array.isArray(h)&&(this._options[S]=h.slice(0))}this.stencil.copyTo(V.stencil);for(const S in this._textures)V.setTexture(S,this._textures[S]);for(const S in this._textureArrays)V.setTextureArray(S,this._textureArrays[S]);for(const S in this._externalTextures)V.setExternalTexture(S,this._externalTextures[S]);for(const S in this._ints)V.setInt(S,this._ints[S]);for(const S in this._uints)V.setUInt(S,this._uints[S]);for(const S in this._floats)V.setFloat(S,this._floats[S]);for(const S in this._floatsArrays)V.setFloats(S,this._floatsArrays[S]);for(const S in this._colors3)V.setColor3(S,this._colors3[S]);for(const S in this._colors3Arrays)V._colors3Arrays[S]=this._colors3Arrays[S];for(const S in this._colors4)V.setColor4(S,this._colors4[S]);for(const S in this._colors4Arrays)V._colors4Arrays[S]=this._colors4Arrays[S];for(const S in this._vectors2)V.setVector2(S,this._vectors2[S]);for(const S in this._vectors3)V.setVector3(S,this._vectors3[S]);for(const S in this._vectors4)V.setVector4(S,this._vectors4[S]);for(const S in this._quaternions)V.setQuaternion(S,this._quaternions[S]);for(const S in this._quaternionsArrays)V._quaternionsArrays[S]=this._quaternionsArrays[S];for(const S in this._matrices)V.setMatrix(S,this._matrices[S]);for(const S in this._matrixArrays)V._matrixArrays[S]=this._matrixArrays[S].slice();for(const S in this._matrices3x3)V.setMatrix3x3(S,this._matrices3x3[S]);for(const S in this._matrices2x2)V.setMatrix2x2(S,this._matrices2x2[S]);for(const S in this._vectors2Arrays)V.setArray2(S,this._vectors2Arrays[S]);for(const S in this._vectors3Arrays)V.setArray3(S,this._vectors3Arrays[S]);for(const S in this._vectors4Arrays)V.setArray4(S,this._vectors4Arrays[S]);for(const S in this._uniformBuffers)V.setUniformBuffer(S,this._uniformBuffers[S]);for(const S in this._textureSamplers)V.setTextureSampler(S,this._textureSamplers[S]);for(const S in this._storageBuffers)V.setStorageBuffer(S,this._storageBuffers[S]);return V}dispose(h,V,i){if(V){let h;for(h in this._textures)this._textures[h].dispose();for(h in this._textureArrays){const V=this._textureArrays[h];for(let h=0;h<V.length;h++)V[h].dispose()}}this._textures={},super.dispose(h,V,i)}serialize(){const h=S.d.Serialize(this);let V;for(V in h.customType="BABYLON.ShaderMaterial",h.uniqueId=this.uniqueId,h.options=this._options,h.shaderPath=this._shaderPath,h.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,h.stencil=this.stencil.serialize(),h.textures={},this._textures)h.textures[V]=this._textures[V].serialize();for(V in h.textureArrays={},this._textureArrays){h.textureArrays[V]=[];const i=this._textureArrays[V];for(let S=0;S<i.length;S++)h.textureArrays[V].push(i[S].serialize())}for(V in h.ints={},this._ints)h.ints[V]=this._ints[V];for(V in h.uints={},this._uints)h.uints[V]=this._uints[V];for(V in h.floats={},this._floats)h.floats[V]=this._floats[V];for(V in h.floatsArrays={},this._floatsArrays)h.floatsArrays[V]=this._floatsArrays[V];for(V in h.colors3={},this._colors3){const i=this._colors3[V];h.colors3[V]=[i.r,i.g,i.b]}for(V in h.colors3Arrays={},this._colors3Arrays)h.colors3Arrays[V]=this._colors3Arrays[V];for(V in h.colors4={},this._colors4){const i=this._colors4[V];h.colors4[V]=[i.r,i.g,i.b,i.a]}for(V in h.colors4Arrays={},this._colors4Arrays)h.colors4Arrays[V]=this._colors4Arrays[V];for(V in h.vectors2={},this._vectors2){const i=this._vectors2[V];h.vectors2[V]=[i.x,i.y]}for(V in h.vectors3={},this._vectors3){const i=this._vectors3[V];h.vectors3[V]=[i.x,i.y,i.z]}for(V in h.vectors4={},this._vectors4){const i=this._vectors4[V];h.vectors4[V]=[i.x,i.y,i.z,i.w]}for(V in h.quaternions={},this._quaternions)h.quaternions[V]=this._quaternions[V].Ng();for(V in h.matrices={},this._matrices)h.matrices[V]=this._matrices[V].Ng();for(V in h.matrixArray={},this._matrixArrays)h.matrixArray[V]=this._matrixArrays[V];for(V in h.matrices3x3={},this._matrices3x3)h.matrices3x3[V]=this._matrices3x3[V];for(V in h.matrices2x2={},this._matrices2x2)h.matrices2x2[V]=this._matrices2x2[V];for(V in h.vectors2Arrays={},this._vectors2Arrays)h.vectors2Arrays[V]=this._vectors2Arrays[V];for(V in h.vectors3Arrays={},this._vectors3Arrays)h.vectors3Arrays[V]=this._vectors3Arrays[V];for(V in h.vectors4Arrays={},this._vectors4Arrays)h.vectors4Arrays[V]=this._vectors4Arrays[V];for(V in h.quaternionsArrays={},this._quaternionsArrays)h.quaternionsArrays[V]=this._quaternionsArrays[V];return h}static Parse(h,V,i){const l=S.d.Parse((()=>new n(h.name,V,h.shaderPath,h.options,h.storeEffectOnSubMeshes)),h,V,i);let g;for(g in h.stencil&&l.stencil.parse(h.stencil,V,i),h.textures)l.setTexture(g,q.d.Parse(h.textures[g],V,i));for(g in h.textureArrays){const S=h.textureArrays[g],Y=[];for(let h=0;h<S.length;h++)Y.push(q.d.Parse(S[h],V,i));l.setTextureArray(g,Y)}for(g in h.ints)l.setInt(g,h.ints[g]);for(g in h.uints)l.setUInt(g,h.uints[g]);for(g in h.floats)l.setFloat(g,h.floats[g]);for(g in h.floatsArrays)l.setFloats(g,h.floatsArrays[g]);for(g in h.colors3){const V=h.colors3[g];l.setColor3(g,{r:V[0],g:V[1],b:V[2]})}for(g in h.colors3Arrays){const V=h.colors3Arrays[g].reduce(((h,V,i)=>(i%3===0?h.push([V]):h[h.length-1].push(V),h)),[]).map((h=>({r:h[0],g:h[1],b:h[2]})));l.setColor3Array(g,V)}for(g in h.colors4){const V=h.colors4[g];l.setColor4(g,{r:V[0],g:V[1],b:V[2],a:V[3]})}for(g in h.colors4Arrays){const V=h.colors4Arrays[g].reduce(((h,V,i)=>(i%4===0?h.push([V]):h[h.length-1].push(V),h)),[]).map((h=>({r:h[0],g:h[1],b:h[2],a:h[3]})));l.setColor4Array(g,V)}for(g in h.vectors2){const V=h.vectors2[g];l.setVector2(g,{x:V[0],y:V[1]})}for(g in h.vectors3){const V=h.vectors3[g];l.setVector3(g,{x:V[0],y:V[1],z:V[2]})}for(g in h.vectors4){const V=h.vectors4[g];l.setVector4(g,{x:V[0],y:V[1],z:V[2],w:V[3]})}for(g in h.quaternions)l.setQuaternion(g,Y.Quaternion.UV(h.quaternions[g]));for(g in h.matrices)l.setMatrix(g,Y.Matrix.UV(h.matrices[g]));for(g in h.matrixArray)l._matrixArrays[g]=new Float32Array(h.matrixArray[g]);for(g in h.matrices3x3)l.setMatrix3x3(g,h.matrices3x3[g]);for(g in h.matrices2x2)l.setMatrix2x2(g,h.matrices2x2[g]);for(g in h.vectors2Arrays)l.setArray2(g,h.vectors2Arrays[g]);for(g in h.vectors3Arrays)l.setArray3(g,h.vectors3Arrays[g]);for(g in h.vectors4Arrays)l.setArray4(g,h.vectors4Arrays[g]);for(g in h.quaternionsArrays)l.setArray4(g,h.quaternionsArrays[g]);return l}static async ParseFromFileAsync(h,V,i){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((l,Y)=>{const g=new I.c;g.addEventListener("readystatechange",(()=>{if(4==g.readyState)if(200==g.status){const V=JSON.parse(g.responseText),Y=this.Parse(V,i||s.d.LastCreatedScene,S);h&&(Y.name=h),l(Y)}else Y("Unable to load the ShaderMaterial")})),g.open("GET",V),g.send()}))}static async ParseFromSnippetAsync(h,V){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((S,l)=>{const Y=new I.c;Y.addEventListener("readystatechange",(()=>{if(4==Y.readyState)if(200==Y.status){const l=JSON.parse(JSON.parse(Y.responseText).jsonPayload),g=JSON.parse(l.shaderMaterial),q=this.Parse(g,V||s.d.LastCreatedScene,i);q.snippetId=h,S(q)}else l("Unable to load the snippet "+h)})),Y.open("GET",this.SnippetUrl+"/"+h.replace(/#/g,"/")),Y.send()}))}}n.SnippetUrl="https://snippet.babylonjs.com",n.CreateFromSnippetAsync=n.ParseFromSnippetAsync,(0,B.f)("BABYLON.ShaderMaterial",n)}}]);