"use strict";(self.h6ljd275xwr=self.h6ljd275xwr||[]).push([[22],{11549:(n,y,H)=>{H.r(y),H.d(y,{ShaderMaterial:()=>z});var o=H(11325),G=H(11554),h=H(11288),k=H(11360),i=H(11269),B=H(11248),V=H(11642),q=H(11140),b=H(11649),A=H(11149),U=H(11710),T=H(11705);const W={effect:null,subMesh:null};class z extends b.d{constructor(n,y,H){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(n,y,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new h.Matrix,this._cachedWorldViewProjectionMatrix=new h.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=H,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...o}}get shaderPath(){return this._shaderPath}set shaderPath(n){this._shaderPath=n}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(n){-1===this._options.uniforms.indexOf(n)&&this._options.uniforms.push(n)}setTexture(n,y){return-1===this._options.samplers.indexOf(n)&&this._options.samplers.push(n),this._textures[n]=y,this}removeTexture(n){delete this._textures[n]}setTextureArray(n,y){return-1===this._options.samplers.indexOf(n)&&this._options.samplers.push(n),this._checkUniform(n),this._textureArrays[n]=y,this}setExternalTexture(n,y){return-1===this._options.externalTextures.indexOf(n)&&this._options.externalTextures.push(n),this._externalTextures[n]=y,this}setFloat(n,y){return this._checkUniform(n),this._floats[n]=y,this}setInt(n,y){return this._checkUniform(n),this._ints[n]=y,this}setUInt(n,y){return this._checkUniform(n),this._uints[n]=y,this}setFloats(n,y){return this._checkUniform(n),this._floatsArrays[n]=y,this}setColor3(n,y){return this._checkUniform(n),this._colors3[n]=y,this}setColor3Array(n,y){return this._checkUniform(n),this._colors3Arrays[n]=y.reduce(((n,y)=>(n.push(y.r,y.g,y.b),n)),[]),this}setColor4(n,y){return this._checkUniform(n),this._colors4[n]=y,this}setColor4Array(n,y){return this._checkUniform(n),this._colors4Arrays[n]=y.reduce(((n,y)=>(n.push(y.r,y.g,y.b,y.a),n)),[]),this}setVector2(n,y){return this._checkUniform(n),this._vectors2[n]=y,this}setVector3(n,y){return this._checkUniform(n),this._vectors3[n]=y,this}setVector4(n,y){return this._checkUniform(n),this._vectors4[n]=y,this}setQuaternion(n,y){return this._checkUniform(n),this._quaternions[n]=y,this}setQuaternionArray(n,y){return this._checkUniform(n),this._quaternionsArrays[n]=y.reduce(((n,y)=>(y.toArray(n,n.length),n)),[]),this}setMatrix(n,y){return this._checkUniform(n),this._matrices[n]=y,this}setMatrices(n,y){this._checkUniform(n);const H=new Float32Array(16*y.length);for(let o=0;o<y.length;o++){y[o].copyToArray(H,16*o)}return this._matrixArrays[n]=H,this}setMatrix3x3(n,y){return this._checkUniform(n),this._matrices3x3[n]=y,this}setMatrix2x2(n,y){return this._checkUniform(n),this._matrices2x2[n]=y,this}setArray2(n,y){return this._checkUniform(n),this._vectors2Arrays[n]=y,this}setArray3(n,y){return this._checkUniform(n),this._vectors3Arrays[n]=y,this}setArray4(n,y){return this._checkUniform(n),this._vectors4Arrays[n]=y,this}setUniformBuffer(n,y){return-1===this._options.uniformBuffers.indexOf(n)&&this._options.uniformBuffers.push(n),this._uniformBuffers[n]=y,this}setTextureSampler(n,y){return-1===this._options.samplerObjects.indexOf(n)&&this._options.samplerObjects.push(n),this._textureSamplers[n]=y,this}setStorageBuffer(n,y){return-1===this._options.storageBuffers.indexOf(n)&&this._options.storageBuffers.push(n),this._storageBuffers[n]=y,this}setDefine(n,y){const H=n.trimEnd()+" ",o=this.options.defines.findIndex((y=>y===n||y.startsWith(H)));return o>=0&&this.options.defines.splice(o,1),("boolean"!==typeof y||y)&&this.options.defines.push(H+y),this}isReadyForSubMesh(n,y,H){return this.isReady(n,H,y)}isReady(n,y,H){var o;const h=H&&this._storeEffectOnSubMeshes;if(this.isFrozen){const n=h?H._drawWrapper:this._drawWrapper;if(n.effect&&n._wasPreviouslyReady&&n._wasPreviouslyUsingInstances===y)return!0}const i=this.pn(),B=i.getEngine(),q=[],b=[];let A=null,z=this._shaderPath,Q=this._options.uniforms,l=this._options.uniformBuffers,v=this._options.samplers;B.getCaps().multiview&&i.activeCamera&&i.activeCamera.outputRenderTarget&&i.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,q.push("#define MULTIVIEW"),-1!==Q.indexOf("viewProjection")&&-1===Q.indexOf("viewProjectionR")&&Q.push("viewProjectionR"));for(let G=0;G<this._options.defines.length;G++){const n=0===this._options.defines[G].indexOf("#define")?this._options.defines[G]:`#define ${this._options.defines[G]}`;q.push(n)}for(let G=0;G<this._options.attributes.length;G++)b.push(this._options.attributes[G]);if(n&&n.isVerticesDataPresent(k.g.ColorKind)&&(-1===b.indexOf(k.g.ColorKind)&&b.push(k.g.ColorKind),q.push("#define VERTEXCOLOR")),y&&(q.push("#define INSTANCES"),(0,T.cb)(b,this._materialHelperNeedsPreviousMatrices),null!==n&&void 0!==n&&n.hasThinInstances&&(q.push("#define THIN_INSTANCES"),n&&n.isVerticesDataPresent(k.g.ColorInstanceKind)&&(b.push(k.g.ColorInstanceKind),q.push("#define INSTANCESCOLOR")))),n&&n.useBones&&n.computeBonesUsingShaders&&n.skeleton){b.push(k.g.MatricesIndicesKind),b.push(k.g.MatricesWeightsKind),n.numBoneInfluencers>4&&(b.push(k.g.MatricesIndicesExtraKind),b.push(k.g.MatricesWeightsExtraKind));const y=n.skeleton;q.push("#define NUM_BONE_INFLUENCERS "+n.numBoneInfluencers),A=new V.b,A.addCPUSkinningFallback(0,n),y.isUsingTextureForMatrices?(q.push("#define BONETEXTURE"),-1===Q.indexOf("boneTextureWidth")&&Q.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(q.push("#define BonesPerMesh "+(y.bones.length+1)),-1===Q.indexOf("mBones")&&Q.push("mBones"))}else q.push("#define NUM_BONE_INFLUENCERS 0");let F=0;const g=n?n.morphTargetManager:null;if(g){const y=-1!==q.indexOf("#define UV1"),H=-1!==q.indexOf("#define UV2"),o=-1!==q.indexOf("#define TANGENT"),G=-1!==q.indexOf("#define NORMAL"),h=-1!==q.indexOf("#define VERTEXCOLOR");F=(0,T.I)(g,q,b,n,!0,G,o,y,H,h),g.isUsingTextureForTargets&&(-1===Q.indexOf("morphTargetTextureIndices")&&Q.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),F>0&&(Q=Q.slice(),Q.push("morphTargetInfluences"),Q.push("morphTargetCount"),Q.push("morphTargetTextureInfo"),Q.push("morphTargetTextureIndices"))}else q.push("#define NUM_MORPH_INFLUENCERS 0");if(n){const y=n.bakedVertexAnimationManager;y&&y.isEnabled&&(q.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===Q.indexOf("bakedVertexAnimationSettings")&&Q.push("bakedVertexAnimationSettings"),-1===Q.indexOf("bakedVertexAnimationTextureSizeInverted")&&Q.push("bakedVertexAnimationTextureSizeInverted"),-1===Q.indexOf("bakedVertexAnimationTime")&&Q.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,T.x)(b,n,q)}for(const G in this._textures)if(!this._textures[G].isReady())return!1;n&&this.needAlphaTestingForMesh(n)&&q.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,U.d)(Q),(0,U.o)(this,i,q)),i.fogEnabled&&null!==n&&void 0!==n&&n.applyFog&&i.fogMode!==G.e.FOGMODE_NONE&&(q.push("#define FOG"),-1===Q.indexOf("view")&&Q.push("view"),-1===Q.indexOf("vFogInfos")&&Q.push("vFogInfos"),-1===Q.indexOf("vFogColor")&&Q.push("vFogColor")),this._useLogarithmicDepth&&(q.push("#define LOGARITHMICDEPTH"),-1===Q.indexOf("logarithmicDepthConstant")&&Q.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(Q=Q.slice(),l=l.slice(),v=v.slice(),z=this.customShaderNameResolve(this.name,Q,l,v,q,b));const M=h?H._getDrawWrapper(void 0,!0):this._drawWrapper,f=(null===M||void 0===M?void 0:M.effect)??null,c=(null===M||void 0===M?void 0:M.defines)??null,p=q.join("\n");let E=f;return c!==p&&(E=B.createEffect(z,{attributes:b,uniformsNames:Q,uniformBuffersNames:l,samplers:v,defines:p,fallbacks:A,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:F},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},B),h?H.setEffect(E,p,this._materialContext):M&&M.setEffect(E,p),this._onEffectCreatedObservable&&(W.effect=E,W.subMesh=H??(null===n||void 0===n?void 0:n.Lh[0])??null,this._onEffectCreatedObservable.notifyObservers(W))),M._wasPreviouslyUsingInstances=!!y,!(null===(o=E)||void 0===o||!o.isReady())&&(f!==E&&i.resetCachedMaterial(),M._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(n,y){const H=y??this.getEffect();if(!H)return;const o=this._options.uniforms;-1!==o.indexOf("world")&&H.setMatrix("world",n);const G=this.pn();-1!==o.indexOf("worldView")&&(n.multiplyToRef(G.getViewMatrix(),this._cachedWorldViewMatrix),H.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==o.indexOf("worldViewProjection")&&(n.multiplyToRef(G.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),H.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==o.indexOf("view")&&H.setMatrix("view",G.getViewMatrix())}bindForSubMesh(n,y,H){var o;this.bind(n,y,null===(o=H._drawWrapperOverride)||void 0===o?void 0:o.effect,H)}bind(n,y,H,o){const G=o&&this._storeEffectOnSubMeshes,h=H??(G?o.effect:this.getEffect());if(!h)return;const k=this.pn();this._activeEffect=h,this.bindOnlyWorldMatrix(n,H);const i=this._options.uniformBuffers;let B=!1;if(h&&i&&i.length>0&&k.getEngine().supportsUniformBuffers)for(let b=0;b<i.length;++b){switch(i[b]){case"Mesh":y&&(y.getMeshUniformBuffer().bindToEffect(h,"Mesh"),y.transferToEffect(n));break;case"Scene":(0,T.o)(h,k.getSceneUniformBuffer()),k.finalizeSceneUbo(),B=!0}}const V=y&&G?this._mustRebind(k,h,o,y.visibility):k.getCachedMaterial()!==this;if(h&&V){let n;for(n in B||-1===this._options.uniforms.indexOf("view")||h.setMatrix("view",k.getViewMatrix()),B||-1===this._options.uniforms.indexOf("projection")||h.setMatrix("projection",k.getProjectionMatrix()),B||-1===this._options.uniforms.indexOf("viewProjection")||(h.setMatrix("viewProjection",k.getTransformMatrix()),this._multiview&&h.setMatrix("viewProjectionR",k._transformMatrixR)),k.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&h.setVector3("cameraPosition",k.activeCamera.globalPosition),(0,T.c)(y,h),(0,U.h)(h,this,k),this._useLogarithmicDepth&&(0,T.m)(G?o.materialDefines:h.defines,h,k),y&&(0,T.g)(k,y,h),this._textures)h.setTexture(n,this._textures[n]);for(n in this._textureArrays)h.setTextureArray(n,this._textureArrays[n]);for(n in this._ints)h.setInt(n,this._ints[n]);for(n in this._uints)h.setUInt(n,this._uints[n]);for(n in this._floats)h.setFloat(n,this._floats[n]);for(n in this._floatsArrays)h.setArray(n,this._floatsArrays[n]);for(n in this._colors3)h.setColor3(n,this._colors3[n]);for(n in this._colors3Arrays)h.setArray3(n,this._colors3Arrays[n]);for(n in this._colors4){const y=this._colors4[n];h.setFloat4(n,y.r,y.g,y.b,y.a)}for(n in this._colors4Arrays)h.setArray4(n,this._colors4Arrays[n]);for(n in this._vectors2)h.setVector2(n,this._vectors2[n]);for(n in this._vectors3)h.setVector3(n,this._vectors3[n]);for(n in this._vectors4)h.setVector4(n,this._vectors4[n]);for(n in this._quaternions)h.setQuaternion(n,this._quaternions[n]);for(n in this._matrices)h.setMatrix(n,this._matrices[n]);for(n in this._matrixArrays)h.setMatrices(n,this._matrixArrays[n]);for(n in this._matrices3x3)h.setMatrix3x3(n,this._matrices3x3[n]);for(n in this._matrices2x2)h.setMatrix2x2(n,this._matrices2x2[n]);for(n in this._vectors2Arrays)h.setArray2(n,this._vectors2Arrays[n]);for(n in this._vectors3Arrays)h.setArray3(n,this._vectors3Arrays[n]);for(n in this._vectors4Arrays)h.setArray4(n,this._vectors4Arrays[n]);for(n in this._quaternionsArrays)h.setArray4(n,this._quaternionsArrays[n]);for(n in this._uniformBuffers){const y=this._uniformBuffers[n].getBuffer();y&&h.bindUniformBuffer(y,n)}const H=k.getEngine(),i=H.setExternalTexture;if(i)for(n in this._externalTextures)i.call(H,n,this._externalTextures[n]);const V=H.setTextureSampler;if(V)for(n in this._textureSamplers)V.call(H,n,this._textureSamplers[n]);const q=H.setStorageBuffer;if(q)for(n in this._storageBuffers)q.call(H,n,this._storageBuffers[n])}if(h&&y&&(V||!this.isFrozen)){(0,T.n)(y,h),y.morphTargetManager&&y.morphTargetManager.isUsingTextureForTargets&&y.morphTargetManager._bind(h);const n=y.bakedVertexAnimationManager;if(n&&n.isEnabled){var q;const n=G?o._drawWrapper:this._drawWrapper;null===(q=y.bakedVertexAnimationManager)||void 0===q||q.bind(h,!!n._wasPreviouslyUsingInstances)}}this._afterBind(y,h,o)}getActiveTextures(){const n=super.getActiveTextures();for(const y in this._textures)n.push(this._textures[y]);for(const y in this._textureArrays){const H=this._textureArrays[y];for(let y=0;y<H.length;y++)n.push(H[y])}return n}hasTexture(n){if(super.hasTexture(n))return!0;for(const y in this._textures)if(this._textures[y]===n)return!0;for(const y in this._textureArrays){const H=this._textureArrays[y];for(let y=0;y<H.length;y++)if(H[y]===n)return!0}return!1}clone(n){const y=o.c.Clone((()=>new z(n,this.pn(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);y.name=n,y.id=n,"object"===typeof y._shaderPath&&(y._shaderPath={...y._shaderPath}),this._options={...this._options};const H=Object.keys(this._options);for(const o of H){const n=this._options[o];Array.isArray(n)&&(this._options[o]=n.slice(0))}this.stencil.copyTo(y.stencil);for(const o in this._textures)y.setTexture(o,this._textures[o]);for(const o in this._textureArrays)y.setTextureArray(o,this._textureArrays[o]);for(const o in this._externalTextures)y.setExternalTexture(o,this._externalTextures[o]);for(const o in this._ints)y.setInt(o,this._ints[o]);for(const o in this._uints)y.setUInt(o,this._uints[o]);for(const o in this._floats)y.setFloat(o,this._floats[o]);for(const o in this._floatsArrays)y.setFloats(o,this._floatsArrays[o]);for(const o in this._colors3)y.setColor3(o,this._colors3[o]);for(const o in this._colors3Arrays)y._colors3Arrays[o]=this._colors3Arrays[o];for(const o in this._colors4)y.setColor4(o,this._colors4[o]);for(const o in this._colors4Arrays)y._colors4Arrays[o]=this._colors4Arrays[o];for(const o in this._vectors2)y.setVector2(o,this._vectors2[o]);for(const o in this._vectors3)y.setVector3(o,this._vectors3[o]);for(const o in this._vectors4)y.setVector4(o,this._vectors4[o]);for(const o in this._quaternions)y.setQuaternion(o,this._quaternions[o]);for(const o in this._quaternionsArrays)y._quaternionsArrays[o]=this._quaternionsArrays[o];for(const o in this._matrices)y.setMatrix(o,this._matrices[o]);for(const o in this._matrixArrays)y._matrixArrays[o]=this._matrixArrays[o].slice();for(const o in this._matrices3x3)y.setMatrix3x3(o,this._matrices3x3[o]);for(const o in this._matrices2x2)y.setMatrix2x2(o,this._matrices2x2[o]);for(const o in this._vectors2Arrays)y.setArray2(o,this._vectors2Arrays[o]);for(const o in this._vectors3Arrays)y.setArray3(o,this._vectors3Arrays[o]);for(const o in this._vectors4Arrays)y.setArray4(o,this._vectors4Arrays[o]);for(const o in this._uniformBuffers)y.setUniformBuffer(o,this._uniformBuffers[o]);for(const o in this._textureSamplers)y.setTextureSampler(o,this._textureSamplers[o]);for(const o in this._storageBuffers)y.setStorageBuffer(o,this._storageBuffers[o]);return y}dispose(n,y,H){if(y){let n;for(n in this._textures)this._textures[n].dispose();for(n in this._textureArrays){const y=this._textureArrays[n];for(let n=0;n<y.length;n++)y[n].dispose()}}this._textures={},super.dispose(n,y,H)}serialize(){const n=o.c.Serialize(this);let y;for(y in n.customType="BABYLON.ShaderMaterial",n.uniqueId=this.uniqueId,n.options=this._options,n.shaderPath=this._shaderPath,n.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,n.stencil=this.stencil.serialize(),n.textures={},this._textures)n.textures[y]=this._textures[y].serialize();for(y in n.textureArrays={},this._textureArrays){n.textureArrays[y]=[];const H=this._textureArrays[y];for(let o=0;o<H.length;o++)n.textureArrays[y].push(H[o].serialize())}for(y in n.ints={},this._ints)n.ints[y]=this._ints[y];for(y in n.uints={},this._uints)n.uints[y]=this._uints[y];for(y in n.floats={},this._floats)n.floats[y]=this._floats[y];for(y in n.floatsArrays={},this._floatsArrays)n.floatsArrays[y]=this._floatsArrays[y];for(y in n.colors3={},this._colors3){const H=this._colors3[y];n.colors3[y]=[H.r,H.g,H.b]}for(y in n.colors3Arrays={},this._colors3Arrays)n.colors3Arrays[y]=this._colors3Arrays[y];for(y in n.colors4={},this._colors4){const H=this._colors4[y];n.colors4[y]=[H.r,H.g,H.b,H.a]}for(y in n.colors4Arrays={},this._colors4Arrays)n.colors4Arrays[y]=this._colors4Arrays[y];for(y in n.vectors2={},this._vectors2){const H=this._vectors2[y];n.vectors2[y]=[H.x,H.y]}for(y in n.vectors3={},this._vectors3){const H=this._vectors3[y];n.vectors3[y]=[H.x,H.y,H.z]}for(y in n.vectors4={},this._vectors4){const H=this._vectors4[y];n.vectors4[y]=[H.x,H.y,H.z,H.w]}for(y in n.quaternions={},this._quaternions)n.quaternions[y]=this._quaternions[y].Ui();for(y in n.matrices={},this._matrices)n.matrices[y]=this._matrices[y].Ui();for(y in n.matrixArray={},this._matrixArrays)n.matrixArray[y]=this._matrixArrays[y];for(y in n.matrices3x3={},this._matrices3x3)n.matrices3x3[y]=this._matrices3x3[y];for(y in n.matrices2x2={},this._matrices2x2)n.matrices2x2[y]=this._matrices2x2[y];for(y in n.vectors2Arrays={},this._vectors2Arrays)n.vectors2Arrays[y]=this._vectors2Arrays[y];for(y in n.vectors3Arrays={},this._vectors3Arrays)n.vectors3Arrays[y]=this._vectors3Arrays[y];for(y in n.vectors4Arrays={},this._vectors4Arrays)n.vectors4Arrays[y]=this._vectors4Arrays[y];for(y in n.quaternionsArrays={},this._quaternionsArrays)n.quaternionsArrays[y]=this._quaternionsArrays[y];return n}static Parse(n,y,H){const G=o.c.Parse((()=>new z(n.name,y,n.shaderPath,n.options,n.storeEffectOnSubMeshes)),n,y,H);let k;for(k in n.stencil&&G.stencil.parse(n.stencil,y,H),n.textures)G.setTexture(k,i.b.Parse(n.textures[k],y,H));for(k in n.textureArrays){const o=n.textureArrays[k],h=[];for(let n=0;n<o.length;n++)h.push(i.b.Parse(o[n],y,H));G.setTextureArray(k,h)}for(k in n.ints)G.setInt(k,n.ints[k]);for(k in n.uints)G.setUInt(k,n.uints[k]);for(k in n.floats)G.setFloat(k,n.floats[k]);for(k in n.floatsArrays)G.setFloats(k,n.floatsArrays[k]);for(k in n.colors3){const y=n.colors3[k];G.setColor3(k,{r:y[0],g:y[1],b:y[2]})}for(k in n.colors3Arrays){const y=n.colors3Arrays[k].reduce(((n,y,H)=>(H%3===0?n.push([y]):n[n.length-1].push(y),n)),[]).map((n=>({r:n[0],g:n[1],b:n[2]})));G.setColor3Array(k,y)}for(k in n.colors4){const y=n.colors4[k];G.setColor4(k,{r:y[0],g:y[1],b:y[2],a:y[3]})}for(k in n.colors4Arrays){const y=n.colors4Arrays[k].reduce(((n,y,H)=>(H%4===0?n.push([y]):n[n.length-1].push(y),n)),[]).map((n=>({r:n[0],g:n[1],b:n[2],a:n[3]})));G.setColor4Array(k,y)}for(k in n.vectors2){const y=n.vectors2[k];G.setVector2(k,{x:y[0],y:y[1]})}for(k in n.vectors3){const y=n.vectors3[k];G.setVector3(k,{x:y[0],y:y[1],z:y[2]})}for(k in n.vectors4){const y=n.vectors4[k];G.setVector4(k,{x:y[0],y:y[1],z:y[2],w:y[3]})}for(k in n.quaternions)G.setQuaternion(k,h.Quaternion.gy(n.quaternions[k]));for(k in n.matrices)G.setMatrix(k,h.Matrix.gy(n.matrices[k]));for(k in n.matrixArray)G._matrixArrays[k]=new Float32Array(n.matrixArray[k]);for(k in n.matrices3x3)G.setMatrix3x3(k,n.matrices3x3[k]);for(k in n.matrices2x2)G.setMatrix2x2(k,n.matrices2x2[k]);for(k in n.vectors2Arrays)G.setArray2(k,n.vectors2Arrays[k]);for(k in n.vectors3Arrays)G.setArray3(k,n.vectors3Arrays[k]);for(k in n.vectors4Arrays)G.setArray4(k,n.vectors4Arrays[k]);for(k in n.quaternionsArrays)G.setArray4(k,n.quaternionsArrays[k]);return G}static async ParseFromFileAsync(n,y,H){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((G,h)=>{const k=new q.b;k.addEventListener("readystatechange",(()=>{if(4==k.readyState)if(200==k.status){const y=JSON.parse(k.responseText),h=this.Parse(y,H||A.c.LastCreatedScene,o);n&&(h.name=n),G(h)}else h("Unable to load the ShaderMaterial")})),k.open("GET",y),k.send()}))}static async ParseFromSnippetAsync(n,y){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((o,G)=>{const h=new q.b;h.addEventListener("readystatechange",(()=>{if(4==h.readyState)if(200==h.status){const G=JSON.parse(JSON.parse(h.responseText).jsonPayload),k=JSON.parse(G.shaderMaterial),i=this.Parse(k,y||A.c.LastCreatedScene,H);i.snippetId=n,o(i)}else G("Unable to load the snippet "+n)})),h.open("GET",this.SnippetUrl+"/"+n.replace(/#/g,"/")),h.send()}))}}z.SnippetUrl="https://snippet.babylonjs.com",z.CreateFromSnippetAsync=z.ParseFromSnippetAsync,(0,B.h)("BABYLON.ShaderMaterial",z)}}]);