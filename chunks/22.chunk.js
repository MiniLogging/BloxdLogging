"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[22],{11534:(F,b,Q)=>{Q.r(b),Q.d(b,{ShaderMaterial:()=>c});var C=Q(11349),z=Q(11537),t=Q(11309),g=Q(11372),W=Q(11287),Z=Q(11265),q=Q(11600),G=Q(11159),K=Q(11602),e=Q(11161),N=Q(11655),y=Q(11650);const E={effect:null,subMesh:null};class c extends K.c{constructor(F,b,Q){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(F,b,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new t.Matrix,this._cachedWorldViewProjectionMatrix=new t.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=Q,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...C}}get shaderPath(){return this._shaderPath}set shaderPath(F){this._shaderPath=F}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(F){-1===this._options.uniforms.indexOf(F)&&this._options.uniforms.push(F)}setTexture(F,b){return-1===this._options.samplers.indexOf(F)&&this._options.samplers.push(F),this._textures[F]=b,this}removeTexture(F){delete this._textures[F]}setTextureArray(F,b){return-1===this._options.samplers.indexOf(F)&&this._options.samplers.push(F),this._checkUniform(F),this._textureArrays[F]=b,this}setExternalTexture(F,b){return-1===this._options.externalTextures.indexOf(F)&&this._options.externalTextures.push(F),this._externalTextures[F]=b,this}setFloat(F,b){return this._checkUniform(F),this._floats[F]=b,this}setInt(F,b){return this._checkUniform(F),this._ints[F]=b,this}setUInt(F,b){return this._checkUniform(F),this._uints[F]=b,this}setFloats(F,b){return this._checkUniform(F),this._floatsArrays[F]=b,this}setColor3(F,b){return this._checkUniform(F),this._colors3[F]=b,this}setColor3Array(F,b){return this._checkUniform(F),this._colors3Arrays[F]=b.reduce(((F,b)=>(F.push(b.r,b.g,b.b),F)),[]),this}setColor4(F,b){return this._checkUniform(F),this._colors4[F]=b,this}setColor4Array(F,b){return this._checkUniform(F),this._colors4Arrays[F]=b.reduce(((F,b)=>(F.push(b.r,b.g,b.b,b.a),F)),[]),this}setVector2(F,b){return this._checkUniform(F),this._vectors2[F]=b,this}setVector3(F,b){return this._checkUniform(F),this._vectors3[F]=b,this}setVector4(F,b){return this._checkUniform(F),this._vectors4[F]=b,this}setQuaternion(F,b){return this._checkUniform(F),this._quaternions[F]=b,this}setQuaternionArray(F,b){return this._checkUniform(F),this._quaternionsArrays[F]=b.reduce(((F,b)=>(b.toArray(F,F.length),F)),[]),this}setMatrix(F,b){return this._checkUniform(F),this._matrices[F]=b,this}setMatrices(F,b){this._checkUniform(F);const Q=new Float32Array(16*b.length);for(let C=0;C<b.length;C++){b[C].copyToArray(Q,16*C)}return this._matrixArrays[F]=Q,this}setMatrix3x3(F,b){return this._checkUniform(F),this._matrices3x3[F]=b,this}setMatrix2x2(F,b){return this._checkUniform(F),this._matrices2x2[F]=b,this}setArray2(F,b){return this._checkUniform(F),this._vectors2Arrays[F]=b,this}setArray3(F,b){return this._checkUniform(F),this._vectors3Arrays[F]=b,this}setArray4(F,b){return this._checkUniform(F),this._vectors4Arrays[F]=b,this}setUniformBuffer(F,b){return-1===this._options.uniformBuffers.indexOf(F)&&this._options.uniformBuffers.push(F),this._uniformBuffers[F]=b,this}setTextureSampler(F,b){return-1===this._options.samplerObjects.indexOf(F)&&this._options.samplerObjects.push(F),this._textureSamplers[F]=b,this}setStorageBuffer(F,b){return-1===this._options.storageBuffers.indexOf(F)&&this._options.storageBuffers.push(F),this._storageBuffers[F]=b,this}setDefine(F,b){const Q=F.trimEnd()+" ",C=this.options.defines.findIndex((b=>b===F||b.startsWith(Q)));return C>=0&&this.options.defines.splice(C,1),("boolean"!==typeof b||b)&&this.options.defines.push(Q+b),this}isReadyForSubMesh(F,b,Q){return this.isReady(F,Q,b)}isReady(F,b,Q){var C;const t=Q&&this._storeEffectOnSubMeshes;if(this.isFrozen){const F=t?Q._drawWrapper:this._drawWrapper;if(F.effect&&F._wasPreviouslyReady&&F._wasPreviouslyUsingInstances===b)return!0}const W=this.RF(),Z=W.getEngine(),G=[],K=[];let e=null,c=this._shaderPath,X=this._options.uniforms,L=this._options.uniformBuffers,i=this._options.samplers;Z.getCaps().multiview&&W.activeCamera&&W.activeCamera.outputRenderTarget&&W.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,G.push("#define MULTIVIEW"),-1!==X.indexOf("viewProjection")&&-1===X.indexOf("viewProjectionR")&&X.push("viewProjectionR"));for(let z=0;z<this._options.defines.length;z++){const F=0===this._options.defines[z].indexOf("#define")?this._options.defines[z]:`#define ${this._options.defines[z]}`;G.push(F)}for(let z=0;z<this._options.attributes.length;z++)K.push(this._options.attributes[z]);if(F&&F.isVerticesDataPresent(g.e.ColorKind)&&(-1===K.indexOf(g.e.ColorKind)&&K.push(g.e.ColorKind),G.push("#define VERTEXCOLOR")),b&&(G.push("#define INSTANCES"),(0,y.ib)(K,this._materialHelperNeedsPreviousMatrices),null!==F&&void 0!==F&&F.hasThinInstances&&(G.push("#define THIN_INSTANCES"),F&&F.isVerticesDataPresent(g.e.ColorInstanceKind)&&(K.push(g.e.ColorInstanceKind),G.push("#define INSTANCESCOLOR")))),F&&F.useBones&&F.computeBonesUsingShaders&&F.skeleton){K.push(g.e.MatricesIndicesKind),K.push(g.e.MatricesWeightsKind),F.numBoneInfluencers>4&&(K.push(g.e.MatricesIndicesExtraKind),K.push(g.e.MatricesWeightsExtraKind));const b=F.skeleton;G.push("#define NUM_BONE_INFLUENCERS "+F.numBoneInfluencers),e=new q.c,e.addCPUSkinningFallback(0,F),b.isUsingTextureForMatrices?(G.push("#define BONETEXTURE"),-1===X.indexOf("boneTextureWidth")&&X.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(G.push("#define BonesPerMesh "+(b.bones.length+1)),-1===X.indexOf("mBones")&&X.push("mBones"))}else G.push("#define NUM_BONE_INFLUENCERS 0");let f=0;const k=F?F.morphTargetManager:null;if(k){const b=-1!==G.indexOf("#define UV1"),Q=-1!==G.indexOf("#define UV2"),C=-1!==G.indexOf("#define TANGENT"),z=-1!==G.indexOf("#define NORMAL"),t=-1!==G.indexOf("#define VERTEXCOLOR");f=(0,y.I)(k,G,K,F,!0,z,C,b,Q,t),k.isUsingTextureForTargets&&(-1===X.indexOf("morphTargetTextureIndices")&&X.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),f>0&&(X=X.slice(),X.push("morphTargetInfluences"),X.push("morphTargetCount"),X.push("morphTargetTextureInfo"),X.push("morphTargetTextureIndices"))}else G.push("#define NUM_MORPH_INFLUENCERS 0");if(F){const b=F.bakedVertexAnimationManager;b&&b.isEnabled&&(G.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===X.indexOf("bakedVertexAnimationSettings")&&X.push("bakedVertexAnimationSettings"),-1===X.indexOf("bakedVertexAnimationTextureSizeInverted")&&X.push("bakedVertexAnimationTextureSizeInverted"),-1===X.indexOf("bakedVertexAnimationTime")&&X.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,y.y)(K,F,G)}for(const z in this._textures)if(!this._textures[z].isReady())return!1;F&&this.needAlphaTestingForMesh(F)&&G.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,N.b)(X),(0,N.j)(this,W,G)),W.fogEnabled&&null!==F&&void 0!==F&&F.applyFog&&W.fogMode!==z.c.FOGMODE_NONE&&(G.push("#define FOG"),-1===X.indexOf("view")&&X.push("view"),-1===X.indexOf("vFogInfos")&&X.push("vFogInfos"),-1===X.indexOf("vFogColor")&&X.push("vFogColor")),this._useLogarithmicDepth&&(G.push("#define LOGARITHMICDEPTH"),-1===X.indexOf("logarithmicDepthConstant")&&X.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(X=X.slice(),L=L.slice(),i=i.slice(),c=this.customShaderNameResolve(this.name,X,L,i,G,K));const m=t?Q._getDrawWrapper(void 0,!0):this._drawWrapper,R=(null===m||void 0===m?void 0:m.effect)??null,p=(null===m||void 0===m?void 0:m.defines)??null,D=G.join("\n");let P=R;return p!==D&&(P=Z.createEffect(c,{attributes:K,uniformsNames:X,uniformBuffersNames:L,samplers:i,defines:D,fallbacks:e,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:f},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},Z),t?Q.setEffect(P,D,this._materialContext):m&&m.setEffect(P,D),this._onEffectCreatedObservable&&(E.effect=P,E.subMesh=Q??(null===F||void 0===F?void 0:F.Xb[0])??null,this._onEffectCreatedObservable.notifyObservers(E))),m._wasPreviouslyUsingInstances=!!b,!(null===(C=P)||void 0===C||!C.isReady())&&(R!==P&&W.resetCachedMaterial(),m._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(F,b){const Q=b??this.getEffect();if(!Q)return;const C=this._options.uniforms;-1!==C.indexOf("world")&&Q.setMatrix("world",F);const z=this.RF();-1!==C.indexOf("worldView")&&(F.multiplyToRef(z.getViewMatrix(),this._cachedWorldViewMatrix),Q.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==C.indexOf("worldViewProjection")&&(F.multiplyToRef(z.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),Q.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==C.indexOf("view")&&Q.setMatrix("view",z.getViewMatrix())}bindForSubMesh(F,b,Q){var C;this.bind(F,b,null===(C=Q._drawWrapperOverride)||void 0===C?void 0:C.effect,Q)}bind(F,b,Q,C){const z=C&&this._storeEffectOnSubMeshes,t=Q??(z?C.effect:this.getEffect());if(!t)return;const g=this.RF();this._activeEffect=t,this.bindOnlyWorldMatrix(F,Q);const W=this._options.uniformBuffers;let Z=!1;if(t&&W&&W.length>0&&g.getEngine().supportsUniformBuffers)for(let K=0;K<W.length;++K){switch(W[K]){case"Mesh":b&&(b.getMeshUniformBuffer().bindToEffect(t,"Mesh"),b.transferToEffect(F));break;case"Scene":(0,y.n)(t,g.getSceneUniformBuffer()),g.finalizeSceneUbo(),Z=!0}}const q=b&&z?this._mustRebind(g,t,C,b.visibility):g.getCachedMaterial()!==this;if(t&&q){let F;for(F in Z||-1===this._options.uniforms.indexOf("view")||t.setMatrix("view",g.getViewMatrix()),Z||-1===this._options.uniforms.indexOf("projection")||t.setMatrix("projection",g.getProjectionMatrix()),Z||-1===this._options.uniforms.indexOf("viewProjection")||(t.setMatrix("viewProjection",g.getTransformMatrix()),this._multiview&&t.setMatrix("viewProjectionR",g._transformMatrixR)),g.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&t.setVector3("cameraPosition",g.activeCamera.globalPosition),(0,y.e)(b,t),(0,N.e)(t,this,g),this._useLogarithmicDepth&&(0,y.k)(z?C.materialDefines:t.defines,t,g),b&&(0,y.h)(g,b,t),this._textures)t.setTexture(F,this._textures[F]);for(F in this._textureArrays)t.setTextureArray(F,this._textureArrays[F]);for(F in this._ints)t.setInt(F,this._ints[F]);for(F in this._uints)t.setUInt(F,this._uints[F]);for(F in this._floats)t.setFloat(F,this._floats[F]);for(F in this._floatsArrays)t.setArray(F,this._floatsArrays[F]);for(F in this._colors3)t.setColor3(F,this._colors3[F]);for(F in this._colors3Arrays)t.setArray3(F,this._colors3Arrays[F]);for(F in this._colors4){const b=this._colors4[F];t.setFloat4(F,b.r,b.g,b.b,b.a)}for(F in this._colors4Arrays)t.setArray4(F,this._colors4Arrays[F]);for(F in this._vectors2)t.setVector2(F,this._vectors2[F]);for(F in this._vectors3)t.setVector3(F,this._vectors3[F]);for(F in this._vectors4)t.setVector4(F,this._vectors4[F]);for(F in this._quaternions)t.setQuaternion(F,this._quaternions[F]);for(F in this._matrices)t.setMatrix(F,this._matrices[F]);for(F in this._matrixArrays)t.setMatrices(F,this._matrixArrays[F]);for(F in this._matrices3x3)t.setMatrix3x3(F,this._matrices3x3[F]);for(F in this._matrices2x2)t.setMatrix2x2(F,this._matrices2x2[F]);for(F in this._vectors2Arrays)t.setArray2(F,this._vectors2Arrays[F]);for(F in this._vectors3Arrays)t.setArray3(F,this._vectors3Arrays[F]);for(F in this._vectors4Arrays)t.setArray4(F,this._vectors4Arrays[F]);for(F in this._quaternionsArrays)t.setArray4(F,this._quaternionsArrays[F]);for(F in this._uniformBuffers){const b=this._uniformBuffers[F].getBuffer();b&&t.bindUniformBuffer(b,F)}const Q=g.getEngine(),W=Q.setExternalTexture;if(W)for(F in this._externalTextures)W.call(Q,F,this._externalTextures[F]);const q=Q.setTextureSampler;if(q)for(F in this._textureSamplers)q.call(Q,F,this._textureSamplers[F]);const G=Q.setStorageBuffer;if(G)for(F in this._storageBuffers)G.call(Q,F,this._storageBuffers[F])}if(t&&b&&(q||!this.isFrozen)){(0,y.l)(b,t),b.morphTargetManager&&b.morphTargetManager.isUsingTextureForTargets&&b.morphTargetManager._bind(t);const F=b.bakedVertexAnimationManager;if(F&&F.isEnabled){var G;const F=z?C._drawWrapper:this._drawWrapper;null===(G=b.bakedVertexAnimationManager)||void 0===G||G.bind(t,!!F._wasPreviouslyUsingInstances)}}this._afterBind(b,t,C)}getActiveTextures(){const F=super.getActiveTextures();for(const b in this._textures)F.push(this._textures[b]);for(const b in this._textureArrays){const Q=this._textureArrays[b];for(let b=0;b<Q.length;b++)F.push(Q[b])}return F}hasTexture(F){if(super.hasTexture(F))return!0;for(const b in this._textures)if(this._textures[b]===F)return!0;for(const b in this._textureArrays){const Q=this._textureArrays[b];for(let b=0;b<Q.length;b++)if(Q[b]===F)return!0}return!1}clone(F){const b=C.e.Clone((()=>new c(F,this.RF(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);b.name=F,b.id=F,"object"===typeof b._shaderPath&&(b._shaderPath={...b._shaderPath}),this._options={...this._options};const Q=Object.keys(this._options);for(const C of Q){const F=this._options[C];Array.isArray(F)&&(this._options[C]=F.slice(0))}this.stencil.copyTo(b.stencil);for(const C in this._textures)b.setTexture(C,this._textures[C]);for(const C in this._textureArrays)b.setTextureArray(C,this._textureArrays[C]);for(const C in this._externalTextures)b.setExternalTexture(C,this._externalTextures[C]);for(const C in this._ints)b.setInt(C,this._ints[C]);for(const C in this._uints)b.setUInt(C,this._uints[C]);for(const C in this._floats)b.setFloat(C,this._floats[C]);for(const C in this._floatsArrays)b.setFloats(C,this._floatsArrays[C]);for(const C in this._colors3)b.setColor3(C,this._colors3[C]);for(const C in this._colors3Arrays)b._colors3Arrays[C]=this._colors3Arrays[C];for(const C in this._colors4)b.setColor4(C,this._colors4[C]);for(const C in this._colors4Arrays)b._colors4Arrays[C]=this._colors4Arrays[C];for(const C in this._vectors2)b.setVector2(C,this._vectors2[C]);for(const C in this._vectors3)b.setVector3(C,this._vectors3[C]);for(const C in this._vectors4)b.setVector4(C,this._vectors4[C]);for(const C in this._quaternions)b.setQuaternion(C,this._quaternions[C]);for(const C in this._quaternionsArrays)b._quaternionsArrays[C]=this._quaternionsArrays[C];for(const C in this._matrices)b.setMatrix(C,this._matrices[C]);for(const C in this._matrixArrays)b._matrixArrays[C]=this._matrixArrays[C].slice();for(const C in this._matrices3x3)b.setMatrix3x3(C,this._matrices3x3[C]);for(const C in this._matrices2x2)b.setMatrix2x2(C,this._matrices2x2[C]);for(const C in this._vectors2Arrays)b.setArray2(C,this._vectors2Arrays[C]);for(const C in this._vectors3Arrays)b.setArray3(C,this._vectors3Arrays[C]);for(const C in this._vectors4Arrays)b.setArray4(C,this._vectors4Arrays[C]);for(const C in this._uniformBuffers)b.setUniformBuffer(C,this._uniformBuffers[C]);for(const C in this._textureSamplers)b.setTextureSampler(C,this._textureSamplers[C]);for(const C in this._storageBuffers)b.setStorageBuffer(C,this._storageBuffers[C]);return b}dispose(F,b,Q){if(b){let F;for(F in this._textures)this._textures[F].dispose();for(F in this._textureArrays){const b=this._textureArrays[F];for(let F=0;F<b.length;F++)b[F].dispose()}}this._textures={},super.dispose(F,b,Q)}serialize(){const F=C.e.Serialize(this);let b;for(b in F.customType="BABYLON.ShaderMaterial",F.uniqueId=this.uniqueId,F.options=this._options,F.shaderPath=this._shaderPath,F.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,F.stencil=this.stencil.serialize(),F.textures={},this._textures)F.textures[b]=this._textures[b].serialize();for(b in F.textureArrays={},this._textureArrays){F.textureArrays[b]=[];const Q=this._textureArrays[b];for(let C=0;C<Q.length;C++)F.textureArrays[b].push(Q[C].serialize())}for(b in F.ints={},this._ints)F.ints[b]=this._ints[b];for(b in F.uints={},this._uints)F.uints[b]=this._uints[b];for(b in F.floats={},this._floats)F.floats[b]=this._floats[b];for(b in F.floatsArrays={},this._floatsArrays)F.floatsArrays[b]=this._floatsArrays[b];for(b in F.colors3={},this._colors3){const Q=this._colors3[b];F.colors3[b]=[Q.r,Q.g,Q.b]}for(b in F.colors3Arrays={},this._colors3Arrays)F.colors3Arrays[b]=this._colors3Arrays[b];for(b in F.colors4={},this._colors4){const Q=this._colors4[b];F.colors4[b]=[Q.r,Q.g,Q.b,Q.a]}for(b in F.colors4Arrays={},this._colors4Arrays)F.colors4Arrays[b]=this._colors4Arrays[b];for(b in F.vectors2={},this._vectors2){const Q=this._vectors2[b];F.vectors2[b]=[Q.x,Q.y]}for(b in F.vectors3={},this._vectors3){const Q=this._vectors3[b];F.vectors3[b]=[Q.x,Q.y,Q.z]}for(b in F.vectors4={},this._vectors4){const Q=this._vectors4[b];F.vectors4[b]=[Q.x,Q.y,Q.z,Q.w]}for(b in F.quaternions={},this._quaternions)F.quaternions[b]=this._quaternions[b].Lb();for(b in F.matrices={},this._matrices)F.matrices[b]=this._matrices[b].Lb();for(b in F.matrixArray={},this._matrixArrays)F.matrixArray[b]=this._matrixArrays[b];for(b in F.matrices3x3={},this._matrices3x3)F.matrices3x3[b]=this._matrices3x3[b];for(b in F.matrices2x2={},this._matrices2x2)F.matrices2x2[b]=this._matrices2x2[b];for(b in F.vectors2Arrays={},this._vectors2Arrays)F.vectors2Arrays[b]=this._vectors2Arrays[b];for(b in F.vectors3Arrays={},this._vectors3Arrays)F.vectors3Arrays[b]=this._vectors3Arrays[b];for(b in F.vectors4Arrays={},this._vectors4Arrays)F.vectors4Arrays[b]=this._vectors4Arrays[b];for(b in F.quaternionsArrays={},this._quaternionsArrays)F.quaternionsArrays[b]=this._quaternionsArrays[b];return F}static Parse(F,b,Q){const z=C.e.Parse((()=>new c(F.name,b,F.shaderPath,F.options,F.storeEffectOnSubMeshes)),F,b,Q);let g;for(g in F.stencil&&z.stencil.parse(F.stencil,b,Q),F.textures)z.setTexture(g,W.b.Parse(F.textures[g],b,Q));for(g in F.textureArrays){const C=F.textureArrays[g],t=[];for(let F=0;F<C.length;F++)t.push(W.b.Parse(C[F],b,Q));z.setTextureArray(g,t)}for(g in F.ints)z.setInt(g,F.ints[g]);for(g in F.uints)z.setUInt(g,F.uints[g]);for(g in F.floats)z.setFloat(g,F.floats[g]);for(g in F.floatsArrays)z.setFloats(g,F.floatsArrays[g]);for(g in F.colors3){const b=F.colors3[g];z.setColor3(g,{r:b[0],g:b[1],b:b[2]})}for(g in F.colors3Arrays){const b=F.colors3Arrays[g].reduce(((F,b,Q)=>(Q%3===0?F.push([b]):F[F.length-1].push(b),F)),[]).map((F=>({r:F[0],g:F[1],b:F[2]})));z.setColor3Array(g,b)}for(g in F.colors4){const b=F.colors4[g];z.setColor4(g,{r:b[0],g:b[1],b:b[2],a:b[3]})}for(g in F.colors4Arrays){const b=F.colors4Arrays[g].reduce(((F,b,Q)=>(Q%4===0?F.push([b]):F[F.length-1].push(b),F)),[]).map((F=>({r:F[0],g:F[1],b:F[2],a:F[3]})));z.setColor4Array(g,b)}for(g in F.vectors2){const b=F.vectors2[g];z.setVector2(g,{x:b[0],y:b[1]})}for(g in F.vectors3){const b=F.vectors3[g];z.setVector3(g,{x:b[0],y:b[1],z:b[2]})}for(g in F.vectors4){const b=F.vectors4[g];z.setVector4(g,{x:b[0],y:b[1],z:b[2],w:b[3]})}for(g in F.quaternions)z.setQuaternion(g,t.Quaternion.KQ(F.quaternions[g]));for(g in F.matrices)z.setMatrix(g,t.Matrix.KQ(F.matrices[g]));for(g in F.matrixArray)z._matrixArrays[g]=new Float32Array(F.matrixArray[g]);for(g in F.matrices3x3)z.setMatrix3x3(g,F.matrices3x3[g]);for(g in F.matrices2x2)z.setMatrix2x2(g,F.matrices2x2[g]);for(g in F.vectors2Arrays)z.setArray2(g,F.vectors2Arrays[g]);for(g in F.vectors3Arrays)z.setArray3(g,F.vectors3Arrays[g]);for(g in F.vectors4Arrays)z.setArray4(g,F.vectors4Arrays[g]);for(g in F.quaternionsArrays)z.setArray4(g,F.quaternionsArrays[g]);return z}static async ParseFromFileAsync(F,b,Q){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((z,t)=>{const g=new G.b;g.addEventListener("readystatechange",(()=>{if(4==g.readyState)if(200==g.status){const b=JSON.parse(g.responseText),t=this.Parse(b,Q||e.d.LastCreatedScene,C);F&&(t.name=F),z(t)}else t("Unable to load the ShaderMaterial")})),g.open("GET",b),g.send()}))}static async ParseFromSnippetAsync(F,b){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((C,z)=>{const t=new G.b;t.addEventListener("readystatechange",(()=>{if(4==t.readyState)if(200==t.status){const z=JSON.parse(JSON.parse(t.responseText).jsonPayload),g=JSON.parse(z.shaderMaterial),W=this.Parse(g,b||e.d.LastCreatedScene,Q);W.snippetId=F,C(W)}else z("Unable to load the snippet "+F)})),t.open("GET",this.SnippetUrl+"/"+F.replace(/#/g,"/")),t.send()}))}}c.SnippetUrl="https://snippet.babylonjs.com",c.CreateFromSnippetAsync=c.ParseFromSnippetAsync,(0,Z.g)("BABYLON.ShaderMaterial",c)}}]);