"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[22],{11373:(P,e,n)=>{n.r(e),n.d(e,{ShaderMaterial:()=>z});var H=n(11170),S=n(11379),p=n(11133),k=n(11213),m=n(11119),t=n(11096),C=n(11427),R=n(11011),q=n(11430),A=n(11017),F=n(11481),Y=n(11473);const j={effect:null,subMesh:null};class z extends q.d{constructor(P,e,n){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(P,e,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new p.Matrix,this._cachedWorldViewProjectionMatrix=new p.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=n,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...H}}get shaderPath(){return this._shaderPath}set shaderPath(P){this._shaderPath=P}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(P){-1===this._options.uniforms.indexOf(P)&&this._options.uniforms.push(P)}setTexture(P,e){return-1===this._options.samplers.indexOf(P)&&this._options.samplers.push(P),this._textures[P]=e,this}removeTexture(P){delete this._textures[P]}setTextureArray(P,e){return-1===this._options.samplers.indexOf(P)&&this._options.samplers.push(P),this._checkUniform(P),this._textureArrays[P]=e,this}setExternalTexture(P,e){return-1===this._options.externalTextures.indexOf(P)&&this._options.externalTextures.push(P),this._externalTextures[P]=e,this}setFloat(P,e){return this._checkUniform(P),this._floats[P]=e,this}setInt(P,e){return this._checkUniform(P),this._ints[P]=e,this}setUInt(P,e){return this._checkUniform(P),this._uints[P]=e,this}setFloats(P,e){return this._checkUniform(P),this._floatsArrays[P]=e,this}setColor3(P,e){return this._checkUniform(P),this._colors3[P]=e,this}setColor3Array(P,e){return this._checkUniform(P),this._colors3Arrays[P]=e.reduce(((P,e)=>(P.push(e.r,e.g,e.b),P)),[]),this}setColor4(P,e){return this._checkUniform(P),this._colors4[P]=e,this}setColor4Array(P,e){return this._checkUniform(P),this._colors4Arrays[P]=e.reduce(((P,e)=>(P.push(e.r,e.g,e.b,e.a),P)),[]),this}setVector2(P,e){return this._checkUniform(P),this._vectors2[P]=e,this}setVector3(P,e){return this._checkUniform(P),this._vectors3[P]=e,this}setVector4(P,e){return this._checkUniform(P),this._vectors4[P]=e,this}setQuaternion(P,e){return this._checkUniform(P),this._quaternions[P]=e,this}setQuaternionArray(P,e){return this._checkUniform(P),this._quaternionsArrays[P]=e.reduce(((P,e)=>(e.toArray(P,P.length),P)),[]),this}setMatrix(P,e){return this._checkUniform(P),this._matrices[P]=e,this}setMatrices(P,e){this._checkUniform(P);const n=new Float32Array(16*e.length);for(let H=0;H<e.length;H++){e[H].copyToArray(n,16*H)}return this._matrixArrays[P]=n,this}setMatrix3x3(P,e){return this._checkUniform(P),this._matrices3x3[P]=e,this}setMatrix2x2(P,e){return this._checkUniform(P),this._matrices2x2[P]=e,this}setArray2(P,e){return this._checkUniform(P),this._vectors2Arrays[P]=e,this}setArray3(P,e){return this._checkUniform(P),this._vectors3Arrays[P]=e,this}setArray4(P,e){return this._checkUniform(P),this._vectors4Arrays[P]=e,this}setUniformBuffer(P,e){return-1===this._options.uniformBuffers.indexOf(P)&&this._options.uniformBuffers.push(P),this._uniformBuffers[P]=e,this}setTextureSampler(P,e){return-1===this._options.samplerObjects.indexOf(P)&&this._options.samplerObjects.push(P),this._textureSamplers[P]=e,this}setStorageBuffer(P,e){return-1===this._options.storageBuffers.indexOf(P)&&this._options.storageBuffers.push(P),this._storageBuffers[P]=e,this}setDefine(P,e){const n=P.trimEnd()+" ",H=this.options.defines.findIndex((e=>e===P||e.startsWith(n)));return H>=0&&this.options.defines.splice(H,1),("boolean"!==typeof e||e)&&this.options.defines.push(n+e),this}isReadyForSubMesh(P,e,n){return this.isReady(P,n,e)}isReady(P,e,n){var H;const p=n&&this._storeEffectOnSubMeshes;if(this.isFrozen){const P=p?n._drawWrapper:this._drawWrapper;if(P.effect&&P._wasPreviouslyReady&&P._wasPreviouslyUsingInstances===e)return!0}const m=this.BP(),t=m.getEngine(),R=[],q=[];let A=null,z=this._shaderPath,w=this._options.uniforms,J=this._options.uniformBuffers,I=this._options.samplers;t.getCaps().multiview&&m.activeCamera&&m.activeCamera.outputRenderTarget&&m.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,R.push("#define MULTIVIEW"),-1!==w.indexOf("viewProjection")&&-1===w.indexOf("viewProjectionR")&&w.push("viewProjectionR"));for(let S=0;S<this._options.defines.length;S++){const P=0===this._options.defines[S].indexOf("#define")?this._options.defines[S]:`#define ${this._options.defines[S]}`;R.push(P)}for(let S=0;S<this._options.attributes.length;S++)q.push(this._options.attributes[S]);if(P&&P.isVerticesDataPresent(k.g.ColorKind)&&(-1===q.indexOf(k.g.ColorKind)&&q.push(k.g.ColorKind),R.push("#define VERTEXCOLOR")),e&&(R.push("#define INSTANCES"),(0,Y.bb)(q,this._materialHelperNeedsPreviousMatrices),null!==P&&void 0!==P&&P.hasThinInstances&&(R.push("#define THIN_INSTANCES"),P&&P.isVerticesDataPresent(k.g.ColorInstanceKind)&&(q.push(k.g.ColorInstanceKind),R.push("#define INSTANCESCOLOR")))),P&&P.useBones&&P.computeBonesUsingShaders&&P.skeleton){q.push(k.g.MatricesIndicesKind),q.push(k.g.MatricesWeightsKind),P.numBoneInfluencers>4&&(q.push(k.g.MatricesIndicesExtraKind),q.push(k.g.MatricesWeightsExtraKind));const e=P.skeleton;R.push("#define NUM_BONE_INFLUENCERS "+P.numBoneInfluencers),A=new C.d,A.addCPUSkinningFallback(0,P),e.isUsingTextureForMatrices?(R.push("#define BONETEXTURE"),-1===w.indexOf("boneTextureWidth")&&w.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(R.push("#define BonesPerMesh "+(e.bones.length+1)),-1===w.indexOf("mBones")&&w.push("mBones"))}else R.push("#define NUM_BONE_INFLUENCERS 0");let O=0;const V=P?P.morphTargetManager:null;if(V){const e=-1!==R.indexOf("#define UV1"),n=-1!==R.indexOf("#define UV2"),H=-1!==R.indexOf("#define TANGENT"),S=-1!==R.indexOf("#define NORMAL"),p=-1!==R.indexOf("#define VERTEXCOLOR");O=(0,Y.H)(V,R,q,P,!0,S,H,e,n,p),V.isUsingTextureForTargets&&(-1===w.indexOf("morphTargetTextureIndices")&&w.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),O>0&&(w=w.slice(),w.push("morphTargetInfluences"),w.push("morphTargetCount"),w.push("morphTargetTextureInfo"),w.push("morphTargetTextureIndices"))}else R.push("#define NUM_MORPH_INFLUENCERS 0");if(P){const e=P.bakedVertexAnimationManager;e&&e.isEnabled&&(R.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===w.indexOf("bakedVertexAnimationSettings")&&w.push("bakedVertexAnimationSettings"),-1===w.indexOf("bakedVertexAnimationTextureSizeInverted")&&w.push("bakedVertexAnimationTextureSizeInverted"),-1===w.indexOf("bakedVertexAnimationTime")&&w.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,Y.x)(q,P,R)}for(const S in this._textures)if(!this._textures[S].isReady())return!1;P&&this.needAlphaTestingForMesh(P)&&R.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,F.e)(w),(0,F.k)(this,m,R)),m.fogEnabled&&null!==P&&void 0!==P&&P.applyFog&&m.fogMode!==S.d.FOGMODE_NONE&&(R.push("#define FOG"),-1===w.indexOf("view")&&w.push("view"),-1===w.indexOf("vFogInfos")&&w.push("vFogInfos"),-1===w.indexOf("vFogColor")&&w.push("vFogColor")),this._useLogarithmicDepth&&(R.push("#define LOGARITHMICDEPTH"),-1===w.indexOf("logarithmicDepthConstant")&&w.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(w=w.slice(),J=J.slice(),I=I.slice(),z=this.customShaderNameResolve(this.name,w,J,I,R,q));const i=p?n._getDrawWrapper(void 0,!0):this._drawWrapper,B=(null===i||void 0===i?void 0:i.effect)??null,l=(null===i||void 0===i?void 0:i.defines)??null,b=R.join("\n");let T=B;return l!==b&&(T=t.createEffect(z,{attributes:q,uniformsNames:w,uniformBuffersNames:J,samplers:I,defines:b,fallbacks:A,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:O},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},t),p?n.setEffect(T,b,this._materialContext):i&&i.setEffect(T,b),this._onEffectCreatedObservable&&(j.effect=T,j.subMesh=n??(null===P||void 0===P?void 0:P.ye[0])??null,this._onEffectCreatedObservable.notifyObservers(j))),i._wasPreviouslyUsingInstances=!!e,!(null===(H=T)||void 0===H||!H.isReady())&&(B!==T&&m.resetCachedMaterial(),i._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(P,e){const n=e??this.getEffect();if(!n)return;const H=this._options.uniforms;-1!==H.indexOf("world")&&n.setMatrix("world",P);const S=this.BP();-1!==H.indexOf("worldView")&&(P.multiplyToRef(S.getViewMatrix(),this._cachedWorldViewMatrix),n.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==H.indexOf("worldViewProjection")&&(P.multiplyToRef(S.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),n.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==H.indexOf("view")&&n.setMatrix("view",S.getViewMatrix())}bindForSubMesh(P,e,n){var H;this.bind(P,e,null===(H=n._drawWrapperOverride)||void 0===H?void 0:H.effect,n)}bind(P,e,n,H){const S=H&&this._storeEffectOnSubMeshes,p=n??(S?H.effect:this.getEffect());if(!p)return;const k=this.BP();this._activeEffect=p,this.bindOnlyWorldMatrix(P,n);const m=this._options.uniformBuffers;let t=!1;if(p&&m&&m.length>0&&k.getEngine().supportsUniformBuffers)for(let q=0;q<m.length;++q){switch(m[q]){case"Mesh":e&&(e.getMeshUniformBuffer().bindToEffect(p,"Mesh"),e.transferToEffect(P));break;case"Scene":(0,Y.p)(p,k.getSceneUniformBuffer()),k.finalizeSceneUbo(),t=!0}}const C=e&&S?this._mustRebind(k,p,H,e.visibility):k.getCachedMaterial()!==this;if(p&&C){let P;for(P in t||-1===this._options.uniforms.indexOf("view")||p.setMatrix("view",k.getViewMatrix()),t||-1===this._options.uniforms.indexOf("projection")||p.setMatrix("projection",k.getProjectionMatrix()),t||-1===this._options.uniforms.indexOf("viewProjection")||(p.setMatrix("viewProjection",k.getTransformMatrix()),this._multiview&&p.setMatrix("viewProjectionR",k._transformMatrixR)),k.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&p.setVector3("cameraPosition",k.activeCamera.globalPosition),(0,Y.c)(e,p),(0,F.g)(p,this,k),this._useLogarithmicDepth&&(0,Y.i)(S?H.materialDefines:p.defines,p,k),e&&(0,Y.g)(k,e,p),this._textures)p.setTexture(P,this._textures[P]);for(P in this._textureArrays)p.setTextureArray(P,this._textureArrays[P]);for(P in this._ints)p.setInt(P,this._ints[P]);for(P in this._uints)p.setUInt(P,this._uints[P]);for(P in this._floats)p.setFloat(P,this._floats[P]);for(P in this._floatsArrays)p.setArray(P,this._floatsArrays[P]);for(P in this._colors3)p.setColor3(P,this._colors3[P]);for(P in this._colors3Arrays)p.setArray3(P,this._colors3Arrays[P]);for(P in this._colors4){const e=this._colors4[P];p.setFloat4(P,e.r,e.g,e.b,e.a)}for(P in this._colors4Arrays)p.setArray4(P,this._colors4Arrays[P]);for(P in this._vectors2)p.setVector2(P,this._vectors2[P]);for(P in this._vectors3)p.setVector3(P,this._vectors3[P]);for(P in this._vectors4)p.setVector4(P,this._vectors4[P]);for(P in this._quaternions)p.setQuaternion(P,this._quaternions[P]);for(P in this._matrices)p.setMatrix(P,this._matrices[P]);for(P in this._matrixArrays)p.setMatrices(P,this._matrixArrays[P]);for(P in this._matrices3x3)p.setMatrix3x3(P,this._matrices3x3[P]);for(P in this._matrices2x2)p.setMatrix2x2(P,this._matrices2x2[P]);for(P in this._vectors2Arrays)p.setArray2(P,this._vectors2Arrays[P]);for(P in this._vectors3Arrays)p.setArray3(P,this._vectors3Arrays[P]);for(P in this._vectors4Arrays)p.setArray4(P,this._vectors4Arrays[P]);for(P in this._quaternionsArrays)p.setArray4(P,this._quaternionsArrays[P]);for(P in this._uniformBuffers){const e=this._uniformBuffers[P].getBuffer();e&&p.bindUniformBuffer(e,P)}const n=k.getEngine(),m=n.setExternalTexture;if(m)for(P in this._externalTextures)m.call(n,P,this._externalTextures[P]);const C=n.setTextureSampler;if(C)for(P in this._textureSamplers)C.call(n,P,this._textureSamplers[P]);const R=n.setStorageBuffer;if(R)for(P in this._storageBuffers)R.call(n,P,this._storageBuffers[P])}if(p&&e&&(C||!this.isFrozen)){(0,Y.m)(e,p),e.morphTargetManager&&e.morphTargetManager.isUsingTextureForTargets&&e.morphTargetManager._bind(p);const P=e.bakedVertexAnimationManager;if(P&&P.isEnabled){var R;const P=S?H._drawWrapper:this._drawWrapper;null===(R=e.bakedVertexAnimationManager)||void 0===R||R.bind(p,!!P._wasPreviouslyUsingInstances)}}this._afterBind(e,p,H)}getActiveTextures(){const P=super.getActiveTextures();for(const e in this._textures)P.push(this._textures[e]);for(const e in this._textureArrays){const n=this._textureArrays[e];for(let e=0;e<n.length;e++)P.push(n[e])}return P}hasTexture(P){if(super.hasTexture(P))return!0;for(const e in this._textures)if(this._textures[e]===P)return!0;for(const e in this._textureArrays){const n=this._textureArrays[e];for(let e=0;e<n.length;e++)if(n[e]===P)return!0}return!1}clone(P){const e=H.c.Clone((()=>new z(P,this.BP(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);e.name=P,e.id=P,"object"===typeof e._shaderPath&&(e._shaderPath={...e._shaderPath}),this._options={...this._options};const n=Object.keys(this._options);for(const H of n){const P=this._options[H];Array.isArray(P)&&(this._options[H]=P.slice(0))}this.stencil.copyTo(e.stencil);for(const H in this._textures)e.setTexture(H,this._textures[H]);for(const H in this._textureArrays)e.setTextureArray(H,this._textureArrays[H]);for(const H in this._externalTextures)e.setExternalTexture(H,this._externalTextures[H]);for(const H in this._ints)e.setInt(H,this._ints[H]);for(const H in this._uints)e.setUInt(H,this._uints[H]);for(const H in this._floats)e.setFloat(H,this._floats[H]);for(const H in this._floatsArrays)e.setFloats(H,this._floatsArrays[H]);for(const H in this._colors3)e.setColor3(H,this._colors3[H]);for(const H in this._colors3Arrays)e._colors3Arrays[H]=this._colors3Arrays[H];for(const H in this._colors4)e.setColor4(H,this._colors4[H]);for(const H in this._colors4Arrays)e._colors4Arrays[H]=this._colors4Arrays[H];for(const H in this._vectors2)e.setVector2(H,this._vectors2[H]);for(const H in this._vectors3)e.setVector3(H,this._vectors3[H]);for(const H in this._vectors4)e.setVector4(H,this._vectors4[H]);for(const H in this._quaternions)e.setQuaternion(H,this._quaternions[H]);for(const H in this._quaternionsArrays)e._quaternionsArrays[H]=this._quaternionsArrays[H];for(const H in this._matrices)e.setMatrix(H,this._matrices[H]);for(const H in this._matrixArrays)e._matrixArrays[H]=this._matrixArrays[H].slice();for(const H in this._matrices3x3)e.setMatrix3x3(H,this._matrices3x3[H]);for(const H in this._matrices2x2)e.setMatrix2x2(H,this._matrices2x2[H]);for(const H in this._vectors2Arrays)e.setArray2(H,this._vectors2Arrays[H]);for(const H in this._vectors3Arrays)e.setArray3(H,this._vectors3Arrays[H]);for(const H in this._vectors4Arrays)e.setArray4(H,this._vectors4Arrays[H]);for(const H in this._uniformBuffers)e.setUniformBuffer(H,this._uniformBuffers[H]);for(const H in this._textureSamplers)e.setTextureSampler(H,this._textureSamplers[H]);for(const H in this._storageBuffers)e.setStorageBuffer(H,this._storageBuffers[H]);return e}dispose(P,e,n){if(e){let P;for(P in this._textures)this._textures[P].dispose();for(P in this._textureArrays){const e=this._textureArrays[P];for(let P=0;P<e.length;P++)e[P].dispose()}}this._textures={},super.dispose(P,e,n)}serialize(){const P=H.c.Serialize(this);let e;for(e in P.customType="BABYLON.ShaderMaterial",P.uniqueId=this.uniqueId,P.options=this._options,P.shaderPath=this._shaderPath,P.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,P.stencil=this.stencil.serialize(),P.textures={},this._textures)P.textures[e]=this._textures[e].serialize();for(e in P.textureArrays={},this._textureArrays){P.textureArrays[e]=[];const n=this._textureArrays[e];for(let H=0;H<n.length;H++)P.textureArrays[e].push(n[H].serialize())}for(e in P.ints={},this._ints)P.ints[e]=this._ints[e];for(e in P.uints={},this._uints)P.uints[e]=this._uints[e];for(e in P.floats={},this._floats)P.floats[e]=this._floats[e];for(e in P.floatsArrays={},this._floatsArrays)P.floatsArrays[e]=this._floatsArrays[e];for(e in P.colors3={},this._colors3){const n=this._colors3[e];P.colors3[e]=[n.r,n.g,n.b]}for(e in P.colors3Arrays={},this._colors3Arrays)P.colors3Arrays[e]=this._colors3Arrays[e];for(e in P.colors4={},this._colors4){const n=this._colors4[e];P.colors4[e]=[n.r,n.g,n.b,n.a]}for(e in P.colors4Arrays={},this._colors4Arrays)P.colors4Arrays[e]=this._colors4Arrays[e];for(e in P.vectors2={},this._vectors2){const n=this._vectors2[e];P.vectors2[e]=[n.x,n.y]}for(e in P.vectors3={},this._vectors3){const n=this._vectors3[e];P.vectors3[e]=[n.x,n.y,n.z]}for(e in P.vectors4={},this._vectors4){const n=this._vectors4[e];P.vectors4[e]=[n.x,n.y,n.z,n.w]}for(e in P.quaternions={},this._quaternions)P.quaternions[e]=this._quaternions[e].fe();for(e in P.matrices={},this._matrices)P.matrices[e]=this._matrices[e].fe();for(e in P.matrixArray={},this._matrixArrays)P.matrixArray[e]=this._matrixArrays[e];for(e in P.matrices3x3={},this._matrices3x3)P.matrices3x3[e]=this._matrices3x3[e];for(e in P.matrices2x2={},this._matrices2x2)P.matrices2x2[e]=this._matrices2x2[e];for(e in P.vectors2Arrays={},this._vectors2Arrays)P.vectors2Arrays[e]=this._vectors2Arrays[e];for(e in P.vectors3Arrays={},this._vectors3Arrays)P.vectors3Arrays[e]=this._vectors3Arrays[e];for(e in P.vectors4Arrays={},this._vectors4Arrays)P.vectors4Arrays[e]=this._vectors4Arrays[e];for(e in P.quaternionsArrays={},this._quaternionsArrays)P.quaternionsArrays[e]=this._quaternionsArrays[e];return P}static Parse(P,e,n){const S=H.c.Parse((()=>new z(P.name,e,P.shaderPath,P.options,P.storeEffectOnSubMeshes)),P,e,n);let k;for(k in P.stencil&&S.stencil.parse(P.stencil,e,n),P.textures)S.setTexture(k,m.e.Parse(P.textures[k],e,n));for(k in P.textureArrays){const H=P.textureArrays[k],p=[];for(let P=0;P<H.length;P++)p.push(m.e.Parse(H[P],e,n));S.setTextureArray(k,p)}for(k in P.ints)S.setInt(k,P.ints[k]);for(k in P.uints)S.setUInt(k,P.uints[k]);for(k in P.floats)S.setFloat(k,P.floats[k]);for(k in P.floatsArrays)S.setFloats(k,P.floatsArrays[k]);for(k in P.colors3){const e=P.colors3[k];S.setColor3(k,{r:e[0],g:e[1],b:e[2]})}for(k in P.colors3Arrays){const e=P.colors3Arrays[k].reduce(((P,e,n)=>(n%3===0?P.push([e]):P[P.length-1].push(e),P)),[]).map((P=>({r:P[0],g:P[1],b:P[2]})));S.setColor3Array(k,e)}for(k in P.colors4){const e=P.colors4[k];S.setColor4(k,{r:e[0],g:e[1],b:e[2],a:e[3]})}for(k in P.colors4Arrays){const e=P.colors4Arrays[k].reduce(((P,e,n)=>(n%4===0?P.push([e]):P[P.length-1].push(e),P)),[]).map((P=>({r:P[0],g:P[1],b:P[2],a:P[3]})));S.setColor4Array(k,e)}for(k in P.vectors2){const e=P.vectors2[k];S.setVector2(k,{x:e[0],y:e[1]})}for(k in P.vectors3){const e=P.vectors3[k];S.setVector3(k,{x:e[0],y:e[1],z:e[2]})}for(k in P.vectors4){const e=P.vectors4[k];S.setVector4(k,{x:e[0],y:e[1],z:e[2],w:e[3]})}for(k in P.quaternions)S.setQuaternion(k,p.Quaternion.Qe(P.quaternions[k]));for(k in P.matrices)S.setMatrix(k,p.Matrix.Qe(P.matrices[k]));for(k in P.matrixArray)S._matrixArrays[k]=new Float32Array(P.matrixArray[k]);for(k in P.matrices3x3)S.setMatrix3x3(k,P.matrices3x3[k]);for(k in P.matrices2x2)S.setMatrix2x2(k,P.matrices2x2[k]);for(k in P.vectors2Arrays)S.setArray2(k,P.vectors2Arrays[k]);for(k in P.vectors3Arrays)S.setArray3(k,P.vectors3Arrays[k]);for(k in P.vectors4Arrays)S.setArray4(k,P.vectors4Arrays[k]);for(k in P.quaternionsArrays)S.setArray4(k,P.quaternionsArrays[k]);return S}static async ParseFromFileAsync(P,e,n){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((S,p)=>{const k=new R.e;k.addEventListener("readystatechange",(()=>{if(4==k.readyState)if(200==k.status){const e=JSON.parse(k.responseText),p=this.Parse(e,n||A.d.LastCreatedScene,H);P&&(p.name=P),S(p)}else p("Unable to load the ShaderMaterial")})),k.open("GET",e),k.send()}))}static async ParseFromSnippetAsync(P,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((H,S)=>{const p=new R.e;p.addEventListener("readystatechange",(()=>{if(4==p.readyState)if(200==p.status){const S=JSON.parse(JSON.parse(p.responseText).jsonPayload),k=JSON.parse(S.shaderMaterial),m=this.Parse(k,e||A.d.LastCreatedScene,n);m.snippetId=P,H(m)}else S("Unable to load the snippet "+P)})),p.open("GET",this.SnippetUrl+"/"+P.replace(/#/g,"/")),p.send()}))}}z.SnippetUrl="https://snippet.babylonjs.com",z.CreateFromSnippetAsync=z.ParseFromSnippetAsync,(0,t.h)("BABYLON.ShaderMaterial",z)}}]);