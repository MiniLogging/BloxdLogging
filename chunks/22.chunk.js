"use strict";(self.g111kvdsqxc=self.g111kvdsqxc||[]).push([[22],{11514:(K,H,M)=>{M.r(H),M.d(H,{ShaderMaterial:()=>L});var q=M(11325),w=M(11522),u=M(11290),y=M(11366),h=M(11267),W=M(11242),I=M(11589),f=M(11135),z=M(11597),G=M(11143),a=M(11656),v=M(11651);const O={effect:null,subMesh:null};class L extends z.c{constructor(K,H,M){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(K,H,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new u.Matrix,this._cachedWorldViewProjectionMatrix=new u.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=M,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...q}}get shaderPath(){return this._shaderPath}set shaderPath(K){this._shaderPath=K}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(K){-1===this._options.uniforms.indexOf(K)&&this._options.uniforms.push(K)}setTexture(K,H){return-1===this._options.samplers.indexOf(K)&&this._options.samplers.push(K),this._textures[K]=H,this}removeTexture(K){delete this._textures[K]}setTextureArray(K,H){return-1===this._options.samplers.indexOf(K)&&this._options.samplers.push(K),this._checkUniform(K),this._textureArrays[K]=H,this}setExternalTexture(K,H){return-1===this._options.externalTextures.indexOf(K)&&this._options.externalTextures.push(K),this._externalTextures[K]=H,this}setFloat(K,H){return this._checkUniform(K),this._floats[K]=H,this}setInt(K,H){return this._checkUniform(K),this._ints[K]=H,this}setUInt(K,H){return this._checkUniform(K),this._uints[K]=H,this}setFloats(K,H){return this._checkUniform(K),this._floatsArrays[K]=H,this}setColor3(K,H){return this._checkUniform(K),this._colors3[K]=H,this}setColor3Array(K,H){return this._checkUniform(K),this._colors3Arrays[K]=H.reduce(((K,H)=>(K.push(H.r,H.g,H.b),K)),[]),this}setColor4(K,H){return this._checkUniform(K),this._colors4[K]=H,this}setColor4Array(K,H){return this._checkUniform(K),this._colors4Arrays[K]=H.reduce(((K,H)=>(K.push(H.r,H.g,H.b,H.a),K)),[]),this}setVector2(K,H){return this._checkUniform(K),this._vectors2[K]=H,this}setVector3(K,H){return this._checkUniform(K),this._vectors3[K]=H,this}setVector4(K,H){return this._checkUniform(K),this._vectors4[K]=H,this}setQuaternion(K,H){return this._checkUniform(K),this._quaternions[K]=H,this}setQuaternionArray(K,H){return this._checkUniform(K),this._quaternionsArrays[K]=H.reduce(((K,H)=>(H.toArray(K,K.length),K)),[]),this}setMatrix(K,H){return this._checkUniform(K),this._matrices[K]=H,this}setMatrices(K,H){this._checkUniform(K);const M=new Float32Array(16*H.length);for(let q=0;q<H.length;q++){H[q].copyToArray(M,16*q)}return this._matrixArrays[K]=M,this}setMatrix3x3(K,H){return this._checkUniform(K),this._matrices3x3[K]=H,this}setMatrix2x2(K,H){return this._checkUniform(K),this._matrices2x2[K]=H,this}setArray2(K,H){return this._checkUniform(K),this._vectors2Arrays[K]=H,this}setArray3(K,H){return this._checkUniform(K),this._vectors3Arrays[K]=H,this}setArray4(K,H){return this._checkUniform(K),this._vectors4Arrays[K]=H,this}setUniformBuffer(K,H){return-1===this._options.uniformBuffers.indexOf(K)&&this._options.uniformBuffers.push(K),this._uniformBuffers[K]=H,this}setTextureSampler(K,H){return-1===this._options.samplerObjects.indexOf(K)&&this._options.samplerObjects.push(K),this._textureSamplers[K]=H,this}setStorageBuffer(K,H){return-1===this._options.storageBuffers.indexOf(K)&&this._options.storageBuffers.push(K),this._storageBuffers[K]=H,this}setDefine(K,H){const M=K.trimEnd()+" ",q=this.options.defines.findIndex((H=>H===K||H.startsWith(M)));return q>=0&&this.options.defines.splice(q,1),("boolean"!==typeof H||H)&&this.options.defines.push(M+H),this}isReadyForSubMesh(K,H,M){return this.isReady(K,M,H)}isReady(K,H,M){var q;const u=M&&this._storeEffectOnSubMeshes;if(this.isFrozen){const K=u?M._drawWrapper:this._drawWrapper;if(K.effect&&K._wasPreviouslyReady&&K._wasPreviouslyUsingInstances===H)return!0}const h=this.sK(),W=h.getEngine(),f=[],z=[];let G=null,L=this._shaderPath,S=this._options.uniforms,B=this._options.uniformBuffers,C=this._options.samplers;W.getCaps().multiview&&h.activeCamera&&h.activeCamera.outputRenderTarget&&h.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,f.push("#define MULTIVIEW"),-1!==S.indexOf("viewProjection")&&-1===S.indexOf("viewProjectionR")&&S.push("viewProjectionR"));for(let w=0;w<this._options.defines.length;w++){const K=0===this._options.defines[w].indexOf("#define")?this._options.defines[w]:`#define ${this._options.defines[w]}`;f.push(K)}for(let w=0;w<this._options.attributes.length;w++)z.push(this._options.attributes[w]);if(K&&K.isVerticesDataPresent(y.d.ColorKind)&&(-1===z.indexOf(y.d.ColorKind)&&z.push(y.d.ColorKind),f.push("#define VERTEXCOLOR")),H&&(f.push("#define INSTANCES"),(0,v.$)(z,this._materialHelperNeedsPreviousMatrices),null!==K&&void 0!==K&&K.hasThinInstances&&(f.push("#define THIN_INSTANCES"),K&&K.isVerticesDataPresent(y.d.ColorInstanceKind)&&(z.push(y.d.ColorInstanceKind),f.push("#define INSTANCESCOLOR")))),K&&K.useBones&&K.computeBonesUsingShaders&&K.skeleton){z.push(y.d.MatricesIndicesKind),z.push(y.d.MatricesWeightsKind),K.numBoneInfluencers>4&&(z.push(y.d.MatricesIndicesExtraKind),z.push(y.d.MatricesWeightsExtraKind));const H=K.skeleton;f.push("#define NUM_BONE_INFLUENCERS "+K.numBoneInfluencers),G=new I.e,G.addCPUSkinningFallback(0,K),H.isUsingTextureForMatrices?(f.push("#define BONETEXTURE"),-1===S.indexOf("boneTextureWidth")&&S.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(f.push("#define BonesPerMesh "+(H.bones.length+1)),-1===S.indexOf("mBones")&&S.push("mBones"))}else f.push("#define NUM_BONE_INFLUENCERS 0");let i=0;const Z=K?K.morphTargetManager:null;if(Z){const H=-1!==f.indexOf("#define UV1"),M=-1!==f.indexOf("#define UV2"),q=-1!==f.indexOf("#define TANGENT"),w=-1!==f.indexOf("#define NORMAL"),u=-1!==f.indexOf("#define VERTEXCOLOR");i=(0,v.E)(Z,f,z,K,!0,w,q,H,M,u),Z.isUsingTextureForTargets&&(-1===S.indexOf("morphTargetTextureIndices")&&S.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),i>0&&(S=S.slice(),S.push("morphTargetInfluences"),S.push("morphTargetCount"),S.push("morphTargetTextureInfo"),S.push("morphTargetTextureIndices"))}else f.push("#define NUM_MORPH_INFLUENCERS 0");if(K){const H=K.bakedVertexAnimationManager;H&&H.isEnabled&&(f.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===S.indexOf("bakedVertexAnimationSettings")&&S.push("bakedVertexAnimationSettings"),-1===S.indexOf("bakedVertexAnimationTextureSizeInverted")&&S.push("bakedVertexAnimationTextureSizeInverted"),-1===S.indexOf("bakedVertexAnimationTime")&&S.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,v.u)(z,K,f)}for(const w in this._textures)if(!this._textures[w].isReady())return!1;K&&this.needAlphaTestingForMesh(K)&&f.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,a.e)(S),(0,a.l)(this,h,f)),h.fogEnabled&&null!==K&&void 0!==K&&K.applyFog&&h.fogMode!==w.b.FOGMODE_NONE&&(f.push("#define FOG"),-1===S.indexOf("view")&&S.push("view"),-1===S.indexOf("vFogInfos")&&S.push("vFogInfos"),-1===S.indexOf("vFogColor")&&S.push("vFogColor")),this._useLogarithmicDepth&&(f.push("#define LOGARITHMICDEPTH"),-1===S.indexOf("logarithmicDepthConstant")&&S.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(S=S.slice(),B=B.slice(),C=C.slice(),L=this.customShaderNameResolve(this.name,S,B,C,f,z));const E=u?M._getDrawWrapper(void 0,!0):this._drawWrapper,l=(null===E||void 0===E?void 0:E.effect)??null,s=(null===E||void 0===E?void 0:E.defines)??null,D=f.join("\n");let V=l;return s!==D&&(V=W.createEffect(L,{attributes:z,uniformsNames:S,uniformBuffersNames:B,samplers:C,defines:D,fallbacks:G,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:i},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},W),u?M.setEffect(V,D,this._materialContext):E&&E.setEffect(V,D),this._onEffectCreatedObservable&&(O.effect=V,O.subMesh=M??(null===K||void 0===K?void 0:K.yh[0])??null,this._onEffectCreatedObservable.notifyObservers(O))),E._wasPreviouslyUsingInstances=!!H,!(null===(q=V)||void 0===q||!q.isReady())&&(l!==V&&h.resetCachedMaterial(),E._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(K,H){const M=H??this.getEffect();if(!M)return;const q=this._options.uniforms;-1!==q.indexOf("world")&&M.setMatrix("world",K);const w=this.sK();-1!==q.indexOf("worldView")&&(K.multiplyToRef(w.getViewMatrix(),this._cachedWorldViewMatrix),M.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==q.indexOf("worldViewProjection")&&(K.multiplyToRef(w.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),M.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==q.indexOf("view")&&M.setMatrix("view",w.getViewMatrix())}bindForSubMesh(K,H,M){var q;this.bind(K,H,null===(q=M._drawWrapperOverride)||void 0===q?void 0:q.effect,M)}bind(K,H,M,q){const w=q&&this._storeEffectOnSubMeshes,u=M??(w?q.effect:this.getEffect());if(!u)return;const y=this.sK();this._activeEffect=u,this.bindOnlyWorldMatrix(K,M);const h=this._options.uniformBuffers;let W=!1;if(u&&h&&h.length>0&&y.getEngine().supportsUniformBuffers)for(let z=0;z<h.length;++z){switch(h[z]){case"Mesh":H&&(H.getMeshUniformBuffer().bindToEffect(u,"Mesh"),H.transferToEffect(K));break;case"Scene":(0,v.r)(u,y.getSceneUniformBuffer()),y.finalizeSceneUbo(),W=!0}}const I=H&&w?this._mustRebind(y,u,q,H.visibility):y.getCachedMaterial()!==this;if(u&&I){let K;for(K in W||-1===this._options.uniforms.indexOf("view")||u.setMatrix("view",y.getViewMatrix()),W||-1===this._options.uniforms.indexOf("projection")||u.setMatrix("projection",y.getProjectionMatrix()),W||-1===this._options.uniforms.indexOf("viewProjection")||(u.setMatrix("viewProjection",y.getTransformMatrix()),this._multiview&&u.setMatrix("viewProjectionR",y._transformMatrixR)),y.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&u.setVector3("cameraPosition",y.activeCamera.globalPosition),(0,v.e)(H,u),(0,a.g)(u,this,y),this._useLogarithmicDepth&&(0,v.l)(w?q.materialDefines:u.defines,u,y),H&&(0,v.g)(y,H,u),this._textures)u.setTexture(K,this._textures[K]);for(K in this._textureArrays)u.setTextureArray(K,this._textureArrays[K]);for(K in this._ints)u.setInt(K,this._ints[K]);for(K in this._uints)u.setUInt(K,this._uints[K]);for(K in this._floats)u.setFloat(K,this._floats[K]);for(K in this._floatsArrays)u.setArray(K,this._floatsArrays[K]);for(K in this._colors3)u.setColor3(K,this._colors3[K]);for(K in this._colors3Arrays)u.setArray3(K,this._colors3Arrays[K]);for(K in this._colors4){const H=this._colors4[K];u.setFloat4(K,H.r,H.g,H.b,H.a)}for(K in this._colors4Arrays)u.setArray4(K,this._colors4Arrays[K]);for(K in this._vectors2)u.setVector2(K,this._vectors2[K]);for(K in this._vectors3)u.setVector3(K,this._vectors3[K]);for(K in this._vectors4)u.setVector4(K,this._vectors4[K]);for(K in this._quaternions)u.setQuaternion(K,this._quaternions[K]);for(K in this._matrices)u.setMatrix(K,this._matrices[K]);for(K in this._matrixArrays)u.setMatrices(K,this._matrixArrays[K]);for(K in this._matrices3x3)u.setMatrix3x3(K,this._matrices3x3[K]);for(K in this._matrices2x2)u.setMatrix2x2(K,this._matrices2x2[K]);for(K in this._vectors2Arrays)u.setArray2(K,this._vectors2Arrays[K]);for(K in this._vectors3Arrays)u.setArray3(K,this._vectors3Arrays[K]);for(K in this._vectors4Arrays)u.setArray4(K,this._vectors4Arrays[K]);for(K in this._quaternionsArrays)u.setArray4(K,this._quaternionsArrays[K]);for(K in this._uniformBuffers){const H=this._uniformBuffers[K].getBuffer();H&&u.bindUniformBuffer(H,K)}const M=y.getEngine(),h=M.setExternalTexture;if(h)for(K in this._externalTextures)h.call(M,K,this._externalTextures[K]);const I=M.setTextureSampler;if(I)for(K in this._textureSamplers)I.call(M,K,this._textureSamplers[K]);const f=M.setStorageBuffer;if(f)for(K in this._storageBuffers)f.call(M,K,this._storageBuffers[K])}if(u&&H&&(I||!this.isFrozen)){(0,v.o)(H,u),H.morphTargetManager&&H.morphTargetManager.isUsingTextureForTargets&&H.morphTargetManager._bind(u);const K=H.bakedVertexAnimationManager;if(K&&K.isEnabled){var f;const K=w?q._drawWrapper:this._drawWrapper;null===(f=H.bakedVertexAnimationManager)||void 0===f||f.bind(u,!!K._wasPreviouslyUsingInstances)}}this._afterBind(H,u,q)}getActiveTextures(){const K=super.getActiveTextures();for(const H in this._textures)K.push(this._textures[H]);for(const H in this._textureArrays){const M=this._textureArrays[H];for(let H=0;H<M.length;H++)K.push(M[H])}return K}hasTexture(K){if(super.hasTexture(K))return!0;for(const H in this._textures)if(this._textures[H]===K)return!0;for(const H in this._textureArrays){const M=this._textureArrays[H];for(let H=0;H<M.length;H++)if(M[H]===K)return!0}return!1}clone(K){const H=q.c.Clone((()=>new L(K,this.sK(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);H.name=K,H.id=K,"object"===typeof H._shaderPath&&(H._shaderPath={...H._shaderPath}),this._options={...this._options};const M=Object.keys(this._options);for(const q of M){const K=this._options[q];Array.isArray(K)&&(this._options[q]=K.slice(0))}this.stencil.copyTo(H.stencil);for(const q in this._textures)H.setTexture(q,this._textures[q]);for(const q in this._textureArrays)H.setTextureArray(q,this._textureArrays[q]);for(const q in this._externalTextures)H.setExternalTexture(q,this._externalTextures[q]);for(const q in this._ints)H.setInt(q,this._ints[q]);for(const q in this._uints)H.setUInt(q,this._uints[q]);for(const q in this._floats)H.setFloat(q,this._floats[q]);for(const q in this._floatsArrays)H.setFloats(q,this._floatsArrays[q]);for(const q in this._colors3)H.setColor3(q,this._colors3[q]);for(const q in this._colors3Arrays)H._colors3Arrays[q]=this._colors3Arrays[q];for(const q in this._colors4)H.setColor4(q,this._colors4[q]);for(const q in this._colors4Arrays)H._colors4Arrays[q]=this._colors4Arrays[q];for(const q in this._vectors2)H.setVector2(q,this._vectors2[q]);for(const q in this._vectors3)H.setVector3(q,this._vectors3[q]);for(const q in this._vectors4)H.setVector4(q,this._vectors4[q]);for(const q in this._quaternions)H.setQuaternion(q,this._quaternions[q]);for(const q in this._quaternionsArrays)H._quaternionsArrays[q]=this._quaternionsArrays[q];for(const q in this._matrices)H.setMatrix(q,this._matrices[q]);for(const q in this._matrixArrays)H._matrixArrays[q]=this._matrixArrays[q].slice();for(const q in this._matrices3x3)H.setMatrix3x3(q,this._matrices3x3[q]);for(const q in this._matrices2x2)H.setMatrix2x2(q,this._matrices2x2[q]);for(const q in this._vectors2Arrays)H.setArray2(q,this._vectors2Arrays[q]);for(const q in this._vectors3Arrays)H.setArray3(q,this._vectors3Arrays[q]);for(const q in this._vectors4Arrays)H.setArray4(q,this._vectors4Arrays[q]);for(const q in this._uniformBuffers)H.setUniformBuffer(q,this._uniformBuffers[q]);for(const q in this._textureSamplers)H.setTextureSampler(q,this._textureSamplers[q]);for(const q in this._storageBuffers)H.setStorageBuffer(q,this._storageBuffers[q]);return H}dispose(K,H,M){if(H){let K;for(K in this._textures)this._textures[K].dispose();for(K in this._textureArrays){const H=this._textureArrays[K];for(let K=0;K<H.length;K++)H[K].dispose()}}this._textures={},super.dispose(K,H,M)}serialize(){const K=q.c.Serialize(this);let H;for(H in K.customType="BABYLON.ShaderMaterial",K.uniqueId=this.uniqueId,K.options=this._options,K.shaderPath=this._shaderPath,K.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,K.stencil=this.stencil.serialize(),K.textures={},this._textures)K.textures[H]=this._textures[H].serialize();for(H in K.textureArrays={},this._textureArrays){K.textureArrays[H]=[];const M=this._textureArrays[H];for(let q=0;q<M.length;q++)K.textureArrays[H].push(M[q].serialize())}for(H in K.ints={},this._ints)K.ints[H]=this._ints[H];for(H in K.uints={},this._uints)K.uints[H]=this._uints[H];for(H in K.floats={},this._floats)K.floats[H]=this._floats[H];for(H in K.floatsArrays={},this._floatsArrays)K.floatsArrays[H]=this._floatsArrays[H];for(H in K.colors3={},this._colors3){const M=this._colors3[H];K.colors3[H]=[M.r,M.g,M.b]}for(H in K.colors3Arrays={},this._colors3Arrays)K.colors3Arrays[H]=this._colors3Arrays[H];for(H in K.colors4={},this._colors4){const M=this._colors4[H];K.colors4[H]=[M.r,M.g,M.b,M.a]}for(H in K.colors4Arrays={},this._colors4Arrays)K.colors4Arrays[H]=this._colors4Arrays[H];for(H in K.vectors2={},this._vectors2){const M=this._vectors2[H];K.vectors2[H]=[M.x,M.y]}for(H in K.vectors3={},this._vectors3){const M=this._vectors3[H];K.vectors3[H]=[M.x,M.y,M.z]}for(H in K.vectors4={},this._vectors4){const M=this._vectors4[H];K.vectors4[H]=[M.x,M.y,M.z,M.w]}for(H in K.quaternions={},this._quaternions)K.quaternions[H]=this._quaternions[H].hh();for(H in K.matrices={},this._matrices)K.matrices[H]=this._matrices[H].hh();for(H in K.matrixArray={},this._matrixArrays)K.matrixArray[H]=this._matrixArrays[H];for(H in K.matrices3x3={},this._matrices3x3)K.matrices3x3[H]=this._matrices3x3[H];for(H in K.matrices2x2={},this._matrices2x2)K.matrices2x2[H]=this._matrices2x2[H];for(H in K.vectors2Arrays={},this._vectors2Arrays)K.vectors2Arrays[H]=this._vectors2Arrays[H];for(H in K.vectors3Arrays={},this._vectors3Arrays)K.vectors3Arrays[H]=this._vectors3Arrays[H];for(H in K.vectors4Arrays={},this._vectors4Arrays)K.vectors4Arrays[H]=this._vectors4Arrays[H];for(H in K.quaternionsArrays={},this._quaternionsArrays)K.quaternionsArrays[H]=this._quaternionsArrays[H];return K}static Parse(K,H,M){const w=q.c.Parse((()=>new L(K.name,H,K.shaderPath,K.options,K.storeEffectOnSubMeshes)),K,H,M);let y;for(y in K.stencil&&w.stencil.parse(K.stencil,H,M),K.textures)w.setTexture(y,h.b.Parse(K.textures[y],H,M));for(y in K.textureArrays){const q=K.textureArrays[y],u=[];for(let K=0;K<q.length;K++)u.push(h.b.Parse(q[K],H,M));w.setTextureArray(y,u)}for(y in K.ints)w.setInt(y,K.ints[y]);for(y in K.uints)w.setUInt(y,K.uints[y]);for(y in K.floats)w.setFloat(y,K.floats[y]);for(y in K.floatsArrays)w.setFloats(y,K.floatsArrays[y]);for(y in K.colors3){const H=K.colors3[y];w.setColor3(y,{r:H[0],g:H[1],b:H[2]})}for(y in K.colors3Arrays){const H=K.colors3Arrays[y].reduce(((K,H,M)=>(M%3===0?K.push([H]):K[K.length-1].push(H),K)),[]).map((K=>({r:K[0],g:K[1],b:K[2]})));w.setColor3Array(y,H)}for(y in K.colors4){const H=K.colors4[y];w.setColor4(y,{r:H[0],g:H[1],b:H[2],a:H[3]})}for(y in K.colors4Arrays){const H=K.colors4Arrays[y].reduce(((K,H,M)=>(M%4===0?K.push([H]):K[K.length-1].push(H),K)),[]).map((K=>({r:K[0],g:K[1],b:K[2],a:K[3]})));w.setColor4Array(y,H)}for(y in K.vectors2){const H=K.vectors2[y];w.setVector2(y,{x:H[0],y:H[1]})}for(y in K.vectors3){const H=K.vectors3[y];w.setVector3(y,{x:H[0],y:H[1],z:H[2]})}for(y in K.vectors4){const H=K.vectors4[y];w.setVector4(y,{x:H[0],y:H[1],z:H[2],w:H[3]})}for(y in K.quaternions)w.setQuaternion(y,u.Quaternion.iH(K.quaternions[y]));for(y in K.matrices)w.setMatrix(y,u.Matrix.iH(K.matrices[y]));for(y in K.matrixArray)w._matrixArrays[y]=new Float32Array(K.matrixArray[y]);for(y in K.matrices3x3)w.setMatrix3x3(y,K.matrices3x3[y]);for(y in K.matrices2x2)w.setMatrix2x2(y,K.matrices2x2[y]);for(y in K.vectors2Arrays)w.setArray2(y,K.vectors2Arrays[y]);for(y in K.vectors3Arrays)w.setArray3(y,K.vectors3Arrays[y]);for(y in K.vectors4Arrays)w.setArray4(y,K.vectors4Arrays[y]);for(y in K.quaternionsArrays)w.setArray4(y,K.quaternionsArrays[y]);return w}static async ParseFromFileAsync(K,H,M){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((w,u)=>{const y=new f.c;y.addEventListener("readystatechange",(()=>{if(4==y.readyState)if(200==y.status){const H=JSON.parse(y.responseText),u=this.Parse(H,M||G.b.LastCreatedScene,q);K&&(u.name=K),w(u)}else u("Unable to load the ShaderMaterial")})),y.open("GET",H),y.send()}))}static async ParseFromSnippetAsync(K,H){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((q,w)=>{const u=new f.c;u.addEventListener("readystatechange",(()=>{if(4==u.readyState)if(200==u.status){const w=JSON.parse(JSON.parse(u.responseText).jsonPayload),y=JSON.parse(w.shaderMaterial),h=this.Parse(y,H||G.b.LastCreatedScene,M);h.snippetId=K,q(h)}else w("Unable to load the snippet "+K)})),u.open("GET",this.SnippetUrl+"/"+K.replace(/#/g,"/")),u.send()}))}}L.SnippetUrl="https://snippet.babylonjs.com",L.CreateFromSnippetAsync=L.ParseFromSnippetAsync,(0,W.f)("BABYLON.ShaderMaterial",L)}}]);