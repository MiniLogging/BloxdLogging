"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[22],{12587:(M,Z,P)=>{P.r(Z),P.d(Z,{ShaderMaterial:()=>n});var x=P(12394),c=P(12596),w=P(12373),v=P(12430),G=P(12344),mM=P(12317),K=P(12672),d=P(12220),O=P(12675),H=P(12225),j=P(12735),B=P(12731);const U={effect:null,subMesh:null};class n extends O.d{constructor(M,Z,P){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(M,Z,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new w.Matrix,this._cachedWorldViewProjectionMatrix=new w.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=P,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...x}}get shaderPath(){return this._shaderPath}set shaderPath(M){this._shaderPath=M}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(M){-1===this._options.uniforms.indexOf(M)&&this._options.uniforms.push(M)}setTexture(M,Z){return-1===this._options.samplers.indexOf(M)&&this._options.samplers.push(M),this._textures[M]=Z,this}removeTexture(M){delete this._textures[M]}setTextureArray(M,Z){return-1===this._options.samplers.indexOf(M)&&this._options.samplers.push(M),this._checkUniform(M),this._textureArrays[M]=Z,this}setExternalTexture(M,Z){return-1===this._options.externalTextures.indexOf(M)&&this._options.externalTextures.push(M),this._externalTextures[M]=Z,this}setFloat(M,Z){return this._checkUniform(M),this._floats[M]=Z,this}setInt(M,Z){return this._checkUniform(M),this._ints[M]=Z,this}setUInt(M,Z){return this._checkUniform(M),this._uints[M]=Z,this}setFloats(M,Z){return this._checkUniform(M),this._floatsArrays[M]=Z,this}setColor3(M,Z){return this._checkUniform(M),this._colors3[M]=Z,this}setColor3Array(M,Z){return this._checkUniform(M),this._colors3Arrays[M]=Z.reduce(((M,Z)=>(M.push(Z.r,Z.g,Z.b),M)),[]),this}setColor4(M,Z){return this._checkUniform(M),this._colors4[M]=Z,this}setColor4Array(M,Z){return this._checkUniform(M),this._colors4Arrays[M]=Z.reduce(((M,Z)=>(M.push(Z.r,Z.g,Z.b,Z.a),M)),[]),this}setVector2(M,Z){return this._checkUniform(M),this._vectors2[M]=Z,this}setVector3(M,Z){return this._checkUniform(M),this._vectors3[M]=Z,this}setVector4(M,Z){return this._checkUniform(M),this._vectors4[M]=Z,this}setQuaternion(M,Z){return this._checkUniform(M),this._quaternions[M]=Z,this}setQuaternionArray(M,Z){return this._checkUniform(M),this._quaternionsArrays[M]=Z.reduce(((M,Z)=>(Z.toArray(M,M.length),M)),[]),this}setMatrix(M,Z){return this._checkUniform(M),this._matrices[M]=Z,this}setMatrices(M,Z){this._checkUniform(M);const P=new Float32Array(16*Z.length);for(let x=0;x<Z.length;x++){Z[x].copyToArray(P,16*x)}return this._matrixArrays[M]=P,this}setMatrix3x3(M,Z){return this._checkUniform(M),this._matrices3x3[M]=Z,this}setMatrix2x2(M,Z){return this._checkUniform(M),this._matrices2x2[M]=Z,this}setArray2(M,Z){return this._checkUniform(M),this._vectors2Arrays[M]=Z,this}setArray3(M,Z){return this._checkUniform(M),this._vectors3Arrays[M]=Z,this}setArray4(M,Z){return this._checkUniform(M),this._vectors4Arrays[M]=Z,this}setUniformBuffer(M,Z){return-1===this._options.uniformBuffers.indexOf(M)&&this._options.uniformBuffers.push(M),this._uniformBuffers[M]=Z,this}setTextureSampler(M,Z){return-1===this._options.samplerObjects.indexOf(M)&&this._options.samplerObjects.push(M),this._textureSamplers[M]=Z,this}setStorageBuffer(M,Z){return-1===this._options.storageBuffers.indexOf(M)&&this._options.storageBuffers.push(M),this._storageBuffers[M]=Z,this}setDefine(M,Z){const P=M.trimEnd()+" ",x=this.options.defines.findIndex((Z=>Z===M||Z.startsWith(P)));return x>=0&&this.options.defines.splice(x,1),("boolean"!==typeof Z||Z)&&this.options.defines.push(P+Z),this}isReadyForSubMesh(M,Z,P){return this.isReady(M,P,Z)}isReady(M,Z,P){var x;const w=P&&this._storeEffectOnSubMeshes;if(this.isFrozen){const M=w?P._drawWrapper:this._drawWrapper;if(M.effect&&M._wasPreviouslyReady&&M._wasPreviouslyUsingInstances===Z)return!0}const G=this.DM(),mM=G.getEngine(),d=[],O=[];let H=null,n=this._shaderPath,L=this._options.uniforms,u=this._options.uniformBuffers,N=this._options.samplers;mM.getCaps().multiview&&G.activeCamera&&G.activeCamera.outputRenderTarget&&G.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,d.push("#define MULTIVIEW"),-1!==L.indexOf("viewProjection")&&-1===L.indexOf("viewProjectionR")&&L.push("viewProjectionR"));for(let c=0;c<this._options.defines.length;c++){const M=0===this._options.defines[c].indexOf("#define")?this._options.defines[c]:`#define ${this._options.defines[c]}`;d.push(M)}for(let c=0;c<this._options.attributes.length;c++)O.push(this._options.attributes[c]);if(M&&M.isVerticesDataPresent(v.g.ColorKind)&&(-1===O.indexOf(v.g.ColorKind)&&O.push(v.g.ColorKind),d.push("#define VERTEXCOLOR")),Z&&(d.push("#define INSTANCES"),(0,B.eb)(O,this._materialHelperNeedsPreviousMatrices),null!==M&&void 0!==M&&M.hasThinInstances&&(d.push("#define THIN_INSTANCES"),M&&M.isVerticesDataPresent(v.g.ColorInstanceKind)&&(O.push(v.g.ColorInstanceKind),d.push("#define INSTANCESCOLOR")))),M&&M.useBones&&M.computeBonesUsingShaders&&M.skeleton){O.push(v.g.MatricesIndicesKind),O.push(v.g.MatricesWeightsKind),M.numBoneInfluencers>4&&(O.push(v.g.MatricesIndicesExtraKind),O.push(v.g.MatricesWeightsExtraKind));const Z=M.skeleton;d.push("#define NUM_BONE_INFLUENCERS "+M.numBoneInfluencers),H=new K.e,H.addCPUSkinningFallback(0,M),Z.isUsingTextureForMatrices?(d.push("#define BONETEXTURE"),-1===L.indexOf("boneTextureWidth")&&L.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(d.push("#define BonesPerMesh "+(Z.bones.length+1)),-1===L.indexOf("mBones")&&L.push("mBones"))}else d.push("#define NUM_BONE_INFLUENCERS 0");let J=0;const t=M?M.morphTargetManager:null;if(t){const Z=-1!==d.indexOf("#define UV1"),P=-1!==d.indexOf("#define UV2"),x=-1!==d.indexOf("#define TANGENT"),c=-1!==d.indexOf("#define NORMAL"),w=-1!==d.indexOf("#define VERTEXCOLOR");J=(0,B.F)(t,d,O,M,!0,c,x,Z,P,w),t.isUsingTextureForTargets&&(-1===L.indexOf("morphTargetTextureIndices")&&L.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),J>0&&(L=L.slice(),L.push("morphTargetInfluences"),L.push("morphTargetCount"),L.push("morphTargetTextureInfo"),L.push("morphTargetTextureIndices"))}else d.push("#define NUM_MORPH_INFLUENCERS 0");if(M){const Z=M.bakedVertexAnimationManager;Z&&Z.isEnabled&&(d.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===L.indexOf("bakedVertexAnimationSettings")&&L.push("bakedVertexAnimationSettings"),-1===L.indexOf("bakedVertexAnimationTextureSizeInverted")&&L.push("bakedVertexAnimationTextureSizeInverted"),-1===L.indexOf("bakedVertexAnimationTime")&&L.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,B.y)(O,M,d)}for(const c in this._textures)if(!this._textures[c].isReady())return!1;M&&this.needAlphaTestingForMesh(M)&&d.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,j.e)(L),(0,j.h)(this,G,d)),G.fogEnabled&&null!==M&&void 0!==M&&M.applyFog&&G.fogMode!==c.e.FOGMODE_NONE&&(d.push("#define FOG"),-1===L.indexOf("view")&&L.push("view"),-1===L.indexOf("vFogInfos")&&L.push("vFogInfos"),-1===L.indexOf("vFogColor")&&L.push("vFogColor")),this._useLogarithmicDepth&&(d.push("#define LOGARITHMICDEPTH"),-1===L.indexOf("logarithmicDepthConstant")&&L.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(L=L.slice(),u=u.slice(),N=N.slice(),n=this.customShaderNameResolve(this.name,L,u,N,d,O));const F=w?P._getDrawWrapper(void 0,!0):this._drawWrapper,D=(null===F||void 0===F?void 0:F.effect)??null,l=(null===F||void 0===F?void 0:F.defines)??null,h=d.join("\n");let Q=D;return l!==h&&(Q=mM.createEffect(n,{attributes:O,uniformsNames:L,uniformBuffersNames:u,samplers:N,defines:h,fallbacks:H,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:J},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},mM),w?P.setEffect(Q,h,this._materialContext):F&&F.setEffect(Q,h),this._onEffectCreatedObservable&&(U.effect=Q,U.subMesh=P??(null===M||void 0===M?void 0:M.Uc[0])??null,this._onEffectCreatedObservable.notifyObservers(U))),F._wasPreviouslyUsingInstances=!!Z,!(null===(x=Q)||void 0===x||!x.isReady())&&(D!==Q&&G.resetCachedMaterial(),F._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(M,Z){const P=Z??this.getEffect();if(!P)return;const x=this._options.uniforms;-1!==x.indexOf("world")&&P.setMatrix("world",M);const c=this.DM();-1!==x.indexOf("worldView")&&(M.multiplyToRef(c.getViewMatrix(),this._cachedWorldViewMatrix),P.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==x.indexOf("worldViewProjection")&&(M.multiplyToRef(c.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),P.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==x.indexOf("view")&&P.setMatrix("view",c.getViewMatrix())}bindForSubMesh(M,Z,P){var x;this.bind(M,Z,null===(x=P._drawWrapperOverride)||void 0===x?void 0:x.effect,P)}bind(M,Z,P,x){const c=x&&this._storeEffectOnSubMeshes,w=P??(c?x.effect:this.getEffect());if(!w)return;const v=this.DM();this._activeEffect=w,this.bindOnlyWorldMatrix(M,P);const G=this._options.uniformBuffers;let mM=!1;if(w&&G&&G.length>0&&v.getEngine().supportsUniformBuffers)for(let O=0;O<G.length;++O){switch(G[O]){case"Mesh":Z&&(Z.getMeshUniformBuffer().bindToEffect(w,"Mesh"),Z.transferToEffect(M));break;case"Scene":(0,B.r)(w,v.getSceneUniformBuffer()),v.finalizeSceneUbo(),mM=!0}}const K=Z&&c?this._mustRebind(v,w,x,Z.visibility):v.getCachedMaterial()!==this;if(w&&K){let M;for(M in mM||-1===this._options.uniforms.indexOf("view")||w.setMatrix("view",v.getViewMatrix()),mM||-1===this._options.uniforms.indexOf("projection")||w.setMatrix("projection",v.getProjectionMatrix()),mM||-1===this._options.uniforms.indexOf("viewProjection")||(w.setMatrix("viewProjection",v.getTransformMatrix()),this._multiview&&w.setMatrix("viewProjectionR",v._transformMatrixR)),v.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&w.setVector3("cameraPosition",v.activeCamera.globalPosition),(0,B.e)(Z,w),(0,j.f)(w,this,v),this._useLogarithmicDepth&&(0,B.m)(c?x.materialDefines:w.defines,w,v),Z&&(0,B.g)(v,Z,w),this._textures)w.setTexture(M,this._textures[M]);for(M in this._textureArrays)w.setTextureArray(M,this._textureArrays[M]);for(M in this._ints)w.setInt(M,this._ints[M]);for(M in this._uints)w.setUInt(M,this._uints[M]);for(M in this._floats)w.setFloat(M,this._floats[M]);for(M in this._floatsArrays)w.setArray(M,this._floatsArrays[M]);for(M in this._colors3)w.setColor3(M,this._colors3[M]);for(M in this._colors3Arrays)w.setArray3(M,this._colors3Arrays[M]);for(M in this._colors4){const Z=this._colors4[M];w.setFloat4(M,Z.r,Z.g,Z.b,Z.a)}for(M in this._colors4Arrays)w.setArray4(M,this._colors4Arrays[M]);for(M in this._vectors2)w.setVector2(M,this._vectors2[M]);for(M in this._vectors3)w.setVector3(M,this._vectors3[M]);for(M in this._vectors4)w.setVector4(M,this._vectors4[M]);for(M in this._quaternions)w.setQuaternion(M,this._quaternions[M]);for(M in this._matrices)w.setMatrix(M,this._matrices[M]);for(M in this._matrixArrays)w.setMatrices(M,this._matrixArrays[M]);for(M in this._matrices3x3)w.setMatrix3x3(M,this._matrices3x3[M]);for(M in this._matrices2x2)w.setMatrix2x2(M,this._matrices2x2[M]);for(M in this._vectors2Arrays)w.setArray2(M,this._vectors2Arrays[M]);for(M in this._vectors3Arrays)w.setArray3(M,this._vectors3Arrays[M]);for(M in this._vectors4Arrays)w.setArray4(M,this._vectors4Arrays[M]);for(M in this._quaternionsArrays)w.setArray4(M,this._quaternionsArrays[M]);for(M in this._uniformBuffers){const Z=this._uniformBuffers[M].getBuffer();Z&&w.bindUniformBuffer(Z,M)}const P=v.getEngine(),G=P.setExternalTexture;if(G)for(M in this._externalTextures)G.call(P,M,this._externalTextures[M]);const K=P.setTextureSampler;if(K)for(M in this._textureSamplers)K.call(P,M,this._textureSamplers[M]);const d=P.setStorageBuffer;if(d)for(M in this._storageBuffers)d.call(P,M,this._storageBuffers[M])}if(w&&Z&&(K||!this.isFrozen)){(0,B.q)(Z,w),Z.morphTargetManager&&Z.morphTargetManager.isUsingTextureForTargets&&Z.morphTargetManager._bind(w);const M=Z.bakedVertexAnimationManager;if(M&&M.isEnabled){var d;const M=c?x._drawWrapper:this._drawWrapper;null===(d=Z.bakedVertexAnimationManager)||void 0===d||d.bind(w,!!M._wasPreviouslyUsingInstances)}}this._afterBind(Z,w,x)}getActiveTextures(){const M=super.getActiveTextures();for(const Z in this._textures)M.push(this._textures[Z]);for(const Z in this._textureArrays){const P=this._textureArrays[Z];for(let Z=0;Z<P.length;Z++)M.push(P[Z])}return M}hasTexture(M){if(super.hasTexture(M))return!0;for(const Z in this._textures)if(this._textures[Z]===M)return!0;for(const Z in this._textureArrays){const P=this._textureArrays[Z];for(let Z=0;Z<P.length;Z++)if(P[Z]===M)return!0}return!1}clone(M){const Z=x.b.Clone((()=>new n(M,this.DM(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);Z.name=M,Z.id=M,"object"===typeof Z._shaderPath&&(Z._shaderPath={...Z._shaderPath}),this._options={...this._options};const P=Object.keys(this._options);for(const x of P){const M=this._options[x];Array.isArray(M)&&(this._options[x]=M.slice(0))}this.Kc.copyTo(Z.Kc);for(const x in this._textures)Z.setTexture(x,this._textures[x]);for(const x in this._textureArrays)Z.setTextureArray(x,this._textureArrays[x]);for(const x in this._externalTextures)Z.setExternalTexture(x,this._externalTextures[x]);for(const x in this._ints)Z.setInt(x,this._ints[x]);for(const x in this._uints)Z.setUInt(x,this._uints[x]);for(const x in this._floats)Z.setFloat(x,this._floats[x]);for(const x in this._floatsArrays)Z.setFloats(x,this._floatsArrays[x]);for(const x in this._colors3)Z.setColor3(x,this._colors3[x]);for(const x in this._colors3Arrays)Z._colors3Arrays[x]=this._colors3Arrays[x];for(const x in this._colors4)Z.setColor4(x,this._colors4[x]);for(const x in this._colors4Arrays)Z._colors4Arrays[x]=this._colors4Arrays[x];for(const x in this._vectors2)Z.setVector2(x,this._vectors2[x]);for(const x in this._vectors3)Z.setVector3(x,this._vectors3[x]);for(const x in this._vectors4)Z.setVector4(x,this._vectors4[x]);for(const x in this._quaternions)Z.setQuaternion(x,this._quaternions[x]);for(const x in this._quaternionsArrays)Z._quaternionsArrays[x]=this._quaternionsArrays[x];for(const x in this._matrices)Z.setMatrix(x,this._matrices[x]);for(const x in this._matrixArrays)Z._matrixArrays[x]=this._matrixArrays[x].slice();for(const x in this._matrices3x3)Z.setMatrix3x3(x,this._matrices3x3[x]);for(const x in this._matrices2x2)Z.setMatrix2x2(x,this._matrices2x2[x]);for(const x in this._vectors2Arrays)Z.setArray2(x,this._vectors2Arrays[x]);for(const x in this._vectors3Arrays)Z.setArray3(x,this._vectors3Arrays[x]);for(const x in this._vectors4Arrays)Z.setArray4(x,this._vectors4Arrays[x]);for(const x in this._uniformBuffers)Z.setUniformBuffer(x,this._uniformBuffers[x]);for(const x in this._textureSamplers)Z.setTextureSampler(x,this._textureSamplers[x]);for(const x in this._storageBuffers)Z.setStorageBuffer(x,this._storageBuffers[x]);return Z}dispose(M,Z,P){if(Z){let M;for(M in this._textures)this._textures[M].dispose();for(M in this._textureArrays){const Z=this._textureArrays[M];for(let M=0;M<Z.length;M++)Z[M].dispose()}}this._textures={},super.dispose(M,Z,P)}serialize(){const M=x.b.Serialize(this);let Z;for(Z in M.customType="BABYLON.ShaderMaterial",M.uniqueId=this.uniqueId,M.options=this._options,M.shaderPath=this._shaderPath,M.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,M.Kc=this.Kc.serialize(),M.textures={},this._textures)M.textures[Z]=this._textures[Z].serialize();for(Z in M.textureArrays={},this._textureArrays){M.textureArrays[Z]=[];const P=this._textureArrays[Z];for(let x=0;x<P.length;x++)M.textureArrays[Z].push(P[x].serialize())}for(Z in M.ints={},this._ints)M.ints[Z]=this._ints[Z];for(Z in M.uints={},this._uints)M.uints[Z]=this._uints[Z];for(Z in M.floats={},this._floats)M.floats[Z]=this._floats[Z];for(Z in M.floatsArrays={},this._floatsArrays)M.floatsArrays[Z]=this._floatsArrays[Z];for(Z in M.colors3={},this._colors3){const P=this._colors3[Z];M.colors3[Z]=[P.r,P.g,P.b]}for(Z in M.colors3Arrays={},this._colors3Arrays)M.colors3Arrays[Z]=this._colors3Arrays[Z];for(Z in M.colors4={},this._colors4){const P=this._colors4[Z];M.colors4[Z]=[P.r,P.g,P.b,P.a]}for(Z in M.colors4Arrays={},this._colors4Arrays)M.colors4Arrays[Z]=this._colors4Arrays[Z];for(Z in M.vectors2={},this._vectors2){const P=this._vectors2[Z];M.vectors2[Z]=[P.x,P.y]}for(Z in M.vectors3={},this._vectors3){const P=this._vectors3[Z];M.vectors3[Z]=[P.x,P.y,P.z]}for(Z in M.vectors4={},this._vectors4){const P=this._vectors4[Z];M.vectors4[Z]=[P.x,P.y,P.z,P.w]}for(Z in M.quaternions={},this._quaternions)M.quaternions[Z]=this._quaternions[Z].nc();for(Z in M.matrices={},this._matrices)M.matrices[Z]=this._matrices[Z].nc();for(Z in M.matrixArray={},this._matrixArrays)M.matrixArray[Z]=this._matrixArrays[Z];for(Z in M.matrices3x3={},this._matrices3x3)M.matrices3x3[Z]=this._matrices3x3[Z];for(Z in M.matrices2x2={},this._matrices2x2)M.matrices2x2[Z]=this._matrices2x2[Z];for(Z in M.vectors2Arrays={},this._vectors2Arrays)M.vectors2Arrays[Z]=this._vectors2Arrays[Z];for(Z in M.vectors3Arrays={},this._vectors3Arrays)M.vectors3Arrays[Z]=this._vectors3Arrays[Z];for(Z in M.vectors4Arrays={},this._vectors4Arrays)M.vectors4Arrays[Z]=this._vectors4Arrays[Z];for(Z in M.quaternionsArrays={},this._quaternionsArrays)M.quaternionsArrays[Z]=this._quaternionsArrays[Z];return M}static Parse(M,Z,P){const c=x.b.Parse((()=>new n(M.name,Z,M.shaderPath,M.options,M.storeEffectOnSubMeshes)),M,Z,P);let v;for(v in M.Kc&&c.Kc.parse(M.Kc,Z,P),M.textures)c.setTexture(v,G.e.Parse(M.textures[v],Z,P));for(v in M.textureArrays){const x=M.textureArrays[v],w=[];for(let M=0;M<x.length;M++)w.push(G.e.Parse(x[M],Z,P));c.setTextureArray(v,w)}for(v in M.ints)c.setInt(v,M.ints[v]);for(v in M.uints)c.setUInt(v,M.uints[v]);for(v in M.floats)c.setFloat(v,M.floats[v]);for(v in M.floatsArrays)c.setFloats(v,M.floatsArrays[v]);for(v in M.colors3){const Z=M.colors3[v];c.setColor3(v,{r:Z[0],g:Z[1],b:Z[2]})}for(v in M.colors3Arrays){const Z=M.colors3Arrays[v].reduce(((M,Z,P)=>(P%3===0?M.push([Z]):M[M.length-1].push(Z),M)),[]).map((M=>({r:M[0],g:M[1],b:M[2]})));c.setColor3Array(v,Z)}for(v in M.colors4){const Z=M.colors4[v];c.setColor4(v,{r:Z[0],g:Z[1],b:Z[2],a:Z[3]})}for(v in M.colors4Arrays){const Z=M.colors4Arrays[v].reduce(((M,Z,P)=>(P%4===0?M.push([Z]):M[M.length-1].push(Z),M)),[]).map((M=>({r:M[0],g:M[1],b:M[2],a:M[3]})));c.setColor4Array(v,Z)}for(v in M.vectors2){const Z=M.vectors2[v];c.setVector2(v,{x:Z[0],y:Z[1]})}for(v in M.vectors3){const Z=M.vectors3[v];c.setVector3(v,{x:Z[0],y:Z[1],z:Z[2]})}for(v in M.vectors4){const Z=M.vectors4[v];c.setVector4(v,{x:Z[0],y:Z[1],z:Z[2],w:Z[3]})}for(v in M.quaternions)c.setQuaternion(v,w.Quaternion.NZ(M.quaternions[v]));for(v in M.matrices)c.setMatrix(v,w.Matrix.NZ(M.matrices[v]));for(v in M.matrixArray)c._matrixArrays[v]=new Float32Array(M.matrixArray[v]);for(v in M.matrices3x3)c.setMatrix3x3(v,M.matrices3x3[v]);for(v in M.matrices2x2)c.setMatrix2x2(v,M.matrices2x2[v]);for(v in M.vectors2Arrays)c.setArray2(v,M.vectors2Arrays[v]);for(v in M.vectors3Arrays)c.setArray3(v,M.vectors3Arrays[v]);for(v in M.vectors4Arrays)c.setArray4(v,M.vectors4Arrays[v]);for(v in M.quaternionsArrays)c.setArray4(v,M.quaternionsArrays[v]);return c}static async ParseFromFileAsync(M,Z,P){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((c,w)=>{const v=new d.c;v.addEventListener("readystatechange",(()=>{if(4==v.readyState)if(200==v.status){const Z=JSON.parse(v.responseText),w=this.Parse(Z,P||H.b.LastCreatedScene,x);M&&(w.name=M),c(w)}else w("Unable to load the ShaderMaterial")})),v.open("GET",Z),v.send()}))}static async ParseFromSnippetAsync(M,Z){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((x,c)=>{const w=new d.c;w.addEventListener("readystatechange",(()=>{if(4==w.readyState)if(200==w.status){const c=JSON.parse(JSON.parse(w.responseText).jsonPayload),v=JSON.parse(c.shaderMaterial),G=this.Parse(v,Z||H.b.LastCreatedScene,P);G.snippetId=M,x(G)}else c("Unable to load the snippet "+M)})),w.open("GET",this.SnippetUrl+"/"+M.replace(/#/g,"/")),w.send()}))}}n.SnippetUrl="https://snippet.babylonjs.com",n.CreateFromSnippetAsync=n.ParseFromSnippetAsync,(0,mM.g)("BABYLON.ShaderMaterial",n)}}]);