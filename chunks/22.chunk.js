"use strict";(self["9jl1vn4ei5r"]=self["9jl1vn4ei5r"]||[]).push([[22],{12031:(M,p,b)=>{b.r(p),b.d(p,{ShaderMaterial:()=>j});var Q=b(11823),q=b(12033),B=b(11796),k=b(11857),u=b(11780),T=b(11757),O=b(12116),H=b(11660),F=b(12122),o=b(11664),W=b(12173),i=b(12167);const A={effect:null,subMesh:null};class j extends F.c{constructor(M,p,b){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(M,p,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new B.Matrix,this._cachedWorldViewProjectionMatrix=new B.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=b,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...Q}}get shaderPath(){return this._shaderPath}set shaderPath(M){this._shaderPath=M}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(M){-1===this._options.uniforms.indexOf(M)&&this._options.uniforms.push(M)}setTexture(M,p){return-1===this._options.samplers.indexOf(M)&&this._options.samplers.push(M),this._textures[M]=p,this}removeTexture(M){delete this._textures[M]}setTextureArray(M,p){return-1===this._options.samplers.indexOf(M)&&this._options.samplers.push(M),this._checkUniform(M),this._textureArrays[M]=p,this}setExternalTexture(M,p){return-1===this._options.externalTextures.indexOf(M)&&this._options.externalTextures.push(M),this._externalTextures[M]=p,this}setFloat(M,p){return this._checkUniform(M),this._floats[M]=p,this}setInt(M,p){return this._checkUniform(M),this._ints[M]=p,this}setUInt(M,p){return this._checkUniform(M),this._uints[M]=p,this}setFloats(M,p){return this._checkUniform(M),this._floatsArrays[M]=p,this}setColor3(M,p){return this._checkUniform(M),this._colors3[M]=p,this}setColor3Array(M,p){return this._checkUniform(M),this._colors3Arrays[M]=p.reduce(((M,p)=>(M.push(p.r,p.g,p.b),M)),[]),this}setColor4(M,p){return this._checkUniform(M),this._colors4[M]=p,this}setColor4Array(M,p){return this._checkUniform(M),this._colors4Arrays[M]=p.reduce(((M,p)=>(M.push(p.r,p.g,p.b,p.a),M)),[]),this}setVector2(M,p){return this._checkUniform(M),this._vectors2[M]=p,this}setVector3(M,p){return this._checkUniform(M),this._vectors3[M]=p,this}setVector4(M,p){return this._checkUniform(M),this._vectors4[M]=p,this}setQuaternion(M,p){return this._checkUniform(M),this._quaternions[M]=p,this}setQuaternionArray(M,p){return this._checkUniform(M),this._quaternionsArrays[M]=p.reduce(((M,p)=>(p.toArray(M,M.length),M)),[]),this}setMatrix(M,p){return this._checkUniform(M),this._matrices[M]=p,this}setMatrices(M,p){this._checkUniform(M);const b=new Float32Array(16*p.length);for(let Q=0;Q<p.length;Q++){p[Q].copyToArray(b,16*Q)}return this._matrixArrays[M]=b,this}setMatrix3x3(M,p){return this._checkUniform(M),this._matrices3x3[M]=p,this}setMatrix2x2(M,p){return this._checkUniform(M),this._matrices2x2[M]=p,this}setArray2(M,p){return this._checkUniform(M),this._vectors2Arrays[M]=p,this}setArray3(M,p){return this._checkUniform(M),this._vectors3Arrays[M]=p,this}setArray4(M,p){return this._checkUniform(M),this._vectors4Arrays[M]=p,this}setUniformBuffer(M,p){return-1===this._options.uniformBuffers.indexOf(M)&&this._options.uniformBuffers.push(M),this._uniformBuffers[M]=p,this}setTextureSampler(M,p){return-1===this._options.samplerObjects.indexOf(M)&&this._options.samplerObjects.push(M),this._textureSamplers[M]=p,this}setStorageBuffer(M,p){return-1===this._options.storageBuffers.indexOf(M)&&this._options.storageBuffers.push(M),this._storageBuffers[M]=p,this}setDefine(M,p){const b=M.trimEnd()+" ",Q=this.options.defines.findIndex((p=>p===M||p.startsWith(b)));return Q>=0&&this.options.defines.splice(Q,1),("boolean"!==typeof p||p)&&this.options.defines.push(b+p),this}isReadyForSubMesh(M,p,b){return this.isReady(M,b,p)}isReady(M,p,b){var Q;const B=b&&this._storeEffectOnSubMeshes;if(this.isFrozen){const M=B?b._drawWrapper:this._drawWrapper;if(M.effect&&M._wasPreviouslyReady&&M._wasPreviouslyUsingInstances===p)return!0}const u=this.RM(),T=u.getEngine(),H=[],F=[];let o=null,j=this._shaderPath,K=this._options.uniforms,D=this._options.uniformBuffers,a=this._options.samplers;T.getCaps().multiview&&u.activeCamera&&u.activeCamera.outputRenderTarget&&u.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,H.push("#define MULTIVIEW"),-1!==K.indexOf("viewProjection")&&-1===K.indexOf("viewProjectionR")&&K.push("viewProjectionR"));for(let q=0;q<this._options.defines.length;q++){const M=0===this._options.defines[q].indexOf("#define")?this._options.defines[q]:`#define ${this._options.defines[q]}`;H.push(M)}for(let q=0;q<this._options.attributes.length;q++)F.push(this._options.attributes[q]);if(M&&M.isVerticesDataPresent(k.f.ColorKind)&&(-1===F.indexOf(k.f.ColorKind)&&F.push(k.f.ColorKind),H.push("#define VERTEXCOLOR")),p&&(H.push("#define INSTANCES"),(0,i.R)(F,this._materialHelperNeedsPreviousMatrices),null!==M&&void 0!==M&&M.hasThinInstances&&(H.push("#define THIN_INSTANCES"),M&&M.isVerticesDataPresent(k.f.ColorInstanceKind)&&(F.push(k.f.ColorInstanceKind),H.push("#define INSTANCESCOLOR")))),M&&M.useBones&&M.computeBonesUsingShaders&&M.skeleton){F.push(k.f.MatricesIndicesKind),F.push(k.f.MatricesWeightsKind),M.numBoneInfluencers>4&&(F.push(k.f.MatricesIndicesExtraKind),F.push(k.f.MatricesWeightsExtraKind));const p=M.skeleton;H.push("#define NUM_BONE_INFLUENCERS "+M.numBoneInfluencers),o=new O.c,o.addCPUSkinningFallback(0,M),p.isUsingTextureForMatrices?(H.push("#define BONETEXTURE"),-1===K.indexOf("boneTextureWidth")&&K.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(H.push("#define BonesPerMesh "+(p.bones.length+1)),-1===K.indexOf("mBones")&&K.push("mBones"))}else H.push("#define NUM_BONE_INFLUENCERS 0");let s=0;const S=M?M.morphTargetManager:null;if(S){const p=-1!==H.indexOf("#define UV1"),b=-1!==H.indexOf("#define UV2"),Q=-1!==H.indexOf("#define TANGENT"),q=-1!==H.indexOf("#define NORMAL"),B=-1!==H.indexOf("#define VERTEXCOLOR");s=(0,i.y)(S,H,F,M,!0,q,Q,p,b,B),S.isUsingTextureForTargets&&(-1===K.indexOf("morphTargetTextureIndices")&&K.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),s>0&&(K=K.slice(),K.push("morphTargetInfluences"),K.push("morphTargetCount"),K.push("morphTargetTextureInfo"),K.push("morphTargetTextureIndices"))}else H.push("#define NUM_MORPH_INFLUENCERS 0");if(M){const p=M.bakedVertexAnimationManager;p&&p.isEnabled&&(H.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===K.indexOf("bakedVertexAnimationSettings")&&K.push("bakedVertexAnimationSettings"),-1===K.indexOf("bakedVertexAnimationTextureSizeInverted")&&K.push("bakedVertexAnimationTextureSizeInverted"),-1===K.indexOf("bakedVertexAnimationTime")&&K.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,i.p)(F,M,H)}for(const q in this._textures)if(!this._textures[q].isReady())return!1;M&&this.needAlphaTestingForMesh(M)&&H.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,W.d)(K),(0,W.i)(this,u,H)),u.fogEnabled&&null!==M&&void 0!==M&&M.applyFog&&u.fogMode!==q.e.FOGMODE_NONE&&(H.push("#define FOG"),-1===K.indexOf("view")&&K.push("view"),-1===K.indexOf("vFogInfos")&&K.push("vFogInfos"),-1===K.indexOf("vFogColor")&&K.push("vFogColor")),this._useLogarithmicDepth&&(H.push("#define LOGARITHMICDEPTH"),-1===K.indexOf("logarithmicDepthConstant")&&K.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(K=K.slice(),D=D.slice(),a=a.slice(),j=this.customShaderNameResolve(this.name,K,D,a,H,F));const f=B?b._getDrawWrapper(void 0,!0):this._drawWrapper,R=(null===f||void 0===f?void 0:f.effect)??null,y=(null===f||void 0===f?void 0:f.defines)??null,x=H.join("\n");let P=R;return y!==x&&(P=T.createEffect(j,{attributes:F,uniformsNames:K,uniformBuffersNames:D,samplers:a,defines:x,fallbacks:o,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:s},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},T),B?b.setEffect(P,x,this._materialContext):f&&f.setEffect(P,x),this._onEffectCreatedObservable&&(A.effect=P,A.subMesh=b??(null===M||void 0===M?void 0:M.Tb[0])??null,this._onEffectCreatedObservable.notifyObservers(A))),f._wasPreviouslyUsingInstances=!!p,!(null===(Q=P)||void 0===Q||!Q.isReady())&&(R!==P&&u.resetCachedMaterial(),f._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(M,p){const b=p??this.getEffect();if(!b)return;const Q=this._options.uniforms;-1!==Q.indexOf("world")&&b.setMatrix("world",M);const q=this.RM();-1!==Q.indexOf("worldView")&&(M.multiplyToRef(q.getViewMatrix(),this._cachedWorldViewMatrix),b.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==Q.indexOf("worldViewProjection")&&(M.multiplyToRef(q.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),b.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==Q.indexOf("view")&&b.setMatrix("view",q.getViewMatrix())}bindForSubMesh(M,p,b){var Q;this.bind(M,p,null===(Q=b._drawWrapperOverride)||void 0===Q?void 0:Q.effect,b)}bind(M,p,b,Q){const q=Q&&this._storeEffectOnSubMeshes,B=b??(q?Q.effect:this.getEffect());if(!B)return;const k=this.RM();this._activeEffect=B,this.bindOnlyWorldMatrix(M,b);const u=this._options.uniformBuffers;let T=!1;if(B&&u&&u.length>0&&k.getEngine().supportsUniformBuffers)for(let F=0;F<u.length;++F){switch(u[F]){case"Mesh":p&&(p.getMeshUniformBuffer().bindToEffect(B,"Mesh"),p.transferToEffect(M));break;case"Scene":(0,i.j)(B,k.getSceneUniformBuffer()),k.finalizeSceneUbo(),T=!0}}const O=p&&q?this._mustRebind(k,B,Q,p.visibility):k.getCachedMaterial()!==this;if(B&&O){let M;for(M in T||-1===this._options.uniforms.indexOf("view")||B.setMatrix("view",k.getViewMatrix()),T||-1===this._options.uniforms.indexOf("projection")||B.setMatrix("projection",k.getProjectionMatrix()),T||-1===this._options.uniforms.indexOf("viewProjection")||(B.setMatrix("viewProjection",k.getTransformMatrix()),this._multiview&&B.setMatrix("viewProjectionR",k._transformMatrixR)),k.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&B.setVector3("cameraPosition",k.activeCamera.globalPosition),(0,i.b)(p,B),(0,W.e)(B,this,k),this._useLogarithmicDepth&&(0,i.e)(q?Q.materialDefines:B.defines,B,k),p&&(0,i.c)(k,p,B),this._textures)B.setTexture(M,this._textures[M]);for(M in this._textureArrays)B.setTextureArray(M,this._textureArrays[M]);for(M in this._ints)B.setInt(M,this._ints[M]);for(M in this._uints)B.setUInt(M,this._uints[M]);for(M in this._floats)B.setFloat(M,this._floats[M]);for(M in this._floatsArrays)B.setArray(M,this._floatsArrays[M]);for(M in this._colors3)B.setColor3(M,this._colors3[M]);for(M in this._colors3Arrays)B.setArray3(M,this._colors3Arrays[M]);for(M in this._colors4){const p=this._colors4[M];B.setFloat4(M,p.r,p.g,p.b,p.a)}for(M in this._colors4Arrays)B.setArray4(M,this._colors4Arrays[M]);for(M in this._vectors2)B.setVector2(M,this._vectors2[M]);for(M in this._vectors3)B.setVector3(M,this._vectors3[M]);for(M in this._vectors4)B.setVector4(M,this._vectors4[M]);for(M in this._quaternions)B.setQuaternion(M,this._quaternions[M]);for(M in this._matrices)B.setMatrix(M,this._matrices[M]);for(M in this._matrixArrays)B.setMatrices(M,this._matrixArrays[M]);for(M in this._matrices3x3)B.setMatrix3x3(M,this._matrices3x3[M]);for(M in this._matrices2x2)B.setMatrix2x2(M,this._matrices2x2[M]);for(M in this._vectors2Arrays)B.setArray2(M,this._vectors2Arrays[M]);for(M in this._vectors3Arrays)B.setArray3(M,this._vectors3Arrays[M]);for(M in this._vectors4Arrays)B.setArray4(M,this._vectors4Arrays[M]);for(M in this._quaternionsArrays)B.setArray4(M,this._quaternionsArrays[M]);for(M in this._uniformBuffers){const p=this._uniformBuffers[M].getBuffer();p&&B.bindUniformBuffer(p,M)}const b=k.getEngine(),u=b.setExternalTexture;if(u)for(M in this._externalTextures)u.call(b,M,this._externalTextures[M]);const O=b.setTextureSampler;if(O)for(M in this._textureSamplers)O.call(b,M,this._textureSamplers[M]);const H=b.setStorageBuffer;if(H)for(M in this._storageBuffers)H.call(b,M,this._storageBuffers[M])}if(B&&p&&(O||!this.isFrozen)){(0,i.g)(p,B),p.morphTargetManager&&p.morphTargetManager.isUsingTextureForTargets&&p.morphTargetManager._bind(B);const M=p.bakedVertexAnimationManager;if(M&&M.isEnabled){var H;const M=q?Q._drawWrapper:this._drawWrapper;null===(H=p.bakedVertexAnimationManager)||void 0===H||H.bind(B,!!M._wasPreviouslyUsingInstances)}}this._afterBind(p,B,Q)}getActiveTextures(){const M=super.getActiveTextures();for(const p in this._textures)M.push(this._textures[p]);for(const p in this._textureArrays){const b=this._textureArrays[p];for(let p=0;p<b.length;p++)M.push(b[p])}return M}hasTexture(M){if(super.hasTexture(M))return!0;for(const p in this._textures)if(this._textures[p]===M)return!0;for(const p in this._textureArrays){const b=this._textureArrays[p];for(let p=0;p<b.length;p++)if(b[p]===M)return!0}return!1}clone(M){const p=Q.b.Clone((()=>new j(M,this.RM(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);p.name=M,p.id=M,"object"===typeof p._shaderPath&&(p._shaderPath={...p._shaderPath}),this._options={...this._options};const b=Object.keys(this._options);for(const Q of b){const M=this._options[Q];Array.isArray(M)&&(this._options[Q]=M.slice(0))}this.stencil.copyTo(p.stencil);for(const Q in this._textures)p.setTexture(Q,this._textures[Q]);for(const Q in this._textureArrays)p.setTextureArray(Q,this._textureArrays[Q]);for(const Q in this._externalTextures)p.setExternalTexture(Q,this._externalTextures[Q]);for(const Q in this._ints)p.setInt(Q,this._ints[Q]);for(const Q in this._uints)p.setUInt(Q,this._uints[Q]);for(const Q in this._floats)p.setFloat(Q,this._floats[Q]);for(const Q in this._floatsArrays)p.setFloats(Q,this._floatsArrays[Q]);for(const Q in this._colors3)p.setColor3(Q,this._colors3[Q]);for(const Q in this._colors3Arrays)p._colors3Arrays[Q]=this._colors3Arrays[Q];for(const Q in this._colors4)p.setColor4(Q,this._colors4[Q]);for(const Q in this._colors4Arrays)p._colors4Arrays[Q]=this._colors4Arrays[Q];for(const Q in this._vectors2)p.setVector2(Q,this._vectors2[Q]);for(const Q in this._vectors3)p.setVector3(Q,this._vectors3[Q]);for(const Q in this._vectors4)p.setVector4(Q,this._vectors4[Q]);for(const Q in this._quaternions)p.setQuaternion(Q,this._quaternions[Q]);for(const Q in this._quaternionsArrays)p._quaternionsArrays[Q]=this._quaternionsArrays[Q];for(const Q in this._matrices)p.setMatrix(Q,this._matrices[Q]);for(const Q in this._matrixArrays)p._matrixArrays[Q]=this._matrixArrays[Q].slice();for(const Q in this._matrices3x3)p.setMatrix3x3(Q,this._matrices3x3[Q]);for(const Q in this._matrices2x2)p.setMatrix2x2(Q,this._matrices2x2[Q]);for(const Q in this._vectors2Arrays)p.setArray2(Q,this._vectors2Arrays[Q]);for(const Q in this._vectors3Arrays)p.setArray3(Q,this._vectors3Arrays[Q]);for(const Q in this._vectors4Arrays)p.setArray4(Q,this._vectors4Arrays[Q]);for(const Q in this._uniformBuffers)p.setUniformBuffer(Q,this._uniformBuffers[Q]);for(const Q in this._textureSamplers)p.setTextureSampler(Q,this._textureSamplers[Q]);for(const Q in this._storageBuffers)p.setStorageBuffer(Q,this._storageBuffers[Q]);return p}dispose(M,p,b){if(p){let M;for(M in this._textures)this._textures[M].dispose();for(M in this._textureArrays){const p=this._textureArrays[M];for(let M=0;M<p.length;M++)p[M].dispose()}}this._textures={},super.dispose(M,p,b)}serialize(){const M=Q.b.Serialize(this);let p;for(p in M.customType="BABYLON.ShaderMaterial",M.uniqueId=this.uniqueId,M.options=this._options,M.shaderPath=this._shaderPath,M.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,M.stencil=this.stencil.serialize(),M.textures={},this._textures)M.textures[p]=this._textures[p].serialize();for(p in M.textureArrays={},this._textureArrays){M.textureArrays[p]=[];const b=this._textureArrays[p];for(let Q=0;Q<b.length;Q++)M.textureArrays[p].push(b[Q].serialize())}for(p in M.ints={},this._ints)M.ints[p]=this._ints[p];for(p in M.uints={},this._uints)M.uints[p]=this._uints[p];for(p in M.floats={},this._floats)M.floats[p]=this._floats[p];for(p in M.floatsArrays={},this._floatsArrays)M.floatsArrays[p]=this._floatsArrays[p];for(p in M.colors3={},this._colors3){const b=this._colors3[p];M.colors3[p]=[b.r,b.g,b.b]}for(p in M.colors3Arrays={},this._colors3Arrays)M.colors3Arrays[p]=this._colors3Arrays[p];for(p in M.colors4={},this._colors4){const b=this._colors4[p];M.colors4[p]=[b.r,b.g,b.b,b.a]}for(p in M.colors4Arrays={},this._colors4Arrays)M.colors4Arrays[p]=this._colors4Arrays[p];for(p in M.vectors2={},this._vectors2){const b=this._vectors2[p];M.vectors2[p]=[b.x,b.y]}for(p in M.vectors3={},this._vectors3){const b=this._vectors3[p];M.vectors3[p]=[b.x,b.y,b.z]}for(p in M.vectors4={},this._vectors4){const b=this._vectors4[p];M.vectors4[p]=[b.x,b.y,b.z,b.w]}for(p in M.quaternions={},this._quaternions)M.quaternions[p]=this._quaternions[p].Ob();for(p in M.matrices={},this._matrices)M.matrices[p]=this._matrices[p].Ob();for(p in M.matrixArray={},this._matrixArrays)M.matrixArray[p]=this._matrixArrays[p];for(p in M.matrices3x3={},this._matrices3x3)M.matrices3x3[p]=this._matrices3x3[p];for(p in M.matrices2x2={},this._matrices2x2)M.matrices2x2[p]=this._matrices2x2[p];for(p in M.vectors2Arrays={},this._vectors2Arrays)M.vectors2Arrays[p]=this._vectors2Arrays[p];for(p in M.vectors3Arrays={},this._vectors3Arrays)M.vectors3Arrays[p]=this._vectors3Arrays[p];for(p in M.vectors4Arrays={},this._vectors4Arrays)M.vectors4Arrays[p]=this._vectors4Arrays[p];for(p in M.quaternionsArrays={},this._quaternionsArrays)M.quaternionsArrays[p]=this._quaternionsArrays[p];return M}static Parse(M,p,b){const q=Q.b.Parse((()=>new j(M.name,p,M.shaderPath,M.options,M.storeEffectOnSubMeshes)),M,p,b);let k;for(k in M.stencil&&q.stencil.parse(M.stencil,p,b),M.textures)q.setTexture(k,u.b.Parse(M.textures[k],p,b));for(k in M.textureArrays){const Q=M.textureArrays[k],B=[];for(let M=0;M<Q.length;M++)B.push(u.b.Parse(Q[M],p,b));q.setTextureArray(k,B)}for(k in M.ints)q.setInt(k,M.ints[k]);for(k in M.uints)q.setUInt(k,M.uints[k]);for(k in M.floats)q.setFloat(k,M.floats[k]);for(k in M.floatsArrays)q.setFloats(k,M.floatsArrays[k]);for(k in M.colors3){const p=M.colors3[k];q.setColor3(k,{r:p[0],g:p[1],b:p[2]})}for(k in M.colors3Arrays){const p=M.colors3Arrays[k].reduce(((M,p,b)=>(b%3===0?M.push([p]):M[M.length-1].push(p),M)),[]).map((M=>({r:M[0],g:M[1],b:M[2]})));q.setColor3Array(k,p)}for(k in M.colors4){const p=M.colors4[k];q.setColor4(k,{r:p[0],g:p[1],b:p[2],a:p[3]})}for(k in M.colors4Arrays){const p=M.colors4Arrays[k].reduce(((M,p,b)=>(b%4===0?M.push([p]):M[M.length-1].push(p),M)),[]).map((M=>({r:M[0],g:M[1],b:M[2],a:M[3]})));q.setColor4Array(k,p)}for(k in M.vectors2){const p=M.vectors2[k];q.setVector2(k,{x:p[0],y:p[1]})}for(k in M.vectors3){const p=M.vectors3[k];q.setVector3(k,{x:p[0],y:p[1],z:p[2]})}for(k in M.vectors4){const p=M.vectors4[k];q.setVector4(k,{x:p[0],y:p[1],z:p[2],w:p[3]})}for(k in M.quaternions)q.setQuaternion(k,B.Quaternion.sp(M.quaternions[k]));for(k in M.matrices)q.setMatrix(k,B.Matrix.sp(M.matrices[k]));for(k in M.matrixArray)q._matrixArrays[k]=new Float32Array(M.matrixArray[k]);for(k in M.matrices3x3)q.setMatrix3x3(k,M.matrices3x3[k]);for(k in M.matrices2x2)q.setMatrix2x2(k,M.matrices2x2[k]);for(k in M.vectors2Arrays)q.setArray2(k,M.vectors2Arrays[k]);for(k in M.vectors3Arrays)q.setArray3(k,M.vectors3Arrays[k]);for(k in M.vectors4Arrays)q.setArray4(k,M.vectors4Arrays[k]);for(k in M.quaternionsArrays)q.setArray4(k,M.quaternionsArrays[k]);return q}static async ParseFromFileAsync(M,p,b){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((q,B)=>{const k=new H.b;k.addEventListener("readystatechange",(()=>{if(4==k.readyState)if(200==k.status){const p=JSON.parse(k.responseText),B=this.Parse(p,b||o.c.LastCreatedScene,Q);M&&(B.name=M),q(B)}else B("Unable to load the ShaderMaterial")})),k.open("GET",p),k.send()}))}static async ParseFromSnippetAsync(M,p){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((Q,q)=>{const B=new H.b;B.addEventListener("readystatechange",(()=>{if(4==B.readyState)if(200==B.status){const q=JSON.parse(JSON.parse(B.responseText).jsonPayload),k=JSON.parse(q.shaderMaterial),u=this.Parse(k,p||o.c.LastCreatedScene,b);u.snippetId=M,Q(u)}else q("Unable to load the snippet "+M)})),B.open("GET",this.SnippetUrl+"/"+M.replace(/#/g,"/")),B.send()}))}}j.SnippetUrl="https://snippet.babylonjs.com",j.CreateFromSnippetAsync=j.ParseFromSnippetAsync,(0,T.g)("BABYLON.ShaderMaterial",j)}}]);