"use strict";(self.fyqbdzs5tyo=self.fyqbdzs5tyo||[]).push([[22],{11469:(V,I,A)=>{A.r(I),A.d(I,{ShaderMaterial:()=>u});var B=A(11265),F=A(11473),E=A(11231),Y=A(11300),H=A(11207),c=A(11189),b=A(11546),X=A(11091),P=A(11553),J=A(11097),G=A(11605),w=A(11597);const t={effect:null,subMesh:null};class u extends P.e{constructor(V,I,A){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(V,I,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new E.Matrix,this._cachedWorldViewProjectionMatrix=new E.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=A,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...B}}get shaderPath(){return this._shaderPath}set shaderPath(V){this._shaderPath=V}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(V){-1===this._options.uniforms.indexOf(V)&&this._options.uniforms.push(V)}setTexture(V,I){return-1===this._options.samplers.indexOf(V)&&this._options.samplers.push(V),this._textures[V]=I,this}removeTexture(V){delete this._textures[V]}setTextureArray(V,I){return-1===this._options.samplers.indexOf(V)&&this._options.samplers.push(V),this._checkUniform(V),this._textureArrays[V]=I,this}setExternalTexture(V,I){return-1===this._options.externalTextures.indexOf(V)&&this._options.externalTextures.push(V),this._externalTextures[V]=I,this}setFloat(V,I){return this._checkUniform(V),this._floats[V]=I,this}setInt(V,I){return this._checkUniform(V),this._ints[V]=I,this}setUInt(V,I){return this._checkUniform(V),this._uints[V]=I,this}setFloats(V,I){return this._checkUniform(V),this._floatsArrays[V]=I,this}setColor3(V,I){return this._checkUniform(V),this._colors3[V]=I,this}setColor3Array(V,I){return this._checkUniform(V),this._colors3Arrays[V]=I.reduce(((V,I)=>(V.push(I.r,I.g,I.b),V)),[]),this}setColor4(V,I){return this._checkUniform(V),this._colors4[V]=I,this}setColor4Array(V,I){return this._checkUniform(V),this._colors4Arrays[V]=I.reduce(((V,I)=>(V.push(I.r,I.g,I.b,I.a),V)),[]),this}setVector2(V,I){return this._checkUniform(V),this._vectors2[V]=I,this}setVector3(V,I){return this._checkUniform(V),this._vectors3[V]=I,this}setVector4(V,I){return this._checkUniform(V),this._vectors4[V]=I,this}setQuaternion(V,I){return this._checkUniform(V),this._quaternions[V]=I,this}setQuaternionArray(V,I){return this._checkUniform(V),this._quaternionsArrays[V]=I.reduce(((V,I)=>(I.toArray(V,V.length),V)),[]),this}setMatrix(V,I){return this._checkUniform(V),this._matrices[V]=I,this}setMatrices(V,I){this._checkUniform(V);const A=new Float32Array(16*I.length);for(let B=0;B<I.length;B++){I[B].copyToArray(A,16*B)}return this._matrixArrays[V]=A,this}setMatrix3x3(V,I){return this._checkUniform(V),this._matrices3x3[V]=I,this}setMatrix2x2(V,I){return this._checkUniform(V),this._matrices2x2[V]=I,this}setArray2(V,I){return this._checkUniform(V),this._vectors2Arrays[V]=I,this}setArray3(V,I){return this._checkUniform(V),this._vectors3Arrays[V]=I,this}setArray4(V,I){return this._checkUniform(V),this._vectors4Arrays[V]=I,this}setUniformBuffer(V,I){return-1===this._options.uniformBuffers.indexOf(V)&&this._options.uniformBuffers.push(V),this._uniformBuffers[V]=I,this}setTextureSampler(V,I){return-1===this._options.samplerObjects.indexOf(V)&&this._options.samplerObjects.push(V),this._textureSamplers[V]=I,this}setStorageBuffer(V,I){return-1===this._options.storageBuffers.indexOf(V)&&this._options.storageBuffers.push(V),this._storageBuffers[V]=I,this}setDefine(V,I){const A=V.trimEnd()+" ",B=this.options.defines.findIndex((I=>I===V||I.startsWith(A)));return B>=0&&this.options.defines.splice(B,1),("boolean"!==typeof I||I)&&this.options.defines.push(A+I),this}isReadyForSubMesh(V,I,A){return this.isReady(V,A,I)}isReady(V,I,A){var B;const E=A&&this._storeEffectOnSubMeshes;if(this.isFrozen){const V=E?A._drawWrapper:this._drawWrapper;if(V.effect&&V._wasPreviouslyReady&&V._wasPreviouslyUsingInstances===I)return!0}const H=this.sV(),c=H.getEngine(),X=[],P=[];let J=null,u=this._shaderPath,W=this._options.uniforms,g=this._options.uniformBuffers,o=this._options.samplers;c.getCaps().multiview&&H.activeCamera&&H.activeCamera.outputRenderTarget&&H.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,X.push("#define MULTIVIEW"),-1!==W.indexOf("viewProjection")&&-1===W.indexOf("viewProjectionR")&&W.push("viewProjectionR"));for(let F=0;F<this._options.defines.length;F++){const V=0===this._options.defines[F].indexOf("#define")?this._options.defines[F]:`#define ${this._options.defines[F]}`;X.push(V)}for(let F=0;F<this._options.attributes.length;F++)P.push(this._options.attributes[F]);if(V&&V.isVerticesDataPresent(Y.g.ColorKind)&&(-1===P.indexOf(Y.g.ColorKind)&&P.push(Y.g.ColorKind),X.push("#define VERTEXCOLOR")),I&&(X.push("#define INSTANCES"),(0,w.ab)(P,this._materialHelperNeedsPreviousMatrices),null!==V&&void 0!==V&&V.hasThinInstances&&(X.push("#define THIN_INSTANCES"),V&&V.isVerticesDataPresent(Y.g.ColorInstanceKind)&&(P.push(Y.g.ColorInstanceKind),X.push("#define INSTANCESCOLOR")))),V&&V.useBones&&V.computeBonesUsingShaders&&V.skeleton){P.push(Y.g.MatricesIndicesKind),P.push(Y.g.MatricesWeightsKind),V.numBoneInfluencers>4&&(P.push(Y.g.MatricesIndicesExtraKind),P.push(Y.g.MatricesWeightsExtraKind));const I=V.skeleton;X.push("#define NUM_BONE_INFLUENCERS "+V.numBoneInfluencers),J=new b.c,J.addCPUSkinningFallback(0,V),I.isUsingTextureForMatrices?(X.push("#define BONETEXTURE"),-1===W.indexOf("boneTextureWidth")&&W.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(X.push("#define BonesPerMesh "+(I.bones.length+1)),-1===W.indexOf("mBones")&&W.push("mBones"))}else X.push("#define NUM_BONE_INFLUENCERS 0");let L=0;const z=V?V.morphTargetManager:null;if(z){const I=-1!==X.indexOf("#define UV1"),A=-1!==X.indexOf("#define UV2"),B=-1!==X.indexOf("#define TANGENT"),F=-1!==X.indexOf("#define NORMAL"),E=-1!==X.indexOf("#define VERTEXCOLOR");L=(0,w.B)(z,X,P,V,!0,F,B,I,A,E),z.isUsingTextureForTargets&&(-1===W.indexOf("morphTargetTextureIndices")&&W.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),L>0&&(W=W.slice(),W.push("morphTargetInfluences"),W.push("morphTargetCount"),W.push("morphTargetTextureInfo"),W.push("morphTargetTextureIndices"))}else X.push("#define NUM_MORPH_INFLUENCERS 0");if(V){const I=V.bakedVertexAnimationManager;I&&I.isEnabled&&(X.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===W.indexOf("bakedVertexAnimationSettings")&&W.push("bakedVertexAnimationSettings"),-1===W.indexOf("bakedVertexAnimationTextureSizeInverted")&&W.push("bakedVertexAnimationTextureSizeInverted"),-1===W.indexOf("bakedVertexAnimationTime")&&W.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,w.w)(P,V,X)}for(const F in this._textures)if(!this._textures[F].isReady())return!1;V&&this.needAlphaTestingForMesh(V)&&X.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,G.d)(W),(0,G.p)(this,H,X)),H.fogEnabled&&null!==V&&void 0!==V&&V.applyFog&&H.fogMode!==F.b.FOGMODE_NONE&&(X.push("#define FOG"),-1===W.indexOf("view")&&W.push("view"),-1===W.indexOf("vFogInfos")&&W.push("vFogInfos"),-1===W.indexOf("vFogColor")&&W.push("vFogColor")),this._useLogarithmicDepth&&(X.push("#define LOGARITHMICDEPTH"),-1===W.indexOf("logarithmicDepthConstant")&&W.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(W=W.slice(),g=g.slice(),o=o.slice(),u=this.customShaderNameResolve(this.name,W,g,o,X,P));const m=E?A._getDrawWrapper(void 0,!0):this._drawWrapper,s=(null===m||void 0===m?void 0:m.effect)??null,e=(null===m||void 0===m?void 0:m.defines)??null,S=X.join("\n");let Q=s;return e!==S&&(Q=c.createEffect(u,{attributes:P,uniformsNames:W,uniformBuffersNames:g,samplers:o,defines:S,fallbacks:J,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:L},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},c),E?A.setEffect(Q,S,this._materialContext):m&&m.setEffect(Q,S),this._onEffectCreatedObservable&&(t.effect=Q,t.subMesh=A??(null===V||void 0===V?void 0:V.IH[0])??null,this._onEffectCreatedObservable.notifyObservers(t))),m._wasPreviouslyUsingInstances=!!I,!(null===(B=Q)||void 0===B||!B.isReady())&&(s!==Q&&H.resetCachedMaterial(),m._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(V,I){const A=I??this.getEffect();if(!A)return;const B=this._options.uniforms;-1!==B.indexOf("world")&&A.setMatrix("world",V);const F=this.sV();-1!==B.indexOf("worldView")&&(V.multiplyToRef(F.getViewMatrix(),this._cachedWorldViewMatrix),A.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==B.indexOf("worldViewProjection")&&(V.multiplyToRef(F.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),A.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==B.indexOf("view")&&A.setMatrix("view",F.getViewMatrix())}bindForSubMesh(V,I,A){var B;this.bind(V,I,null===(B=A._drawWrapperOverride)||void 0===B?void 0:B.effect,A)}bind(V,I,A,B){const F=B&&this._storeEffectOnSubMeshes,E=A??(F?B.effect:this.getEffect());if(!E)return;const Y=this.sV();this._activeEffect=E,this.bindOnlyWorldMatrix(V,A);const H=this._options.uniformBuffers;let c=!1;if(E&&H&&H.length>0&&Y.getEngine().supportsUniformBuffers)for(let P=0;P<H.length;++P){switch(H[P]){case"Mesh":I&&(I.getMeshUniformBuffer().bindToEffect(E,"Mesh"),I.transferToEffect(V));break;case"Scene":(0,w.r)(E,Y.getSceneUniformBuffer()),Y.finalizeSceneUbo(),c=!0}}const b=I&&F?this._mustRebind(Y,E,B,I.visibility):Y.getCachedMaterial()!==this;if(E&&b){let V;for(V in c||-1===this._options.uniforms.indexOf("view")||E.setMatrix("view",Y.getViewMatrix()),c||-1===this._options.uniforms.indexOf("projection")||E.setMatrix("projection",Y.getProjectionMatrix()),c||-1===this._options.uniforms.indexOf("viewProjection")||(E.setMatrix("viewProjection",Y.getTransformMatrix()),this._multiview&&E.setMatrix("viewProjectionR",Y._transformMatrixR)),Y.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&E.setVector3("cameraPosition",Y.activeCamera.globalPosition),(0,w.c)(I,E),(0,G.h)(E,this,Y),this._useLogarithmicDepth&&(0,w.l)(F?B.materialDefines:E.defines,E,Y),I&&(0,w.d)(Y,I,E),this._textures)E.setTexture(V,this._textures[V]);for(V in this._textureArrays)E.setTextureArray(V,this._textureArrays[V]);for(V in this._ints)E.setInt(V,this._ints[V]);for(V in this._uints)E.setUInt(V,this._uints[V]);for(V in this._floats)E.setFloat(V,this._floats[V]);for(V in this._floatsArrays)E.setArray(V,this._floatsArrays[V]);for(V in this._colors3)E.setColor3(V,this._colors3[V]);for(V in this._colors3Arrays)E.setArray3(V,this._colors3Arrays[V]);for(V in this._colors4){const I=this._colors4[V];E.setFloat4(V,I.r,I.g,I.b,I.a)}for(V in this._colors4Arrays)E.setArray4(V,this._colors4Arrays[V]);for(V in this._vectors2)E.setVector2(V,this._vectors2[V]);for(V in this._vectors3)E.setVector3(V,this._vectors3[V]);for(V in this._vectors4)E.setVector4(V,this._vectors4[V]);for(V in this._quaternions)E.setQuaternion(V,this._quaternions[V]);for(V in this._matrices)E.setMatrix(V,this._matrices[V]);for(V in this._matrixArrays)E.setMatrices(V,this._matrixArrays[V]);for(V in this._matrices3x3)E.setMatrix3x3(V,this._matrices3x3[V]);for(V in this._matrices2x2)E.setMatrix2x2(V,this._matrices2x2[V]);for(V in this._vectors2Arrays)E.setArray2(V,this._vectors2Arrays[V]);for(V in this._vectors3Arrays)E.setArray3(V,this._vectors3Arrays[V]);for(V in this._vectors4Arrays)E.setArray4(V,this._vectors4Arrays[V]);for(V in this._quaternionsArrays)E.setArray4(V,this._quaternionsArrays[V]);for(V in this._uniformBuffers){const I=this._uniformBuffers[V].getBuffer();I&&E.bindUniformBuffer(I,V)}const A=Y.getEngine(),H=A.setExternalTexture;if(H)for(V in this._externalTextures)H.call(A,V,this._externalTextures[V]);const b=A.setTextureSampler;if(b)for(V in this._textureSamplers)b.call(A,V,this._textureSamplers[V]);const X=A.setStorageBuffer;if(X)for(V in this._storageBuffers)X.call(A,V,this._storageBuffers[V])}if(E&&I&&(b||!this.isFrozen)){(0,w.o)(I,E),I.morphTargetManager&&I.morphTargetManager.isUsingTextureForTargets&&I.morphTargetManager._bind(E);const V=I.bakedVertexAnimationManager;if(V&&V.isEnabled){var X;const V=F?B._drawWrapper:this._drawWrapper;null===(X=I.bakedVertexAnimationManager)||void 0===X||X.bind(E,!!V._wasPreviouslyUsingInstances)}}this._afterBind(I,E,B)}getActiveTextures(){const V=super.getActiveTextures();for(const I in this._textures)V.push(this._textures[I]);for(const I in this._textureArrays){const A=this._textureArrays[I];for(let I=0;I<A.length;I++)V.push(A[I])}return V}hasTexture(V){if(super.hasTexture(V))return!0;for(const I in this._textures)if(this._textures[I]===V)return!0;for(const I in this._textureArrays){const A=this._textureArrays[I];for(let I=0;I<A.length;I++)if(A[I]===V)return!0}return!1}clone(V){const I=B.b.Clone((()=>new u(V,this.sV(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);I.name=V,I.id=V,"object"===typeof I._shaderPath&&(I._shaderPath={...I._shaderPath}),this._options={...this._options};const A=Object.keys(this._options);for(const B of A){const V=this._options[B];Array.isArray(V)&&(this._options[B]=V.slice(0))}this.stencil.copyTo(I.stencil);for(const B in this._textures)I.setTexture(B,this._textures[B]);for(const B in this._textureArrays)I.setTextureArray(B,this._textureArrays[B]);for(const B in this._externalTextures)I.setExternalTexture(B,this._externalTextures[B]);for(const B in this._ints)I.setInt(B,this._ints[B]);for(const B in this._uints)I.setUInt(B,this._uints[B]);for(const B in this._floats)I.setFloat(B,this._floats[B]);for(const B in this._floatsArrays)I.setFloats(B,this._floatsArrays[B]);for(const B in this._colors3)I.setColor3(B,this._colors3[B]);for(const B in this._colors3Arrays)I._colors3Arrays[B]=this._colors3Arrays[B];for(const B in this._colors4)I.setColor4(B,this._colors4[B]);for(const B in this._colors4Arrays)I._colors4Arrays[B]=this._colors4Arrays[B];for(const B in this._vectors2)I.setVector2(B,this._vectors2[B]);for(const B in this._vectors3)I.setVector3(B,this._vectors3[B]);for(const B in this._vectors4)I.setVector4(B,this._vectors4[B]);for(const B in this._quaternions)I.setQuaternion(B,this._quaternions[B]);for(const B in this._quaternionsArrays)I._quaternionsArrays[B]=this._quaternionsArrays[B];for(const B in this._matrices)I.setMatrix(B,this._matrices[B]);for(const B in this._matrixArrays)I._matrixArrays[B]=this._matrixArrays[B].slice();for(const B in this._matrices3x3)I.setMatrix3x3(B,this._matrices3x3[B]);for(const B in this._matrices2x2)I.setMatrix2x2(B,this._matrices2x2[B]);for(const B in this._vectors2Arrays)I.setArray2(B,this._vectors2Arrays[B]);for(const B in this._vectors3Arrays)I.setArray3(B,this._vectors3Arrays[B]);for(const B in this._vectors4Arrays)I.setArray4(B,this._vectors4Arrays[B]);for(const B in this._uniformBuffers)I.setUniformBuffer(B,this._uniformBuffers[B]);for(const B in this._textureSamplers)I.setTextureSampler(B,this._textureSamplers[B]);for(const B in this._storageBuffers)I.setStorageBuffer(B,this._storageBuffers[B]);return I}dispose(V,I,A){if(I){let V;for(V in this._textures)this._textures[V].dispose();for(V in this._textureArrays){const I=this._textureArrays[V];for(let V=0;V<I.length;V++)I[V].dispose()}}this._textures={},super.dispose(V,I,A)}serialize(){const V=B.b.Serialize(this);let I;for(I in V.customType="BABYLON.ShaderMaterial",V.uniqueId=this.uniqueId,V.options=this._options,V.shaderPath=this._shaderPath,V.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,V.stencil=this.stencil.serialize(),V.textures={},this._textures)V.textures[I]=this._textures[I].serialize();for(I in V.textureArrays={},this._textureArrays){V.textureArrays[I]=[];const A=this._textureArrays[I];for(let B=0;B<A.length;B++)V.textureArrays[I].push(A[B].serialize())}for(I in V.ints={},this._ints)V.ints[I]=this._ints[I];for(I in V.uints={},this._uints)V.uints[I]=this._uints[I];for(I in V.floats={},this._floats)V.floats[I]=this._floats[I];for(I in V.floatsArrays={},this._floatsArrays)V.floatsArrays[I]=this._floatsArrays[I];for(I in V.colors3={},this._colors3){const A=this._colors3[I];V.colors3[I]=[A.r,A.g,A.b]}for(I in V.colors3Arrays={},this._colors3Arrays)V.colors3Arrays[I]=this._colors3Arrays[I];for(I in V.colors4={},this._colors4){const A=this._colors4[I];V.colors4[I]=[A.r,A.g,A.b,A.a]}for(I in V.colors4Arrays={},this._colors4Arrays)V.colors4Arrays[I]=this._colors4Arrays[I];for(I in V.vectors2={},this._vectors2){const A=this._vectors2[I];V.vectors2[I]=[A.x,A.y]}for(I in V.vectors3={},this._vectors3){const A=this._vectors3[I];V.vectors3[I]=[A.x,A.y,A.z]}for(I in V.vectors4={},this._vectors4){const A=this._vectors4[I];V.vectors4[I]=[A.x,A.y,A.z,A.w]}for(I in V.quaternions={},this._quaternions)V.quaternions[I]=this._quaternions[I].AH();for(I in V.matrices={},this._matrices)V.matrices[I]=this._matrices[I].AH();for(I in V.matrixArray={},this._matrixArrays)V.matrixArray[I]=this._matrixArrays[I];for(I in V.matrices3x3={},this._matrices3x3)V.matrices3x3[I]=this._matrices3x3[I];for(I in V.matrices2x2={},this._matrices2x2)V.matrices2x2[I]=this._matrices2x2[I];for(I in V.vectors2Arrays={},this._vectors2Arrays)V.vectors2Arrays[I]=this._vectors2Arrays[I];for(I in V.vectors3Arrays={},this._vectors3Arrays)V.vectors3Arrays[I]=this._vectors3Arrays[I];for(I in V.vectors4Arrays={},this._vectors4Arrays)V.vectors4Arrays[I]=this._vectors4Arrays[I];for(I in V.quaternionsArrays={},this._quaternionsArrays)V.quaternionsArrays[I]=this._quaternionsArrays[I];return V}static Parse(V,I,A){const F=B.b.Parse((()=>new u(V.name,I,V.shaderPath,V.options,V.storeEffectOnSubMeshes)),V,I,A);let Y;for(Y in V.stencil&&F.stencil.parse(V.stencil,I,A),V.textures)F.setTexture(Y,H.e.Parse(V.textures[Y],I,A));for(Y in V.textureArrays){const B=V.textureArrays[Y],E=[];for(let V=0;V<B.length;V++)E.push(H.e.Parse(B[V],I,A));F.setTextureArray(Y,E)}for(Y in V.ints)F.setInt(Y,V.ints[Y]);for(Y in V.uints)F.setUInt(Y,V.uints[Y]);for(Y in V.floats)F.setFloat(Y,V.floats[Y]);for(Y in V.floatsArrays)F.setFloats(Y,V.floatsArrays[Y]);for(Y in V.colors3){const I=V.colors3[Y];F.setColor3(Y,{r:I[0],g:I[1],b:I[2]})}for(Y in V.colors3Arrays){const I=V.colors3Arrays[Y].reduce(((V,I,A)=>(A%3===0?V.push([I]):V[V.length-1].push(I),V)),[]).map((V=>({r:V[0],g:V[1],b:V[2]})));F.setColor3Array(Y,I)}for(Y in V.colors4){const I=V.colors4[Y];F.setColor4(Y,{r:I[0],g:I[1],b:I[2],a:I[3]})}for(Y in V.colors4Arrays){const I=V.colors4Arrays[Y].reduce(((V,I,A)=>(A%4===0?V.push([I]):V[V.length-1].push(I),V)),[]).map((V=>({r:V[0],g:V[1],b:V[2],a:V[3]})));F.setColor4Array(Y,I)}for(Y in V.vectors2){const I=V.vectors2[Y];F.setVector2(Y,{x:I[0],y:I[1]})}for(Y in V.vectors3){const I=V.vectors3[Y];F.setVector3(Y,{x:I[0],y:I[1],z:I[2]})}for(Y in V.vectors4){const I=V.vectors4[Y];F.setVector4(Y,{x:I[0],y:I[1],z:I[2],w:I[3]})}for(Y in V.quaternions)F.setQuaternion(Y,E.Quaternion.LI(V.quaternions[Y]));for(Y in V.matrices)F.setMatrix(Y,E.Matrix.LI(V.matrices[Y]));for(Y in V.matrixArray)F._matrixArrays[Y]=new Float32Array(V.matrixArray[Y]);for(Y in V.matrices3x3)F.setMatrix3x3(Y,V.matrices3x3[Y]);for(Y in V.matrices2x2)F.setMatrix2x2(Y,V.matrices2x2[Y]);for(Y in V.vectors2Arrays)F.setArray2(Y,V.vectors2Arrays[Y]);for(Y in V.vectors3Arrays)F.setArray3(Y,V.vectors3Arrays[Y]);for(Y in V.vectors4Arrays)F.setArray4(Y,V.vectors4Arrays[Y]);for(Y in V.quaternionsArrays)F.setArray4(Y,V.quaternionsArrays[Y]);return F}static async ParseFromFileAsync(V,I,A){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((F,E)=>{const Y=new X.b;Y.addEventListener("readystatechange",(()=>{if(4==Y.readyState)if(200==Y.status){const I=JSON.parse(Y.responseText),E=this.Parse(I,A||J.e.LastCreatedScene,B);V&&(E.name=V),F(E)}else E("Unable to load the ShaderMaterial")})),Y.open("GET",I),Y.send()}))}static async ParseFromSnippetAsync(V,I){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((B,F)=>{const E=new X.b;E.addEventListener("readystatechange",(()=>{if(4==E.readyState)if(200==E.status){const F=JSON.parse(JSON.parse(E.responseText).jsonPayload),Y=JSON.parse(F.shaderMaterial),H=this.Parse(Y,I||J.e.LastCreatedScene,A);H.snippetId=V,B(H)}else F("Unable to load the snippet "+V)})),E.open("GET",this.SnippetUrl+"/"+V.replace(/#/g,"/")),E.send()}))}}u.SnippetUrl="https://snippet.babylonjs.com",u.CreateFromSnippetAsync=u.ParseFromSnippetAsync,(0,c.e)("BABYLON.ShaderMaterial",u)}}]);