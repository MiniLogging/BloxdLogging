"use strict";(self["3gghkoft8x"]=self["3gghkoft8x"]||[]).push([[22],{12553:(y,S,I)=>{I.r(S),I.d(S,{ShaderMaterial:()=>l});var V=I(12352),i=I(12556),A=I(12321),B=I(12390),d=I(12304),F=I(12282),J=I(12625),u=I(12177),K=I(12631),G=I(12185),p=I(12683),L=I(12675);const T={effect:null,subMesh:null};class l extends K.d{constructor(y,S,I){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(y,S,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new A.Matrix,this._cachedWorldViewProjectionMatrix=new A.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=I,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...V}}get shaderPath(){return this._shaderPath}set shaderPath(y){this._shaderPath=y}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(y){-1===this._options.uniforms.indexOf(y)&&this._options.uniforms.push(y)}setTexture(y,S){return-1===this._options.samplers.indexOf(y)&&this._options.samplers.push(y),this._textures[y]=S,this}removeTexture(y){delete this._textures[y]}setTextureArray(y,S){return-1===this._options.samplers.indexOf(y)&&this._options.samplers.push(y),this._checkUniform(y),this._textureArrays[y]=S,this}setExternalTexture(y,S){return-1===this._options.externalTextures.indexOf(y)&&this._options.externalTextures.push(y),this._externalTextures[y]=S,this}setFloat(y,S){return this._checkUniform(y),this._floats[y]=S,this}setInt(y,S){return this._checkUniform(y),this._ints[y]=S,this}setUInt(y,S){return this._checkUniform(y),this._uints[y]=S,this}setFloats(y,S){return this._checkUniform(y),this._floatsArrays[y]=S,this}setColor3(y,S){return this._checkUniform(y),this._colors3[y]=S,this}setColor3Array(y,S){return this._checkUniform(y),this._colors3Arrays[y]=S.reduce(((y,S)=>(y.push(S.r,S.g,S.b),y)),[]),this}setColor4(y,S){return this._checkUniform(y),this._colors4[y]=S,this}setColor4Array(y,S){return this._checkUniform(y),this._colors4Arrays[y]=S.reduce(((y,S)=>(y.push(S.r,S.g,S.b,S.a),y)),[]),this}setVector2(y,S){return this._checkUniform(y),this._vectors2[y]=S,this}setVector3(y,S){return this._checkUniform(y),this._vectors3[y]=S,this}setVector4(y,S){return this._checkUniform(y),this._vectors4[y]=S,this}setQuaternion(y,S){return this._checkUniform(y),this._quaternions[y]=S,this}setQuaternionArray(y,S){return this._checkUniform(y),this._quaternionsArrays[y]=S.reduce(((y,S)=>(S.toArray(y,y.length),y)),[]),this}setMatrix(y,S){return this._checkUniform(y),this._matrices[y]=S,this}setMatrices(y,S){this._checkUniform(y);const I=new Float32Array(16*S.length);for(let V=0;V<S.length;V++){S[V].copyToArray(I,16*V)}return this._matrixArrays[y]=I,this}setMatrix3x3(y,S){return this._checkUniform(y),this._matrices3x3[y]=S,this}setMatrix2x2(y,S){return this._checkUniform(y),this._matrices2x2[y]=S,this}setArray2(y,S){return this._checkUniform(y),this._vectors2Arrays[y]=S,this}setArray3(y,S){return this._checkUniform(y),this._vectors3Arrays[y]=S,this}setArray4(y,S){return this._checkUniform(y),this._vectors4Arrays[y]=S,this}setUniformBuffer(y,S){return-1===this._options.uniformBuffers.indexOf(y)&&this._options.uniformBuffers.push(y),this._uniformBuffers[y]=S,this}setTextureSampler(y,S){return-1===this._options.samplerObjects.indexOf(y)&&this._options.samplerObjects.push(y),this._textureSamplers[y]=S,this}setStorageBuffer(y,S){return-1===this._options.storageBuffers.indexOf(y)&&this._options.storageBuffers.push(y),this._storageBuffers[y]=S,this}setDefine(y,S){const I=y.trimEnd()+" ",V=this.options.defines.findIndex((S=>S===y||S.startsWith(I)));return V>=0&&this.options.defines.splice(V,1),("boolean"!==typeof S||S)&&this.options.defines.push(I+S),this}isReadyForSubMesh(y,S,I){return this.isReady(y,I,S)}isReady(y,S,I){var V;const A=I&&this._storeEffectOnSubMeshes;if(this.isFrozen){const y=A?I._drawWrapper:this._drawWrapper;if(y.effect&&y._wasPreviouslyReady&&y._wasPreviouslyUsingInstances===S)return!0}const d=this.Ey(),F=d.getEngine(),u=[],K=[];let G=null,l=this._shaderPath,j=this._options.uniforms,s=this._options.uniformBuffers,O=this._options.samplers;F.getCaps().multiview&&d.activeCamera&&d.activeCamera.outputRenderTarget&&d.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,u.push("#define MULTIVIEW"),-1!==j.indexOf("viewProjection")&&-1===j.indexOf("viewProjectionR")&&j.push("viewProjectionR"));for(let i=0;i<this._options.defines.length;i++){const y=0===this._options.defines[i].indexOf("#define")?this._options.defines[i]:`#define ${this._options.defines[i]}`;u.push(y)}for(let i=0;i<this._options.attributes.length;i++)K.push(this._options.attributes[i]);if(y&&y.isVerticesDataPresent(B.e.ColorKind)&&(-1===K.indexOf(B.e.ColorKind)&&K.push(B.e.ColorKind),u.push("#define VERTEXCOLOR")),S&&(u.push("#define INSTANCES"),(0,L._)(K,this._materialHelperNeedsPreviousMatrices),null!==y&&void 0!==y&&y.hasThinInstances&&(u.push("#define THIN_INSTANCES"),y&&y.isVerticesDataPresent(B.e.ColorInstanceKind)&&(K.push(B.e.ColorInstanceKind),u.push("#define INSTANCESCOLOR")))),y&&y.useBones&&y.computeBonesUsingShaders&&y.skeleton){K.push(B.e.MatricesIndicesKind),K.push(B.e.MatricesWeightsKind),y.numBoneInfluencers>4&&(K.push(B.e.MatricesIndicesExtraKind),K.push(B.e.MatricesWeightsExtraKind));const S=y.skeleton;u.push("#define NUM_BONE_INFLUENCERS "+y.numBoneInfluencers),G=new J.e,G.addCPUSkinningFallback(0,y),S.isUsingTextureForMatrices?(u.push("#define BONETEXTURE"),-1===j.indexOf("boneTextureWidth")&&j.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(u.push("#define BonesPerMesh "+(S.bones.length+1)),-1===j.indexOf("mBones")&&j.push("mBones"))}else u.push("#define NUM_BONE_INFLUENCERS 0");let f=0;const my=y?y.morphTargetManager:null;if(my){const S=-1!==u.indexOf("#define UV1"),I=-1!==u.indexOf("#define UV2"),V=-1!==u.indexOf("#define TANGENT"),i=-1!==u.indexOf("#define NORMAL"),A=-1!==u.indexOf("#define VERTEXCOLOR");f=(0,L.G)(my,u,K,y,!0,i,V,S,I,A),my.isUsingTextureForTargets&&(-1===j.indexOf("morphTargetTextureIndices")&&j.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),f>0&&(j=j.slice(),j.push("morphTargetInfluences"),j.push("morphTargetCount"),j.push("morphTargetTextureInfo"),j.push("morphTargetTextureIndices"))}else u.push("#define NUM_MORPH_INFLUENCERS 0");if(y){const S=y.bakedVertexAnimationManager;S&&S.isEnabled&&(u.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===j.indexOf("bakedVertexAnimationSettings")&&j.push("bakedVertexAnimationSettings"),-1===j.indexOf("bakedVertexAnimationTextureSizeInverted")&&j.push("bakedVertexAnimationTextureSizeInverted"),-1===j.indexOf("bakedVertexAnimationTime")&&j.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,L.y)(K,y,u)}for(const i in this._textures)if(!this._textures[i].isReady())return!1;y&&this.needAlphaTestingForMesh(y)&&u.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,p.e)(j),(0,p.h)(this,d,u)),d.fogEnabled&&null!==y&&void 0!==y&&y.applyFog&&d.fogMode!==i.e.FOGMODE_NONE&&(u.push("#define FOG"),-1===j.indexOf("view")&&j.push("view"),-1===j.indexOf("vFogInfos")&&j.push("vFogInfos"),-1===j.indexOf("vFogColor")&&j.push("vFogColor")),this._useLogarithmicDepth&&(u.push("#define LOGARITHMICDEPTH"),-1===j.indexOf("logarithmicDepthConstant")&&j.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(j=j.slice(),s=s.slice(),O=O.slice(),l=this.customShaderNameResolve(this.name,j,s,O,u,K));const C=A?I._getDrawWrapper(void 0,!0):this._drawWrapper,D=(null===C||void 0===C?void 0:C.effect)??null,o=(null===C||void 0===C?void 0:C.defines)??null,E=u.join("\n");let z=D;return o!==E&&(z=F.createEffect(l,{attributes:K,uniformsNames:j,uniformBuffersNames:s,samplers:O,defines:E,fallbacks:G,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:f},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},F),A?I.setEffect(z,E,this._materialContext):C&&C.setEffect(z,E),this._onEffectCreatedObservable&&(T.effect=z,T.subMesh=I??(null===y||void 0===y?void 0:y.wi[0])??null,this._onEffectCreatedObservable.notifyObservers(T))),C._wasPreviouslyUsingInstances=!!S,!(null===(V=z)||void 0===V||!V.isReady())&&(D!==z&&d.resetCachedMaterial(),C._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(y,S){const I=S??this.getEffect();if(!I)return;const V=this._options.uniforms;-1!==V.indexOf("world")&&I.setMatrix("world",y);const i=this.Ey();-1!==V.indexOf("worldView")&&(y.multiplyToRef(i.getViewMatrix(),this._cachedWorldViewMatrix),I.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==V.indexOf("worldViewProjection")&&(y.multiplyToRef(i.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),I.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==V.indexOf("view")&&I.setMatrix("view",i.getViewMatrix())}bindForSubMesh(y,S,I){var V;this.bind(y,S,null===(V=I._drawWrapperOverride)||void 0===V?void 0:V.effect,I)}bind(y,S,I,V){const i=V&&this._storeEffectOnSubMeshes,A=I??(i?V.effect:this.getEffect());if(!A)return;const B=this.Ey();this._activeEffect=A,this.bindOnlyWorldMatrix(y,I);const d=this._options.uniformBuffers;let F=!1;if(A&&d&&d.length>0&&B.getEngine().supportsUniformBuffers)for(let K=0;K<d.length;++K){switch(d[K]){case"Mesh":S&&(S.getMeshUniformBuffer().bindToEffect(A,"Mesh"),S.transferToEffect(y));break;case"Scene":(0,L.p)(A,B.getSceneUniformBuffer()),B.finalizeSceneUbo(),F=!0}}const J=S&&i?this._mustRebind(B,A,V,S.visibility):B.getCachedMaterial()!==this;if(A&&J){let y;for(y in F||-1===this._options.uniforms.indexOf("view")||A.setMatrix("view",B.getViewMatrix()),F||-1===this._options.uniforms.indexOf("projection")||A.setMatrix("projection",B.getProjectionMatrix()),F||-1===this._options.uniforms.indexOf("viewProjection")||(A.setMatrix("viewProjection",B.getTransformMatrix()),this._multiview&&A.setMatrix("viewProjectionR",B._transformMatrixR)),B.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&A.setVector3("cameraPosition",B.activeCamera.globalPosition),(0,L.e)(S,A),(0,p.f)(A,this,B),this._useLogarithmicDepth&&(0,L.k)(i?V.materialDefines:A.defines,A,B),S&&(0,L.f)(B,S,A),this._textures)A.setTexture(y,this._textures[y]);for(y in this._textureArrays)A.setTextureArray(y,this._textureArrays[y]);for(y in this._ints)A.setInt(y,this._ints[y]);for(y in this._uints)A.setUInt(y,this._uints[y]);for(y in this._floats)A.setFloat(y,this._floats[y]);for(y in this._floatsArrays)A.setArray(y,this._floatsArrays[y]);for(y in this._colors3)A.setColor3(y,this._colors3[y]);for(y in this._colors3Arrays)A.setArray3(y,this._colors3Arrays[y]);for(y in this._colors4){const S=this._colors4[y];A.setFloat4(y,S.r,S.g,S.b,S.a)}for(y in this._colors4Arrays)A.setArray4(y,this._colors4Arrays[y]);for(y in this._vectors2)A.setVector2(y,this._vectors2[y]);for(y in this._vectors3)A.setVector3(y,this._vectors3[y]);for(y in this._vectors4)A.setVector4(y,this._vectors4[y]);for(y in this._quaternions)A.setQuaternion(y,this._quaternions[y]);for(y in this._matrices)A.setMatrix(y,this._matrices[y]);for(y in this._matrixArrays)A.setMatrices(y,this._matrixArrays[y]);for(y in this._matrices3x3)A.setMatrix3x3(y,this._matrices3x3[y]);for(y in this._matrices2x2)A.setMatrix2x2(y,this._matrices2x2[y]);for(y in this._vectors2Arrays)A.setArray2(y,this._vectors2Arrays[y]);for(y in this._vectors3Arrays)A.setArray3(y,this._vectors3Arrays[y]);for(y in this._vectors4Arrays)A.setArray4(y,this._vectors4Arrays[y]);for(y in this._quaternionsArrays)A.setArray4(y,this._quaternionsArrays[y]);for(y in this._uniformBuffers){const S=this._uniformBuffers[y].getBuffer();S&&A.bindUniformBuffer(S,y)}const I=B.getEngine(),d=I.setExternalTexture;if(d)for(y in this._externalTextures)d.call(I,y,this._externalTextures[y]);const J=I.setTextureSampler;if(J)for(y in this._textureSamplers)J.call(I,y,this._textureSamplers[y]);const u=I.setStorageBuffer;if(u)for(y in this._storageBuffers)u.call(I,y,this._storageBuffers[y])}if(A&&S&&(J||!this.isFrozen)){(0,L.l)(S,A),S.morphTargetManager&&S.morphTargetManager.isUsingTextureForTargets&&S.morphTargetManager._bind(A);const y=S.bakedVertexAnimationManager;if(y&&y.isEnabled){var u;const y=i?V._drawWrapper:this._drawWrapper;null===(u=S.bakedVertexAnimationManager)||void 0===u||u.bind(A,!!y._wasPreviouslyUsingInstances)}}this._afterBind(S,A,V)}getActiveTextures(){const y=super.getActiveTextures();for(const S in this._textures)y.push(this._textures[S]);for(const S in this._textureArrays){const I=this._textureArrays[S];for(let S=0;S<I.length;S++)y.push(I[S])}return y}hasTexture(y){if(super.hasTexture(y))return!0;for(const S in this._textures)if(this._textures[S]===y)return!0;for(const S in this._textureArrays){const I=this._textureArrays[S];for(let S=0;S<I.length;S++)if(I[S]===y)return!0}return!1}clone(y){const S=V.d.Clone((()=>new l(y,this.Ey(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);S.name=y,S.id=y,"object"===typeof S._shaderPath&&(S._shaderPath={...S._shaderPath}),this._options={...this._options};const I=Object.keys(this._options);for(const V of I){const y=this._options[V];Array.isArray(y)&&(this._options[V]=y.slice(0))}this.gi.copyTo(S.gi);for(const V in this._textures)S.setTexture(V,this._textures[V]);for(const V in this._textureArrays)S.setTextureArray(V,this._textureArrays[V]);for(const V in this._externalTextures)S.setExternalTexture(V,this._externalTextures[V]);for(const V in this._ints)S.setInt(V,this._ints[V]);for(const V in this._uints)S.setUInt(V,this._uints[V]);for(const V in this._floats)S.setFloat(V,this._floats[V]);for(const V in this._floatsArrays)S.setFloats(V,this._floatsArrays[V]);for(const V in this._colors3)S.setColor3(V,this._colors3[V]);for(const V in this._colors3Arrays)S._colors3Arrays[V]=this._colors3Arrays[V];for(const V in this._colors4)S.setColor4(V,this._colors4[V]);for(const V in this._colors4Arrays)S._colors4Arrays[V]=this._colors4Arrays[V];for(const V in this._vectors2)S.setVector2(V,this._vectors2[V]);for(const V in this._vectors3)S.setVector3(V,this._vectors3[V]);for(const V in this._vectors4)S.setVector4(V,this._vectors4[V]);for(const V in this._quaternions)S.setQuaternion(V,this._quaternions[V]);for(const V in this._quaternionsArrays)S._quaternionsArrays[V]=this._quaternionsArrays[V];for(const V in this._matrices)S.setMatrix(V,this._matrices[V]);for(const V in this._matrixArrays)S._matrixArrays[V]=this._matrixArrays[V].slice();for(const V in this._matrices3x3)S.setMatrix3x3(V,this._matrices3x3[V]);for(const V in this._matrices2x2)S.setMatrix2x2(V,this._matrices2x2[V]);for(const V in this._vectors2Arrays)S.setArray2(V,this._vectors2Arrays[V]);for(const V in this._vectors3Arrays)S.setArray3(V,this._vectors3Arrays[V]);for(const V in this._vectors4Arrays)S.setArray4(V,this._vectors4Arrays[V]);for(const V in this._uniformBuffers)S.setUniformBuffer(V,this._uniformBuffers[V]);for(const V in this._textureSamplers)S.setTextureSampler(V,this._textureSamplers[V]);for(const V in this._storageBuffers)S.setStorageBuffer(V,this._storageBuffers[V]);return S}dispose(y,S,I){if(S){let y;for(y in this._textures)this._textures[y].dispose();for(y in this._textureArrays){const S=this._textureArrays[y];for(let y=0;y<S.length;y++)S[y].dispose()}}this._textures={},super.dispose(y,S,I)}serialize(){const y=V.d.Serialize(this);let S;for(S in y.customType="BABYLON.ShaderMaterial",y.uniqueId=this.uniqueId,y.options=this._options,y.shaderPath=this._shaderPath,y.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,y.gi=this.gi.serialize(),y.textures={},this._textures)y.textures[S]=this._textures[S].serialize();for(S in y.textureArrays={},this._textureArrays){y.textureArrays[S]=[];const I=this._textureArrays[S];for(let V=0;V<I.length;V++)y.textureArrays[S].push(I[V].serialize())}for(S in y.ints={},this._ints)y.ints[S]=this._ints[S];for(S in y.uints={},this._uints)y.uints[S]=this._uints[S];for(S in y.floats={},this._floats)y.floats[S]=this._floats[S];for(S in y.floatsArrays={},this._floatsArrays)y.floatsArrays[S]=this._floatsArrays[S];for(S in y.colors3={},this._colors3){const I=this._colors3[S];y.colors3[S]=[I.r,I.g,I.b]}for(S in y.colors3Arrays={},this._colors3Arrays)y.colors3Arrays[S]=this._colors3Arrays[S];for(S in y.colors4={},this._colors4){const I=this._colors4[S];y.colors4[S]=[I.r,I.g,I.b,I.a]}for(S in y.colors4Arrays={},this._colors4Arrays)y.colors4Arrays[S]=this._colors4Arrays[S];for(S in y.vectors2={},this._vectors2){const I=this._vectors2[S];y.vectors2[S]=[I.x,I.y]}for(S in y.vectors3={},this._vectors3){const I=this._vectors3[S];y.vectors3[S]=[I.x,I.y,I.z]}for(S in y.vectors4={},this._vectors4){const I=this._vectors4[S];y.vectors4[S]=[I.x,I.y,I.z,I.w]}for(S in y.quaternions={},this._quaternions)y.quaternions[S]=this._quaternions[S].Vd();for(S in y.matrices={},this._matrices)y.matrices[S]=this._matrices[S].Vd();for(S in y.matrixArray={},this._matrixArrays)y.matrixArray[S]=this._matrixArrays[S];for(S in y.matrices3x3={},this._matrices3x3)y.matrices3x3[S]=this._matrices3x3[S];for(S in y.matrices2x2={},this._matrices2x2)y.matrices2x2[S]=this._matrices2x2[S];for(S in y.vectors2Arrays={},this._vectors2Arrays)y.vectors2Arrays[S]=this._vectors2Arrays[S];for(S in y.vectors3Arrays={},this._vectors3Arrays)y.vectors3Arrays[S]=this._vectors3Arrays[S];for(S in y.vectors4Arrays={},this._vectors4Arrays)y.vectors4Arrays[S]=this._vectors4Arrays[S];for(S in y.quaternionsArrays={},this._quaternionsArrays)y.quaternionsArrays[S]=this._quaternionsArrays[S];return y}static Parse(y,S,I){const i=V.d.Parse((()=>new l(y.name,S,y.shaderPath,y.options,y.storeEffectOnSubMeshes)),y,S,I);let B;for(B in y.gi&&i.gi.parse(y.gi,S,I),y.textures)i.setTexture(B,d.e.Parse(y.textures[B],S,I));for(B in y.textureArrays){const V=y.textureArrays[B],A=[];for(let y=0;y<V.length;y++)A.push(d.e.Parse(V[y],S,I));i.setTextureArray(B,A)}for(B in y.ints)i.setInt(B,y.ints[B]);for(B in y.uints)i.setUInt(B,y.uints[B]);for(B in y.floats)i.setFloat(B,y.floats[B]);for(B in y.floatsArrays)i.setFloats(B,y.floatsArrays[B]);for(B in y.colors3){const S=y.colors3[B];i.setColor3(B,{r:S[0],g:S[1],b:S[2]})}for(B in y.colors3Arrays){const S=y.colors3Arrays[B].reduce(((y,S,I)=>(I%3===0?y.push([S]):y[y.length-1].push(S),y)),[]).map((y=>({r:y[0],g:y[1],b:y[2]})));i.setColor3Array(B,S)}for(B in y.colors4){const S=y.colors4[B];i.setColor4(B,{r:S[0],g:S[1],b:S[2],a:S[3]})}for(B in y.colors4Arrays){const S=y.colors4Arrays[B].reduce(((y,S,I)=>(I%4===0?y.push([S]):y[y.length-1].push(S),y)),[]).map((y=>({r:y[0],g:y[1],b:y[2],a:y[3]})));i.setColor4Array(B,S)}for(B in y.vectors2){const S=y.vectors2[B];i.setVector2(B,{x:S[0],y:S[1]})}for(B in y.vectors3){const S=y.vectors3[B];i.setVector3(B,{x:S[0],y:S[1],z:S[2]})}for(B in y.vectors4){const S=y.vectors4[B];i.setVector4(B,{x:S[0],y:S[1],z:S[2],w:S[3]})}for(B in y.quaternions)i.setQuaternion(B,A.Quaternion.oS(y.quaternions[B]));for(B in y.matrices)i.setMatrix(B,A.Matrix.oS(y.matrices[B]));for(B in y.matrixArray)i._matrixArrays[B]=new Float32Array(y.matrixArray[B]);for(B in y.matrices3x3)i.setMatrix3x3(B,y.matrices3x3[B]);for(B in y.matrices2x2)i.setMatrix2x2(B,y.matrices2x2[B]);for(B in y.vectors2Arrays)i.setArray2(B,y.vectors2Arrays[B]);for(B in y.vectors3Arrays)i.setArray3(B,y.vectors3Arrays[B]);for(B in y.vectors4Arrays)i.setArray4(B,y.vectors4Arrays[B]);for(B in y.quaternionsArrays)i.setArray4(B,y.quaternionsArrays[B]);return i}static async ParseFromFileAsync(y,S,I){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((i,A)=>{const B=new u.e;B.addEventListener("readystatechange",(()=>{if(4==B.readyState)if(200==B.status){const S=JSON.parse(B.responseText),A=this.Parse(S,I||G.e.LastCreatedScene,V);y&&(A.name=y),i(A)}else A("Unable to load the ShaderMaterial")})),B.open("GET",S),B.send()}))}static async ParseFromSnippetAsync(y,S){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((V,i)=>{const A=new u.e;A.addEventListener("readystatechange",(()=>{if(4==A.readyState)if(200==A.status){const i=JSON.parse(JSON.parse(A.responseText).jsonPayload),B=JSON.parse(i.shaderMaterial),d=this.Parse(B,S||G.e.LastCreatedScene,I);d.snippetId=y,V(d)}else i("Unable to load the snippet "+y)})),A.open("GET",this.SnippetUrl+"/"+y.replace(/#/g,"/")),A.send()}))}}l.SnippetUrl="https://snippet.babylonjs.com",l.CreateFromSnippetAsync=l.ParseFromSnippetAsync,(0,F.e)("BABYLON.ShaderMaterial",l)}}]);