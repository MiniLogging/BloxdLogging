"use strict";(self.fwuvyyymhp8=self.fwuvyyymhp8||[]).push([[22],{12598:(N,U,V)=>{V.r(U),V.d(U,{ShaderMaterial:()=>J});var A=V(12413),t=V(12601),n=V(12383),q=V(12453),i=V(12364),z=V(12344),S=V(12662),E=V(12218),p=V(12667),k=V(12223),B=V(12717),C=V(12713);const x={effect:null,subMesh:null};class J extends p.c{constructor(N,U,V){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(N,U,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new n.Matrix,this._cachedWorldViewProjectionMatrix=new n.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=V,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...A}}get shaderPath(){return this._shaderPath}set shaderPath(N){this._shaderPath=N}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(N){-1===this._options.uniforms.indexOf(N)&&this._options.uniforms.push(N)}setTexture(N,U){return-1===this._options.samplers.indexOf(N)&&this._options.samplers.push(N),this._textures[N]=U,this}removeTexture(N){delete this._textures[N]}setTextureArray(N,U){return-1===this._options.samplers.indexOf(N)&&this._options.samplers.push(N),this._checkUniform(N),this._textureArrays[N]=U,this}setExternalTexture(N,U){return-1===this._options.externalTextures.indexOf(N)&&this._options.externalTextures.push(N),this._externalTextures[N]=U,this}setFloat(N,U){return this._checkUniform(N),this._floats[N]=U,this}setInt(N,U){return this._checkUniform(N),this._ints[N]=U,this}setUInt(N,U){return this._checkUniform(N),this._uints[N]=U,this}setFloats(N,U){return this._checkUniform(N),this._floatsArrays[N]=U,this}setColor3(N,U){return this._checkUniform(N),this._colors3[N]=U,this}setColor3Array(N,U){return this._checkUniform(N),this._colors3Arrays[N]=U.reduce(((N,U)=>(N.push(U.r,U.g,U.b),N)),[]),this}setColor4(N,U){return this._checkUniform(N),this._colors4[N]=U,this}setColor4Array(N,U){return this._checkUniform(N),this._colors4Arrays[N]=U.reduce(((N,U)=>(N.push(U.r,U.g,U.b,U.a),N)),[]),this}setVector2(N,U){return this._checkUniform(N),this._vectors2[N]=U,this}setVector3(N,U){return this._checkUniform(N),this._vectors3[N]=U,this}setVector4(N,U){return this._checkUniform(N),this._vectors4[N]=U,this}setQuaternion(N,U){return this._checkUniform(N),this._quaternions[N]=U,this}setQuaternionArray(N,U){return this._checkUniform(N),this._quaternionsArrays[N]=U.reduce(((N,U)=>(U.toArray(N,N.length),N)),[]),this}setMatrix(N,U){return this._checkUniform(N),this._matrices[N]=U,this}setMatrices(N,U){this._checkUniform(N);const V=new Float32Array(16*U.length);for(let A=0;A<U.length;A++){U[A].copyToArray(V,16*A)}return this._matrixArrays[N]=V,this}setMatrix3x3(N,U){return this._checkUniform(N),this._matrices3x3[N]=U,this}setMatrix2x2(N,U){return this._checkUniform(N),this._matrices2x2[N]=U,this}setArray2(N,U){return this._checkUniform(N),this._vectors2Arrays[N]=U,this}setArray3(N,U){return this._checkUniform(N),this._vectors3Arrays[N]=U,this}setArray4(N,U){return this._checkUniform(N),this._vectors4Arrays[N]=U,this}setUniformBuffer(N,U){return-1===this._options.uniformBuffers.indexOf(N)&&this._options.uniformBuffers.push(N),this._uniformBuffers[N]=U,this}setTextureSampler(N,U){return-1===this._options.samplerObjects.indexOf(N)&&this._options.samplerObjects.push(N),this._textureSamplers[N]=U,this}setStorageBuffer(N,U){return-1===this._options.storageBuffers.indexOf(N)&&this._options.storageBuffers.push(N),this._storageBuffers[N]=U,this}setDefine(N,U){const V=N.trimEnd()+" ",A=this.options.defines.findIndex((U=>U===N||U.startsWith(V)));return A>=0&&this.options.defines.splice(A,1),("boolean"!==typeof U||U)&&this.options.defines.push(V+U),this}isReadyForSubMesh(N,U,V){return this.isReady(N,V,U)}isReady(N,U,V){var A;const n=V&&this._storeEffectOnSubMeshes;if(this.isFrozen){const N=n?V._drawWrapper:this._drawWrapper;if(N.effect&&N._wasPreviouslyReady&&N._wasPreviouslyUsingInstances===U)return!0}const i=this.YN(),z=i.getEngine(),E=[],p=[];let k=null,J=this._shaderPath,d=this._options.uniforms,r=this._options.uniformBuffers,v=this._options.samplers;z.getCaps().multiview&&i.activeCamera&&i.activeCamera.outputRenderTarget&&i.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,E.push("#define MULTIVIEW"),-1!==d.indexOf("viewProjection")&&-1===d.indexOf("viewProjectionR")&&d.push("viewProjectionR"));for(let t=0;t<this._options.defines.length;t++){const N=0===this._options.defines[t].indexOf("#define")?this._options.defines[t]:`#define ${this._options.defines[t]}`;E.push(N)}for(let t=0;t<this._options.attributes.length;t++)p.push(this._options.attributes[t]);if(N&&N.isVerticesDataPresent(q.f.ColorKind)&&(-1===p.indexOf(q.f.ColorKind)&&p.push(q.f.ColorKind),E.push("#define VERTEXCOLOR")),U&&(E.push("#define INSTANCES"),(0,C.cb)(p,this._materialHelperNeedsPreviousMatrices),null!==N&&void 0!==N&&N.hasThinInstances&&(E.push("#define THIN_INSTANCES"),N&&N.isVerticesDataPresent(q.f.ColorInstanceKind)&&(p.push(q.f.ColorInstanceKind),E.push("#define INSTANCESCOLOR")))),N&&N.useBones&&N.computeBonesUsingShaders&&N.skeleton){p.push(q.f.MatricesIndicesKind),p.push(q.f.MatricesWeightsKind),N.numBoneInfluencers>4&&(p.push(q.f.MatricesIndicesExtraKind),p.push(q.f.MatricesWeightsExtraKind));const U=N.skeleton;E.push("#define NUM_BONE_INFLUENCERS "+N.numBoneInfluencers),k=new S.e,k.addCPUSkinningFallback(0,N),U.isUsingTextureForMatrices?(E.push("#define BONETEXTURE"),-1===d.indexOf("boneTextureWidth")&&d.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(E.push("#define BonesPerMesh "+(U.bones.length+1)),-1===d.indexOf("mBones")&&d.push("mBones"))}else E.push("#define NUM_BONE_INFLUENCERS 0");let h=0;const c=N?N.morphTargetManager:null;if(c){const U=-1!==E.indexOf("#define UV1"),V=-1!==E.indexOf("#define UV2"),A=-1!==E.indexOf("#define TANGENT"),t=-1!==E.indexOf("#define NORMAL"),n=-1!==E.indexOf("#define VERTEXCOLOR");h=(0,C.H)(c,E,p,N,!0,t,A,U,V,n),c.isUsingTextureForTargets&&(-1===d.indexOf("morphTargetTextureIndices")&&d.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),h>0&&(d=d.slice(),d.push("morphTargetInfluences"),d.push("morphTargetCount"),d.push("morphTargetTextureInfo"),d.push("morphTargetTextureIndices"))}else E.push("#define NUM_MORPH_INFLUENCERS 0");if(N){const U=N.bakedVertexAnimationManager;U&&U.isEnabled&&(E.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===d.indexOf("bakedVertexAnimationSettings")&&d.push("bakedVertexAnimationSettings"),-1===d.indexOf("bakedVertexAnimationTextureSizeInverted")&&d.push("bakedVertexAnimationTextureSizeInverted"),-1===d.indexOf("bakedVertexAnimationTime")&&d.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,C.x)(p,N,E)}for(const t in this._textures)if(!this._textures[t].isReady())return!1;N&&this.needAlphaTestingForMesh(N)&&E.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,B.b)(d),(0,B.k)(this,i,E)),i.fogEnabled&&null!==N&&void 0!==N&&N.applyFog&&i.fogMode!==t.e.FOGMODE_NONE&&(E.push("#define FOG"),-1===d.indexOf("view")&&d.push("view"),-1===d.indexOf("vFogInfos")&&d.push("vFogInfos"),-1===d.indexOf("vFogColor")&&d.push("vFogColor")),this._useLogarithmicDepth&&(E.push("#define LOGARITHMICDEPTH"),-1===d.indexOf("logarithmicDepthConstant")&&d.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(d=d.slice(),r=r.slice(),v=v.slice(),J=this.customShaderNameResolve(this.name,d,r,v,E,p));const H=n?V._getDrawWrapper(void 0,!0):this._drawWrapper,Y=(null===H||void 0===H?void 0:H.effect)??null,W=(null===H||void 0===H?void 0:H.defines)??null,s=E.join("\n");let M=Y;return W!==s&&(M=z.createEffect(J,{attributes:p,uniformsNames:d,uniformBuffersNames:r,samplers:v,defines:s,fallbacks:k,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:h},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},z),n?V.setEffect(M,s,this._materialContext):H&&H.setEffect(M,s),this._onEffectCreatedObservable&&(x.effect=M,x.subMesh=V??(null===N||void 0===N?void 0:N.Ei[0])??null,this._onEffectCreatedObservable.notifyObservers(x))),H._wasPreviouslyUsingInstances=!!U,!(null===(A=M)||void 0===A||!A.isReady())&&(Y!==M&&i.resetCachedMaterial(),H._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(N,U){const V=U??this.getEffect();if(!V)return;const A=this._options.uniforms;-1!==A.indexOf("world")&&V.setMatrix("world",N);const t=this.YN();-1!==A.indexOf("worldView")&&(N.multiplyToRef(t.getViewMatrix(),this._cachedWorldViewMatrix),V.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==A.indexOf("worldViewProjection")&&(N.multiplyToRef(t.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),V.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==A.indexOf("view")&&V.setMatrix("view",t.getViewMatrix())}bindForSubMesh(N,U,V){var A;this.bind(N,U,null===(A=V._drawWrapperOverride)||void 0===A?void 0:A.effect,V)}bind(N,U,V,A){const t=A&&this._storeEffectOnSubMeshes,n=V??(t?A.effect:this.getEffect());if(!n)return;const q=this.YN();this._activeEffect=n,this.bindOnlyWorldMatrix(N,V);const i=this._options.uniformBuffers;let z=!1;if(n&&i&&i.length>0&&q.getEngine().supportsUniformBuffers)for(let p=0;p<i.length;++p){switch(i[p]){case"Mesh":U&&(U.getMeshUniformBuffer().bindToEffect(n,"Mesh"),U.transferToEffect(N));break;case"Scene":(0,C.p)(n,q.getSceneUniformBuffer()),q.finalizeSceneUbo(),z=!0}}const S=U&&t?this._mustRebind(q,n,A,U.visibility):q.getCachedMaterial()!==this;if(n&&S){let N;for(N in z||-1===this._options.uniforms.indexOf("view")||n.setMatrix("view",q.getViewMatrix()),z||-1===this._options.uniforms.indexOf("projection")||n.setMatrix("projection",q.getProjectionMatrix()),z||-1===this._options.uniforms.indexOf("viewProjection")||(n.setMatrix("viewProjection",q.getTransformMatrix()),this._multiview&&n.setMatrix("viewProjectionR",q._transformMatrixR)),q.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&n.setVector3("cameraPosition",q.activeCamera.globalPosition),(0,C.b)(U,n),(0,B.d)(n,this,q),this._useLogarithmicDepth&&(0,C.k)(t?A.materialDefines:n.defines,n,q),U&&(0,C.f)(q,U,n),this._textures)n.setTexture(N,this._textures[N]);for(N in this._textureArrays)n.setTextureArray(N,this._textureArrays[N]);for(N in this._ints)n.setInt(N,this._ints[N]);for(N in this._uints)n.setUInt(N,this._uints[N]);for(N in this._floats)n.setFloat(N,this._floats[N]);for(N in this._floatsArrays)n.setArray(N,this._floatsArrays[N]);for(N in this._colors3)n.setColor3(N,this._colors3[N]);for(N in this._colors3Arrays)n.setArray3(N,this._colors3Arrays[N]);for(N in this._colors4){const U=this._colors4[N];n.setFloat4(N,U.r,U.g,U.b,U.a)}for(N in this._colors4Arrays)n.setArray4(N,this._colors4Arrays[N]);for(N in this._vectors2)n.setVector2(N,this._vectors2[N]);for(N in this._vectors3)n.setVector3(N,this._vectors3[N]);for(N in this._vectors4)n.setVector4(N,this._vectors4[N]);for(N in this._quaternions)n.setQuaternion(N,this._quaternions[N]);for(N in this._matrices)n.setMatrix(N,this._matrices[N]);for(N in this._matrixArrays)n.setMatrices(N,this._matrixArrays[N]);for(N in this._matrices3x3)n.setMatrix3x3(N,this._matrices3x3[N]);for(N in this._matrices2x2)n.setMatrix2x2(N,this._matrices2x2[N]);for(N in this._vectors2Arrays)n.setArray2(N,this._vectors2Arrays[N]);for(N in this._vectors3Arrays)n.setArray3(N,this._vectors3Arrays[N]);for(N in this._vectors4Arrays)n.setArray4(N,this._vectors4Arrays[N]);for(N in this._quaternionsArrays)n.setArray4(N,this._quaternionsArrays[N]);for(N in this._uniformBuffers){const U=this._uniformBuffers[N].getBuffer();U&&n.bindUniformBuffer(U,N)}const V=q.getEngine(),i=V.setExternalTexture;if(i)for(N in this._externalTextures)i.call(V,N,this._externalTextures[N]);const S=V.setTextureSampler;if(S)for(N in this._textureSamplers)S.call(V,N,this._textureSamplers[N]);const E=V.setStorageBuffer;if(E)for(N in this._storageBuffers)E.call(V,N,this._storageBuffers[N])}if(n&&U&&(S||!this.isFrozen)){(0,C.n)(U,n),U.morphTargetManager&&U.morphTargetManager.isUsingTextureForTargets&&U.morphTargetManager._bind(n);const N=U.bakedVertexAnimationManager;if(N&&N.isEnabled){var E;const N=t?A._drawWrapper:this._drawWrapper;null===(E=U.bakedVertexAnimationManager)||void 0===E||E.bind(n,!!N._wasPreviouslyUsingInstances)}}this._afterBind(U,n,A)}getActiveTextures(){const N=super.getActiveTextures();for(const U in this._textures)N.push(this._textures[U]);for(const U in this._textureArrays){const V=this._textureArrays[U];for(let U=0;U<V.length;U++)N.push(V[U])}return N}hasTexture(N){if(super.hasTexture(N))return!0;for(const U in this._textures)if(this._textures[U]===N)return!0;for(const U in this._textureArrays){const V=this._textureArrays[U];for(let U=0;U<V.length;U++)if(V[U]===N)return!0}return!1}clone(N){const U=A.d.Clone((()=>new J(N,this.YN(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);U.name=N,U.id=N,"object"===typeof U._shaderPath&&(U._shaderPath={...U._shaderPath}),this._options={...this._options};const V=Object.keys(this._options);for(const A of V){const N=this._options[A];Array.isArray(N)&&(this._options[A]=N.slice(0))}this.ti.copyTo(U.ti);for(const A in this._textures)U.setTexture(A,this._textures[A]);for(const A in this._textureArrays)U.setTextureArray(A,this._textureArrays[A]);for(const A in this._externalTextures)U.setExternalTexture(A,this._externalTextures[A]);for(const A in this._ints)U.setInt(A,this._ints[A]);for(const A in this._uints)U.setUInt(A,this._uints[A]);for(const A in this._floats)U.setFloat(A,this._floats[A]);for(const A in this._floatsArrays)U.setFloats(A,this._floatsArrays[A]);for(const A in this._colors3)U.setColor3(A,this._colors3[A]);for(const A in this._colors3Arrays)U._colors3Arrays[A]=this._colors3Arrays[A];for(const A in this._colors4)U.setColor4(A,this._colors4[A]);for(const A in this._colors4Arrays)U._colors4Arrays[A]=this._colors4Arrays[A];for(const A in this._vectors2)U.setVector2(A,this._vectors2[A]);for(const A in this._vectors3)U.setVector3(A,this._vectors3[A]);for(const A in this._vectors4)U.setVector4(A,this._vectors4[A]);for(const A in this._quaternions)U.setQuaternion(A,this._quaternions[A]);for(const A in this._quaternionsArrays)U._quaternionsArrays[A]=this._quaternionsArrays[A];for(const A in this._matrices)U.setMatrix(A,this._matrices[A]);for(const A in this._matrixArrays)U._matrixArrays[A]=this._matrixArrays[A].slice();for(const A in this._matrices3x3)U.setMatrix3x3(A,this._matrices3x3[A]);for(const A in this._matrices2x2)U.setMatrix2x2(A,this._matrices2x2[A]);for(const A in this._vectors2Arrays)U.setArray2(A,this._vectors2Arrays[A]);for(const A in this._vectors3Arrays)U.setArray3(A,this._vectors3Arrays[A]);for(const A in this._vectors4Arrays)U.setArray4(A,this._vectors4Arrays[A]);for(const A in this._uniformBuffers)U.setUniformBuffer(A,this._uniformBuffers[A]);for(const A in this._textureSamplers)U.setTextureSampler(A,this._textureSamplers[A]);for(const A in this._storageBuffers)U.setStorageBuffer(A,this._storageBuffers[A]);return U}dispose(N,U,V){if(U){let N;for(N in this._textures)this._textures[N].dispose();for(N in this._textureArrays){const U=this._textureArrays[N];for(let N=0;N<U.length;N++)U[N].dispose()}}this._textures={},super.dispose(N,U,V)}serialize(){const N=A.d.Serialize(this);let U;for(U in N.customType="BABYLON.ShaderMaterial",N.uniqueId=this.uniqueId,N.options=this._options,N.shaderPath=this._shaderPath,N.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,N.ti=this.ti.serialize(),N.textures={},this._textures)N.textures[U]=this._textures[U].serialize();for(U in N.textureArrays={},this._textureArrays){N.textureArrays[U]=[];const V=this._textureArrays[U];for(let A=0;A<V.length;A++)N.textureArrays[U].push(V[A].serialize())}for(U in N.ints={},this._ints)N.ints[U]=this._ints[U];for(U in N.uints={},this._uints)N.uints[U]=this._uints[U];for(U in N.floats={},this._floats)N.floats[U]=this._floats[U];for(U in N.floatsArrays={},this._floatsArrays)N.floatsArrays[U]=this._floatsArrays[U];for(U in N.colors3={},this._colors3){const V=this._colors3[U];N.colors3[U]=[V.r,V.g,V.b]}for(U in N.colors3Arrays={},this._colors3Arrays)N.colors3Arrays[U]=this._colors3Arrays[U];for(U in N.colors4={},this._colors4){const V=this._colors4[U];N.colors4[U]=[V.r,V.g,V.b,V.a]}for(U in N.colors4Arrays={},this._colors4Arrays)N.colors4Arrays[U]=this._colors4Arrays[U];for(U in N.vectors2={},this._vectors2){const V=this._vectors2[U];N.vectors2[U]=[V.x,V.y]}for(U in N.vectors3={},this._vectors3){const V=this._vectors3[U];N.vectors3[U]=[V.x,V.y,V.z]}for(U in N.vectors4={},this._vectors4){const V=this._vectors4[U];N.vectors4[U]=[V.x,V.y,V.z,V.w]}for(U in N.quaternions={},this._quaternions)N.quaternions[U]=this._quaternions[U].pi();for(U in N.matrices={},this._matrices)N.matrices[U]=this._matrices[U].pi();for(U in N.matrixArray={},this._matrixArrays)N.matrixArray[U]=this._matrixArrays[U];for(U in N.matrices3x3={},this._matrices3x3)N.matrices3x3[U]=this._matrices3x3[U];for(U in N.matrices2x2={},this._matrices2x2)N.matrices2x2[U]=this._matrices2x2[U];for(U in N.vectors2Arrays={},this._vectors2Arrays)N.vectors2Arrays[U]=this._vectors2Arrays[U];for(U in N.vectors3Arrays={},this._vectors3Arrays)N.vectors3Arrays[U]=this._vectors3Arrays[U];for(U in N.vectors4Arrays={},this._vectors4Arrays)N.vectors4Arrays[U]=this._vectors4Arrays[U];for(U in N.quaternionsArrays={},this._quaternionsArrays)N.quaternionsArrays[U]=this._quaternionsArrays[U];return N}static Parse(N,U,V){const t=A.d.Parse((()=>new J(N.name,U,N.shaderPath,N.options,N.storeEffectOnSubMeshes)),N,U,V);let q;for(q in N.ti&&t.ti.parse(N.ti,U,V),N.textures)t.setTexture(q,i.e.Parse(N.textures[q],U,V));for(q in N.textureArrays){const A=N.textureArrays[q],n=[];for(let N=0;N<A.length;N++)n.push(i.e.Parse(A[N],U,V));t.setTextureArray(q,n)}for(q in N.ints)t.setInt(q,N.ints[q]);for(q in N.uints)t.setUInt(q,N.uints[q]);for(q in N.floats)t.setFloat(q,N.floats[q]);for(q in N.floatsArrays)t.setFloats(q,N.floatsArrays[q]);for(q in N.colors3){const U=N.colors3[q];t.setColor3(q,{r:U[0],g:U[1],b:U[2]})}for(q in N.colors3Arrays){const U=N.colors3Arrays[q].reduce(((N,U,V)=>(V%3===0?N.push([U]):N[N.length-1].push(U),N)),[]).map((N=>({r:N[0],g:N[1],b:N[2]})));t.setColor3Array(q,U)}for(q in N.colors4){const U=N.colors4[q];t.setColor4(q,{r:U[0],g:U[1],b:U[2],a:U[3]})}for(q in N.colors4Arrays){const U=N.colors4Arrays[q].reduce(((N,U,V)=>(V%4===0?N.push([U]):N[N.length-1].push(U),N)),[]).map((N=>({r:N[0],g:N[1],b:N[2],a:N[3]})));t.setColor4Array(q,U)}for(q in N.vectors2){const U=N.vectors2[q];t.setVector2(q,{x:U[0],y:U[1]})}for(q in N.vectors3){const U=N.vectors3[q];t.setVector3(q,{x:U[0],y:U[1],z:U[2]})}for(q in N.vectors4){const U=N.vectors4[q];t.setVector4(q,{x:U[0],y:U[1],z:U[2],w:U[3]})}for(q in N.quaternions)t.setQuaternion(q,n.Quaternion.vU(N.quaternions[q]));for(q in N.matrices)t.setMatrix(q,n.Matrix.vU(N.matrices[q]));for(q in N.matrixArray)t._matrixArrays[q]=new Float32Array(N.matrixArray[q]);for(q in N.matrices3x3)t.setMatrix3x3(q,N.matrices3x3[q]);for(q in N.matrices2x2)t.setMatrix2x2(q,N.matrices2x2[q]);for(q in N.vectors2Arrays)t.setArray2(q,N.vectors2Arrays[q]);for(q in N.vectors3Arrays)t.setArray3(q,N.vectors3Arrays[q]);for(q in N.vectors4Arrays)t.setArray4(q,N.vectors4Arrays[q]);for(q in N.quaternionsArrays)t.setArray4(q,N.quaternionsArrays[q]);return t}static async ParseFromFileAsync(N,U,V){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((t,n)=>{const q=new E.b;q.addEventListener("readystatechange",(()=>{if(4==q.readyState)if(200==q.status){const U=JSON.parse(q.responseText),n=this.Parse(U,V||k.e.LastCreatedScene,A);N&&(n.name=N),t(n)}else n("Unable to load the ShaderMaterial")})),q.open("GET",U),q.send()}))}static async ParseFromSnippetAsync(N,U){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((A,t)=>{const n=new E.b;n.addEventListener("readystatechange",(()=>{if(4==n.readyState)if(200==n.status){const t=JSON.parse(JSON.parse(n.responseText).jsonPayload),q=JSON.parse(t.shaderMaterial),i=this.Parse(q,U||k.e.LastCreatedScene,V);i.snippetId=N,A(i)}else t("Unable to load the snippet "+N)})),n.open("GET",this.SnippetUrl+"/"+N.replace(/#/g,"/")),n.send()}))}}J.SnippetUrl="https://snippet.babylonjs.com",J.CreateFromSnippetAsync=J.ParseFromSnippetAsync,(0,z.e)("BABYLON.ShaderMaterial",J)}}]);