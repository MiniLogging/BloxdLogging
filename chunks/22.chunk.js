"use strict";(self.ipz2em9uj1g=self.ipz2em9uj1g||[]).push([[22],{12799:(r,O,W)=>{W.r(O),W.d(O,{ShaderMaterial:()=>b});var q=W(12617),Q=W(12802),C=W(12591),T=W(12660),h=W(12575),J=W(12560),mr=W(12868),d=W(12481),v=W(12872),g=W(12484),K=W(12917),U=W(12915);const P={effect:null,subMesh:null};class b extends v.e{constructor(r,O,W){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(r,O,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new C.Matrix,this._cachedWorldViewProjectionMatrix=new C.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=W,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...q}}get shaderPath(){return this._shaderPath}set shaderPath(r){this._shaderPath=r}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(r){-1===this._options.uniforms.indexOf(r)&&this._options.uniforms.push(r)}setTexture(r,O){return-1===this._options.samplers.indexOf(r)&&this._options.samplers.push(r),this._textures[r]=O,this}removeTexture(r){delete this._textures[r]}setTextureArray(r,O){return-1===this._options.samplers.indexOf(r)&&this._options.samplers.push(r),this._checkUniform(r),this._textureArrays[r]=O,this}setExternalTexture(r,O){return-1===this._options.externalTextures.indexOf(r)&&this._options.externalTextures.push(r),this._externalTextures[r]=O,this}setFloat(r,O){return this._checkUniform(r),this._floats[r]=O,this}setInt(r,O){return this._checkUniform(r),this._ints[r]=O,this}setUInt(r,O){return this._checkUniform(r),this._uints[r]=O,this}setFloats(r,O){return this._checkUniform(r),this._floatsArrays[r]=O,this}setColor3(r,O){return this._checkUniform(r),this._colors3[r]=O,this}setColor3Array(r,O){return this._checkUniform(r),this._colors3Arrays[r]=O.reduce(((r,O)=>(r.push(O.r,O.g,O.b),r)),[]),this}setColor4(r,O){return this._checkUniform(r),this._colors4[r]=O,this}setColor4Array(r,O){return this._checkUniform(r),this._colors4Arrays[r]=O.reduce(((r,O)=>(r.push(O.r,O.g,O.b,O.a),r)),[]),this}setVector2(r,O){return this._checkUniform(r),this._vectors2[r]=O,this}setVector3(r,O){return this._checkUniform(r),this._vectors3[r]=O,this}setVector4(r,O){return this._checkUniform(r),this._vectors4[r]=O,this}setQuaternion(r,O){return this._checkUniform(r),this._quaternions[r]=O,this}setQuaternionArray(r,O){return this._checkUniform(r),this._quaternionsArrays[r]=O.reduce(((r,O)=>(O.toArray(r,r.length),r)),[]),this}setMatrix(r,O){return this._checkUniform(r),this._matrices[r]=O,this}setMatrices(r,O){this._checkUniform(r);const W=new Float32Array(16*O.length);for(let q=0;q<O.length;q++){O[q].copyToArray(W,16*q)}return this._matrixArrays[r]=W,this}setMatrix3x3(r,O){return this._checkUniform(r),this._matrices3x3[r]=O,this}setMatrix2x2(r,O){return this._checkUniform(r),this._matrices2x2[r]=O,this}setArray2(r,O){return this._checkUniform(r),this._vectors2Arrays[r]=O,this}setArray3(r,O){return this._checkUniform(r),this._vectors3Arrays[r]=O,this}setArray4(r,O){return this._checkUniform(r),this._vectors4Arrays[r]=O,this}setUniformBuffer(r,O){return-1===this._options.uniformBuffers.indexOf(r)&&this._options.uniformBuffers.push(r),this._uniformBuffers[r]=O,this}setTextureSampler(r,O){return-1===this._options.samplerObjects.indexOf(r)&&this._options.samplerObjects.push(r),this._textureSamplers[r]=O,this}setStorageBuffer(r,O){return-1===this._options.storageBuffers.indexOf(r)&&this._options.storageBuffers.push(r),this._storageBuffers[r]=O,this}setDefine(r,O){const W=r.trimEnd()+" ",q=this.options.defines.findIndex((O=>O===r||O.startsWith(W)));return q>=0&&this.options.defines.splice(q,1),("boolean"!==typeof O||O)&&this.options.defines.push(W+O),this}isReadyForSubMesh(r,O,W){return this.isReady(r,W,O)}isReady(r,O,W){var q;const C=W&&this._storeEffectOnSubMeshes;if(this.isFrozen){const r=C?W._drawWrapper:this._drawWrapper;if(r.effect&&r._wasPreviouslyReady&&r._wasPreviouslyUsingInstances===O)return!0}const h=this.Dr(),J=h.getEngine(),d=[],v=[];let g=null,b=this._shaderPath,e=this._options.uniforms,Y=this._options.uniformBuffers,G=this._options.samplers;J.getCaps().multiview&&h.activeCamera&&h.activeCamera.outputRenderTarget&&h.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,d.push("#define MULTIVIEW"),-1!==e.indexOf("viewProjection")&&-1===e.indexOf("viewProjectionR")&&e.push("viewProjectionR"));for(let Q=0;Q<this._options.defines.length;Q++){const r=0===this._options.defines[Q].indexOf("#define")?this._options.defines[Q]:`#define ${this._options.defines[Q]}`;d.push(r)}for(let Q=0;Q<this._options.attributes.length;Q++)v.push(this._options.attributes[Q]);if(r&&r.isVerticesDataPresent(T.i.ColorKind)&&(-1===v.indexOf(T.i.ColorKind)&&v.push(T.i.ColorKind),d.push("#define VERTEXCOLOR")),O&&(d.push("#define INSTANCES"),(0,U.hb)(v,this._materialHelperNeedsPreviousMatrices),null!==r&&void 0!==r&&r.hasThinInstances&&(d.push("#define THIN_INSTANCES"),r&&r.isVerticesDataPresent(T.i.ColorInstanceKind)&&(v.push(T.i.ColorInstanceKind),d.push("#define INSTANCESCOLOR")))),r&&r.useBones&&r.computeBonesUsingShaders&&r.skeleton){v.push(T.i.MatricesIndicesKind),v.push(T.i.MatricesWeightsKind),r.numBoneInfluencers>4&&(v.push(T.i.MatricesIndicesExtraKind),v.push(T.i.MatricesWeightsExtraKind));const O=r.skeleton;d.push("#define NUM_BONE_INFLUENCERS "+r.numBoneInfluencers),g=new mr.c,g.addCPUSkinningFallback(0,r),O.isUsingTextureForMatrices?(d.push("#define BONETEXTURE"),-1===e.indexOf("boneTextureWidth")&&e.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(d.push("#define BonesPerMesh "+(O.bones.length+1)),-1===e.indexOf("mBones")&&e.push("mBones"))}else d.push("#define NUM_BONE_INFLUENCERS 0");let X=0;const S=r?r.morphTargetManager:null;if(S){const O=-1!==d.indexOf("#define UV1"),W=-1!==d.indexOf("#define UV2"),q=-1!==d.indexOf("#define TANGENT"),Q=-1!==d.indexOf("#define NORMAL"),C=-1!==d.indexOf("#define VERTEXCOLOR");X=(0,U.J)(S,d,v,r,!0,Q,q,O,W,C),S.isUsingTextureForTargets&&(-1===e.indexOf("morphTargetTextureIndices")&&e.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),X>0&&(e=e.slice(),e.push("morphTargetInfluences"),e.push("morphTargetCount"),e.push("morphTargetTextureInfo"),e.push("morphTargetTextureIndices"))}else d.push("#define NUM_MORPH_INFLUENCERS 0");if(r){const O=r.bakedVertexAnimationManager;O&&O.isEnabled&&(d.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===e.indexOf("bakedVertexAnimationSettings")&&e.push("bakedVertexAnimationSettings"),-1===e.indexOf("bakedVertexAnimationTextureSizeInverted")&&e.push("bakedVertexAnimationTextureSizeInverted"),-1===e.indexOf("bakedVertexAnimationTime")&&e.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,U.A)(v,r,d)}for(const Q in this._textures)if(!this._textures[Q].isReady())return!1;r&&this.needAlphaTestingForMesh(r)&&d.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,K.c)(e),(0,K.m)(this,h,d)),h.fogEnabled&&null!==r&&void 0!==r&&r.applyFog&&h.fogMode!==Q.e.FOGMODE_NONE&&(d.push("#define FOG"),-1===e.indexOf("view")&&e.push("view"),-1===e.indexOf("vFogInfos")&&e.push("vFogInfos"),-1===e.indexOf("vFogColor")&&e.push("vFogColor")),this._useLogarithmicDepth&&(d.push("#define LOGARITHMICDEPTH"),-1===e.indexOf("logarithmicDepthConstant")&&e.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(e=e.slice(),Y=Y.slice(),G=G.slice(),b=this.customShaderNameResolve(this.name,e,Y,G,d,v));const o=C?W._getDrawWrapper(void 0,!0):this._drawWrapper,N=(null===o||void 0===o?void 0:o.effect)??null,D=(null===o||void 0===o?void 0:o.defines)??null,p=d.join("\n");let z=N;return D!==p&&(z=J.createEffect(b,{attributes:v,uniformsNames:e,uniformBuffersNames:Y,samplers:G,defines:p,fallbacks:g,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:X},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},J),C?W.setEffect(z,p,this._materialContext):o&&o.setEffect(z,p),this._onEffectCreatedObservable&&(P.effect=z,P.subMesh=W??(null===r||void 0===r?void 0:r.eh[0])??null,this._onEffectCreatedObservable.notifyObservers(P))),o._wasPreviouslyUsingInstances=!!O,!(null===(q=z)||void 0===q||!q.isReady())&&(N!==z&&h.resetCachedMaterial(),o._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(r,O){const W=O??this.getEffect();if(!W)return;const q=this._options.uniforms;-1!==q.indexOf("world")&&W.setMatrix("world",r);const Q=this.Dr();-1!==q.indexOf("worldView")&&(r.multiplyToRef(Q.getViewMatrix(),this._cachedWorldViewMatrix),W.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==q.indexOf("worldViewProjection")&&(r.multiplyToRef(Q.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),W.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==q.indexOf("view")&&W.setMatrix("view",Q.getViewMatrix())}bindForSubMesh(r,O,W){var q;this.bind(r,O,null===(q=W._drawWrapperOverride)||void 0===q?void 0:q.effect,W)}bind(r,O,W,q){const Q=q&&this._storeEffectOnSubMeshes,C=W??(Q?q.effect:this.getEffect());if(!C)return;const T=this.Dr();this._activeEffect=C,this.bindOnlyWorldMatrix(r,W);const h=this._options.uniformBuffers;let J=!1;if(C&&h&&h.length>0&&T.getEngine().supportsUniformBuffers)for(let v=0;v<h.length;++v){switch(h[v]){case"Mesh":O&&(O.getMeshUniformBuffer().bindToEffect(C,"Mesh"),O.transferToEffect(r));break;case"Scene":(0,U.r)(C,T.getSceneUniformBuffer()),T.finalizeSceneUbo(),J=!0}}const mr=O&&Q?this._mustRebind(T,C,q,O.visibility):T.getCachedMaterial()!==this;if(C&&mr){let r;for(r in J||-1===this._options.uniforms.indexOf("view")||C.setMatrix("view",T.getViewMatrix()),J||-1===this._options.uniforms.indexOf("projection")||C.setMatrix("projection",T.getProjectionMatrix()),J||-1===this._options.uniforms.indexOf("viewProjection")||(C.setMatrix("viewProjection",T.getTransformMatrix()),this._multiview&&C.setMatrix("viewProjectionR",T._transformMatrixR)),T.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&C.setVector3("cameraPosition",T.activeCamera.globalPosition),(0,U.e)(O,C),(0,K.f)(C,this,T),this._useLogarithmicDepth&&(0,U.l)(Q?q.materialDefines:C.defines,C,T),O&&(0,U.h)(T,O,C),this._textures)C.setTexture(r,this._textures[r]);for(r in this._textureArrays)C.setTextureArray(r,this._textureArrays[r]);for(r in this._ints)C.setInt(r,this._ints[r]);for(r in this._uints)C.setUInt(r,this._uints[r]);for(r in this._floats)C.setFloat(r,this._floats[r]);for(r in this._floatsArrays)C.setArray(r,this._floatsArrays[r]);for(r in this._colors3)C.setColor3(r,this._colors3[r]);for(r in this._colors3Arrays)C.setArray3(r,this._colors3Arrays[r]);for(r in this._colors4){const O=this._colors4[r];C.setFloat4(r,O.r,O.g,O.b,O.a)}for(r in this._colors4Arrays)C.setArray4(r,this._colors4Arrays[r]);for(r in this._vectors2)C.setVector2(r,this._vectors2[r]);for(r in this._vectors3)C.setVector3(r,this._vectors3[r]);for(r in this._vectors4)C.setVector4(r,this._vectors4[r]);for(r in this._quaternions)C.setQuaternion(r,this._quaternions[r]);for(r in this._matrices)C.setMatrix(r,this._matrices[r]);for(r in this._matrixArrays)C.setMatrices(r,this._matrixArrays[r]);for(r in this._matrices3x3)C.setMatrix3x3(r,this._matrices3x3[r]);for(r in this._matrices2x2)C.setMatrix2x2(r,this._matrices2x2[r]);for(r in this._vectors2Arrays)C.setArray2(r,this._vectors2Arrays[r]);for(r in this._vectors3Arrays)C.setArray3(r,this._vectors3Arrays[r]);for(r in this._vectors4Arrays)C.setArray4(r,this._vectors4Arrays[r]);for(r in this._quaternionsArrays)C.setArray4(r,this._quaternionsArrays[r]);for(r in this._uniformBuffers){const O=this._uniformBuffers[r].getBuffer();O&&C.bindUniformBuffer(O,r)}const W=T.getEngine(),h=W.setExternalTexture;if(h)for(r in this._externalTextures)h.call(W,r,this._externalTextures[r]);const mr=W.setTextureSampler;if(mr)for(r in this._textureSamplers)mr.call(W,r,this._textureSamplers[r]);const d=W.setStorageBuffer;if(d)for(r in this._storageBuffers)d.call(W,r,this._storageBuffers[r])}if(C&&O&&(mr||!this.isFrozen)){(0,U.n)(O,C),O.morphTargetManager&&O.morphTargetManager.isUsingTextureForTargets&&O.morphTargetManager._bind(C);const r=O.bakedVertexAnimationManager;if(r&&r.isEnabled){var d;const r=Q?q._drawWrapper:this._drawWrapper;null===(d=O.bakedVertexAnimationManager)||void 0===d||d.bind(C,!!r._wasPreviouslyUsingInstances)}}this._afterBind(O,C,q)}getActiveTextures(){const r=super.getActiveTextures();for(const O in this._textures)r.push(this._textures[O]);for(const O in this._textureArrays){const W=this._textureArrays[O];for(let O=0;O<W.length;O++)r.push(W[O])}return r}hasTexture(r){if(super.hasTexture(r))return!0;for(const O in this._textures)if(this._textures[O]===r)return!0;for(const O in this._textureArrays){const W=this._textureArrays[O];for(let O=0;O<W.length;O++)if(W[O]===r)return!0}return!1}clone(r){const O=q.b.Clone((()=>new b(r,this.Dr(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);O.name=r,O.id=r,"object"===typeof O._shaderPath&&(O._shaderPath={...O._shaderPath}),this._options={...this._options};const W=Object.keys(this._options);for(const q of W){const r=this._options[q];Array.isArray(r)&&(this._options[q]=r.slice(0))}this.dh.copyTo(O.dh);for(const q in this._textures)O.setTexture(q,this._textures[q]);for(const q in this._textureArrays)O.setTextureArray(q,this._textureArrays[q]);for(const q in this._externalTextures)O.setExternalTexture(q,this._externalTextures[q]);for(const q in this._ints)O.setInt(q,this._ints[q]);for(const q in this._uints)O.setUInt(q,this._uints[q]);for(const q in this._floats)O.setFloat(q,this._floats[q]);for(const q in this._floatsArrays)O.setFloats(q,this._floatsArrays[q]);for(const q in this._colors3)O.setColor3(q,this._colors3[q]);for(const q in this._colors3Arrays)O._colors3Arrays[q]=this._colors3Arrays[q];for(const q in this._colors4)O.setColor4(q,this._colors4[q]);for(const q in this._colors4Arrays)O._colors4Arrays[q]=this._colors4Arrays[q];for(const q in this._vectors2)O.setVector2(q,this._vectors2[q]);for(const q in this._vectors3)O.setVector3(q,this._vectors3[q]);for(const q in this._vectors4)O.setVector4(q,this._vectors4[q]);for(const q in this._quaternions)O.setQuaternion(q,this._quaternions[q]);for(const q in this._quaternionsArrays)O._quaternionsArrays[q]=this._quaternionsArrays[q];for(const q in this._matrices)O.setMatrix(q,this._matrices[q]);for(const q in this._matrixArrays)O._matrixArrays[q]=this._matrixArrays[q].slice();for(const q in this._matrices3x3)O.setMatrix3x3(q,this._matrices3x3[q]);for(const q in this._matrices2x2)O.setMatrix2x2(q,this._matrices2x2[q]);for(const q in this._vectors2Arrays)O.setArray2(q,this._vectors2Arrays[q]);for(const q in this._vectors3Arrays)O.setArray3(q,this._vectors3Arrays[q]);for(const q in this._vectors4Arrays)O.setArray4(q,this._vectors4Arrays[q]);for(const q in this._uniformBuffers)O.setUniformBuffer(q,this._uniformBuffers[q]);for(const q in this._textureSamplers)O.setTextureSampler(q,this._textureSamplers[q]);for(const q in this._storageBuffers)O.setStorageBuffer(q,this._storageBuffers[q]);return O}dispose(r,O,W){if(O){let r;for(r in this._textures)this._textures[r].dispose();for(r in this._textureArrays){const O=this._textureArrays[r];for(let r=0;r<O.length;r++)O[r].dispose()}}this._textures={},super.dispose(r,O,W)}serialize(){const r=q.b.Serialize(this);let O;for(O in r.customType="BABYLON.ShaderMaterial",r.uniqueId=this.uniqueId,r.options=this._options,r.shaderPath=this._shaderPath,r.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,r.dh=this.dh.serialize(),r.textures={},this._textures)r.textures[O]=this._textures[O].serialize();for(O in r.textureArrays={},this._textureArrays){r.textureArrays[O]=[];const W=this._textureArrays[O];for(let q=0;q<W.length;q++)r.textureArrays[O].push(W[q].serialize())}for(O in r.ints={},this._ints)r.ints[O]=this._ints[O];for(O in r.uints={},this._uints)r.uints[O]=this._uints[O];for(O in r.floats={},this._floats)r.floats[O]=this._floats[O];for(O in r.floatsArrays={},this._floatsArrays)r.floatsArrays[O]=this._floatsArrays[O];for(O in r.colors3={},this._colors3){const W=this._colors3[O];r.colors3[O]=[W.r,W.g,W.b]}for(O in r.colors3Arrays={},this._colors3Arrays)r.colors3Arrays[O]=this._colors3Arrays[O];for(O in r.colors4={},this._colors4){const W=this._colors4[O];r.colors4[O]=[W.r,W.g,W.b,W.a]}for(O in r.colors4Arrays={},this._colors4Arrays)r.colors4Arrays[O]=this._colors4Arrays[O];for(O in r.vectors2={},this._vectors2){const W=this._vectors2[O];r.vectors2[O]=[W.x,W.y]}for(O in r.vectors3={},this._vectors3){const W=this._vectors3[O];r.vectors3[O]=[W.x,W.y,W.z]}for(O in r.vectors4={},this._vectors4){const W=this._vectors4[O];r.vectors4[O]=[W.x,W.y,W.z,W.w]}for(O in r.quaternions={},this._quaternions)r.quaternions[O]=this._quaternions[O].Yh();for(O in r.matrices={},this._matrices)r.matrices[O]=this._matrices[O].Yh();for(O in r.matrixArray={},this._matrixArrays)r.matrixArray[O]=this._matrixArrays[O];for(O in r.matrices3x3={},this._matrices3x3)r.matrices3x3[O]=this._matrices3x3[O];for(O in r.matrices2x2={},this._matrices2x2)r.matrices2x2[O]=this._matrices2x2[O];for(O in r.vectors2Arrays={},this._vectors2Arrays)r.vectors2Arrays[O]=this._vectors2Arrays[O];for(O in r.vectors3Arrays={},this._vectors3Arrays)r.vectors3Arrays[O]=this._vectors3Arrays[O];for(O in r.vectors4Arrays={},this._vectors4Arrays)r.vectors4Arrays[O]=this._vectors4Arrays[O];for(O in r.quaternionsArrays={},this._quaternionsArrays)r.quaternionsArrays[O]=this._quaternionsArrays[O];return r}static Parse(r,O,W){const Q=q.b.Parse((()=>new b(r.name,O,r.shaderPath,r.options,r.storeEffectOnSubMeshes)),r,O,W);let T;for(T in r.dh&&Q.dh.parse(r.dh,O,W),r.textures)Q.setTexture(T,h.e.Parse(r.textures[T],O,W));for(T in r.textureArrays){const q=r.textureArrays[T],C=[];for(let r=0;r<q.length;r++)C.push(h.e.Parse(q[r],O,W));Q.setTextureArray(T,C)}for(T in r.ints)Q.setInt(T,r.ints[T]);for(T in r.uints)Q.setUInt(T,r.uints[T]);for(T in r.floats)Q.setFloat(T,r.floats[T]);for(T in r.floatsArrays)Q.setFloats(T,r.floatsArrays[T]);for(T in r.colors3){const O=r.colors3[T];Q.setColor3(T,{r:O[0],g:O[1],b:O[2]})}for(T in r.colors3Arrays){const O=r.colors3Arrays[T].reduce(((r,O,W)=>(W%3===0?r.push([O]):r[r.length-1].push(O),r)),[]).map((r=>({r:r[0],g:r[1],b:r[2]})));Q.setColor3Array(T,O)}for(T in r.colors4){const O=r.colors4[T];Q.setColor4(T,{r:O[0],g:O[1],b:O[2],a:O[3]})}for(T in r.colors4Arrays){const O=r.colors4Arrays[T].reduce(((r,O,W)=>(W%4===0?r.push([O]):r[r.length-1].push(O),r)),[]).map((r=>({r:r[0],g:r[1],b:r[2],a:r[3]})));Q.setColor4Array(T,O)}for(T in r.vectors2){const O=r.vectors2[T];Q.setVector2(T,{x:O[0],y:O[1]})}for(T in r.vectors3){const O=r.vectors3[T];Q.setVector3(T,{x:O[0],y:O[1],z:O[2]})}for(T in r.vectors4){const O=r.vectors4[T];Q.setVector4(T,{x:O[0],y:O[1],z:O[2],w:O[3]})}for(T in r.quaternions)Q.setQuaternion(T,C.Quaternion.oO(r.quaternions[T]));for(T in r.matrices)Q.setMatrix(T,C.Matrix.oO(r.matrices[T]));for(T in r.matrixArray)Q._matrixArrays[T]=new Float32Array(r.matrixArray[T]);for(T in r.matrices3x3)Q.setMatrix3x3(T,r.matrices3x3[T]);for(T in r.matrices2x2)Q.setMatrix2x2(T,r.matrices2x2[T]);for(T in r.vectors2Arrays)Q.setArray2(T,r.vectors2Arrays[T]);for(T in r.vectors3Arrays)Q.setArray3(T,r.vectors3Arrays[T]);for(T in r.vectors4Arrays)Q.setArray4(T,r.vectors4Arrays[T]);for(T in r.quaternionsArrays)Q.setArray4(T,r.quaternionsArrays[T]);return Q}static async ParseFromFileAsync(r,O,W){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((Q,C)=>{const T=new d.e;T.addEventListener("readystatechange",(()=>{if(4==T.readyState)if(200==T.status){const O=JSON.parse(T.responseText),C=this.Parse(O,W||g.d.LastCreatedScene,q);r&&(C.name=r),Q(C)}else C("Unable to load the ShaderMaterial")})),T.open("GET",O),T.send()}))}static async ParseFromSnippetAsync(r,O){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((q,Q)=>{const C=new d.e;C.addEventListener("readystatechange",(()=>{if(4==C.readyState)if(200==C.status){const Q=JSON.parse(JSON.parse(C.responseText).jsonPayload),T=JSON.parse(Q.shaderMaterial),h=this.Parse(T,O||g.d.LastCreatedScene,W);h.snippetId=r,q(h)}else Q("Unable to load the snippet "+r)})),C.open("GET",this.SnippetUrl+"/"+r.replace(/#/g,"/")),C.send()}))}}b.SnippetUrl="https://snippet.babylonjs.com",b.CreateFromSnippetAsync=b.ParseFromSnippetAsync,(0,J.e)("BABYLON.ShaderMaterial",b)}}]);