"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[22],{11562:(m,S,h)=>{h.r(S),h.d(S,{ShaderMaterial:()=>E});var l=h(11377),M=h(11567),O=h(11347),u=h(11410),b=h(11321),q=h(11293),Y=h(11617),V=h(11191),I=h(11625),Z=h(11196),C=h(11668),B=h(11663);const D={effect:null,subMesh:null};class E extends I.d{constructor(m,S,h){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(m,S,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new O.Matrix,this._cachedWorldViewProjectionMatrix=new O.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=h,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...l}}get shaderPath(){return this._shaderPath}set shaderPath(m){this._shaderPath=m}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(m){-1===this._options.uniforms.indexOf(m)&&this._options.uniforms.push(m)}setTexture(m,S){return-1===this._options.samplers.indexOf(m)&&this._options.samplers.push(m),this._textures[m]=S,this}removeTexture(m){delete this._textures[m]}setTextureArray(m,S){return-1===this._options.samplers.indexOf(m)&&this._options.samplers.push(m),this._checkUniform(m),this._textureArrays[m]=S,this}setExternalTexture(m,S){return-1===this._options.externalTextures.indexOf(m)&&this._options.externalTextures.push(m),this._externalTextures[m]=S,this}setFloat(m,S){return this._checkUniform(m),this._floats[m]=S,this}setInt(m,S){return this._checkUniform(m),this._ints[m]=S,this}setUInt(m,S){return this._checkUniform(m),this._uints[m]=S,this}setFloats(m,S){return this._checkUniform(m),this._floatsArrays[m]=S,this}setColor3(m,S){return this._checkUniform(m),this._colors3[m]=S,this}setColor3Array(m,S){return this._checkUniform(m),this._colors3Arrays[m]=S.reduce(((m,S)=>(m.push(S.r,S.g,S.b),m)),[]),this}setColor4(m,S){return this._checkUniform(m),this._colors4[m]=S,this}setColor4Array(m,S){return this._checkUniform(m),this._colors4Arrays[m]=S.reduce(((m,S)=>(m.push(S.r,S.g,S.b,S.a),m)),[]),this}setVector2(m,S){return this._checkUniform(m),this._vectors2[m]=S,this}setVector3(m,S){return this._checkUniform(m),this._vectors3[m]=S,this}setVector4(m,S){return this._checkUniform(m),this._vectors4[m]=S,this}setQuaternion(m,S){return this._checkUniform(m),this._quaternions[m]=S,this}setQuaternionArray(m,S){return this._checkUniform(m),this._quaternionsArrays[m]=S.reduce(((m,S)=>(S.toArray(m,m.length),m)),[]),this}setMatrix(m,S){return this._checkUniform(m),this._matrices[m]=S,this}setMatrices(m,S){this._checkUniform(m);const h=new Float32Array(16*S.length);for(let l=0;l<S.length;l++){S[l].copyToArray(h,16*l)}return this._matrixArrays[m]=h,this}setMatrix3x3(m,S){return this._checkUniform(m),this._matrices3x3[m]=S,this}setMatrix2x2(m,S){return this._checkUniform(m),this._matrices2x2[m]=S,this}setArray2(m,S){return this._checkUniform(m),this._vectors2Arrays[m]=S,this}setArray3(m,S){return this._checkUniform(m),this._vectors3Arrays[m]=S,this}setArray4(m,S){return this._checkUniform(m),this._vectors4Arrays[m]=S,this}setUniformBuffer(m,S){return-1===this._options.uniformBuffers.indexOf(m)&&this._options.uniformBuffers.push(m),this._uniformBuffers[m]=S,this}setTextureSampler(m,S){return-1===this._options.samplerObjects.indexOf(m)&&this._options.samplerObjects.push(m),this._textureSamplers[m]=S,this}setStorageBuffer(m,S){return-1===this._options.storageBuffers.indexOf(m)&&this._options.storageBuffers.push(m),this._storageBuffers[m]=S,this}setDefine(m,S){const h=m.trimEnd()+" ",l=this.options.defines.findIndex((S=>S===m||S.startsWith(h)));return l>=0&&this.options.defines.splice(l,1),("boolean"!==typeof S||S)&&this.options.defines.push(h+S),this}isReadyForSubMesh(m,S,h){return this.isReady(m,h,S)}isReady(m,S,h){var l;const O=h&&this._storeEffectOnSubMeshes;if(this.isFrozen){const m=O?h._drawWrapper:this._drawWrapper;if(m.effect&&m._wasPreviouslyReady&&m._wasPreviouslyUsingInstances===S)return!0}const b=this.sm(),q=b.getEngine(),V=[],I=[];let Z=null,E=this._shaderPath,n=this._options.uniforms,L=this._options.uniformBuffers,U=this._options.samplers;q.getCaps().multiview&&b.activeCamera&&b.activeCamera.outputRenderTarget&&b.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,V.push("#define MULTIVIEW"),-1!==n.indexOf("viewProjection")&&-1===n.indexOf("viewProjectionR")&&n.push("viewProjectionR"));for(let M=0;M<this._options.defines.length;M++){const m=0===this._options.defines[M].indexOf("#define")?this._options.defines[M]:`#define ${this._options.defines[M]}`;V.push(m)}for(let M=0;M<this._options.attributes.length;M++)I.push(this._options.attributes[M]);if(m&&m.isVerticesDataPresent(u.f.ColorKind)&&(-1===I.indexOf(u.f.ColorKind)&&I.push(u.f.ColorKind),V.push("#define VERTEXCOLOR")),S&&(V.push("#define INSTANCES"),(0,B.lb)(I,this._materialHelperNeedsPreviousMatrices),null!==m&&void 0!==m&&m.hasThinInstances&&(V.push("#define THIN_INSTANCES"),m&&m.isVerticesDataPresent(u.f.ColorInstanceKind)&&(I.push(u.f.ColorInstanceKind),V.push("#define INSTANCESCOLOR")))),m&&m.useBones&&m.computeBonesUsingShaders&&m.skeleton){I.push(u.f.MatricesIndicesKind),I.push(u.f.MatricesWeightsKind),m.numBoneInfluencers>4&&(I.push(u.f.MatricesIndicesExtraKind),I.push(u.f.MatricesWeightsExtraKind));const S=m.skeleton;V.push("#define NUM_BONE_INFLUENCERS "+m.numBoneInfluencers),Z=new Y.e,Z.addCPUSkinningFallback(0,m),S.isUsingTextureForMatrices?(V.push("#define BONETEXTURE"),-1===n.indexOf("boneTextureWidth")&&n.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(V.push("#define BonesPerMesh "+(S.bones.length+1)),-1===n.indexOf("mBones")&&n.push("mBones"))}else V.push("#define NUM_BONE_INFLUENCERS 0");let H=0;const R=m?m.morphTargetManager:null;if(R){const S=-1!==V.indexOf("#define UV1"),h=-1!==V.indexOf("#define UV2"),l=-1!==V.indexOf("#define TANGENT"),M=-1!==V.indexOf("#define NORMAL"),O=-1!==V.indexOf("#define VERTEXCOLOR");H=(0,B.K)(R,V,I,m,!0,M,l,S,h,O),R.isUsingTextureForTargets&&(-1===n.indexOf("morphTargetTextureIndices")&&n.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),H>0&&(n=n.slice(),n.push("morphTargetInfluences"),n.push("morphTargetCount"),n.push("morphTargetTextureInfo"),n.push("morphTargetTextureIndices"))}else V.push("#define NUM_MORPH_INFLUENCERS 0");if(m){const S=m.bakedVertexAnimationManager;S&&S.isEnabled&&(V.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===n.indexOf("bakedVertexAnimationSettings")&&n.push("bakedVertexAnimationSettings"),-1===n.indexOf("bakedVertexAnimationTextureSizeInverted")&&n.push("bakedVertexAnimationTextureSizeInverted"),-1===n.indexOf("bakedVertexAnimationTime")&&n.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,B.w)(I,m,V)}for(const M in this._textures)if(!this._textures[M].isReady())return!1;m&&this.needAlphaTestingForMesh(m)&&V.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,C.e)(n),(0,C.m)(this,b,V)),b.fogEnabled&&null!==m&&void 0!==m&&m.applyFog&&b.fogMode!==M.c.FOGMODE_NONE&&(V.push("#define FOG"),-1===n.indexOf("view")&&n.push("view"),-1===n.indexOf("vFogInfos")&&n.push("vFogInfos"),-1===n.indexOf("vFogColor")&&n.push("vFogColor")),this._useLogarithmicDepth&&(V.push("#define LOGARITHMICDEPTH"),-1===n.indexOf("logarithmicDepthConstant")&&n.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(n=n.slice(),L=L.slice(),U=U.slice(),E=this.customShaderNameResolve(this.name,n,L,U,V,I));const y=O?h._getDrawWrapper(void 0,!0):this._drawWrapper,o=(null===y||void 0===y?void 0:y.effect)??null,s=(null===y||void 0===y?void 0:y.defines)??null,v=V.join("\n");let T=o;return s!==v&&(T=q.createEffect(E,{attributes:I,uniformsNames:n,uniformBuffersNames:L,samplers:U,defines:v,fallbacks:Z,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:H},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},q),O?h.setEffect(T,v,this._materialContext):y&&y.setEffect(T,v),this._onEffectCreatedObservable&&(D.effect=T,D.subMesh=h??(null===m||void 0===m?void 0:m.CM[0])??null,this._onEffectCreatedObservable.notifyObservers(D))),y._wasPreviouslyUsingInstances=!!S,!(null===(l=T)||void 0===l||!l.isReady())&&(o!==T&&b.resetCachedMaterial(),y._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(m,S){const h=S??this.getEffect();if(!h)return;const l=this._options.uniforms;-1!==l.indexOf("world")&&h.setMatrix("world",m);const M=this.sm();-1!==l.indexOf("worldView")&&(m.multiplyToRef(M.getViewMatrix(),this._cachedWorldViewMatrix),h.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==l.indexOf("worldViewProjection")&&(m.multiplyToRef(M.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),h.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==l.indexOf("view")&&h.setMatrix("view",M.getViewMatrix())}bindForSubMesh(m,S,h){var l;this.bind(m,S,null===(l=h._drawWrapperOverride)||void 0===l?void 0:l.effect,h)}bind(m,S,h,l){const M=l&&this._storeEffectOnSubMeshes,O=h??(M?l.effect:this.getEffect());if(!O)return;const u=this.sm();this._activeEffect=O,this.bindOnlyWorldMatrix(m,h);const b=this._options.uniformBuffers;let q=!1;if(O&&b&&b.length>0&&u.getEngine().supportsUniformBuffers)for(let I=0;I<b.length;++I){switch(b[I]){case"Mesh":S&&(S.getMeshUniformBuffer().bindToEffect(O,"Mesh"),S.transferToEffect(m));break;case"Scene":(0,B.o)(O,u.getSceneUniformBuffer()),u.finalizeSceneUbo(),q=!0}}const Y=S&&M?this._mustRebind(u,O,l,S.visibility):u.getCachedMaterial()!==this;if(O&&Y){let m;for(m in q||-1===this._options.uniforms.indexOf("view")||O.setMatrix("view",u.getViewMatrix()),q||-1===this._options.uniforms.indexOf("projection")||O.setMatrix("projection",u.getProjectionMatrix()),q||-1===this._options.uniforms.indexOf("viewProjection")||(O.setMatrix("viewProjection",u.getTransformMatrix()),this._multiview&&O.setMatrix("viewProjectionR",u._transformMatrixR)),u.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&O.setVector3("cameraPosition",u.activeCamera.globalPosition),(0,B.c)(S,O),(0,C.g)(O,this,u),this._useLogarithmicDepth&&(0,B.j)(M?l.materialDefines:O.defines,O,u),S&&(0,B.g)(u,S,O),this._textures)O.setTexture(m,this._textures[m]);for(m in this._textureArrays)O.setTextureArray(m,this._textureArrays[m]);for(m in this._ints)O.setInt(m,this._ints[m]);for(m in this._uints)O.setUInt(m,this._uints[m]);for(m in this._floats)O.setFloat(m,this._floats[m]);for(m in this._floatsArrays)O.setArray(m,this._floatsArrays[m]);for(m in this._colors3)O.setColor3(m,this._colors3[m]);for(m in this._colors3Arrays)O.setArray3(m,this._colors3Arrays[m]);for(m in this._colors4){const S=this._colors4[m];O.setFloat4(m,S.r,S.g,S.b,S.a)}for(m in this._colors4Arrays)O.setArray4(m,this._colors4Arrays[m]);for(m in this._vectors2)O.setVector2(m,this._vectors2[m]);for(m in this._vectors3)O.setVector3(m,this._vectors3[m]);for(m in this._vectors4)O.setVector4(m,this._vectors4[m]);for(m in this._quaternions)O.setQuaternion(m,this._quaternions[m]);for(m in this._matrices)O.setMatrix(m,this._matrices[m]);for(m in this._matrixArrays)O.setMatrices(m,this._matrixArrays[m]);for(m in this._matrices3x3)O.setMatrix3x3(m,this._matrices3x3[m]);for(m in this._matrices2x2)O.setMatrix2x2(m,this._matrices2x2[m]);for(m in this._vectors2Arrays)O.setArray2(m,this._vectors2Arrays[m]);for(m in this._vectors3Arrays)O.setArray3(m,this._vectors3Arrays[m]);for(m in this._vectors4Arrays)O.setArray4(m,this._vectors4Arrays[m]);for(m in this._quaternionsArrays)O.setArray4(m,this._quaternionsArrays[m]);for(m in this._uniformBuffers){const S=this._uniformBuffers[m].getBuffer();S&&O.bindUniformBuffer(S,m)}const h=u.getEngine(),b=h.setExternalTexture;if(b)for(m in this._externalTextures)b.call(h,m,this._externalTextures[m]);const Y=h.setTextureSampler;if(Y)for(m in this._textureSamplers)Y.call(h,m,this._textureSamplers[m]);const V=h.setStorageBuffer;if(V)for(m in this._storageBuffers)V.call(h,m,this._storageBuffers[m])}if(O&&S&&(Y||!this.isFrozen)){(0,B.n)(S,O),S.morphTargetManager&&S.morphTargetManager.isUsingTextureForTargets&&S.morphTargetManager._bind(O);const m=S.bakedVertexAnimationManager;if(m&&m.isEnabled){var V;const m=M?l._drawWrapper:this._drawWrapper;null===(V=S.bakedVertexAnimationManager)||void 0===V||V.bind(O,!!m._wasPreviouslyUsingInstances)}}this._afterBind(S,O,l)}getActiveTextures(){const m=super.getActiveTextures();for(const S in this._textures)m.push(this._textures[S]);for(const S in this._textureArrays){const h=this._textureArrays[S];for(let S=0;S<h.length;S++)m.push(h[S])}return m}hasTexture(m){if(super.hasTexture(m))return!0;for(const S in this._textures)if(this._textures[S]===m)return!0;for(const S in this._textureArrays){const h=this._textureArrays[S];for(let S=0;S<h.length;S++)if(h[S]===m)return!0}return!1}clone(m){const S=l.e.Clone((()=>new E(m,this.sm(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);S.name=m,S.id=m,"object"===typeof S._shaderPath&&(S._shaderPath={...S._shaderPath}),this._options={...this._options};const h=Object.keys(this._options);for(const l of h){const m=this._options[l];Array.isArray(m)&&(this._options[l]=m.slice(0))}this.stencil.copyTo(S.stencil);for(const l in this._textures)S.setTexture(l,this._textures[l]);for(const l in this._textureArrays)S.setTextureArray(l,this._textureArrays[l]);for(const l in this._externalTextures)S.setExternalTexture(l,this._externalTextures[l]);for(const l in this._ints)S.setInt(l,this._ints[l]);for(const l in this._uints)S.setUInt(l,this._uints[l]);for(const l in this._floats)S.setFloat(l,this._floats[l]);for(const l in this._floatsArrays)S.setFloats(l,this._floatsArrays[l]);for(const l in this._colors3)S.setColor3(l,this._colors3[l]);for(const l in this._colors3Arrays)S._colors3Arrays[l]=this._colors3Arrays[l];for(const l in this._colors4)S.setColor4(l,this._colors4[l]);for(const l in this._colors4Arrays)S._colors4Arrays[l]=this._colors4Arrays[l];for(const l in this._vectors2)S.setVector2(l,this._vectors2[l]);for(const l in this._vectors3)S.setVector3(l,this._vectors3[l]);for(const l in this._vectors4)S.setVector4(l,this._vectors4[l]);for(const l in this._quaternions)S.setQuaternion(l,this._quaternions[l]);for(const l in this._quaternionsArrays)S._quaternionsArrays[l]=this._quaternionsArrays[l];for(const l in this._matrices)S.setMatrix(l,this._matrices[l]);for(const l in this._matrixArrays)S._matrixArrays[l]=this._matrixArrays[l].slice();for(const l in this._matrices3x3)S.setMatrix3x3(l,this._matrices3x3[l]);for(const l in this._matrices2x2)S.setMatrix2x2(l,this._matrices2x2[l]);for(const l in this._vectors2Arrays)S.setArray2(l,this._vectors2Arrays[l]);for(const l in this._vectors3Arrays)S.setArray3(l,this._vectors3Arrays[l]);for(const l in this._vectors4Arrays)S.setArray4(l,this._vectors4Arrays[l]);for(const l in this._uniformBuffers)S.setUniformBuffer(l,this._uniformBuffers[l]);for(const l in this._textureSamplers)S.setTextureSampler(l,this._textureSamplers[l]);for(const l in this._storageBuffers)S.setStorageBuffer(l,this._storageBuffers[l]);return S}dispose(m,S,h){if(S){let m;for(m in this._textures)this._textures[m].dispose();for(m in this._textureArrays){const S=this._textureArrays[m];for(let m=0;m<S.length;m++)S[m].dispose()}}this._textures={},super.dispose(m,S,h)}serialize(){const m=l.e.Serialize(this);let S;for(S in m.customType="BABYLON.ShaderMaterial",m.uniqueId=this.uniqueId,m.options=this._options,m.shaderPath=this._shaderPath,m.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,m.stencil=this.stencil.serialize(),m.textures={},this._textures)m.textures[S]=this._textures[S].serialize();for(S in m.textureArrays={},this._textureArrays){m.textureArrays[S]=[];const h=this._textureArrays[S];for(let l=0;l<h.length;l++)m.textureArrays[S].push(h[l].serialize())}for(S in m.ints={},this._ints)m.ints[S]=this._ints[S];for(S in m.uints={},this._uints)m.uints[S]=this._uints[S];for(S in m.floats={},this._floats)m.floats[S]=this._floats[S];for(S in m.floatsArrays={},this._floatsArrays)m.floatsArrays[S]=this._floatsArrays[S];for(S in m.colors3={},this._colors3){const h=this._colors3[S];m.colors3[S]=[h.r,h.g,h.b]}for(S in m.colors3Arrays={},this._colors3Arrays)m.colors3Arrays[S]=this._colors3Arrays[S];for(S in m.colors4={},this._colors4){const h=this._colors4[S];m.colors4[S]=[h.r,h.g,h.b,h.a]}for(S in m.colors4Arrays={},this._colors4Arrays)m.colors4Arrays[S]=this._colors4Arrays[S];for(S in m.vectors2={},this._vectors2){const h=this._vectors2[S];m.vectors2[S]=[h.x,h.y]}for(S in m.vectors3={},this._vectors3){const h=this._vectors3[S];m.vectors3[S]=[h.x,h.y,h.z]}for(S in m.vectors4={},this._vectors4){const h=this._vectors4[S];m.vectors4[S]=[h.x,h.y,h.z,h.w]}for(S in m.quaternions={},this._quaternions)m.quaternions[S]=this._quaternions[S].DM();for(S in m.matrices={},this._matrices)m.matrices[S]=this._matrices[S].DM();for(S in m.matrixArray={},this._matrixArrays)m.matrixArray[S]=this._matrixArrays[S];for(S in m.matrices3x3={},this._matrices3x3)m.matrices3x3[S]=this._matrices3x3[S];for(S in m.matrices2x2={},this._matrices2x2)m.matrices2x2[S]=this._matrices2x2[S];for(S in m.vectors2Arrays={},this._vectors2Arrays)m.vectors2Arrays[S]=this._vectors2Arrays[S];for(S in m.vectors3Arrays={},this._vectors3Arrays)m.vectors3Arrays[S]=this._vectors3Arrays[S];for(S in m.vectors4Arrays={},this._vectors4Arrays)m.vectors4Arrays[S]=this._vectors4Arrays[S];for(S in m.quaternionsArrays={},this._quaternionsArrays)m.quaternionsArrays[S]=this._quaternionsArrays[S];return m}static Parse(m,S,h){const M=l.e.Parse((()=>new E(m.name,S,m.shaderPath,m.options,m.storeEffectOnSubMeshes)),m,S,h);let u;for(u in m.stencil&&M.stencil.parse(m.stencil,S,h),m.textures)M.setTexture(u,b.e.Parse(m.textures[u],S,h));for(u in m.textureArrays){const l=m.textureArrays[u],O=[];for(let m=0;m<l.length;m++)O.push(b.e.Parse(l[m],S,h));M.setTextureArray(u,O)}for(u in m.ints)M.setInt(u,m.ints[u]);for(u in m.uints)M.setUInt(u,m.uints[u]);for(u in m.floats)M.setFloat(u,m.floats[u]);for(u in m.floatsArrays)M.setFloats(u,m.floatsArrays[u]);for(u in m.colors3){const S=m.colors3[u];M.setColor3(u,{r:S[0],g:S[1],b:S[2]})}for(u in m.colors3Arrays){const S=m.colors3Arrays[u].reduce(((m,S,h)=>(h%3===0?m.push([S]):m[m.length-1].push(S),m)),[]).map((m=>({r:m[0],g:m[1],b:m[2]})));M.setColor3Array(u,S)}for(u in m.colors4){const S=m.colors4[u];M.setColor4(u,{r:S[0],g:S[1],b:S[2],a:S[3]})}for(u in m.colors4Arrays){const S=m.colors4Arrays[u].reduce(((m,S,h)=>(h%4===0?m.push([S]):m[m.length-1].push(S),m)),[]).map((m=>({r:m[0],g:m[1],b:m[2],a:m[3]})));M.setColor4Array(u,S)}for(u in m.vectors2){const S=m.vectors2[u];M.setVector2(u,{x:S[0],y:S[1]})}for(u in m.vectors3){const S=m.vectors3[u];M.setVector3(u,{x:S[0],y:S[1],z:S[2]})}for(u in m.vectors4){const S=m.vectors4[u];M.setVector4(u,{x:S[0],y:S[1],z:S[2],w:S[3]})}for(u in m.quaternions)M.setQuaternion(u,O.Quaternion.yS(m.quaternions[u]));for(u in m.matrices)M.setMatrix(u,O.Matrix.yS(m.matrices[u]));for(u in m.matrixArray)M._matrixArrays[u]=new Float32Array(m.matrixArray[u]);for(u in m.matrices3x3)M.setMatrix3x3(u,m.matrices3x3[u]);for(u in m.matrices2x2)M.setMatrix2x2(u,m.matrices2x2[u]);for(u in m.vectors2Arrays)M.setArray2(u,m.vectors2Arrays[u]);for(u in m.vectors3Arrays)M.setArray3(u,m.vectors3Arrays[u]);for(u in m.vectors4Arrays)M.setArray4(u,m.vectors4Arrays[u]);for(u in m.quaternionsArrays)M.setArray4(u,m.quaternionsArrays[u]);return M}static async ParseFromFileAsync(m,S,h){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((M,O)=>{const u=new V.b;u.addEventListener("readystatechange",(()=>{if(4==u.readyState)if(200==u.status){const S=JSON.parse(u.responseText),O=this.Parse(S,h||Z.d.LastCreatedScene,l);m&&(O.name=m),M(O)}else O("Unable to load the ShaderMaterial")})),u.open("GET",S),u.send()}))}static async ParseFromSnippetAsync(m,S){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((l,M)=>{const O=new V.b;O.addEventListener("readystatechange",(()=>{if(4==O.readyState)if(200==O.status){const M=JSON.parse(JSON.parse(O.responseText).jsonPayload),u=JSON.parse(M.shaderMaterial),b=this.Parse(u,S||Z.d.LastCreatedScene,h);b.snippetId=m,l(b)}else M("Unable to load the snippet "+m)})),O.open("GET",this.SnippetUrl+"/"+m.replace(/#/g,"/")),O.send()}))}}E.SnippetUrl="https://snippet.babylonjs.com",E.CreateFromSnippetAsync=E.ParseFromSnippetAsync,(0,q.e)("BABYLON.ShaderMaterial",E)}}]);