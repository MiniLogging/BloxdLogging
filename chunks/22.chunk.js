"use strict";(self.zjjkhojdx1=self.zjjkhojdx1||[]).push([[22],{11470:(k,h,o)=>{o.r(h),o.d(h,{ShaderMaterial:()=>W});var x=o(11271),I=o(11472),q=o(11239),Y=o(11308),J=o(11223),G=o(11199),l=o(11537),A=o(11112),K=o(11544),a=o(11120),N=o(11602),X=o(11593);const c={effect:null,subMesh:null};class W extends K.d{constructor(k,h,o){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(k,h,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new q.Matrix,this._cachedWorldViewProjectionMatrix=new q.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=o,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...x}}get shaderPath(){return this._shaderPath}set shaderPath(k){this._shaderPath=k}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(k){-1===this._options.uniforms.indexOf(k)&&this._options.uniforms.push(k)}setTexture(k,h){return-1===this._options.samplers.indexOf(k)&&this._options.samplers.push(k),this._textures[k]=h,this}removeTexture(k){delete this._textures[k]}setTextureArray(k,h){return-1===this._options.samplers.indexOf(k)&&this._options.samplers.push(k),this._checkUniform(k),this._textureArrays[k]=h,this}setExternalTexture(k,h){return-1===this._options.externalTextures.indexOf(k)&&this._options.externalTextures.push(k),this._externalTextures[k]=h,this}setFloat(k,h){return this._checkUniform(k),this._floats[k]=h,this}setInt(k,h){return this._checkUniform(k),this._ints[k]=h,this}setUInt(k,h){return this._checkUniform(k),this._uints[k]=h,this}setFloats(k,h){return this._checkUniform(k),this._floatsArrays[k]=h,this}setColor3(k,h){return this._checkUniform(k),this._colors3[k]=h,this}setColor3Array(k,h){return this._checkUniform(k),this._colors3Arrays[k]=h.reduce(((k,h)=>(k.push(h.r,h.g,h.b),k)),[]),this}setColor4(k,h){return this._checkUniform(k),this._colors4[k]=h,this}setColor4Array(k,h){return this._checkUniform(k),this._colors4Arrays[k]=h.reduce(((k,h)=>(k.push(h.r,h.g,h.b,h.a),k)),[]),this}setVector2(k,h){return this._checkUniform(k),this._vectors2[k]=h,this}setVector3(k,h){return this._checkUniform(k),this._vectors3[k]=h,this}setVector4(k,h){return this._checkUniform(k),this._vectors4[k]=h,this}setQuaternion(k,h){return this._checkUniform(k),this._quaternions[k]=h,this}setQuaternionArray(k,h){return this._checkUniform(k),this._quaternionsArrays[k]=h.reduce(((k,h)=>(h.toArray(k,k.length),k)),[]),this}setMatrix(k,h){return this._checkUniform(k),this._matrices[k]=h,this}setMatrices(k,h){this._checkUniform(k);const o=new Float32Array(16*h.length);for(let x=0;x<h.length;x++){h[x].copyToArray(o,16*x)}return this._matrixArrays[k]=o,this}setMatrix3x3(k,h){return this._checkUniform(k),this._matrices3x3[k]=h,this}setMatrix2x2(k,h){return this._checkUniform(k),this._matrices2x2[k]=h,this}setArray2(k,h){return this._checkUniform(k),this._vectors2Arrays[k]=h,this}setArray3(k,h){return this._checkUniform(k),this._vectors3Arrays[k]=h,this}setArray4(k,h){return this._checkUniform(k),this._vectors4Arrays[k]=h,this}setUniformBuffer(k,h){return-1===this._options.uniformBuffers.indexOf(k)&&this._options.uniformBuffers.push(k),this._uniformBuffers[k]=h,this}setTextureSampler(k,h){return-1===this._options.samplerObjects.indexOf(k)&&this._options.samplerObjects.push(k),this._textureSamplers[k]=h,this}setStorageBuffer(k,h){return-1===this._options.storageBuffers.indexOf(k)&&this._options.storageBuffers.push(k),this._storageBuffers[k]=h,this}setDefine(k,h){const o=k.trimEnd()+" ",x=this.options.defines.findIndex((h=>h===k||h.startsWith(o)));return x>=0&&this.options.defines.splice(x,1),("boolean"!==typeof h||h)&&this.options.defines.push(o+h),this}isReadyForSubMesh(k,h,o){return this.isReady(k,o,h)}isReady(k,h,o){var x;const q=o&&this._storeEffectOnSubMeshes;if(this.isFrozen){const k=q?o._drawWrapper:this._drawWrapper;if(k.effect&&k._wasPreviouslyReady&&k._wasPreviouslyUsingInstances===h)return!0}const J=this.ik(),G=J.getEngine(),A=[],K=[];let a=null,W=this._shaderPath,f=this._options.uniforms,M=this._options.uniformBuffers,T=this._options.samplers;G.getCaps().multiview&&J.activeCamera&&J.activeCamera.outputRenderTarget&&J.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,A.push("#define MULTIVIEW"),-1!==f.indexOf("viewProjection")&&-1===f.indexOf("viewProjectionR")&&f.push("viewProjectionR"));for(let I=0;I<this._options.defines.length;I++){const k=0===this._options.defines[I].indexOf("#define")?this._options.defines[I]:`#define ${this._options.defines[I]}`;A.push(k)}for(let I=0;I<this._options.attributes.length;I++)K.push(this._options.attributes[I]);if(k&&k.isVerticesDataPresent(Y.g.ColorKind)&&(-1===K.indexOf(Y.g.ColorKind)&&K.push(Y.g.ColorKind),A.push("#define VERTEXCOLOR")),h&&(A.push("#define INSTANCES"),(0,X.ab)(K,this._materialHelperNeedsPreviousMatrices),null!==k&&void 0!==k&&k.hasThinInstances&&(A.push("#define THIN_INSTANCES"),k&&k.isVerticesDataPresent(Y.g.ColorInstanceKind)&&(K.push(Y.g.ColorInstanceKind),A.push("#define INSTANCESCOLOR")))),k&&k.useBones&&k.computeBonesUsingShaders&&k.skeleton){K.push(Y.g.MatricesIndicesKind),K.push(Y.g.MatricesWeightsKind),k.numBoneInfluencers>4&&(K.push(Y.g.MatricesIndicesExtraKind),K.push(Y.g.MatricesWeightsExtraKind));const h=k.skeleton;A.push("#define NUM_BONE_INFLUENCERS "+k.numBoneInfluencers),a=new l.b,a.addCPUSkinningFallback(0,k),h.isUsingTextureForMatrices?(A.push("#define BONETEXTURE"),-1===f.indexOf("boneTextureWidth")&&f.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(A.push("#define BonesPerMesh "+(h.bones.length+1)),-1===f.indexOf("mBones")&&f.push("mBones"))}else A.push("#define NUM_BONE_INFLUENCERS 0");let j=0;const d=k?k.morphTargetManager:null;if(d){const h=-1!==A.indexOf("#define UV1"),o=-1!==A.indexOf("#define UV2"),x=-1!==A.indexOf("#define TANGENT"),I=-1!==A.indexOf("#define NORMAL"),q=-1!==A.indexOf("#define VERTEXCOLOR");j=(0,X.F)(d,A,K,k,!0,I,x,h,o,q),d.isUsingTextureForTargets&&(-1===f.indexOf("morphTargetTextureIndices")&&f.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),j>0&&(f=f.slice(),f.push("morphTargetInfluences"),f.push("morphTargetCount"),f.push("morphTargetTextureInfo"),f.push("morphTargetTextureIndices"))}else A.push("#define NUM_MORPH_INFLUENCERS 0");if(k){const h=k.bakedVertexAnimationManager;h&&h.isEnabled&&(A.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===f.indexOf("bakedVertexAnimationSettings")&&f.push("bakedVertexAnimationSettings"),-1===f.indexOf("bakedVertexAnimationTextureSizeInverted")&&f.push("bakedVertexAnimationTextureSizeInverted"),-1===f.indexOf("bakedVertexAnimationTime")&&f.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,X.t)(K,k,A)}for(const I in this._textures)if(!this._textures[I].isReady())return!1;k&&this.needAlphaTestingForMesh(k)&&A.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,N.c)(f),(0,N.n)(this,J,A)),J.fogEnabled&&null!==k&&void 0!==k&&k.applyFog&&J.fogMode!==I.e.FOGMODE_NONE&&(A.push("#define FOG"),-1===f.indexOf("view")&&f.push("view"),-1===f.indexOf("vFogInfos")&&f.push("vFogInfos"),-1===f.indexOf("vFogColor")&&f.push("vFogColor")),this._useLogarithmicDepth&&(A.push("#define LOGARITHMICDEPTH"),-1===f.indexOf("logarithmicDepthConstant")&&f.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(f=f.slice(),M=M.slice(),T=T.slice(),W=this.customShaderNameResolve(this.name,f,M,T,A,K));const b=q?o._getDrawWrapper(void 0,!0):this._drawWrapper,V=(null===b||void 0===b?void 0:b.effect)??null,i=(null===b||void 0===b?void 0:b.defines)??null,F=A.join("\n");let R=V;return i!==F&&(R=G.createEffect(W,{attributes:K,uniformsNames:f,uniformBuffersNames:M,samplers:T,defines:F,fallbacks:a,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:j},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},G),q?o.setEffect(R,F,this._materialContext):b&&b.setEffect(R,F),this._onEffectCreatedObservable&&(c.effect=R,c.subMesh=o??(null===k||void 0===k?void 0:k.Oh[0])??null,this._onEffectCreatedObservable.notifyObservers(c))),b._wasPreviouslyUsingInstances=!!h,!(null===(x=R)||void 0===x||!x.isReady())&&(V!==R&&J.resetCachedMaterial(),b._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(k,h){const o=h??this.getEffect();if(!o)return;const x=this._options.uniforms;-1!==x.indexOf("world")&&o.setMatrix("world",k);const I=this.ik();-1!==x.indexOf("worldView")&&(k.multiplyToRef(I.getViewMatrix(),this._cachedWorldViewMatrix),o.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==x.indexOf("worldViewProjection")&&(k.multiplyToRef(I.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),o.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==x.indexOf("view")&&o.setMatrix("view",I.getViewMatrix())}bindForSubMesh(k,h,o){var x;this.bind(k,h,null===(x=o._drawWrapperOverride)||void 0===x?void 0:x.effect,o)}bind(k,h,o,x){const I=x&&this._storeEffectOnSubMeshes,q=o??(I?x.effect:this.getEffect());if(!q)return;const Y=this.ik();this._activeEffect=q,this.bindOnlyWorldMatrix(k,o);const J=this._options.uniformBuffers;let G=!1;if(q&&J&&J.length>0&&Y.getEngine().supportsUniformBuffers)for(let K=0;K<J.length;++K){switch(J[K]){case"Mesh":h&&(h.getMeshUniformBuffer().bindToEffect(q,"Mesh"),h.transferToEffect(k));break;case"Scene":(0,X.l)(q,Y.getSceneUniformBuffer()),Y.finalizeSceneUbo(),G=!0}}const l=h&&I?this._mustRebind(Y,q,x,h.visibility):Y.getCachedMaterial()!==this;if(q&&l){let k;for(k in G||-1===this._options.uniforms.indexOf("view")||q.setMatrix("view",Y.getViewMatrix()),G||-1===this._options.uniforms.indexOf("projection")||q.setMatrix("projection",Y.getProjectionMatrix()),G||-1===this._options.uniforms.indexOf("viewProjection")||(q.setMatrix("viewProjection",Y.getTransformMatrix()),this._multiview&&q.setMatrix("viewProjectionR",Y._transformMatrixR)),Y.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&q.setVector3("cameraPosition",Y.activeCamera.globalPosition),(0,X.e)(h,q),(0,N.g)(q,this,Y),this._useLogarithmicDepth&&(0,X.j)(I?x.materialDefines:q.defines,q,Y),h&&(0,X.f)(Y,h,q),this._textures)q.setTexture(k,this._textures[k]);for(k in this._textureArrays)q.setTextureArray(k,this._textureArrays[k]);for(k in this._ints)q.setInt(k,this._ints[k]);for(k in this._uints)q.setUInt(k,this._uints[k]);for(k in this._floats)q.setFloat(k,this._floats[k]);for(k in this._floatsArrays)q.setArray(k,this._floatsArrays[k]);for(k in this._colors3)q.setColor3(k,this._colors3[k]);for(k in this._colors3Arrays)q.setArray3(k,this._colors3Arrays[k]);for(k in this._colors4){const h=this._colors4[k];q.setFloat4(k,h.r,h.g,h.b,h.a)}for(k in this._colors4Arrays)q.setArray4(k,this._colors4Arrays[k]);for(k in this._vectors2)q.setVector2(k,this._vectors2[k]);for(k in this._vectors3)q.setVector3(k,this._vectors3[k]);for(k in this._vectors4)q.setVector4(k,this._vectors4[k]);for(k in this._quaternions)q.setQuaternion(k,this._quaternions[k]);for(k in this._matrices)q.setMatrix(k,this._matrices[k]);for(k in this._matrixArrays)q.setMatrices(k,this._matrixArrays[k]);for(k in this._matrices3x3)q.setMatrix3x3(k,this._matrices3x3[k]);for(k in this._matrices2x2)q.setMatrix2x2(k,this._matrices2x2[k]);for(k in this._vectors2Arrays)q.setArray2(k,this._vectors2Arrays[k]);for(k in this._vectors3Arrays)q.setArray3(k,this._vectors3Arrays[k]);for(k in this._vectors4Arrays)q.setArray4(k,this._vectors4Arrays[k]);for(k in this._quaternionsArrays)q.setArray4(k,this._quaternionsArrays[k]);for(k in this._uniformBuffers){const h=this._uniformBuffers[k].getBuffer();h&&q.bindUniformBuffer(h,k)}const o=Y.getEngine(),J=o.setExternalTexture;if(J)for(k in this._externalTextures)J.call(o,k,this._externalTextures[k]);const l=o.setTextureSampler;if(l)for(k in this._textureSamplers)l.call(o,k,this._textureSamplers[k]);const A=o.setStorageBuffer;if(A)for(k in this._storageBuffers)A.call(o,k,this._storageBuffers[k])}if(q&&h&&(l||!this.isFrozen)){(0,X.k)(h,q),h.morphTargetManager&&h.morphTargetManager.isUsingTextureForTargets&&h.morphTargetManager._bind(q);const k=h.bakedVertexAnimationManager;if(k&&k.isEnabled){var A;const k=I?x._drawWrapper:this._drawWrapper;null===(A=h.bakedVertexAnimationManager)||void 0===A||A.bind(q,!!k._wasPreviouslyUsingInstances)}}this._afterBind(h,q,x)}getActiveTextures(){const k=super.getActiveTextures();for(const h in this._textures)k.push(this._textures[h]);for(const h in this._textureArrays){const o=this._textureArrays[h];for(let h=0;h<o.length;h++)k.push(o[h])}return k}hasTexture(k){if(super.hasTexture(k))return!0;for(const h in this._textures)if(this._textures[h]===k)return!0;for(const h in this._textureArrays){const o=this._textureArrays[h];for(let h=0;h<o.length;h++)if(o[h]===k)return!0}return!1}clone(k){const h=x.c.Clone((()=>new W(k,this.ik(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);h.name=k,h.id=k,"object"===typeof h._shaderPath&&(h._shaderPath={...h._shaderPath}),this._options={...this._options};const o=Object.keys(this._options);for(const x of o){const k=this._options[x];Array.isArray(k)&&(this._options[x]=k.slice(0))}this.stencil.copyTo(h.stencil);for(const x in this._textures)h.setTexture(x,this._textures[x]);for(const x in this._textureArrays)h.setTextureArray(x,this._textureArrays[x]);for(const x in this._externalTextures)h.setExternalTexture(x,this._externalTextures[x]);for(const x in this._ints)h.setInt(x,this._ints[x]);for(const x in this._uints)h.setUInt(x,this._uints[x]);for(const x in this._floats)h.setFloat(x,this._floats[x]);for(const x in this._floatsArrays)h.setFloats(x,this._floatsArrays[x]);for(const x in this._colors3)h.setColor3(x,this._colors3[x]);for(const x in this._colors3Arrays)h._colors3Arrays[x]=this._colors3Arrays[x];for(const x in this._colors4)h.setColor4(x,this._colors4[x]);for(const x in this._colors4Arrays)h._colors4Arrays[x]=this._colors4Arrays[x];for(const x in this._vectors2)h.setVector2(x,this._vectors2[x]);for(const x in this._vectors3)h.setVector3(x,this._vectors3[x]);for(const x in this._vectors4)h.setVector4(x,this._vectors4[x]);for(const x in this._quaternions)h.setQuaternion(x,this._quaternions[x]);for(const x in this._quaternionsArrays)h._quaternionsArrays[x]=this._quaternionsArrays[x];for(const x in this._matrices)h.setMatrix(x,this._matrices[x]);for(const x in this._matrixArrays)h._matrixArrays[x]=this._matrixArrays[x].slice();for(const x in this._matrices3x3)h.setMatrix3x3(x,this._matrices3x3[x]);for(const x in this._matrices2x2)h.setMatrix2x2(x,this._matrices2x2[x]);for(const x in this._vectors2Arrays)h.setArray2(x,this._vectors2Arrays[x]);for(const x in this._vectors3Arrays)h.setArray3(x,this._vectors3Arrays[x]);for(const x in this._vectors4Arrays)h.setArray4(x,this._vectors4Arrays[x]);for(const x in this._uniformBuffers)h.setUniformBuffer(x,this._uniformBuffers[x]);for(const x in this._textureSamplers)h.setTextureSampler(x,this._textureSamplers[x]);for(const x in this._storageBuffers)h.setStorageBuffer(x,this._storageBuffers[x]);return h}dispose(k,h,o){if(h){let k;for(k in this._textures)this._textures[k].dispose();for(k in this._textureArrays){const h=this._textureArrays[k];for(let k=0;k<h.length;k++)h[k].dispose()}}this._textures={},super.dispose(k,h,o)}serialize(){const k=x.c.Serialize(this);let h;for(h in k.customType="BABYLON.ShaderMaterial",k.uniqueId=this.uniqueId,k.options=this._options,k.shaderPath=this._shaderPath,k.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,k.stencil=this.stencil.serialize(),k.textures={},this._textures)k.textures[h]=this._textures[h].serialize();for(h in k.textureArrays={},this._textureArrays){k.textureArrays[h]=[];const o=this._textureArrays[h];for(let x=0;x<o.length;x++)k.textureArrays[h].push(o[x].serialize())}for(h in k.ints={},this._ints)k.ints[h]=this._ints[h];for(h in k.uints={},this._uints)k.uints[h]=this._uints[h];for(h in k.floats={},this._floats)k.floats[h]=this._floats[h];for(h in k.floatsArrays={},this._floatsArrays)k.floatsArrays[h]=this._floatsArrays[h];for(h in k.colors3={},this._colors3){const o=this._colors3[h];k.colors3[h]=[o.r,o.g,o.b]}for(h in k.colors3Arrays={},this._colors3Arrays)k.colors3Arrays[h]=this._colors3Arrays[h];for(h in k.colors4={},this._colors4){const o=this._colors4[h];k.colors4[h]=[o.r,o.g,o.b,o.a]}for(h in k.colors4Arrays={},this._colors4Arrays)k.colors4Arrays[h]=this._colors4Arrays[h];for(h in k.vectors2={},this._vectors2){const o=this._vectors2[h];k.vectors2[h]=[o.x,o.y]}for(h in k.vectors3={},this._vectors3){const o=this._vectors3[h];k.vectors3[h]=[o.x,o.y,o.z]}for(h in k.vectors4={},this._vectors4){const o=this._vectors4[h];k.vectors4[h]=[o.x,o.y,o.z,o.w]}for(h in k.quaternions={},this._quaternions)k.quaternions[h]=this._quaternions[h].rh();for(h in k.matrices={},this._matrices)k.matrices[h]=this._matrices[h].rh();for(h in k.matrixArray={},this._matrixArrays)k.matrixArray[h]=this._matrixArrays[h];for(h in k.matrices3x3={},this._matrices3x3)k.matrices3x3[h]=this._matrices3x3[h];for(h in k.matrices2x2={},this._matrices2x2)k.matrices2x2[h]=this._matrices2x2[h];for(h in k.vectors2Arrays={},this._vectors2Arrays)k.vectors2Arrays[h]=this._vectors2Arrays[h];for(h in k.vectors3Arrays={},this._vectors3Arrays)k.vectors3Arrays[h]=this._vectors3Arrays[h];for(h in k.vectors4Arrays={},this._vectors4Arrays)k.vectors4Arrays[h]=this._vectors4Arrays[h];for(h in k.quaternionsArrays={},this._quaternionsArrays)k.quaternionsArrays[h]=this._quaternionsArrays[h];return k}static Parse(k,h,o){const I=x.c.Parse((()=>new W(k.name,h,k.shaderPath,k.options,k.storeEffectOnSubMeshes)),k,h,o);let Y;for(Y in k.stencil&&I.stencil.parse(k.stencil,h,o),k.textures)I.setTexture(Y,J.b.Parse(k.textures[Y],h,o));for(Y in k.textureArrays){const x=k.textureArrays[Y],q=[];for(let k=0;k<x.length;k++)q.push(J.b.Parse(x[k],h,o));I.setTextureArray(Y,q)}for(Y in k.ints)I.setInt(Y,k.ints[Y]);for(Y in k.uints)I.setUInt(Y,k.uints[Y]);for(Y in k.floats)I.setFloat(Y,k.floats[Y]);for(Y in k.floatsArrays)I.setFloats(Y,k.floatsArrays[Y]);for(Y in k.colors3){const h=k.colors3[Y];I.setColor3(Y,{r:h[0],g:h[1],b:h[2]})}for(Y in k.colors3Arrays){const h=k.colors3Arrays[Y].reduce(((k,h,o)=>(o%3===0?k.push([h]):k[k.length-1].push(h),k)),[]).map((k=>({r:k[0],g:k[1],b:k[2]})));I.setColor3Array(Y,h)}for(Y in k.colors4){const h=k.colors4[Y];I.setColor4(Y,{r:h[0],g:h[1],b:h[2],a:h[3]})}for(Y in k.colors4Arrays){const h=k.colors4Arrays[Y].reduce(((k,h,o)=>(o%4===0?k.push([h]):k[k.length-1].push(h),k)),[]).map((k=>({r:k[0],g:k[1],b:k[2],a:k[3]})));I.setColor4Array(Y,h)}for(Y in k.vectors2){const h=k.vectors2[Y];I.setVector2(Y,{x:h[0],y:h[1]})}for(Y in k.vectors3){const h=k.vectors3[Y];I.setVector3(Y,{x:h[0],y:h[1],z:h[2]})}for(Y in k.vectors4){const h=k.vectors4[Y];I.setVector4(Y,{x:h[0],y:h[1],z:h[2],w:h[3]})}for(Y in k.quaternions)I.setQuaternion(Y,q.Quaternion.Uh(k.quaternions[Y]));for(Y in k.matrices)I.setMatrix(Y,q.Matrix.Uh(k.matrices[Y]));for(Y in k.matrixArray)I._matrixArrays[Y]=new Float32Array(k.matrixArray[Y]);for(Y in k.matrices3x3)I.setMatrix3x3(Y,k.matrices3x3[Y]);for(Y in k.matrices2x2)I.setMatrix2x2(Y,k.matrices2x2[Y]);for(Y in k.vectors2Arrays)I.setArray2(Y,k.vectors2Arrays[Y]);for(Y in k.vectors3Arrays)I.setArray3(Y,k.vectors3Arrays[Y]);for(Y in k.vectors4Arrays)I.setArray4(Y,k.vectors4Arrays[Y]);for(Y in k.quaternionsArrays)I.setArray4(Y,k.quaternionsArrays[Y]);return I}static async ParseFromFileAsync(k,h,o){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((I,q)=>{const Y=new A.e;Y.addEventListener("readystatechange",(()=>{if(4==Y.readyState)if(200==Y.status){const h=JSON.parse(Y.responseText),q=this.Parse(h,o||a.b.LastCreatedScene,x);k&&(q.name=k),I(q)}else q("Unable to load the ShaderMaterial")})),Y.open("GET",h),Y.send()}))}static async ParseFromSnippetAsync(k,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((x,I)=>{const q=new A.e;q.addEventListener("readystatechange",(()=>{if(4==q.readyState)if(200==q.status){const I=JSON.parse(JSON.parse(q.responseText).jsonPayload),Y=JSON.parse(I.shaderMaterial),J=this.Parse(Y,h||a.b.LastCreatedScene,o);J.snippetId=k,x(J)}else I("Unable to load the snippet "+k)})),q.open("GET",this.SnippetUrl+"/"+k.replace(/#/g,"/")),q.send()}))}}W.SnippetUrl="https://snippet.babylonjs.com",W.CreateFromSnippetAsync=W.ParseFromSnippetAsync,(0,G.g)("BABYLON.ShaderMaterial",W)}}]);