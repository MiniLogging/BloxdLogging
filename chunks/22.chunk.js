"use strict";(self.mo7o6813fhb=self.mo7o6813fhb||[]).push([[22],{12647:(t,U,y)=>{y.r(U),y.d(U,{ShaderMaterial:()=>w});var I=y(12426),r=y(12653),Y=y(12386),mt=y(12480),X=y(12361),P=y(12338),G=y(12731),M=y(12248),L=y(12737),h=y(12250),Q=y(12788),F=y(12785);const E={effect:null,subMesh:null};class w extends L.e{constructor(t,U,y){let I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(t,U,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new Y.Matrix,this._cachedWorldViewProjectionMatrix=new Y.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=y,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...I}}get shaderPath(){return this._shaderPath}set shaderPath(t){this._shaderPath=t}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(t){-1===this._options.uniforms.indexOf(t)&&this._options.uniforms.push(t)}setTexture(t,U){return-1===this._options.samplers.indexOf(t)&&this._options.samplers.push(t),this._textures[t]=U,this}removeTexture(t){delete this._textures[t]}setTextureArray(t,U){return-1===this._options.samplers.indexOf(t)&&this._options.samplers.push(t),this._checkUniform(t),this._textureArrays[t]=U,this}setExternalTexture(t,U){return-1===this._options.externalTextures.indexOf(t)&&this._options.externalTextures.push(t),this._externalTextures[t]=U,this}setFloat(t,U){return this._checkUniform(t),this._floats[t]=U,this}setInt(t,U){return this._checkUniform(t),this._ints[t]=U,this}setUInt(t,U){return this._checkUniform(t),this._uints[t]=U,this}setFloats(t,U){return this._checkUniform(t),this._floatsArrays[t]=U,this}setColor3(t,U){return this._checkUniform(t),this._colors3[t]=U,this}setColor3Array(t,U){return this._checkUniform(t),this._colors3Arrays[t]=U.reduce(((t,U)=>(t.push(U.r,U.g,U.b),t)),[]),this}setColor4(t,U){return this._checkUniform(t),this._colors4[t]=U,this}setColor4Array(t,U){return this._checkUniform(t),this._colors4Arrays[t]=U.reduce(((t,U)=>(t.push(U.r,U.g,U.b,U.a),t)),[]),this}setVector2(t,U){return this._checkUniform(t),this._vectors2[t]=U,this}setVector3(t,U){return this._checkUniform(t),this._vectors3[t]=U,this}setVector4(t,U){return this._checkUniform(t),this._vectors4[t]=U,this}setQuaternion(t,U){return this._checkUniform(t),this._quaternions[t]=U,this}setQuaternionArray(t,U){return this._checkUniform(t),this._quaternionsArrays[t]=U.reduce(((t,U)=>(U.toArray(t,t.length),t)),[]),this}setMatrix(t,U){return this._checkUniform(t),this._matrices[t]=U,this}setMatrices(t,U){this._checkUniform(t);const y=new Float32Array(16*U.length);for(let I=0;I<U.length;I++){U[I].copyToArray(y,16*I)}return this._matrixArrays[t]=y,this}setMatrix3x3(t,U){return this._checkUniform(t),this._matrices3x3[t]=U,this}setMatrix2x2(t,U){return this._checkUniform(t),this._matrices2x2[t]=U,this}setArray2(t,U){return this._checkUniform(t),this._vectors2Arrays[t]=U,this}setArray3(t,U){return this._checkUniform(t),this._vectors3Arrays[t]=U,this}setArray4(t,U){return this._checkUniform(t),this._vectors4Arrays[t]=U,this}setUniformBuffer(t,U){return-1===this._options.uniformBuffers.indexOf(t)&&this._options.uniformBuffers.push(t),this._uniformBuffers[t]=U,this}setTextureSampler(t,U){return-1===this._options.samplerObjects.indexOf(t)&&this._options.samplerObjects.push(t),this._textureSamplers[t]=U,this}setStorageBuffer(t,U){return-1===this._options.storageBuffers.indexOf(t)&&this._options.storageBuffers.push(t),this._storageBuffers[t]=U,this}setDefine(t,U){const y=t.trimEnd()+" ",I=this.options.defines.findIndex((U=>U===t||U.startsWith(y)));return I>=0&&this.options.defines.splice(I,1),("boolean"!==typeof U||U)&&this.options.defines.push(y+U),this}isReadyForSubMesh(t,U,y){return this.isReady(t,y,U)}isReady(t,U,y){var I;const Y=y&&this._storeEffectOnSubMeshes;if(this.isFrozen){const t=Y?y._drawWrapper:this._drawWrapper;if(t.effect&&t._wasPreviouslyReady&&t._wasPreviouslyUsingInstances===U)return!0}const X=this.St(),P=X.getEngine(),M=[],L=[];let h=null,w=this._shaderPath,D=this._options.uniforms,l=this._options.uniformBuffers,g=this._options.samplers;P.getCaps().multiview&&X.activeCamera&&X.activeCamera.outputRenderTarget&&X.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,M.push("#define MULTIVIEW"),-1!==D.indexOf("viewProjection")&&-1===D.indexOf("viewProjectionR")&&D.push("viewProjectionR"));for(let r=0;r<this._options.defines.length;r++){const t=0===this._options.defines[r].indexOf("#define")?this._options.defines[r]:`#define ${this._options.defines[r]}`;M.push(t)}for(let r=0;r<this._options.attributes.length;r++)L.push(this._options.attributes[r]);if(t&&t.isVerticesDataPresent(mt.e.ColorKind)&&(-1===L.indexOf(mt.e.ColorKind)&&L.push(mt.e.ColorKind),M.push("#define VERTEXCOLOR")),U&&(M.push("#define INSTANCES"),(0,F._)(L,this._materialHelperNeedsPreviousMatrices),null!==t&&void 0!==t&&t.hasThinInstances&&(M.push("#define THIN_INSTANCES"),t&&t.isVerticesDataPresent(mt.e.ColorInstanceKind)&&(L.push(mt.e.ColorInstanceKind),M.push("#define INSTANCESCOLOR")))),t&&t.useBones&&t.computeBonesUsingShaders&&t.skeleton){L.push(mt.e.MatricesIndicesKind),L.push(mt.e.MatricesWeightsKind),t.numBoneInfluencers>4&&(L.push(mt.e.MatricesIndicesExtraKind),L.push(mt.e.MatricesWeightsExtraKind));const U=t.skeleton;M.push("#define NUM_BONE_INFLUENCERS "+t.numBoneInfluencers),h=new G.b,h.addCPUSkinningFallback(0,t),U.isUsingTextureForMatrices?(M.push("#define BONETEXTURE"),-1===D.indexOf("boneTextureWidth")&&D.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(M.push("#define BonesPerMesh "+(U.bones.length+1)),-1===D.indexOf("mBones")&&D.push("mBones"))}else M.push("#define NUM_BONE_INFLUENCERS 0");let B=0;const b=t?t.morphTargetManager:null;if(b){const U=-1!==M.indexOf("#define UV1"),y=-1!==M.indexOf("#define UV2"),I=-1!==M.indexOf("#define TANGENT"),r=-1!==M.indexOf("#define NORMAL"),Y=-1!==M.indexOf("#define VERTEXCOLOR");B=(0,F.F)(b,M,L,t,!0,r,I,U,y,Y),b.isUsingTextureForTargets&&(-1===D.indexOf("morphTargetTextureIndices")&&D.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),B>0&&(D=D.slice(),D.push("morphTargetInfluences"),D.push("morphTargetCount"),D.push("morphTargetTextureInfo"),D.push("morphTargetTextureIndices"))}else M.push("#define NUM_MORPH_INFLUENCERS 0");if(t){const U=t.bakedVertexAnimationManager;U&&U.isEnabled&&(M.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===D.indexOf("bakedVertexAnimationSettings")&&D.push("bakedVertexAnimationSettings"),-1===D.indexOf("bakedVertexAnimationTextureSizeInverted")&&D.push("bakedVertexAnimationTextureSizeInverted"),-1===D.indexOf("bakedVertexAnimationTime")&&D.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,F.u)(L,t,M)}for(const r in this._textures)if(!this._textures[r].isReady())return!1;t&&this.needAlphaTestingForMesh(t)&&M.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,Q.d)(D),(0,Q.k)(this,X,M)),X.fogEnabled&&null!==t&&void 0!==t&&t.applyFog&&X.fogMode!==r.e.FOGMODE_NONE&&(M.push("#define FOG"),-1===D.indexOf("view")&&D.push("view"),-1===D.indexOf("vFogInfos")&&D.push("vFogInfos"),-1===D.indexOf("vFogColor")&&D.push("vFogColor")),this._useLogarithmicDepth&&(M.push("#define LOGARITHMICDEPTH"),-1===D.indexOf("logarithmicDepthConstant")&&D.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(D=D.slice(),l=l.slice(),g=g.slice(),w=this.customShaderNameResolve(this.name,D,l,g,M,L));const p=Y?y._getDrawWrapper(void 0,!0):this._drawWrapper,c=(null===p||void 0===p?void 0:p.effect)??null,f=(null===p||void 0===p?void 0:p.defines)??null,S=M.join("\n");let N=c;return f!==S&&(N=P.createEffect(w,{attributes:L,uniformsNames:D,uniformBuffersNames:l,samplers:g,defines:S,fallbacks:h,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:B},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},P),Y?y.setEffect(N,S,this._materialContext):p&&p.setEffect(N,S),this._onEffectCreatedObservable&&(E.effect=N,E.subMesh=y??(null===t||void 0===t?void 0:t.BX[0])??null,this._onEffectCreatedObservable.notifyObservers(E))),p._wasPreviouslyUsingInstances=!!U,!(null===(I=N)||void 0===I||!I.isReady())&&(c!==N&&X.resetCachedMaterial(),p._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(t,U){const y=U??this.getEffect();if(!y)return;const I=this._options.uniforms;-1!==I.indexOf("world")&&y.setMatrix("world",t);const r=this.St();-1!==I.indexOf("worldView")&&(t.multiplyToRef(r.getViewMatrix(),this._cachedWorldViewMatrix),y.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==I.indexOf("worldViewProjection")&&(t.multiplyToRef(r.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),y.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==I.indexOf("view")&&y.setMatrix("view",r.getViewMatrix())}bindForSubMesh(t,U,y){var I;this.bind(t,U,null===(I=y._drawWrapperOverride)||void 0===I?void 0:I.effect,y)}bind(t,U,y,I){const r=I&&this._storeEffectOnSubMeshes,Y=y??(r?I.effect:this.getEffect());if(!Y)return;const mt=this.St();this._activeEffect=Y,this.bindOnlyWorldMatrix(t,y);const X=this._options.uniformBuffers;let P=!1;if(Y&&X&&X.length>0&&mt.getEngine().supportsUniformBuffers)for(let L=0;L<X.length;++L){switch(X[L]){case"Mesh":U&&(U.getMeshUniformBuffer().bindToEffect(Y,"Mesh"),U.transferToEffect(t));break;case"Scene":(0,F.l)(Y,mt.getSceneUniformBuffer()),mt.finalizeSceneUbo(),P=!0}}const G=U&&r?this._mustRebind(mt,Y,I,U.visibility):mt.getCachedMaterial()!==this;if(Y&&G){let t;for(t in P||-1===this._options.uniforms.indexOf("view")||Y.setMatrix("view",mt.getViewMatrix()),P||-1===this._options.uniforms.indexOf("projection")||Y.setMatrix("projection",mt.getProjectionMatrix()),P||-1===this._options.uniforms.indexOf("viewProjection")||(Y.setMatrix("viewProjection",mt.getTransformMatrix()),this._multiview&&Y.setMatrix("viewProjectionR",mt._transformMatrixR)),mt.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&Y.setVector3("cameraPosition",mt.activeCamera.globalPosition),(0,F.c)(U,Y),(0,Q.e)(Y,this,mt),this._useLogarithmicDepth&&(0,F.h)(r?I.materialDefines:Y.defines,Y,mt),U&&(0,F.e)(mt,U,Y),this._textures)Y.setTexture(t,this._textures[t]);for(t in this._textureArrays)Y.setTextureArray(t,this._textureArrays[t]);for(t in this._ints)Y.setInt(t,this._ints[t]);for(t in this._uints)Y.setUInt(t,this._uints[t]);for(t in this._floats)Y.setFloat(t,this._floats[t]);for(t in this._floatsArrays)Y.setArray(t,this._floatsArrays[t]);for(t in this._colors3)Y.setColor3(t,this._colors3[t]);for(t in this._colors3Arrays)Y.setArray3(t,this._colors3Arrays[t]);for(t in this._colors4){const U=this._colors4[t];Y.setFloat4(t,U.r,U.g,U.b,U.a)}for(t in this._colors4Arrays)Y.setArray4(t,this._colors4Arrays[t]);for(t in this._vectors2)Y.setVector2(t,this._vectors2[t]);for(t in this._vectors3)Y.setVector3(t,this._vectors3[t]);for(t in this._vectors4)Y.setVector4(t,this._vectors4[t]);for(t in this._quaternions)Y.setQuaternion(t,this._quaternions[t]);for(t in this._matrices)Y.setMatrix(t,this._matrices[t]);for(t in this._matrixArrays)Y.setMatrices(t,this._matrixArrays[t]);for(t in this._matrices3x3)Y.setMatrix3x3(t,this._matrices3x3[t]);for(t in this._matrices2x2)Y.setMatrix2x2(t,this._matrices2x2[t]);for(t in this._vectors2Arrays)Y.setArray2(t,this._vectors2Arrays[t]);for(t in this._vectors3Arrays)Y.setArray3(t,this._vectors3Arrays[t]);for(t in this._vectors4Arrays)Y.setArray4(t,this._vectors4Arrays[t]);for(t in this._quaternionsArrays)Y.setArray4(t,this._quaternionsArrays[t]);for(t in this._uniformBuffers){const U=this._uniformBuffers[t].getBuffer();U&&Y.bindUniformBuffer(U,t)}const y=mt.getEngine(),X=y.setExternalTexture;if(X)for(t in this._externalTextures)X.call(y,t,this._externalTextures[t]);const G=y.setTextureSampler;if(G)for(t in this._textureSamplers)G.call(y,t,this._textureSamplers[t]);const M=y.setStorageBuffer;if(M)for(t in this._storageBuffers)M.call(y,t,this._storageBuffers[t])}if(Y&&U&&(G||!this.isFrozen)){(0,F.k)(U,Y),U.morphTargetManager&&U.morphTargetManager.isUsingTextureForTargets&&U.morphTargetManager._bind(Y);const t=U.bakedVertexAnimationManager;if(t&&t.isEnabled){var M;const t=r?I._drawWrapper:this._drawWrapper;null===(M=U.bakedVertexAnimationManager)||void 0===M||M.bind(Y,!!t._wasPreviouslyUsingInstances)}}this._afterBind(U,Y,I)}getActiveTextures(){const t=super.getActiveTextures();for(const U in this._textures)t.push(this._textures[U]);for(const U in this._textureArrays){const y=this._textureArrays[U];for(let U=0;U<y.length;U++)t.push(y[U])}return t}hasTexture(t){if(super.hasTexture(t))return!0;for(const U in this._textures)if(this._textures[U]===t)return!0;for(const U in this._textureArrays){const y=this._textureArrays[U];for(let U=0;U<y.length;U++)if(y[U]===t)return!0}return!1}clone(t){const U=I.b.Clone((()=>new w(t,this.St(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);U.name=t,U.id=t,"object"===typeof U._shaderPath&&(U._shaderPath={...U._shaderPath}),this._options={...this._options};const y=Object.keys(this._options);for(const I of y){const t=this._options[I];Array.isArray(t)&&(this._options[I]=t.slice(0))}this.EX.copyTo(U.EX);for(const I in this._textures)U.setTexture(I,this._textures[I]);for(const I in this._textureArrays)U.setTextureArray(I,this._textureArrays[I]);for(const I in this._externalTextures)U.setExternalTexture(I,this._externalTextures[I]);for(const I in this._ints)U.setInt(I,this._ints[I]);for(const I in this._uints)U.setUInt(I,this._uints[I]);for(const I in this._floats)U.setFloat(I,this._floats[I]);for(const I in this._floatsArrays)U.setFloats(I,this._floatsArrays[I]);for(const I in this._colors3)U.setColor3(I,this._colors3[I]);for(const I in this._colors3Arrays)U._colors3Arrays[I]=this._colors3Arrays[I];for(const I in this._colors4)U.setColor4(I,this._colors4[I]);for(const I in this._colors4Arrays)U._colors4Arrays[I]=this._colors4Arrays[I];for(const I in this._vectors2)U.setVector2(I,this._vectors2[I]);for(const I in this._vectors3)U.setVector3(I,this._vectors3[I]);for(const I in this._vectors4)U.setVector4(I,this._vectors4[I]);for(const I in this._quaternions)U.setQuaternion(I,this._quaternions[I]);for(const I in this._quaternionsArrays)U._quaternionsArrays[I]=this._quaternionsArrays[I];for(const I in this._matrices)U.setMatrix(I,this._matrices[I]);for(const I in this._matrixArrays)U._matrixArrays[I]=this._matrixArrays[I].slice();for(const I in this._matrices3x3)U.setMatrix3x3(I,this._matrices3x3[I]);for(const I in this._matrices2x2)U.setMatrix2x2(I,this._matrices2x2[I]);for(const I in this._vectors2Arrays)U.setArray2(I,this._vectors2Arrays[I]);for(const I in this._vectors3Arrays)U.setArray3(I,this._vectors3Arrays[I]);for(const I in this._vectors4Arrays)U.setArray4(I,this._vectors4Arrays[I]);for(const I in this._uniformBuffers)U.setUniformBuffer(I,this._uniformBuffers[I]);for(const I in this._textureSamplers)U.setTextureSampler(I,this._textureSamplers[I]);for(const I in this._storageBuffers)U.setStorageBuffer(I,this._storageBuffers[I]);return U}dispose(t,U,y){if(U){let t;for(t in this._textures)this._textures[t].dispose();for(t in this._textureArrays){const U=this._textureArrays[t];for(let t=0;t<U.length;t++)U[t].dispose()}}this._textures={},super.dispose(t,U,y)}serialize(){const t=I.b.Serialize(this);let U;for(U in t.customType="BABYLON.ShaderMaterial",t.uniqueId=this.uniqueId,t.options=this._options,t.shaderPath=this._shaderPath,t.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,t.EX=this.EX.serialize(),t.textures={},this._textures)t.textures[U]=this._textures[U].serialize();for(U in t.textureArrays={},this._textureArrays){t.textureArrays[U]=[];const y=this._textureArrays[U];for(let I=0;I<y.length;I++)t.textureArrays[U].push(y[I].serialize())}for(U in t.ints={},this._ints)t.ints[U]=this._ints[U];for(U in t.uints={},this._uints)t.uints[U]=this._uints[U];for(U in t.floats={},this._floats)t.floats[U]=this._floats[U];for(U in t.floatsArrays={},this._floatsArrays)t.floatsArrays[U]=this._floatsArrays[U];for(U in t.colors3={},this._colors3){const y=this._colors3[U];t.colors3[U]=[y.r,y.g,y.b]}for(U in t.colors3Arrays={},this._colors3Arrays)t.colors3Arrays[U]=this._colors3Arrays[U];for(U in t.colors4={},this._colors4){const y=this._colors4[U];t.colors4[U]=[y.r,y.g,y.b,y.a]}for(U in t.colors4Arrays={},this._colors4Arrays)t.colors4Arrays[U]=this._colors4Arrays[U];for(U in t.vectors2={},this._vectors2){const y=this._vectors2[U];t.vectors2[U]=[y.x,y.y]}for(U in t.vectors3={},this._vectors3){const y=this._vectors3[U];t.vectors3[U]=[y.x,y.y,y.z]}for(U in t.vectors4={},this._vectors4){const y=this._vectors4[U];t.vectors4[U]=[y.x,y.y,y.z,y.w]}for(U in t.quaternions={},this._quaternions)t.quaternions[U]=this._quaternions[U].bX();for(U in t.matrices={},this._matrices)t.matrices[U]=this._matrices[U].bX();for(U in t.matrixArray={},this._matrixArrays)t.matrixArray[U]=this._matrixArrays[U];for(U in t.matrices3x3={},this._matrices3x3)t.matrices3x3[U]=this._matrices3x3[U];for(U in t.matrices2x2={},this._matrices2x2)t.matrices2x2[U]=this._matrices2x2[U];for(U in t.vectors2Arrays={},this._vectors2Arrays)t.vectors2Arrays[U]=this._vectors2Arrays[U];for(U in t.vectors3Arrays={},this._vectors3Arrays)t.vectors3Arrays[U]=this._vectors3Arrays[U];for(U in t.vectors4Arrays={},this._vectors4Arrays)t.vectors4Arrays[U]=this._vectors4Arrays[U];for(U in t.quaternionsArrays={},this._quaternionsArrays)t.quaternionsArrays[U]=this._quaternionsArrays[U];return t}static Parse(t,U,y){const r=I.b.Parse((()=>new w(t.name,U,t.shaderPath,t.options,t.storeEffectOnSubMeshes)),t,U,y);let mt;for(mt in t.EX&&r.EX.parse(t.EX,U,y),t.textures)r.setTexture(mt,X.d.Parse(t.textures[mt],U,y));for(mt in t.textureArrays){const I=t.textureArrays[mt],Y=[];for(let t=0;t<I.length;t++)Y.push(X.d.Parse(I[t],U,y));r.setTextureArray(mt,Y)}for(mt in t.ints)r.setInt(mt,t.ints[mt]);for(mt in t.uints)r.setUInt(mt,t.uints[mt]);for(mt in t.floats)r.setFloat(mt,t.floats[mt]);for(mt in t.floatsArrays)r.setFloats(mt,t.floatsArrays[mt]);for(mt in t.colors3){const U=t.colors3[mt];r.setColor3(mt,{r:U[0],g:U[1],b:U[2]})}for(mt in t.colors3Arrays){const U=t.colors3Arrays[mt].reduce(((t,U,y)=>(y%3===0?t.push([U]):t[t.length-1].push(U),t)),[]).map((t=>({r:t[0],g:t[1],b:t[2]})));r.setColor3Array(mt,U)}for(mt in t.colors4){const U=t.colors4[mt];r.setColor4(mt,{r:U[0],g:U[1],b:U[2],a:U[3]})}for(mt in t.colors4Arrays){const U=t.colors4Arrays[mt].reduce(((t,U,y)=>(y%4===0?t.push([U]):t[t.length-1].push(U),t)),[]).map((t=>({r:t[0],g:t[1],b:t[2],a:t[3]})));r.setColor4Array(mt,U)}for(mt in t.vectors2){const U=t.vectors2[mt];r.setVector2(mt,{x:U[0],y:U[1]})}for(mt in t.vectors3){const U=t.vectors3[mt];r.setVector3(mt,{x:U[0],y:U[1],z:U[2]})}for(mt in t.vectors4){const U=t.vectors4[mt];r.setVector4(mt,{x:U[0],y:U[1],z:U[2],w:U[3]})}for(mt in t.quaternions)r.setQuaternion(mt,Y.Quaternion.pU(t.quaternions[mt]));for(mt in t.matrices)r.setMatrix(mt,Y.Matrix.pU(t.matrices[mt]));for(mt in t.matrixArray)r._matrixArrays[mt]=new Float32Array(t.matrixArray[mt]);for(mt in t.matrices3x3)r.setMatrix3x3(mt,t.matrices3x3[mt]);for(mt in t.matrices2x2)r.setMatrix2x2(mt,t.matrices2x2[mt]);for(mt in t.vectors2Arrays)r.setArray2(mt,t.vectors2Arrays[mt]);for(mt in t.vectors3Arrays)r.setArray3(mt,t.vectors3Arrays[mt]);for(mt in t.vectors4Arrays)r.setArray4(mt,t.vectors4Arrays[mt]);for(mt in t.quaternionsArrays)r.setArray4(mt,t.quaternionsArrays[mt]);return r}static async ParseFromFileAsync(t,U,y){let I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((r,Y)=>{const mt=new M.d;mt.addEventListener("readystatechange",(()=>{if(4==mt.readyState)if(200==mt.status){const U=JSON.parse(mt.responseText),Y=this.Parse(U,y||h.d.LastCreatedScene,I);t&&(Y.name=t),r(Y)}else Y("Unable to load the ShaderMaterial")})),mt.open("GET",U),mt.send()}))}static async ParseFromSnippetAsync(t,U){let y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((I,r)=>{const Y=new M.d;Y.addEventListener("readystatechange",(()=>{if(4==Y.readyState)if(200==Y.status){const r=JSON.parse(JSON.parse(Y.responseText).jsonPayload),mt=JSON.parse(r.shaderMaterial),X=this.Parse(mt,U||h.d.LastCreatedScene,y);X.snippetId=t,I(X)}else r("Unable to load the snippet "+t)})),Y.open("GET",this.SnippetUrl+"/"+t.replace(/#/g,"/")),Y.send()}))}}w.SnippetUrl="https://snippet.babylonjs.com",w.CreateFromSnippetAsync=w.ParseFromSnippetAsync,(0,P.f)("BABYLON.ShaderMaterial",w)}}]);