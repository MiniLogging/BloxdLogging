"use strict";(self.i6szn8jgzh=self.i6szn8jgzh||[]).push([[22],{12003:(b,n,i)=>{i.r(n),i.d(n,{ShaderMaterial:()=>I});var e=i(11811),V=i(12005),Q=i(11778),U=i(11842),Y=i(11748),L=i(11734),B=i(12081),mb=i(11639),N=i(12090),Z=i(11646),T=i(12142),z=i(12134);const K={effect:null,subMesh:null};class I extends N.c{constructor(b,n,i){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(b,n,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new Q.Matrix,this._cachedWorldViewProjectionMatrix=new Q.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=i,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...e}}get shaderPath(){return this._shaderPath}set shaderPath(b){this._shaderPath=b}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(b){-1===this._options.uniforms.indexOf(b)&&this._options.uniforms.push(b)}setTexture(b,n){return-1===this._options.samplers.indexOf(b)&&this._options.samplers.push(b),this._textures[b]=n,this}removeTexture(b){delete this._textures[b]}setTextureArray(b,n){return-1===this._options.samplers.indexOf(b)&&this._options.samplers.push(b),this._checkUniform(b),this._textureArrays[b]=n,this}setExternalTexture(b,n){return-1===this._options.externalTextures.indexOf(b)&&this._options.externalTextures.push(b),this._externalTextures[b]=n,this}setFloat(b,n){return this._checkUniform(b),this._floats[b]=n,this}setInt(b,n){return this._checkUniform(b),this._ints[b]=n,this}setUInt(b,n){return this._checkUniform(b),this._uints[b]=n,this}setFloats(b,n){return this._checkUniform(b),this._floatsArrays[b]=n,this}setColor3(b,n){return this._checkUniform(b),this._colors3[b]=n,this}setColor3Array(b,n){return this._checkUniform(b),this._colors3Arrays[b]=n.reduce(((b,n)=>(b.push(n.r,n.g,n.b),b)),[]),this}setColor4(b,n){return this._checkUniform(b),this._colors4[b]=n,this}setColor4Array(b,n){return this._checkUniform(b),this._colors4Arrays[b]=n.reduce(((b,n)=>(b.push(n.r,n.g,n.b,n.a),b)),[]),this}setVector2(b,n){return this._checkUniform(b),this._vectors2[b]=n,this}setVector3(b,n){return this._checkUniform(b),this._vectors3[b]=n,this}setVector4(b,n){return this._checkUniform(b),this._vectors4[b]=n,this}setQuaternion(b,n){return this._checkUniform(b),this._quaternions[b]=n,this}setQuaternionArray(b,n){return this._checkUniform(b),this._quaternionsArrays[b]=n.reduce(((b,n)=>(n.toArray(b,b.length),b)),[]),this}setMatrix(b,n){return this._checkUniform(b),this._matrices[b]=n,this}setMatrices(b,n){this._checkUniform(b);const i=new Float32Array(16*n.length);for(let e=0;e<n.length;e++){n[e].copyToArray(i,16*e)}return this._matrixArrays[b]=i,this}setMatrix3x3(b,n){return this._checkUniform(b),this._matrices3x3[b]=n,this}setMatrix2x2(b,n){return this._checkUniform(b),this._matrices2x2[b]=n,this}setArray2(b,n){return this._checkUniform(b),this._vectors2Arrays[b]=n,this}setArray3(b,n){return this._checkUniform(b),this._vectors3Arrays[b]=n,this}setArray4(b,n){return this._checkUniform(b),this._vectors4Arrays[b]=n,this}setUniformBuffer(b,n){return-1===this._options.uniformBuffers.indexOf(b)&&this._options.uniformBuffers.push(b),this._uniformBuffers[b]=n,this}setTextureSampler(b,n){return-1===this._options.samplerObjects.indexOf(b)&&this._options.samplerObjects.push(b),this._textureSamplers[b]=n,this}setStorageBuffer(b,n){return-1===this._options.storageBuffers.indexOf(b)&&this._options.storageBuffers.push(b),this._storageBuffers[b]=n,this}setDefine(b,n){const i=b.trimEnd()+" ",e=this.options.defines.findIndex((n=>n===b||n.startsWith(i)));return e>=0&&this.options.defines.splice(e,1),("boolean"!==typeof n||n)&&this.options.defines.push(i+n),this}isReadyForSubMesh(b,n,i){return this.isReady(b,i,n)}isReady(b,n,i){var e;const Q=i&&this._storeEffectOnSubMeshes;if(this.isFrozen){const b=Q?i._drawWrapper:this._drawWrapper;if(b.effect&&b._wasPreviouslyReady&&b._wasPreviouslyUsingInstances===n)return!0}const Y=this.ab(),L=Y.getEngine(),mb=[],N=[];let Z=null,I=this._shaderPath,O=this._options.uniforms,u=this._options.uniformBuffers,d=this._options.samplers;L.getCaps().multiview&&Y.activeCamera&&Y.activeCamera.outputRenderTarget&&Y.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,mb.push("#define MULTIVIEW"),-1!==O.indexOf("viewProjection")&&-1===O.indexOf("viewProjectionR")&&O.push("viewProjectionR"));for(let V=0;V<this._options.defines.length;V++){const b=0===this._options.defines[V].indexOf("#define")?this._options.defines[V]:`#define ${this._options.defines[V]}`;mb.push(b)}for(let V=0;V<this._options.attributes.length;V++)N.push(this._options.attributes[V]);if(b&&b.isVerticesDataPresent(U.g.ColorKind)&&(-1===N.indexOf(U.g.ColorKind)&&N.push(U.g.ColorKind),mb.push("#define VERTEXCOLOR")),n&&(mb.push("#define INSTANCES"),(0,z.hb)(N,this._materialHelperNeedsPreviousMatrices),null!==b&&void 0!==b&&b.hasThinInstances&&(mb.push("#define THIN_INSTANCES"),b&&b.isVerticesDataPresent(U.g.ColorInstanceKind)&&(N.push(U.g.ColorInstanceKind),mb.push("#define INSTANCESCOLOR")))),b&&b.useBones&&b.computeBonesUsingShaders&&b.skeleton){N.push(U.g.MatricesIndicesKind),N.push(U.g.MatricesWeightsKind),b.numBoneInfluencers>4&&(N.push(U.g.MatricesIndicesExtraKind),N.push(U.g.MatricesWeightsExtraKind));const n=b.skeleton;mb.push("#define NUM_BONE_INFLUENCERS "+b.numBoneInfluencers),Z=new B.b,Z.addCPUSkinningFallback(0,b),n.isUsingTextureForMatrices?(mb.push("#define BONETEXTURE"),-1===O.indexOf("boneTextureWidth")&&O.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(mb.push("#define BonesPerMesh "+(n.bones.length+1)),-1===O.indexOf("mBones")&&O.push("mBones"))}else mb.push("#define NUM_BONE_INFLUENCERS 0");let G=0;const o=b?b.morphTargetManager:null;if(o){const n=-1!==mb.indexOf("#define UV1"),i=-1!==mb.indexOf("#define UV2"),e=-1!==mb.indexOf("#define TANGENT"),V=-1!==mb.indexOf("#define NORMAL"),Q=-1!==mb.indexOf("#define VERTEXCOLOR");G=(0,z.M)(o,mb,N,b,!0,V,e,n,i,Q),o.isUsingTextureForTargets&&(-1===O.indexOf("morphTargetTextureIndices")&&O.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),G>0&&(O=O.slice(),O.push("morphTargetInfluences"),O.push("morphTargetCount"),O.push("morphTargetTextureInfo"),O.push("morphTargetTextureIndices"))}else mb.push("#define NUM_MORPH_INFLUENCERS 0");if(b){const n=b.bakedVertexAnimationManager;n&&n.isEnabled&&(mb.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===O.indexOf("bakedVertexAnimationSettings")&&O.push("bakedVertexAnimationSettings"),-1===O.indexOf("bakedVertexAnimationTextureSizeInverted")&&O.push("bakedVertexAnimationTextureSizeInverted"),-1===O.indexOf("bakedVertexAnimationTime")&&O.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,z.A)(N,b,mb)}for(const V in this._textures)if(!this._textures[V].isReady())return!1;b&&this.needAlphaTestingForMesh(b)&&mb.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,T.c)(O),(0,T.h)(this,Y,mb)),Y.fogEnabled&&null!==b&&void 0!==b&&b.applyFog&&Y.fogMode!==V.b.FOGMODE_NONE&&(mb.push("#define FOG"),-1===O.indexOf("view")&&O.push("view"),-1===O.indexOf("vFogInfos")&&O.push("vFogInfos"),-1===O.indexOf("vFogColor")&&O.push("vFogColor")),this._useLogarithmicDepth&&(mb.push("#define LOGARITHMICDEPTH"),-1===O.indexOf("logarithmicDepthConstant")&&O.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(O=O.slice(),u=u.slice(),d=d.slice(),I=this.customShaderNameResolve(this.name,O,u,d,mb,N));const M=Q?i._getDrawWrapper(void 0,!0):this._drawWrapper,j=(null===M||void 0===M?void 0:M.effect)??null,a=(null===M||void 0===M?void 0:M.defines)??null,D=mb.join("\n");let x=j;return a!==D&&(x=L.createEffect(I,{attributes:N,uniformsNames:O,uniformBuffersNames:u,samplers:d,defines:D,fallbacks:Z,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:G},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},L),Q?i.setEffect(x,D,this._materialContext):M&&M.setEffect(x,D),this._onEffectCreatedObservable&&(K.effect=x,K.subMesh=i??(null===b||void 0===b?void 0:b.xe[0])??null,this._onEffectCreatedObservable.notifyObservers(K))),M._wasPreviouslyUsingInstances=!!n,!(null===(e=x)||void 0===e||!e.isReady())&&(j!==x&&Y.resetCachedMaterial(),M._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(b,n){const i=n??this.getEffect();if(!i)return;const e=this._options.uniforms;-1!==e.indexOf("world")&&i.setMatrix("world",b);const V=this.ab();-1!==e.indexOf("worldView")&&(b.multiplyToRef(V.getViewMatrix(),this._cachedWorldViewMatrix),i.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==e.indexOf("worldViewProjection")&&(b.multiplyToRef(V.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),i.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==e.indexOf("view")&&i.setMatrix("view",V.getViewMatrix())}bindForSubMesh(b,n,i){var e;this.bind(b,n,null===(e=i._drawWrapperOverride)||void 0===e?void 0:e.effect,i)}bind(b,n,i,e){const V=e&&this._storeEffectOnSubMeshes,Q=i??(V?e.effect:this.getEffect());if(!Q)return;const U=this.ab();this._activeEffect=Q,this.bindOnlyWorldMatrix(b,i);const Y=this._options.uniformBuffers;let L=!1;if(Q&&Y&&Y.length>0&&U.getEngine().supportsUniformBuffers)for(let N=0;N<Y.length;++N){switch(Y[N]){case"Mesh":n&&(n.getMeshUniformBuffer().bindToEffect(Q,"Mesh"),n.transferToEffect(b));break;case"Scene":(0,z.s)(Q,U.getSceneUniformBuffer()),U.finalizeSceneUbo(),L=!0}}const B=n&&V?this._mustRebind(U,Q,e,n.visibility):U.getCachedMaterial()!==this;if(Q&&B){let b;for(b in L||-1===this._options.uniforms.indexOf("view")||Q.setMatrix("view",U.getViewMatrix()),L||-1===this._options.uniforms.indexOf("projection")||Q.setMatrix("projection",U.getProjectionMatrix()),L||-1===this._options.uniforms.indexOf("viewProjection")||(Q.setMatrix("viewProjection",U.getTransformMatrix()),this._multiview&&Q.setMatrix("viewProjectionR",U._transformMatrixR)),U.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&Q.setVector3("cameraPosition",U.activeCamera.globalPosition),(0,z.d)(n,Q),(0,T.d)(Q,this,U),this._useLogarithmicDepth&&(0,z.k)(V?e.materialDefines:Q.defines,Q,U),n&&(0,z.e)(U,n,Q),this._textures)Q.setTexture(b,this._textures[b]);for(b in this._textureArrays)Q.setTextureArray(b,this._textureArrays[b]);for(b in this._ints)Q.setInt(b,this._ints[b]);for(b in this._uints)Q.setUInt(b,this._uints[b]);for(b in this._floats)Q.setFloat(b,this._floats[b]);for(b in this._floatsArrays)Q.setArray(b,this._floatsArrays[b]);for(b in this._colors3)Q.setColor3(b,this._colors3[b]);for(b in this._colors3Arrays)Q.setArray3(b,this._colors3Arrays[b]);for(b in this._colors4){const n=this._colors4[b];Q.setFloat4(b,n.r,n.g,n.b,n.a)}for(b in this._colors4Arrays)Q.setArray4(b,this._colors4Arrays[b]);for(b in this._vectors2)Q.setVector2(b,this._vectors2[b]);for(b in this._vectors3)Q.setVector3(b,this._vectors3[b]);for(b in this._vectors4)Q.setVector4(b,this._vectors4[b]);for(b in this._quaternions)Q.setQuaternion(b,this._quaternions[b]);for(b in this._matrices)Q.setMatrix(b,this._matrices[b]);for(b in this._matrixArrays)Q.setMatrices(b,this._matrixArrays[b]);for(b in this._matrices3x3)Q.setMatrix3x3(b,this._matrices3x3[b]);for(b in this._matrices2x2)Q.setMatrix2x2(b,this._matrices2x2[b]);for(b in this._vectors2Arrays)Q.setArray2(b,this._vectors2Arrays[b]);for(b in this._vectors3Arrays)Q.setArray3(b,this._vectors3Arrays[b]);for(b in this._vectors4Arrays)Q.setArray4(b,this._vectors4Arrays[b]);for(b in this._quaternionsArrays)Q.setArray4(b,this._quaternionsArrays[b]);for(b in this._uniformBuffers){const n=this._uniformBuffers[b].getBuffer();n&&Q.bindUniformBuffer(n,b)}const i=U.getEngine(),Y=i.setExternalTexture;if(Y)for(b in this._externalTextures)Y.call(i,b,this._externalTextures[b]);const B=i.setTextureSampler;if(B)for(b in this._textureSamplers)B.call(i,b,this._textureSamplers[b]);const mb=i.setStorageBuffer;if(mb)for(b in this._storageBuffers)mb.call(i,b,this._storageBuffers[b])}if(Q&&n&&(B||!this.isFrozen)){(0,z.o)(n,Q),n.morphTargetManager&&n.morphTargetManager.isUsingTextureForTargets&&n.morphTargetManager._bind(Q);const b=n.bakedVertexAnimationManager;if(b&&b.isEnabled){var mb;const b=V?e._drawWrapper:this._drawWrapper;null===(mb=n.bakedVertexAnimationManager)||void 0===mb||mb.bind(Q,!!b._wasPreviouslyUsingInstances)}}this._afterBind(n,Q,e)}getActiveTextures(){const b=super.getActiveTextures();for(const n in this._textures)b.push(this._textures[n]);for(const n in this._textureArrays){const i=this._textureArrays[n];for(let n=0;n<i.length;n++)b.push(i[n])}return b}hasTexture(b){if(super.hasTexture(b))return!0;for(const n in this._textures)if(this._textures[n]===b)return!0;for(const n in this._textureArrays){const i=this._textureArrays[n];for(let n=0;n<i.length;n++)if(i[n]===b)return!0}return!1}clone(b){const n=e.c.Clone((()=>new I(b,this.ab(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);n.name=b,n.id=b,"object"===typeof n._shaderPath&&(n._shaderPath={...n._shaderPath}),this._options={...this._options};const i=Object.keys(this._options);for(const e of i){const b=this._options[e];Array.isArray(b)&&(this._options[e]=b.slice(0))}this.stencil.copyTo(n.stencil);for(const e in this._textures)n.setTexture(e,this._textures[e]);for(const e in this._textureArrays)n.setTextureArray(e,this._textureArrays[e]);for(const e in this._externalTextures)n.setExternalTexture(e,this._externalTextures[e]);for(const e in this._ints)n.setInt(e,this._ints[e]);for(const e in this._uints)n.setUInt(e,this._uints[e]);for(const e in this._floats)n.setFloat(e,this._floats[e]);for(const e in this._floatsArrays)n.setFloats(e,this._floatsArrays[e]);for(const e in this._colors3)n.setColor3(e,this._colors3[e]);for(const e in this._colors3Arrays)n._colors3Arrays[e]=this._colors3Arrays[e];for(const e in this._colors4)n.setColor4(e,this._colors4[e]);for(const e in this._colors4Arrays)n._colors4Arrays[e]=this._colors4Arrays[e];for(const e in this._vectors2)n.setVector2(e,this._vectors2[e]);for(const e in this._vectors3)n.setVector3(e,this._vectors3[e]);for(const e in this._vectors4)n.setVector4(e,this._vectors4[e]);for(const e in this._quaternions)n.setQuaternion(e,this._quaternions[e]);for(const e in this._quaternionsArrays)n._quaternionsArrays[e]=this._quaternionsArrays[e];for(const e in this._matrices)n.setMatrix(e,this._matrices[e]);for(const e in this._matrixArrays)n._matrixArrays[e]=this._matrixArrays[e].slice();for(const e in this._matrices3x3)n.setMatrix3x3(e,this._matrices3x3[e]);for(const e in this._matrices2x2)n.setMatrix2x2(e,this._matrices2x2[e]);for(const e in this._vectors2Arrays)n.setArray2(e,this._vectors2Arrays[e]);for(const e in this._vectors3Arrays)n.setArray3(e,this._vectors3Arrays[e]);for(const e in this._vectors4Arrays)n.setArray4(e,this._vectors4Arrays[e]);for(const e in this._uniformBuffers)n.setUniformBuffer(e,this._uniformBuffers[e]);for(const e in this._textureSamplers)n.setTextureSampler(e,this._textureSamplers[e]);for(const e in this._storageBuffers)n.setStorageBuffer(e,this._storageBuffers[e]);return n}dispose(b,n,i){if(n){let b;for(b in this._textures)this._textures[b].dispose();for(b in this._textureArrays){const n=this._textureArrays[b];for(let b=0;b<n.length;b++)n[b].dispose()}}this._textures={},super.dispose(b,n,i)}serialize(){const b=e.c.Serialize(this);let n;for(n in b.customType="BABYLON.ShaderMaterial",b.uniqueId=this.uniqueId,b.options=this._options,b.shaderPath=this._shaderPath,b.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,b.stencil=this.stencil.serialize(),b.textures={},this._textures)b.textures[n]=this._textures[n].serialize();for(n in b.textureArrays={},this._textureArrays){b.textureArrays[n]=[];const i=this._textureArrays[n];for(let e=0;e<i.length;e++)b.textureArrays[n].push(i[e].serialize())}for(n in b.ints={},this._ints)b.ints[n]=this._ints[n];for(n in b.uints={},this._uints)b.uints[n]=this._uints[n];for(n in b.floats={},this._floats)b.floats[n]=this._floats[n];for(n in b.floatsArrays={},this._floatsArrays)b.floatsArrays[n]=this._floatsArrays[n];for(n in b.colors3={},this._colors3){const i=this._colors3[n];b.colors3[n]=[i.r,i.g,i.b]}for(n in b.colors3Arrays={},this._colors3Arrays)b.colors3Arrays[n]=this._colors3Arrays[n];for(n in b.colors4={},this._colors4){const i=this._colors4[n];b.colors4[n]=[i.r,i.g,i.b,i.a]}for(n in b.colors4Arrays={},this._colors4Arrays)b.colors4Arrays[n]=this._colors4Arrays[n];for(n in b.vectors2={},this._vectors2){const i=this._vectors2[n];b.vectors2[n]=[i.x,i.y]}for(n in b.vectors3={},this._vectors3){const i=this._vectors3[n];b.vectors3[n]=[i.x,i.y,i.z]}for(n in b.vectors4={},this._vectors4){const i=this._vectors4[n];b.vectors4[n]=[i.x,i.y,i.z,i.w]}for(n in b.quaternions={},this._quaternions)b.quaternions[n]=this._quaternions[n].ye();for(n in b.matrices={},this._matrices)b.matrices[n]=this._matrices[n].ye();for(n in b.matrixArray={},this._matrixArrays)b.matrixArray[n]=this._matrixArrays[n];for(n in b.matrices3x3={},this._matrices3x3)b.matrices3x3[n]=this._matrices3x3[n];for(n in b.matrices2x2={},this._matrices2x2)b.matrices2x2[n]=this._matrices2x2[n];for(n in b.vectors2Arrays={},this._vectors2Arrays)b.vectors2Arrays[n]=this._vectors2Arrays[n];for(n in b.vectors3Arrays={},this._vectors3Arrays)b.vectors3Arrays[n]=this._vectors3Arrays[n];for(n in b.vectors4Arrays={},this._vectors4Arrays)b.vectors4Arrays[n]=this._vectors4Arrays[n];for(n in b.quaternionsArrays={},this._quaternionsArrays)b.quaternionsArrays[n]=this._quaternionsArrays[n];return b}static Parse(b,n,i){const V=e.c.Parse((()=>new I(b.name,n,b.shaderPath,b.options,b.storeEffectOnSubMeshes)),b,n,i);let U;for(U in b.stencil&&V.stencil.parse(b.stencil,n,i),b.textures)V.setTexture(U,Y.e.Parse(b.textures[U],n,i));for(U in b.textureArrays){const e=b.textureArrays[U],Q=[];for(let b=0;b<e.length;b++)Q.push(Y.e.Parse(e[b],n,i));V.setTextureArray(U,Q)}for(U in b.ints)V.setInt(U,b.ints[U]);for(U in b.uints)V.setUInt(U,b.uints[U]);for(U in b.floats)V.setFloat(U,b.floats[U]);for(U in b.floatsArrays)V.setFloats(U,b.floatsArrays[U]);for(U in b.colors3){const n=b.colors3[U];V.setColor3(U,{r:n[0],g:n[1],b:n[2]})}for(U in b.colors3Arrays){const n=b.colors3Arrays[U].reduce(((b,n,i)=>(i%3===0?b.push([n]):b[b.length-1].push(n),b)),[]).map((b=>({r:b[0],g:b[1],b:b[2]})));V.setColor3Array(U,n)}for(U in b.colors4){const n=b.colors4[U];V.setColor4(U,{r:n[0],g:n[1],b:n[2],a:n[3]})}for(U in b.colors4Arrays){const n=b.colors4Arrays[U].reduce(((b,n,i)=>(i%4===0?b.push([n]):b[b.length-1].push(n),b)),[]).map((b=>({r:b[0],g:b[1],b:b[2],a:b[3]})));V.setColor4Array(U,n)}for(U in b.vectors2){const n=b.vectors2[U];V.setVector2(U,{x:n[0],y:n[1]})}for(U in b.vectors3){const n=b.vectors3[U];V.setVector3(U,{x:n[0],y:n[1],z:n[2]})}for(U in b.vectors4){const n=b.vectors4[U];V.setVector4(U,{x:n[0],y:n[1],z:n[2],w:n[3]})}for(U in b.quaternions)V.setQuaternion(U,Q.Quaternion.jn(b.quaternions[U]));for(U in b.matrices)V.setMatrix(U,Q.Matrix.jn(b.matrices[U]));for(U in b.matrixArray)V._matrixArrays[U]=new Float32Array(b.matrixArray[U]);for(U in b.matrices3x3)V.setMatrix3x3(U,b.matrices3x3[U]);for(U in b.matrices2x2)V.setMatrix2x2(U,b.matrices2x2[U]);for(U in b.vectors2Arrays)V.setArray2(U,b.vectors2Arrays[U]);for(U in b.vectors3Arrays)V.setArray3(U,b.vectors3Arrays[U]);for(U in b.vectors4Arrays)V.setArray4(U,b.vectors4Arrays[U]);for(U in b.quaternionsArrays)V.setArray4(U,b.quaternionsArrays[U]);return V}static async ParseFromFileAsync(b,n,i){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((V,Q)=>{const U=new mb.e;U.addEventListener("readystatechange",(()=>{if(4==U.readyState)if(200==U.status){const n=JSON.parse(U.responseText),Q=this.Parse(n,i||Z.d.LastCreatedScene,e);b&&(Q.name=b),V(Q)}else Q("Unable to load the ShaderMaterial")})),U.open("GET",n),U.send()}))}static async ParseFromSnippetAsync(b,n){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((e,V)=>{const Q=new mb.e;Q.addEventListener("readystatechange",(()=>{if(4==Q.readyState)if(200==Q.status){const V=JSON.parse(JSON.parse(Q.responseText).jsonPayload),U=JSON.parse(V.shaderMaterial),Y=this.Parse(U,n||Z.d.LastCreatedScene,i);Y.snippetId=b,e(Y)}else V("Unable to load the snippet "+b)})),Q.open("GET",this.SnippetUrl+"/"+b.replace(/#/g,"/")),Q.send()}))}}I.SnippetUrl="https://snippet.babylonjs.com",I.CreateFromSnippetAsync=I.ParseFromSnippetAsync,(0,L.i)("BABYLON.ShaderMaterial",I)}}]);