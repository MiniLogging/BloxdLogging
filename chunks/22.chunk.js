"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[22],{12701:(u,R,I)=>{I.r(R),I.d(R,{ShaderMaterial:()=>E});var B=I(12507),U=I(12703),K=I(12481),C=I(12549),D=I(12460),s=I(12433),t=I(12782),G=I(12337),S=I(12787),b=I(12346),r=I(12840),P=I(12831);const X={effect:null,subMesh:null};class E extends S.e{constructor(u,R,I){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(u,R,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new K.Matrix,this._cachedWorldViewProjectionMatrix=new K.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=I,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...B}}get shaderPath(){return this._shaderPath}set shaderPath(u){this._shaderPath=u}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(u){-1===this._options.uniforms.indexOf(u)&&this._options.uniforms.push(u)}setTexture(u,R){return-1===this._options.samplers.indexOf(u)&&this._options.samplers.push(u),this._textures[u]=R,this}removeTexture(u){delete this._textures[u]}setTextureArray(u,R){return-1===this._options.samplers.indexOf(u)&&this._options.samplers.push(u),this._checkUniform(u),this._textureArrays[u]=R,this}setExternalTexture(u,R){return-1===this._options.externalTextures.indexOf(u)&&this._options.externalTextures.push(u),this._externalTextures[u]=R,this}setFloat(u,R){return this._checkUniform(u),this._floats[u]=R,this}setInt(u,R){return this._checkUniform(u),this._ints[u]=R,this}setUInt(u,R){return this._checkUniform(u),this._uints[u]=R,this}setFloats(u,R){return this._checkUniform(u),this._floatsArrays[u]=R,this}setColor3(u,R){return this._checkUniform(u),this._colors3[u]=R,this}setColor3Array(u,R){return this._checkUniform(u),this._colors3Arrays[u]=R.reduce(((u,R)=>(u.push(R.r,R.g,R.b),u)),[]),this}setColor4(u,R){return this._checkUniform(u),this._colors4[u]=R,this}setColor4Array(u,R){return this._checkUniform(u),this._colors4Arrays[u]=R.reduce(((u,R)=>(u.push(R.r,R.g,R.b,R.a),u)),[]),this}setVector2(u,R){return this._checkUniform(u),this._vectors2[u]=R,this}setVector3(u,R){return this._checkUniform(u),this._vectors3[u]=R,this}setVector4(u,R){return this._checkUniform(u),this._vectors4[u]=R,this}setQuaternion(u,R){return this._checkUniform(u),this._quaternions[u]=R,this}setQuaternionArray(u,R){return this._checkUniform(u),this._quaternionsArrays[u]=R.reduce(((u,R)=>(R.toArray(u,u.length),u)),[]),this}setMatrix(u,R){return this._checkUniform(u),this._matrices[u]=R,this}setMatrices(u,R){this._checkUniform(u);const I=new Float32Array(16*R.length);for(let B=0;B<R.length;B++){R[B].copyToArray(I,16*B)}return this._matrixArrays[u]=I,this}setMatrix3x3(u,R){return this._checkUniform(u),this._matrices3x3[u]=R,this}setMatrix2x2(u,R){return this._checkUniform(u),this._matrices2x2[u]=R,this}setArray2(u,R){return this._checkUniform(u),this._vectors2Arrays[u]=R,this}setArray3(u,R){return this._checkUniform(u),this._vectors3Arrays[u]=R,this}setArray4(u,R){return this._checkUniform(u),this._vectors4Arrays[u]=R,this}setUniformBuffer(u,R){return-1===this._options.uniformBuffers.indexOf(u)&&this._options.uniformBuffers.push(u),this._uniformBuffers[u]=R,this}setTextureSampler(u,R){return-1===this._options.samplerObjects.indexOf(u)&&this._options.samplerObjects.push(u),this._textureSamplers[u]=R,this}setStorageBuffer(u,R){return-1===this._options.storageBuffers.indexOf(u)&&this._options.storageBuffers.push(u),this._storageBuffers[u]=R,this}setDefine(u,R){const I=u.trimEnd()+" ",B=this.options.defines.findIndex((R=>R===u||R.startsWith(I)));return B>=0&&this.options.defines.splice(B,1),("boolean"!==typeof R||R)&&this.options.defines.push(I+R),this}isReadyForSubMesh(u,R,I){return this.isReady(u,I,R)}isReady(u,R,I){var B;const K=I&&this._storeEffectOnSubMeshes;if(this.isFrozen){const u=K?I._drawWrapper:this._drawWrapper;if(u.effect&&u._wasPreviouslyReady&&u._wasPreviouslyUsingInstances===R)return!0}const D=this.eu(),s=D.getEngine(),G=[],S=[];let b=null,E=this._shaderPath,z=this._options.uniforms,f=this._options.uniformBuffers,T=this._options.samplers;s.getCaps().multiview&&D.activeCamera&&D.activeCamera.outputRenderTarget&&D.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,G.push("#define MULTIVIEW"),-1!==z.indexOf("viewProjection")&&-1===z.indexOf("viewProjectionR")&&z.push("viewProjectionR"));for(let U=0;U<this._options.defines.length;U++){const u=0===this._options.defines[U].indexOf("#define")?this._options.defines[U]:`#define ${this._options.defines[U]}`;G.push(u)}for(let U=0;U<this._options.attributes.length;U++)S.push(this._options.attributes[U]);if(u&&u.isVerticesDataPresent(C.i.ColorKind)&&(-1===S.indexOf(C.i.ColorKind)&&S.push(C.i.ColorKind),G.push("#define VERTEXCOLOR")),R&&(G.push("#define INSTANCES"),(0,P.db)(S,this._materialHelperNeedsPreviousMatrices),null!==u&&void 0!==u&&u.hasThinInstances&&(G.push("#define THIN_INSTANCES"),u&&u.isVerticesDataPresent(C.i.ColorInstanceKind)&&(S.push(C.i.ColorInstanceKind),G.push("#define INSTANCESCOLOR")))),u&&u.useBones&&u.computeBonesUsingShaders&&u.skeleton){S.push(C.i.MatricesIndicesKind),S.push(C.i.MatricesWeightsKind),u.numBoneInfluencers>4&&(S.push(C.i.MatricesIndicesExtraKind),S.push(C.i.MatricesWeightsExtraKind));const R=u.skeleton;G.push("#define NUM_BONE_INFLUENCERS "+u.numBoneInfluencers),b=new t.e,b.addCPUSkinningFallback(0,u),R.isUsingTextureForMatrices?(G.push("#define BONETEXTURE"),-1===z.indexOf("boneTextureWidth")&&z.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(G.push("#define BonesPerMesh "+(R.bones.length+1)),-1===z.indexOf("mBones")&&z.push("mBones"))}else G.push("#define NUM_BONE_INFLUENCERS 0");let Q=0;const V=u?u.morphTargetManager:null;if(V){const R=-1!==G.indexOf("#define UV1"),I=-1!==G.indexOf("#define UV2"),B=-1!==G.indexOf("#define TANGENT"),U=-1!==G.indexOf("#define NORMAL"),K=-1!==G.indexOf("#define VERTEXCOLOR");Q=(0,P.C)(V,G,S,u,!0,U,B,R,I,K),V.isUsingTextureForTargets&&(-1===z.indexOf("morphTargetTextureIndices")&&z.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),Q>0&&(z=z.slice(),z.push("morphTargetInfluences"),z.push("morphTargetCount"),z.push("morphTargetTextureInfo"),z.push("morphTargetTextureIndices"))}else G.push("#define NUM_MORPH_INFLUENCERS 0");if(u){const R=u.bakedVertexAnimationManager;R&&R.isEnabled&&(G.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===z.indexOf("bakedVertexAnimationSettings")&&z.push("bakedVertexAnimationSettings"),-1===z.indexOf("bakedVertexAnimationTextureSizeInverted")&&z.push("bakedVertexAnimationTextureSizeInverted"),-1===z.indexOf("bakedVertexAnimationTime")&&z.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,P.r)(S,u,G)}for(const U in this._textures)if(!this._textures[U].isReady())return!1;u&&this.needAlphaTestingForMesh(u)&&G.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,r.e)(z),(0,r.n)(this,D,G)),D.fogEnabled&&null!==u&&void 0!==u&&u.applyFog&&D.fogMode!==U.c.FOGMODE_NONE&&(G.push("#define FOG"),-1===z.indexOf("view")&&z.push("view"),-1===z.indexOf("vFogInfos")&&z.push("vFogInfos"),-1===z.indexOf("vFogColor")&&z.push("vFogColor")),this._useLogarithmicDepth&&(G.push("#define LOGARITHMICDEPTH"),-1===z.indexOf("logarithmicDepthConstant")&&z.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(z=z.slice(),f=f.slice(),T=T.slice(),E=this.customShaderNameResolve(this.name,z,f,T,G,S));const q=K?I._getDrawWrapper(void 0,!0):this._drawWrapper,e=(null===q||void 0===q?void 0:q.effect)??null,Y=(null===q||void 0===q?void 0:q.defines)??null,M=G.join("\n");let o=e;return Y!==M&&(o=s.createEffect(E,{attributes:S,uniformsNames:z,uniformBuffersNames:f,samplers:T,defines:M,fallbacks:b,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:Q},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},s),K?I.setEffect(o,M,this._materialContext):q&&q.setEffect(o,M),this._onEffectCreatedObservable&&(X.effect=o,X.subMesh=I??(null===u||void 0===u?void 0:u.DD[0])??null,this._onEffectCreatedObservable.notifyObservers(X))),q._wasPreviouslyUsingInstances=!!R,!(null===(B=o)||void 0===B||!B.isReady())&&(e!==o&&D.resetCachedMaterial(),q._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(u,R){const I=R??this.getEffect();if(!I)return;const B=this._options.uniforms;-1!==B.indexOf("world")&&I.setMatrix("world",u);const U=this.eu();-1!==B.indexOf("worldView")&&(u.multiplyToRef(U.getViewMatrix(),this._cachedWorldViewMatrix),I.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==B.indexOf("worldViewProjection")&&(u.multiplyToRef(U.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),I.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==B.indexOf("view")&&I.setMatrix("view",U.getViewMatrix())}bindForSubMesh(u,R,I){var B;this.bind(u,R,null===(B=I._drawWrapperOverride)||void 0===B?void 0:B.effect,I)}bind(u,R,I,B){const U=B&&this._storeEffectOnSubMeshes,K=I??(U?B.effect:this.getEffect());if(!K)return;const C=this.eu();this._activeEffect=K,this.bindOnlyWorldMatrix(u,I);const D=this._options.uniformBuffers;let s=!1;if(K&&D&&D.length>0&&C.getEngine().supportsUniformBuffers)for(let S=0;S<D.length;++S){switch(D[S]){case"Mesh":R&&(R.getMeshUniformBuffer().bindToEffect(K,"Mesh"),R.transferToEffect(u));break;case"Scene":(0,P.n)(K,C.getSceneUniformBuffer()),C.finalizeSceneUbo(),s=!0}}const t=R&&U?this._mustRebind(C,K,B,R.visibility):C.getCachedMaterial()!==this;if(K&&t){let u;for(u in s||-1===this._options.uniforms.indexOf("view")||K.setMatrix("view",C.getViewMatrix()),s||-1===this._options.uniforms.indexOf("projection")||K.setMatrix("projection",C.getProjectionMatrix()),s||-1===this._options.uniforms.indexOf("viewProjection")||(K.setMatrix("viewProjection",C.getTransformMatrix()),this._multiview&&K.setMatrix("viewProjectionR",C._transformMatrixR)),C.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&K.setVector3("cameraPosition",C.activeCamera.globalPosition),(0,P.b)(R,K),(0,r.g)(K,this,C),this._useLogarithmicDepth&&(0,P.j)(U?B.materialDefines:K.defines,K,C),R&&(0,P.d)(C,R,K),this._textures)K.setTexture(u,this._textures[u]);for(u in this._textureArrays)K.setTextureArray(u,this._textureArrays[u]);for(u in this._ints)K.setInt(u,this._ints[u]);for(u in this._uints)K.setUInt(u,this._uints[u]);for(u in this._floats)K.setFloat(u,this._floats[u]);for(u in this._floatsArrays)K.setArray(u,this._floatsArrays[u]);for(u in this._colors3)K.setColor3(u,this._colors3[u]);for(u in this._colors3Arrays)K.setArray3(u,this._colors3Arrays[u]);for(u in this._colors4){const R=this._colors4[u];K.setFloat4(u,R.r,R.g,R.b,R.a)}for(u in this._colors4Arrays)K.setArray4(u,this._colors4Arrays[u]);for(u in this._vectors2)K.setVector2(u,this._vectors2[u]);for(u in this._vectors3)K.setVector3(u,this._vectors3[u]);for(u in this._vectors4)K.setVector4(u,this._vectors4[u]);for(u in this._quaternions)K.setQuaternion(u,this._quaternions[u]);for(u in this._matrices)K.setMatrix(u,this._matrices[u]);for(u in this._matrixArrays)K.setMatrices(u,this._matrixArrays[u]);for(u in this._matrices3x3)K.setMatrix3x3(u,this._matrices3x3[u]);for(u in this._matrices2x2)K.setMatrix2x2(u,this._matrices2x2[u]);for(u in this._vectors2Arrays)K.setArray2(u,this._vectors2Arrays[u]);for(u in this._vectors3Arrays)K.setArray3(u,this._vectors3Arrays[u]);for(u in this._vectors4Arrays)K.setArray4(u,this._vectors4Arrays[u]);for(u in this._quaternionsArrays)K.setArray4(u,this._quaternionsArrays[u]);for(u in this._uniformBuffers){const R=this._uniformBuffers[u].getBuffer();R&&K.bindUniformBuffer(R,u)}const I=C.getEngine(),D=I.setExternalTexture;if(D)for(u in this._externalTextures)D.call(I,u,this._externalTextures[u]);const t=I.setTextureSampler;if(t)for(u in this._textureSamplers)t.call(I,u,this._textureSamplers[u]);const G=I.setStorageBuffer;if(G)for(u in this._storageBuffers)G.call(I,u,this._storageBuffers[u])}if(K&&R&&(t||!this.isFrozen)){(0,P.l)(R,K),R.morphTargetManager&&R.morphTargetManager.isUsingTextureForTargets&&R.morphTargetManager._bind(K);const u=R.bakedVertexAnimationManager;if(u&&u.isEnabled){var G;const u=U?B._drawWrapper:this._drawWrapper;null===(G=R.bakedVertexAnimationManager)||void 0===G||G.bind(K,!!u._wasPreviouslyUsingInstances)}}this._afterBind(R,K,B)}getActiveTextures(){const u=super.getActiveTextures();for(const R in this._textures)u.push(this._textures[R]);for(const R in this._textureArrays){const I=this._textureArrays[R];for(let R=0;R<I.length;R++)u.push(I[R])}return u}hasTexture(u){if(super.hasTexture(u))return!0;for(const R in this._textures)if(this._textures[R]===u)return!0;for(const R in this._textureArrays){const I=this._textureArrays[R];for(let R=0;R<I.length;R++)if(I[R]===u)return!0}return!1}clone(u){const R=B.e.Clone((()=>new E(u,this.eu(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);R.name=u,R.id=u,"object"===typeof R._shaderPath&&(R._shaderPath={...R._shaderPath}),this._options={...this._options};const I=Object.keys(this._options);for(const B of I){const u=this._options[B];Array.isArray(u)&&(this._options[B]=u.slice(0))}this.RD.copyTo(R.RD);for(const B in this._textures)R.setTexture(B,this._textures[B]);for(const B in this._textureArrays)R.setTextureArray(B,this._textureArrays[B]);for(const B in this._externalTextures)R.setExternalTexture(B,this._externalTextures[B]);for(const B in this._ints)R.setInt(B,this._ints[B]);for(const B in this._uints)R.setUInt(B,this._uints[B]);for(const B in this._floats)R.setFloat(B,this._floats[B]);for(const B in this._floatsArrays)R.setFloats(B,this._floatsArrays[B]);for(const B in this._colors3)R.setColor3(B,this._colors3[B]);for(const B in this._colors3Arrays)R._colors3Arrays[B]=this._colors3Arrays[B];for(const B in this._colors4)R.setColor4(B,this._colors4[B]);for(const B in this._colors4Arrays)R._colors4Arrays[B]=this._colors4Arrays[B];for(const B in this._vectors2)R.setVector2(B,this._vectors2[B]);for(const B in this._vectors3)R.setVector3(B,this._vectors3[B]);for(const B in this._vectors4)R.setVector4(B,this._vectors4[B]);for(const B in this._quaternions)R.setQuaternion(B,this._quaternions[B]);for(const B in this._quaternionsArrays)R._quaternionsArrays[B]=this._quaternionsArrays[B];for(const B in this._matrices)R.setMatrix(B,this._matrices[B]);for(const B in this._matrixArrays)R._matrixArrays[B]=this._matrixArrays[B].slice();for(const B in this._matrices3x3)R.setMatrix3x3(B,this._matrices3x3[B]);for(const B in this._matrices2x2)R.setMatrix2x2(B,this._matrices2x2[B]);for(const B in this._vectors2Arrays)R.setArray2(B,this._vectors2Arrays[B]);for(const B in this._vectors3Arrays)R.setArray3(B,this._vectors3Arrays[B]);for(const B in this._vectors4Arrays)R.setArray4(B,this._vectors4Arrays[B]);for(const B in this._uniformBuffers)R.setUniformBuffer(B,this._uniformBuffers[B]);for(const B in this._textureSamplers)R.setTextureSampler(B,this._textureSamplers[B]);for(const B in this._storageBuffers)R.setStorageBuffer(B,this._storageBuffers[B]);return R}dispose(u,R,I){if(R){let u;for(u in this._textures)this._textures[u].dispose();for(u in this._textureArrays){const R=this._textureArrays[u];for(let u=0;u<R.length;u++)R[u].dispose()}}this._textures={},super.dispose(u,R,I)}serialize(){const u=B.e.Serialize(this);let R;for(R in u.customType="BABYLON.ShaderMaterial",u.uniqueId=this.uniqueId,u.options=this._options,u.shaderPath=this._shaderPath,u.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,u.RD=this.RD.serialize(),u.textures={},this._textures)u.textures[R]=this._textures[R].serialize();for(R in u.textureArrays={},this._textureArrays){u.textureArrays[R]=[];const I=this._textureArrays[R];for(let B=0;B<I.length;B++)u.textureArrays[R].push(I[B].serialize())}for(R in u.ints={},this._ints)u.ints[R]=this._ints[R];for(R in u.uints={},this._uints)u.uints[R]=this._uints[R];for(R in u.floats={},this._floats)u.floats[R]=this._floats[R];for(R in u.floatsArrays={},this._floatsArrays)u.floatsArrays[R]=this._floatsArrays[R];for(R in u.colors3={},this._colors3){const I=this._colors3[R];u.colors3[R]=[I.r,I.g,I.b]}for(R in u.colors3Arrays={},this._colors3Arrays)u.colors3Arrays[R]=this._colors3Arrays[R];for(R in u.colors4={},this._colors4){const I=this._colors4[R];u.colors4[R]=[I.r,I.g,I.b,I.a]}for(R in u.colors4Arrays={},this._colors4Arrays)u.colors4Arrays[R]=this._colors4Arrays[R];for(R in u.vectors2={},this._vectors2){const I=this._vectors2[R];u.vectors2[R]=[I.x,I.y]}for(R in u.vectors3={},this._vectors3){const I=this._vectors3[R];u.vectors3[R]=[I.x,I.y,I.z]}for(R in u.vectors4={},this._vectors4){const I=this._vectors4[R];u.vectors4[R]=[I.x,I.y,I.z,I.w]}for(R in u.quaternions={},this._quaternions)u.quaternions[R]=this._quaternions[R].sD();for(R in u.matrices={},this._matrices)u.matrices[R]=this._matrices[R].sD();for(R in u.matrixArray={},this._matrixArrays)u.matrixArray[R]=this._matrixArrays[R];for(R in u.matrices3x3={},this._matrices3x3)u.matrices3x3[R]=this._matrices3x3[R];for(R in u.matrices2x2={},this._matrices2x2)u.matrices2x2[R]=this._matrices2x2[R];for(R in u.vectors2Arrays={},this._vectors2Arrays)u.vectors2Arrays[R]=this._vectors2Arrays[R];for(R in u.vectors3Arrays={},this._vectors3Arrays)u.vectors3Arrays[R]=this._vectors3Arrays[R];for(R in u.vectors4Arrays={},this._vectors4Arrays)u.vectors4Arrays[R]=this._vectors4Arrays[R];for(R in u.quaternionsArrays={},this._quaternionsArrays)u.quaternionsArrays[R]=this._quaternionsArrays[R];return u}static Parse(u,R,I){const U=B.e.Parse((()=>new E(u.name,R,u.shaderPath,u.options,u.storeEffectOnSubMeshes)),u,R,I);let C;for(C in u.RD&&U.RD.parse(u.RD,R,I),u.textures)U.setTexture(C,D.b.Parse(u.textures[C],R,I));for(C in u.textureArrays){const B=u.textureArrays[C],K=[];for(let u=0;u<B.length;u++)K.push(D.b.Parse(B[u],R,I));U.setTextureArray(C,K)}for(C in u.ints)U.setInt(C,u.ints[C]);for(C in u.uints)U.setUInt(C,u.uints[C]);for(C in u.floats)U.setFloat(C,u.floats[C]);for(C in u.floatsArrays)U.setFloats(C,u.floatsArrays[C]);for(C in u.colors3){const R=u.colors3[C];U.setColor3(C,{r:R[0],g:R[1],b:R[2]})}for(C in u.colors3Arrays){const R=u.colors3Arrays[C].reduce(((u,R,I)=>(I%3===0?u.push([R]):u[u.length-1].push(R),u)),[]).map((u=>({r:u[0],g:u[1],b:u[2]})));U.setColor3Array(C,R)}for(C in u.colors4){const R=u.colors4[C];U.setColor4(C,{r:R[0],g:R[1],b:R[2],a:R[3]})}for(C in u.colors4Arrays){const R=u.colors4Arrays[C].reduce(((u,R,I)=>(I%4===0?u.push([R]):u[u.length-1].push(R),u)),[]).map((u=>({r:u[0],g:u[1],b:u[2],a:u[3]})));U.setColor4Array(C,R)}for(C in u.vectors2){const R=u.vectors2[C];U.setVector2(C,{x:R[0],y:R[1]})}for(C in u.vectors3){const R=u.vectors3[C];U.setVector3(C,{x:R[0],y:R[1],z:R[2]})}for(C in u.vectors4){const R=u.vectors4[C];U.setVector4(C,{x:R[0],y:R[1],z:R[2],w:R[3]})}for(C in u.quaternions)U.setQuaternion(C,K.Quaternion.TR(u.quaternions[C]));for(C in u.matrices)U.setMatrix(C,K.Matrix.TR(u.matrices[C]));for(C in u.matrixArray)U._matrixArrays[C]=new Float32Array(u.matrixArray[C]);for(C in u.matrices3x3)U.setMatrix3x3(C,u.matrices3x3[C]);for(C in u.matrices2x2)U.setMatrix2x2(C,u.matrices2x2[C]);for(C in u.vectors2Arrays)U.setArray2(C,u.vectors2Arrays[C]);for(C in u.vectors3Arrays)U.setArray3(C,u.vectors3Arrays[C]);for(C in u.vectors4Arrays)U.setArray4(C,u.vectors4Arrays[C]);for(C in u.quaternionsArrays)U.setArray4(C,u.quaternionsArrays[C]);return U}static async ParseFromFileAsync(u,R,I){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((U,K)=>{const C=new G.c;C.addEventListener("readystatechange",(()=>{if(4==C.readyState)if(200==C.status){const R=JSON.parse(C.responseText),K=this.Parse(R,I||b.e.LastCreatedScene,B);u&&(K.name=u),U(K)}else K("Unable to load the ShaderMaterial")})),C.open("GET",R),C.send()}))}static async ParseFromSnippetAsync(u,R){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((B,U)=>{const K=new G.c;K.addEventListener("readystatechange",(()=>{if(4==K.readyState)if(200==K.status){const U=JSON.parse(JSON.parse(K.responseText).jsonPayload),C=JSON.parse(U.shaderMaterial),D=this.Parse(C,R||b.e.LastCreatedScene,I);D.snippetId=u,B(D)}else U("Unable to load the snippet "+u)})),K.open("GET",this.SnippetUrl+"/"+u.replace(/#/g,"/")),K.send()}))}}E.SnippetUrl="https://snippet.babylonjs.com",E.CreateFromSnippetAsync=E.ParseFromSnippetAsync,(0,s.e)("BABYLON.ShaderMaterial",E)}}]);