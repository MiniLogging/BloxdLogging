"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[22],{13068:(Y,b,C)=>{C.r(b),C.d(b,{ShaderMaterial:()=>I});var R=C(12870),q=C(13077),A=C(12831),E=C(12903),B=C(12814),g=C(12790),r=C(13128),O=C(12696),F=C(13137),y=C(12702),S=C(13187),n=C(13181);const t={effect:null,subMesh:null};class I extends F.c{constructor(Y,b,C){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(Y,b,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new A.Matrix,this._cachedWorldViewProjectionMatrix=new A.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=C,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...R}}get shaderPath(){return this._shaderPath}set shaderPath(Y){this._shaderPath=Y}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(Y){-1===this._options.uniforms.indexOf(Y)&&this._options.uniforms.push(Y)}setTexture(Y,b){return-1===this._options.samplers.indexOf(Y)&&this._options.samplers.push(Y),this._textures[Y]=b,this}removeTexture(Y){delete this._textures[Y]}setTextureArray(Y,b){return-1===this._options.samplers.indexOf(Y)&&this._options.samplers.push(Y),this._checkUniform(Y),this._textureArrays[Y]=b,this}setExternalTexture(Y,b){return-1===this._options.externalTextures.indexOf(Y)&&this._options.externalTextures.push(Y),this._externalTextures[Y]=b,this}setFloat(Y,b){return this._checkUniform(Y),this._floats[Y]=b,this}setInt(Y,b){return this._checkUniform(Y),this._ints[Y]=b,this}setUInt(Y,b){return this._checkUniform(Y),this._uints[Y]=b,this}setFloats(Y,b){return this._checkUniform(Y),this._floatsArrays[Y]=b,this}setColor3(Y,b){return this._checkUniform(Y),this._colors3[Y]=b,this}setColor3Array(Y,b){return this._checkUniform(Y),this._colors3Arrays[Y]=b.reduce(((Y,b)=>(Y.push(b.r,b.g,b.b),Y)),[]),this}setColor4(Y,b){return this._checkUniform(Y),this._colors4[Y]=b,this}setColor4Array(Y,b){return this._checkUniform(Y),this._colors4Arrays[Y]=b.reduce(((Y,b)=>(Y.push(b.r,b.g,b.b,b.a),Y)),[]),this}setVector2(Y,b){return this._checkUniform(Y),this._vectors2[Y]=b,this}setVector3(Y,b){return this._checkUniform(Y),this._vectors3[Y]=b,this}setVector4(Y,b){return this._checkUniform(Y),this._vectors4[Y]=b,this}setQuaternion(Y,b){return this._checkUniform(Y),this._quaternions[Y]=b,this}setQuaternionArray(Y,b){return this._checkUniform(Y),this._quaternionsArrays[Y]=b.reduce(((Y,b)=>(b.toArray(Y,Y.length),Y)),[]),this}setMatrix(Y,b){return this._checkUniform(Y),this._matrices[Y]=b,this}setMatrices(Y,b){this._checkUniform(Y);const C=new Float32Array(16*b.length);for(let R=0;R<b.length;R++){b[R].copyToArray(C,16*R)}return this._matrixArrays[Y]=C,this}setMatrix3x3(Y,b){return this._checkUniform(Y),this._matrices3x3[Y]=b,this}setMatrix2x2(Y,b){return this._checkUniform(Y),this._matrices2x2[Y]=b,this}setArray2(Y,b){return this._checkUniform(Y),this._vectors2Arrays[Y]=b,this}setArray3(Y,b){return this._checkUniform(Y),this._vectors3Arrays[Y]=b,this}setArray4(Y,b){return this._checkUniform(Y),this._vectors4Arrays[Y]=b,this}setUniformBuffer(Y,b){return-1===this._options.uniformBuffers.indexOf(Y)&&this._options.uniformBuffers.push(Y),this._uniformBuffers[Y]=b,this}setTextureSampler(Y,b){return-1===this._options.samplerObjects.indexOf(Y)&&this._options.samplerObjects.push(Y),this._textureSamplers[Y]=b,this}setStorageBuffer(Y,b){return-1===this._options.storageBuffers.indexOf(Y)&&this._options.storageBuffers.push(Y),this._storageBuffers[Y]=b,this}setDefine(Y,b){const C=Y.trimEnd()+" ",R=this.options.defines.findIndex((b=>b===Y||b.startsWith(C)));return R>=0&&this.options.defines.splice(R,1),("boolean"!==typeof b||b)&&this.options.defines.push(C+b),this}isReadyForSubMesh(Y,b,C){return this.isReady(Y,C,b)}isReady(Y,b,C){var R;const A=C&&this._storeEffectOnSubMeshes;if(this.isFrozen){const Y=A?C._drawWrapper:this._drawWrapper;if(Y.effect&&Y._wasPreviouslyReady&&Y._wasPreviouslyUsingInstances===b)return!0}const B=this.uY(),g=B.getEngine(),O=[],F=[];let y=null,I=this._shaderPath,w=this._options.uniforms,Q=this._options.uniformBuffers,N=this._options.samplers;g.getCaps().multiview&&B.activeCamera&&B.activeCamera.outputRenderTarget&&B.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,O.push("#define MULTIVIEW"),-1!==w.indexOf("viewProjection")&&-1===w.indexOf("viewProjectionR")&&w.push("viewProjectionR"));for(let q=0;q<this._options.defines.length;q++){const Y=0===this._options.defines[q].indexOf("#define")?this._options.defines[q]:`#define ${this._options.defines[q]}`;O.push(Y)}for(let q=0;q<this._options.attributes.length;q++)F.push(this._options.attributes[q]);if(Y&&Y.isVerticesDataPresent(E.e.ColorKind)&&(-1===F.indexOf(E.e.ColorKind)&&F.push(E.e.ColorKind),O.push("#define VERTEXCOLOR")),b&&(O.push("#define INSTANCES"),(0,n.Z)(F,this._materialHelperNeedsPreviousMatrices),null!==Y&&void 0!==Y&&Y.hasThinInstances&&(O.push("#define THIN_INSTANCES"),Y&&Y.isVerticesDataPresent(E.e.ColorInstanceKind)&&(F.push(E.e.ColorInstanceKind),O.push("#define INSTANCESCOLOR")))),Y&&Y.useBones&&Y.computeBonesUsingShaders&&Y.skeleton){F.push(E.e.MatricesIndicesKind),F.push(E.e.MatricesWeightsKind),Y.numBoneInfluencers>4&&(F.push(E.e.MatricesIndicesExtraKind),F.push(E.e.MatricesWeightsExtraKind));const b=Y.skeleton;O.push("#define NUM_BONE_INFLUENCERS "+Y.numBoneInfluencers),y=new r.b,y.addCPUSkinningFallback(0,Y),b.isUsingTextureForMatrices?(O.push("#define BONETEXTURE"),-1===w.indexOf("boneTextureWidth")&&w.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(O.push("#define BonesPerMesh "+(b.bones.length+1)),-1===w.indexOf("mBones")&&w.push("mBones"))}else O.push("#define NUM_BONE_INFLUENCERS 0");let p=0;const mY=Y?Y.morphTargetManager:null;if(mY){const b=-1!==O.indexOf("#define UV1"),C=-1!==O.indexOf("#define UV2"),R=-1!==O.indexOf("#define TANGENT"),q=-1!==O.indexOf("#define NORMAL"),A=-1!==O.indexOf("#define VERTEXCOLOR");p=(0,n.G)(mY,O,F,Y,!0,q,R,b,C,A),mY.isUsingTextureForTargets&&(-1===w.indexOf("morphTargetTextureIndices")&&w.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),p>0&&(w=w.slice(),w.push("morphTargetInfluences"),w.push("morphTargetCount"),w.push("morphTargetTextureInfo"),w.push("morphTargetTextureIndices"))}else O.push("#define NUM_MORPH_INFLUENCERS 0");if(Y){const b=Y.bakedVertexAnimationManager;b&&b.isEnabled&&(O.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===w.indexOf("bakedVertexAnimationSettings")&&w.push("bakedVertexAnimationSettings"),-1===w.indexOf("bakedVertexAnimationTextureSizeInverted")&&w.push("bakedVertexAnimationTextureSizeInverted"),-1===w.indexOf("bakedVertexAnimationTime")&&w.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,n.y)(F,Y,O)}for(const q in this._textures)if(!this._textures[q].isReady())return!1;Y&&this.needAlphaTestingForMesh(Y)&&O.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,S.c)(w),(0,S.i)(this,B,O)),B.fogEnabled&&null!==Y&&void 0!==Y&&Y.applyFog&&B.fogMode!==q.b.FOGMODE_NONE&&(O.push("#define FOG"),-1===w.indexOf("view")&&w.push("view"),-1===w.indexOf("vFogInfos")&&w.push("vFogInfos"),-1===w.indexOf("vFogColor")&&w.push("vFogColor")),this._useLogarithmicDepth&&(O.push("#define LOGARITHMICDEPTH"),-1===w.indexOf("logarithmicDepthConstant")&&w.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(w=w.slice(),Q=Q.slice(),N=N.slice(),I=this.customShaderNameResolve(this.name,w,Q,N,O,F));const L=A?C._getDrawWrapper(void 0,!0):this._drawWrapper,u=(null===L||void 0===L?void 0:L.effect)??null,c=(null===L||void 0===L?void 0:L.defines)??null,l=O.join("\n");let X=u;return c!==l&&(X=g.createEffect(I,{attributes:F,uniformsNames:w,uniformBuffersNames:Q,samplers:N,defines:l,fallbacks:y,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:p},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},g),A?C.setEffect(X,l,this._materialContext):L&&L.setEffect(X,l),this._onEffectCreatedObservable&&(t.effect=X,t.subMesh=C??(null===Y||void 0===Y?void 0:Y.ub[0])??null,this._onEffectCreatedObservable.notifyObservers(t))),L._wasPreviouslyUsingInstances=!!b,!(null===(R=X)||void 0===R||!R.isReady())&&(u!==X&&B.resetCachedMaterial(),L._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(Y,b){const C=b??this.getEffect();if(!C)return;const R=this._options.uniforms;-1!==R.indexOf("world")&&C.setMatrix("world",Y);const q=this.uY();-1!==R.indexOf("worldView")&&(Y.multiplyToRef(q.getViewMatrix(),this._cachedWorldViewMatrix),C.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==R.indexOf("worldViewProjection")&&(Y.multiplyToRef(q.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),C.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==R.indexOf("view")&&C.setMatrix("view",q.getViewMatrix())}bindForSubMesh(Y,b,C){var R;this.bind(Y,b,null===(R=C._drawWrapperOverride)||void 0===R?void 0:R.effect,C)}bind(Y,b,C,R){const q=R&&this._storeEffectOnSubMeshes,A=C??(q?R.effect:this.getEffect());if(!A)return;const E=this.uY();this._activeEffect=A,this.bindOnlyWorldMatrix(Y,C);const B=this._options.uniformBuffers;let g=!1;if(A&&B&&B.length>0&&E.getEngine().supportsUniformBuffers)for(let F=0;F<B.length;++F){switch(B[F]){case"Mesh":b&&(b.getMeshUniformBuffer().bindToEffect(A,"Mesh"),b.transferToEffect(Y));break;case"Scene":(0,n.r)(A,E.getSceneUniformBuffer()),E.finalizeSceneUbo(),g=!0}}const r=b&&q?this._mustRebind(E,A,R,b.visibility):E.getCachedMaterial()!==this;if(A&&r){let Y;for(Y in g||-1===this._options.uniforms.indexOf("view")||A.setMatrix("view",E.getViewMatrix()),g||-1===this._options.uniforms.indexOf("projection")||A.setMatrix("projection",E.getProjectionMatrix()),g||-1===this._options.uniforms.indexOf("viewProjection")||(A.setMatrix("viewProjection",E.getTransformMatrix()),this._multiview&&A.setMatrix("viewProjectionR",E._transformMatrixR)),E.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&A.setVector3("cameraPosition",E.activeCamera.globalPosition),(0,n.e)(b,A),(0,S.g)(A,this,E),this._useLogarithmicDepth&&(0,n.n)(q?R.materialDefines:A.defines,A,E),b&&(0,n.h)(E,b,A),this._textures)A.setTexture(Y,this._textures[Y]);for(Y in this._textureArrays)A.setTextureArray(Y,this._textureArrays[Y]);for(Y in this._ints)A.setInt(Y,this._ints[Y]);for(Y in this._uints)A.setUInt(Y,this._uints[Y]);for(Y in this._floats)A.setFloat(Y,this._floats[Y]);for(Y in this._floatsArrays)A.setArray(Y,this._floatsArrays[Y]);for(Y in this._colors3)A.setColor3(Y,this._colors3[Y]);for(Y in this._colors3Arrays)A.setArray3(Y,this._colors3Arrays[Y]);for(Y in this._colors4){const b=this._colors4[Y];A.setFloat4(Y,b.r,b.g,b.b,b.a)}for(Y in this._colors4Arrays)A.setArray4(Y,this._colors4Arrays[Y]);for(Y in this._vectors2)A.setVector2(Y,this._vectors2[Y]);for(Y in this._vectors3)A.setVector3(Y,this._vectors3[Y]);for(Y in this._vectors4)A.setVector4(Y,this._vectors4[Y]);for(Y in this._quaternions)A.setQuaternion(Y,this._quaternions[Y]);for(Y in this._matrices)A.setMatrix(Y,this._matrices[Y]);for(Y in this._matrixArrays)A.setMatrices(Y,this._matrixArrays[Y]);for(Y in this._matrices3x3)A.setMatrix3x3(Y,this._matrices3x3[Y]);for(Y in this._matrices2x2)A.setMatrix2x2(Y,this._matrices2x2[Y]);for(Y in this._vectors2Arrays)A.setArray2(Y,this._vectors2Arrays[Y]);for(Y in this._vectors3Arrays)A.setArray3(Y,this._vectors3Arrays[Y]);for(Y in this._vectors4Arrays)A.setArray4(Y,this._vectors4Arrays[Y]);for(Y in this._quaternionsArrays)A.setArray4(Y,this._quaternionsArrays[Y]);for(Y in this._uniformBuffers){const b=this._uniformBuffers[Y].getBuffer();b&&A.bindUniformBuffer(b,Y)}const C=E.getEngine(),B=C.setExternalTexture;if(B)for(Y in this._externalTextures)B.call(C,Y,this._externalTextures[Y]);const r=C.setTextureSampler;if(r)for(Y in this._textureSamplers)r.call(C,Y,this._textureSamplers[Y]);const O=C.setStorageBuffer;if(O)for(Y in this._storageBuffers)O.call(C,Y,this._storageBuffers[Y])}if(A&&b&&(r||!this.isFrozen)){(0,n.o)(b,A),b.morphTargetManager&&b.morphTargetManager.isUsingTextureForTargets&&b.morphTargetManager._bind(A);const Y=b.bakedVertexAnimationManager;if(Y&&Y.isEnabled){var O;const Y=q?R._drawWrapper:this._drawWrapper;null===(O=b.bakedVertexAnimationManager)||void 0===O||O.bind(A,!!Y._wasPreviouslyUsingInstances)}}this._afterBind(b,A,R)}getActiveTextures(){const Y=super.getActiveTextures();for(const b in this._textures)Y.push(this._textures[b]);for(const b in this._textureArrays){const C=this._textureArrays[b];for(let b=0;b<C.length;b++)Y.push(C[b])}return Y}hasTexture(Y){if(super.hasTexture(Y))return!0;for(const b in this._textures)if(this._textures[b]===Y)return!0;for(const b in this._textureArrays){const C=this._textureArrays[b];for(let b=0;b<C.length;b++)if(C[b]===Y)return!0}return!1}clone(Y){const b=R.e.Clone((()=>new I(Y,this.uY(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);b.name=Y,b.id=Y,"object"===typeof b._shaderPath&&(b._shaderPath={...b._shaderPath}),this._options={...this._options};const C=Object.keys(this._options);for(const R of C){const Y=this._options[R];Array.isArray(Y)&&(this._options[R]=Y.slice(0))}this.nb.copyTo(b.nb);for(const R in this._textures)b.setTexture(R,this._textures[R]);for(const R in this._textureArrays)b.setTextureArray(R,this._textureArrays[R]);for(const R in this._externalTextures)b.setExternalTexture(R,this._externalTextures[R]);for(const R in this._ints)b.setInt(R,this._ints[R]);for(const R in this._uints)b.setUInt(R,this._uints[R]);for(const R in this._floats)b.setFloat(R,this._floats[R]);for(const R in this._floatsArrays)b.setFloats(R,this._floatsArrays[R]);for(const R in this._colors3)b.setColor3(R,this._colors3[R]);for(const R in this._colors3Arrays)b._colors3Arrays[R]=this._colors3Arrays[R];for(const R in this._colors4)b.setColor4(R,this._colors4[R]);for(const R in this._colors4Arrays)b._colors4Arrays[R]=this._colors4Arrays[R];for(const R in this._vectors2)b.setVector2(R,this._vectors2[R]);for(const R in this._vectors3)b.setVector3(R,this._vectors3[R]);for(const R in this._vectors4)b.setVector4(R,this._vectors4[R]);for(const R in this._quaternions)b.setQuaternion(R,this._quaternions[R]);for(const R in this._quaternionsArrays)b._quaternionsArrays[R]=this._quaternionsArrays[R];for(const R in this._matrices)b.setMatrix(R,this._matrices[R]);for(const R in this._matrixArrays)b._matrixArrays[R]=this._matrixArrays[R].slice();for(const R in this._matrices3x3)b.setMatrix3x3(R,this._matrices3x3[R]);for(const R in this._matrices2x2)b.setMatrix2x2(R,this._matrices2x2[R]);for(const R in this._vectors2Arrays)b.setArray2(R,this._vectors2Arrays[R]);for(const R in this._vectors3Arrays)b.setArray3(R,this._vectors3Arrays[R]);for(const R in this._vectors4Arrays)b.setArray4(R,this._vectors4Arrays[R]);for(const R in this._uniformBuffers)b.setUniformBuffer(R,this._uniformBuffers[R]);for(const R in this._textureSamplers)b.setTextureSampler(R,this._textureSamplers[R]);for(const R in this._storageBuffers)b.setStorageBuffer(R,this._storageBuffers[R]);return b}dispose(Y,b,C){if(b){let Y;for(Y in this._textures)this._textures[Y].dispose();for(Y in this._textureArrays){const b=this._textureArrays[Y];for(let Y=0;Y<b.length;Y++)b[Y].dispose()}}this._textures={},super.dispose(Y,b,C)}serialize(){const Y=R.e.Serialize(this);let b;for(b in Y.customType="BABYLON.ShaderMaterial",Y.uniqueId=this.uniqueId,Y.options=this._options,Y.shaderPath=this._shaderPath,Y.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,Y.nb=this.nb.serialize(),Y.textures={},this._textures)Y.textures[b]=this._textures[b].serialize();for(b in Y.textureArrays={},this._textureArrays){Y.textureArrays[b]=[];const C=this._textureArrays[b];for(let R=0;R<C.length;R++)Y.textureArrays[b].push(C[R].serialize())}for(b in Y.ints={},this._ints)Y.ints[b]=this._ints[b];for(b in Y.uints={},this._uints)Y.uints[b]=this._uints[b];for(b in Y.floats={},this._floats)Y.floats[b]=this._floats[b];for(b in Y.floatsArrays={},this._floatsArrays)Y.floatsArrays[b]=this._floatsArrays[b];for(b in Y.colors3={},this._colors3){const C=this._colors3[b];Y.colors3[b]=[C.r,C.g,C.b]}for(b in Y.colors3Arrays={},this._colors3Arrays)Y.colors3Arrays[b]=this._colors3Arrays[b];for(b in Y.colors4={},this._colors4){const C=this._colors4[b];Y.colors4[b]=[C.r,C.g,C.b,C.a]}for(b in Y.colors4Arrays={},this._colors4Arrays)Y.colors4Arrays[b]=this._colors4Arrays[b];for(b in Y.vectors2={},this._vectors2){const C=this._vectors2[b];Y.vectors2[b]=[C.x,C.y]}for(b in Y.vectors3={},this._vectors3){const C=this._vectors3[b];Y.vectors3[b]=[C.x,C.y,C.z]}for(b in Y.vectors4={},this._vectors4){const C=this._vectors4[b];Y.vectors4[b]=[C.x,C.y,C.z,C.w]}for(b in Y.quaternions={},this._quaternions)Y.quaternions[b]=this._quaternions[b].cb();for(b in Y.matrices={},this._matrices)Y.matrices[b]=this._matrices[b].cb();for(b in Y.matrixArray={},this._matrixArrays)Y.matrixArray[b]=this._matrixArrays[b];for(b in Y.matrices3x3={},this._matrices3x3)Y.matrices3x3[b]=this._matrices3x3[b];for(b in Y.matrices2x2={},this._matrices2x2)Y.matrices2x2[b]=this._matrices2x2[b];for(b in Y.vectors2Arrays={},this._vectors2Arrays)Y.vectors2Arrays[b]=this._vectors2Arrays[b];for(b in Y.vectors3Arrays={},this._vectors3Arrays)Y.vectors3Arrays[b]=this._vectors3Arrays[b];for(b in Y.vectors4Arrays={},this._vectors4Arrays)Y.vectors4Arrays[b]=this._vectors4Arrays[b];for(b in Y.quaternionsArrays={},this._quaternionsArrays)Y.quaternionsArrays[b]=this._quaternionsArrays[b];return Y}static Parse(Y,b,C){const q=R.e.Parse((()=>new I(Y.name,b,Y.shaderPath,Y.options,Y.storeEffectOnSubMeshes)),Y,b,C);let E;for(E in Y.nb&&q.nb.parse(Y.nb,b,C),Y.textures)q.setTexture(E,B.b.Parse(Y.textures[E],b,C));for(E in Y.textureArrays){const R=Y.textureArrays[E],A=[];for(let Y=0;Y<R.length;Y++)A.push(B.b.Parse(R[Y],b,C));q.setTextureArray(E,A)}for(E in Y.ints)q.setInt(E,Y.ints[E]);for(E in Y.uints)q.setUInt(E,Y.uints[E]);for(E in Y.floats)q.setFloat(E,Y.floats[E]);for(E in Y.floatsArrays)q.setFloats(E,Y.floatsArrays[E]);for(E in Y.colors3){const b=Y.colors3[E];q.setColor3(E,{r:b[0],g:b[1],b:b[2]})}for(E in Y.colors3Arrays){const b=Y.colors3Arrays[E].reduce(((Y,b,C)=>(C%3===0?Y.push([b]):Y[Y.length-1].push(b),Y)),[]).map((Y=>({r:Y[0],g:Y[1],b:Y[2]})));q.setColor3Array(E,b)}for(E in Y.colors4){const b=Y.colors4[E];q.setColor4(E,{r:b[0],g:b[1],b:b[2],a:b[3]})}for(E in Y.colors4Arrays){const b=Y.colors4Arrays[E].reduce(((Y,b,C)=>(C%4===0?Y.push([b]):Y[Y.length-1].push(b),Y)),[]).map((Y=>({r:Y[0],g:Y[1],b:Y[2],a:Y[3]})));q.setColor4Array(E,b)}for(E in Y.vectors2){const b=Y.vectors2[E];q.setVector2(E,{x:b[0],y:b[1]})}for(E in Y.vectors3){const b=Y.vectors3[E];q.setVector3(E,{x:b[0],y:b[1],z:b[2]})}for(E in Y.vectors4){const b=Y.vectors4[E];q.setVector4(E,{x:b[0],y:b[1],z:b[2],w:b[3]})}for(E in Y.quaternions)q.setQuaternion(E,A.Quaternion.OC(Y.quaternions[E]));for(E in Y.matrices)q.setMatrix(E,A.Matrix.OC(Y.matrices[E]));for(E in Y.matrixArray)q._matrixArrays[E]=new Float32Array(Y.matrixArray[E]);for(E in Y.matrices3x3)q.setMatrix3x3(E,Y.matrices3x3[E]);for(E in Y.matrices2x2)q.setMatrix2x2(E,Y.matrices2x2[E]);for(E in Y.vectors2Arrays)q.setArray2(E,Y.vectors2Arrays[E]);for(E in Y.vectors3Arrays)q.setArray3(E,Y.vectors3Arrays[E]);for(E in Y.vectors4Arrays)q.setArray4(E,Y.vectors4Arrays[E]);for(E in Y.quaternionsArrays)q.setArray4(E,Y.quaternionsArrays[E]);return q}static async ParseFromFileAsync(Y,b,C){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((q,A)=>{const E=new O.e;E.addEventListener("readystatechange",(()=>{if(4==E.readyState)if(200==E.status){const b=JSON.parse(E.responseText),A=this.Parse(b,C||y.d.LastCreatedScene,R);Y&&(A.name=Y),q(A)}else A("Unable to load the ShaderMaterial")})),E.open("GET",b),E.send()}))}static async ParseFromSnippetAsync(Y,b){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((R,q)=>{const A=new O.e;A.addEventListener("readystatechange",(()=>{if(4==A.readyState)if(200==A.status){const q=JSON.parse(JSON.parse(A.responseText).jsonPayload),E=JSON.parse(q.shaderMaterial),B=this.Parse(E,b||y.d.LastCreatedScene,C);B.snippetId=Y,R(B)}else q("Unable to load the snippet "+Y)})),A.open("GET",this.SnippetUrl+"/"+Y.replace(/#/g,"/")),A.send()}))}}I.SnippetUrl="https://snippet.babylonjs.com",I.CreateFromSnippetAsync=I.ParseFromSnippetAsync,(0,g.g)("BABYLON.ShaderMaterial",I)}}]);