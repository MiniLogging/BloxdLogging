"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[22],{13211:(I,x,L)=>{L.r(x),L.d(x,{ShaderMaterial:()=>H});var F=L(13012),X=L(13218),G=L(12983),Y=L(13048),p=L(12965),B=L(12938),l=L(13293),W=L(12832),Q=L(13295),e=L(12840),g=L(13340),v=L(13336);const z={effect:null,subMesh:null};class H extends Q.c{constructor(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(I,x,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new G.Matrix,this._cachedWorldViewProjectionMatrix=new G.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=L,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...F}}get shaderPath(){return this._shaderPath}set shaderPath(I){this._shaderPath=I}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(I){-1===this._options.uniforms.indexOf(I)&&this._options.uniforms.push(I)}setTexture(I,x){return-1===this._options.samplers.indexOf(I)&&this._options.samplers.push(I),this._textures[I]=x,this}removeTexture(I){delete this._textures[I]}setTextureArray(I,x){return-1===this._options.samplers.indexOf(I)&&this._options.samplers.push(I),this._checkUniform(I),this._textureArrays[I]=x,this}setExternalTexture(I,x){return-1===this._options.externalTextures.indexOf(I)&&this._options.externalTextures.push(I),this._externalTextures[I]=x,this}setFloat(I,x){return this._checkUniform(I),this._floats[I]=x,this}setInt(I,x){return this._checkUniform(I),this._ints[I]=x,this}setUInt(I,x){return this._checkUniform(I),this._uints[I]=x,this}setFloats(I,x){return this._checkUniform(I),this._floatsArrays[I]=x,this}setColor3(I,x){return this._checkUniform(I),this._colors3[I]=x,this}setColor3Array(I,x){return this._checkUniform(I),this._colors3Arrays[I]=x.reduce(((I,x)=>(I.push(x.r,x.g,x.b),I)),[]),this}setColor4(I,x){return this._checkUniform(I),this._colors4[I]=x,this}setColor4Array(I,x){return this._checkUniform(I),this._colors4Arrays[I]=x.reduce(((I,x)=>(I.push(x.r,x.g,x.b,x.a),I)),[]),this}setVector2(I,x){return this._checkUniform(I),this._vectors2[I]=x,this}setVector3(I,x){return this._checkUniform(I),this._vectors3[I]=x,this}setVector4(I,x){return this._checkUniform(I),this._vectors4[I]=x,this}setQuaternion(I,x){return this._checkUniform(I),this._quaternions[I]=x,this}setQuaternionArray(I,x){return this._checkUniform(I),this._quaternionsArrays[I]=x.reduce(((I,x)=>(x.toArray(I,I.length),I)),[]),this}setMatrix(I,x){return this._checkUniform(I),this._matrices[I]=x,this}setMatrices(I,x){this._checkUniform(I);const L=new Float32Array(16*x.length);for(let F=0;F<x.length;F++){x[F].copyToArray(L,16*F)}return this._matrixArrays[I]=L,this}setMatrix3x3(I,x){return this._checkUniform(I),this._matrices3x3[I]=x,this}setMatrix2x2(I,x){return this._checkUniform(I),this._matrices2x2[I]=x,this}setArray2(I,x){return this._checkUniform(I),this._vectors2Arrays[I]=x,this}setArray3(I,x){return this._checkUniform(I),this._vectors3Arrays[I]=x,this}setArray4(I,x){return this._checkUniform(I),this._vectors4Arrays[I]=x,this}setUniformBuffer(I,x){return-1===this._options.uniformBuffers.indexOf(I)&&this._options.uniformBuffers.push(I),this._uniformBuffers[I]=x,this}setTextureSampler(I,x){return-1===this._options.samplerObjects.indexOf(I)&&this._options.samplerObjects.push(I),this._textureSamplers[I]=x,this}setStorageBuffer(I,x){return-1===this._options.storageBuffers.indexOf(I)&&this._options.storageBuffers.push(I),this._storageBuffers[I]=x,this}setDefine(I,x){const L=I.trimEnd()+" ",F=this.options.defines.findIndex((x=>x===I||x.startsWith(L)));return F>=0&&this.options.defines.splice(F,1),("boolean"!==typeof x||x)&&this.options.defines.push(L+x),this}isReadyForSubMesh(I,x,L){return this.isReady(I,L,x)}isReady(I,x,L){var F;const G=L&&this._storeEffectOnSubMeshes;if(this.isFrozen){const I=G?L._drawWrapper:this._drawWrapper;if(I.effect&&I._wasPreviouslyReady&&I._wasPreviouslyUsingInstances===x)return!0}const p=this.tI(),B=p.getEngine(),W=[],Q=[];let e=null,H=this._shaderPath,s=this._options.uniforms,U=this._options.uniformBuffers,q=this._options.samplers;B.getCaps().multiview&&p.activeCamera&&p.activeCamera.outputRenderTarget&&p.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,W.push("#define MULTIVIEW"),-1!==s.indexOf("viewProjection")&&-1===s.indexOf("viewProjectionR")&&s.push("viewProjectionR"));for(let X=0;X<this._options.defines.length;X++){const I=0===this._options.defines[X].indexOf("#define")?this._options.defines[X]:`#define ${this._options.defines[X]}`;W.push(I)}for(let X=0;X<this._options.attributes.length;X++)Q.push(this._options.attributes[X]);if(I&&I.isVerticesDataPresent(Y.g.ColorKind)&&(-1===Q.indexOf(Y.g.ColorKind)&&Q.push(Y.g.ColorKind),W.push("#define VERTEXCOLOR")),x&&(W.push("#define INSTANCES"),(0,v.eb)(Q,this._materialHelperNeedsPreviousMatrices),null!==I&&void 0!==I&&I.hasThinInstances&&(W.push("#define THIN_INSTANCES"),I&&I.isVerticesDataPresent(Y.g.ColorInstanceKind)&&(Q.push(Y.g.ColorInstanceKind),W.push("#define INSTANCESCOLOR")))),I&&I.useBones&&I.computeBonesUsingShaders&&I.skeleton){Q.push(Y.g.MatricesIndicesKind),Q.push(Y.g.MatricesWeightsKind),I.numBoneInfluencers>4&&(Q.push(Y.g.MatricesIndicesExtraKind),Q.push(Y.g.MatricesWeightsExtraKind));const x=I.skeleton;W.push("#define NUM_BONE_INFLUENCERS "+I.numBoneInfluencers),e=new l.e,e.addCPUSkinningFallback(0,I),x.isUsingTextureForMatrices?(W.push("#define BONETEXTURE"),-1===s.indexOf("boneTextureWidth")&&s.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(W.push("#define BonesPerMesh "+(x.bones.length+1)),-1===s.indexOf("mBones")&&s.push("mBones"))}else W.push("#define NUM_BONE_INFLUENCERS 0");let y=0;const T=I?I.morphTargetManager:null;if(T){const x=-1!==W.indexOf("#define UV1"),L=-1!==W.indexOf("#define UV2"),F=-1!==W.indexOf("#define TANGENT"),X=-1!==W.indexOf("#define NORMAL"),G=-1!==W.indexOf("#define VERTEXCOLOR");y=(0,v.H)(T,W,Q,I,!0,X,F,x,L,G),T.isUsingTextureForTargets&&(-1===s.indexOf("morphTargetTextureIndices")&&s.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),y>0&&(s=s.slice(),s.push("morphTargetInfluences"),s.push("morphTargetCount"),s.push("morphTargetTextureInfo"),s.push("morphTargetTextureIndices"))}else W.push("#define NUM_MORPH_INFLUENCERS 0");if(I){const x=I.bakedVertexAnimationManager;x&&x.isEnabled&&(W.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===s.indexOf("bakedVertexAnimationSettings")&&s.push("bakedVertexAnimationSettings"),-1===s.indexOf("bakedVertexAnimationTextureSizeInverted")&&s.push("bakedVertexAnimationTextureSizeInverted"),-1===s.indexOf("bakedVertexAnimationTime")&&s.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,v.t)(Q,I,W)}for(const X in this._textures)if(!this._textures[X].isReady())return!1;I&&this.needAlphaTestingForMesh(I)&&W.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,g.d)(s),(0,g.j)(this,p,W)),p.fogEnabled&&null!==I&&void 0!==I&&I.applyFog&&p.fogMode!==X.b.FOGMODE_NONE&&(W.push("#define FOG"),-1===s.indexOf("view")&&s.push("view"),-1===s.indexOf("vFogInfos")&&s.push("vFogInfos"),-1===s.indexOf("vFogColor")&&s.push("vFogColor")),this._useLogarithmicDepth&&(W.push("#define LOGARITHMICDEPTH"),-1===s.indexOf("logarithmicDepthConstant")&&s.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(s=s.slice(),U=U.slice(),q=q.slice(),H=this.customShaderNameResolve(this.name,s,U,q,W,Q));const Z=G?L._getDrawWrapper(void 0,!0):this._drawWrapper,t=(null===Z||void 0===Z?void 0:Z.effect)??null,f=(null===Z||void 0===Z?void 0:Z.defines)??null,R=W.join("\n");let n=t;return f!==R&&(n=B.createEffect(H,{attributes:Q,uniformsNames:s,uniformBuffersNames:U,samplers:q,defines:R,fallbacks:e,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:y},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},B),G?L.setEffect(n,R,this._materialContext):Z&&Z.setEffect(n,R),this._onEffectCreatedObservable&&(z.effect=n,z.subMesh=L??(null===I||void 0===I?void 0:I.jp[0])??null,this._onEffectCreatedObservable.notifyObservers(z))),Z._wasPreviouslyUsingInstances=!!x,!(null===(F=n)||void 0===F||!F.isReady())&&(t!==n&&p.resetCachedMaterial(),Z._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(I,x){const L=x??this.getEffect();if(!L)return;const F=this._options.uniforms;-1!==F.indexOf("world")&&L.setMatrix("world",I);const X=this.tI();-1!==F.indexOf("worldView")&&(I.multiplyToRef(X.getViewMatrix(),this._cachedWorldViewMatrix),L.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==F.indexOf("worldViewProjection")&&(I.multiplyToRef(X.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),L.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==F.indexOf("view")&&L.setMatrix("view",X.getViewMatrix())}bindForSubMesh(I,x,L){var F;this.bind(I,x,null===(F=L._drawWrapperOverride)||void 0===F?void 0:F.effect,L)}bind(I,x,L,F){const X=F&&this._storeEffectOnSubMeshes,G=L??(X?F.effect:this.getEffect());if(!G)return;const Y=this.tI();this._activeEffect=G,this.bindOnlyWorldMatrix(I,L);const p=this._options.uniformBuffers;let B=!1;if(G&&p&&p.length>0&&Y.getEngine().supportsUniformBuffers)for(let Q=0;Q<p.length;++Q){switch(p[Q]){case"Mesh":x&&(x.getMeshUniformBuffer().bindToEffect(G,"Mesh"),x.transferToEffect(I));break;case"Scene":(0,v.j)(G,Y.getSceneUniformBuffer()),Y.finalizeSceneUbo(),B=!0}}const l=x&&X?this._mustRebind(Y,G,F,x.visibility):Y.getCachedMaterial()!==this;if(G&&l){let I;for(I in B||-1===this._options.uniforms.indexOf("view")||G.setMatrix("view",Y.getViewMatrix()),B||-1===this._options.uniforms.indexOf("projection")||G.setMatrix("projection",Y.getProjectionMatrix()),B||-1===this._options.uniforms.indexOf("viewProjection")||(G.setMatrix("viewProjection",Y.getTransformMatrix()),this._multiview&&G.setMatrix("viewProjectionR",Y._transformMatrixR)),Y.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&G.setVector3("cameraPosition",Y.activeCamera.globalPosition),(0,v.c)(x,G),(0,g.e)(G,this,Y),this._useLogarithmicDepth&&(0,v.g)(X?F.materialDefines:G.defines,G,Y),x&&(0,v.e)(Y,x,G),this._textures)G.setTexture(I,this._textures[I]);for(I in this._textureArrays)G.setTextureArray(I,this._textureArrays[I]);for(I in this._ints)G.setInt(I,this._ints[I]);for(I in this._uints)G.setUInt(I,this._uints[I]);for(I in this._floats)G.setFloat(I,this._floats[I]);for(I in this._floatsArrays)G.setArray(I,this._floatsArrays[I]);for(I in this._colors3)G.setColor3(I,this._colors3[I]);for(I in this._colors3Arrays)G.setArray3(I,this._colors3Arrays[I]);for(I in this._colors4){const x=this._colors4[I];G.setFloat4(I,x.r,x.g,x.b,x.a)}for(I in this._colors4Arrays)G.setArray4(I,this._colors4Arrays[I]);for(I in this._vectors2)G.setVector2(I,this._vectors2[I]);for(I in this._vectors3)G.setVector3(I,this._vectors3[I]);for(I in this._vectors4)G.setVector4(I,this._vectors4[I]);for(I in this._quaternions)G.setQuaternion(I,this._quaternions[I]);for(I in this._matrices)G.setMatrix(I,this._matrices[I]);for(I in this._matrixArrays)G.setMatrices(I,this._matrixArrays[I]);for(I in this._matrices3x3)G.setMatrix3x3(I,this._matrices3x3[I]);for(I in this._matrices2x2)G.setMatrix2x2(I,this._matrices2x2[I]);for(I in this._vectors2Arrays)G.setArray2(I,this._vectors2Arrays[I]);for(I in this._vectors3Arrays)G.setArray3(I,this._vectors3Arrays[I]);for(I in this._vectors4Arrays)G.setArray4(I,this._vectors4Arrays[I]);for(I in this._quaternionsArrays)G.setArray4(I,this._quaternionsArrays[I]);for(I in this._uniformBuffers){const x=this._uniformBuffers[I].getBuffer();x&&G.bindUniformBuffer(x,I)}const L=Y.getEngine(),p=L.setExternalTexture;if(p)for(I in this._externalTextures)p.call(L,I,this._externalTextures[I]);const l=L.setTextureSampler;if(l)for(I in this._textureSamplers)l.call(L,I,this._textureSamplers[I]);const W=L.setStorageBuffer;if(W)for(I in this._storageBuffers)W.call(L,I,this._storageBuffers[I])}if(G&&x&&(l||!this.isFrozen)){(0,v.i)(x,G),x.morphTargetManager&&x.morphTargetManager.isUsingTextureForTargets&&x.morphTargetManager._bind(G);const I=x.bakedVertexAnimationManager;if(I&&I.isEnabled){var W;const I=X?F._drawWrapper:this._drawWrapper;null===(W=x.bakedVertexAnimationManager)||void 0===W||W.bind(G,!!I._wasPreviouslyUsingInstances)}}this._afterBind(x,G,F)}getActiveTextures(){const I=super.getActiveTextures();for(const x in this._textures)I.push(this._textures[x]);for(const x in this._textureArrays){const L=this._textureArrays[x];for(let x=0;x<L.length;x++)I.push(L[x])}return I}hasTexture(I){if(super.hasTexture(I))return!0;for(const x in this._textures)if(this._textures[x]===I)return!0;for(const x in this._textureArrays){const L=this._textureArrays[x];for(let x=0;x<L.length;x++)if(L[x]===I)return!0}return!1}clone(I){const x=F.c.Clone((()=>new H(I,this.tI(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);x.name=I,x.id=I,"object"===typeof x._shaderPath&&(x._shaderPath={...x._shaderPath}),this._options={...this._options};const L=Object.keys(this._options);for(const F of L){const I=this._options[F];Array.isArray(I)&&(this._options[F]=I.slice(0))}this.op.copyTo(x.op);for(const F in this._textures)x.setTexture(F,this._textures[F]);for(const F in this._textureArrays)x.setTextureArray(F,this._textureArrays[F]);for(const F in this._externalTextures)x.setExternalTexture(F,this._externalTextures[F]);for(const F in this._ints)x.setInt(F,this._ints[F]);for(const F in this._uints)x.setUInt(F,this._uints[F]);for(const F in this._floats)x.setFloat(F,this._floats[F]);for(const F in this._floatsArrays)x.setFloats(F,this._floatsArrays[F]);for(const F in this._colors3)x.setColor3(F,this._colors3[F]);for(const F in this._colors3Arrays)x._colors3Arrays[F]=this._colors3Arrays[F];for(const F in this._colors4)x.setColor4(F,this._colors4[F]);for(const F in this._colors4Arrays)x._colors4Arrays[F]=this._colors4Arrays[F];for(const F in this._vectors2)x.setVector2(F,this._vectors2[F]);for(const F in this._vectors3)x.setVector3(F,this._vectors3[F]);for(const F in this._vectors4)x.setVector4(F,this._vectors4[F]);for(const F in this._quaternions)x.setQuaternion(F,this._quaternions[F]);for(const F in this._quaternionsArrays)x._quaternionsArrays[F]=this._quaternionsArrays[F];for(const F in this._matrices)x.setMatrix(F,this._matrices[F]);for(const F in this._matrixArrays)x._matrixArrays[F]=this._matrixArrays[F].slice();for(const F in this._matrices3x3)x.setMatrix3x3(F,this._matrices3x3[F]);for(const F in this._matrices2x2)x.setMatrix2x2(F,this._matrices2x2[F]);for(const F in this._vectors2Arrays)x.setArray2(F,this._vectors2Arrays[F]);for(const F in this._vectors3Arrays)x.setArray3(F,this._vectors3Arrays[F]);for(const F in this._vectors4Arrays)x.setArray4(F,this._vectors4Arrays[F]);for(const F in this._uniformBuffers)x.setUniformBuffer(F,this._uniformBuffers[F]);for(const F in this._textureSamplers)x.setTextureSampler(F,this._textureSamplers[F]);for(const F in this._storageBuffers)x.setStorageBuffer(F,this._storageBuffers[F]);return x}dispose(I,x,L){if(x){let I;for(I in this._textures)this._textures[I].dispose();for(I in this._textureArrays){const x=this._textureArrays[I];for(let I=0;I<x.length;I++)x[I].dispose()}}this._textures={},super.dispose(I,x,L)}serialize(){const I=F.c.Serialize(this);let x;for(x in I.customType="BABYLON.ShaderMaterial",I.uniqueId=this.uniqueId,I.options=this._options,I.shaderPath=this._shaderPath,I.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,I.op=this.op.serialize(),I.textures={},this._textures)I.textures[x]=this._textures[x].serialize();for(x in I.textureArrays={},this._textureArrays){I.textureArrays[x]=[];const L=this._textureArrays[x];for(let F=0;F<L.length;F++)I.textureArrays[x].push(L[F].serialize())}for(x in I.ints={},this._ints)I.ints[x]=this._ints[x];for(x in I.uints={},this._uints)I.uints[x]=this._uints[x];for(x in I.floats={},this._floats)I.floats[x]=this._floats[x];for(x in I.floatsArrays={},this._floatsArrays)I.floatsArrays[x]=this._floatsArrays[x];for(x in I.colors3={},this._colors3){const L=this._colors3[x];I.colors3[x]=[L.r,L.g,L.b]}for(x in I.colors3Arrays={},this._colors3Arrays)I.colors3Arrays[x]=this._colors3Arrays[x];for(x in I.colors4={},this._colors4){const L=this._colors4[x];I.colors4[x]=[L.r,L.g,L.b,L.a]}for(x in I.colors4Arrays={},this._colors4Arrays)I.colors4Arrays[x]=this._colors4Arrays[x];for(x in I.vectors2={},this._vectors2){const L=this._vectors2[x];I.vectors2[x]=[L.x,L.y]}for(x in I.vectors3={},this._vectors3){const L=this._vectors3[x];I.vectors3[x]=[L.x,L.y,L.z]}for(x in I.vectors4={},this._vectors4){const L=this._vectors4[x];I.vectors4[x]=[L.x,L.y,L.z,L.w]}for(x in I.quaternions={},this._quaternions)I.quaternions[x]=this._quaternions[x].Cp();for(x in I.matrices={},this._matrices)I.matrices[x]=this._matrices[x].Cp();for(x in I.matrixArray={},this._matrixArrays)I.matrixArray[x]=this._matrixArrays[x];for(x in I.matrices3x3={},this._matrices3x3)I.matrices3x3[x]=this._matrices3x3[x];for(x in I.matrices2x2={},this._matrices2x2)I.matrices2x2[x]=this._matrices2x2[x];for(x in I.vectors2Arrays={},this._vectors2Arrays)I.vectors2Arrays[x]=this._vectors2Arrays[x];for(x in I.vectors3Arrays={},this._vectors3Arrays)I.vectors3Arrays[x]=this._vectors3Arrays[x];for(x in I.vectors4Arrays={},this._vectors4Arrays)I.vectors4Arrays[x]=this._vectors4Arrays[x];for(x in I.quaternionsArrays={},this._quaternionsArrays)I.quaternionsArrays[x]=this._quaternionsArrays[x];return I}static Parse(I,x,L){const X=F.c.Parse((()=>new H(I.name,x,I.shaderPath,I.options,I.storeEffectOnSubMeshes)),I,x,L);let Y;for(Y in I.op&&X.op.parse(I.op,x,L),I.textures)X.setTexture(Y,p.d.Parse(I.textures[Y],x,L));for(Y in I.textureArrays){const F=I.textureArrays[Y],G=[];for(let I=0;I<F.length;I++)G.push(p.d.Parse(F[I],x,L));X.setTextureArray(Y,G)}for(Y in I.ints)X.setInt(Y,I.ints[Y]);for(Y in I.uints)X.setUInt(Y,I.uints[Y]);for(Y in I.floats)X.setFloat(Y,I.floats[Y]);for(Y in I.floatsArrays)X.setFloats(Y,I.floatsArrays[Y]);for(Y in I.colors3){const x=I.colors3[Y];X.setColor3(Y,{r:x[0],g:x[1],b:x[2]})}for(Y in I.colors3Arrays){const x=I.colors3Arrays[Y].reduce(((I,x,L)=>(L%3===0?I.push([x]):I[I.length-1].push(x),I)),[]).map((I=>({r:I[0],g:I[1],b:I[2]})));X.setColor3Array(Y,x)}for(Y in I.colors4){const x=I.colors4[Y];X.setColor4(Y,{r:x[0],g:x[1],b:x[2],a:x[3]})}for(Y in I.colors4Arrays){const x=I.colors4Arrays[Y].reduce(((I,x,L)=>(L%4===0?I.push([x]):I[I.length-1].push(x),I)),[]).map((I=>({r:I[0],g:I[1],b:I[2],a:I[3]})));X.setColor4Array(Y,x)}for(Y in I.vectors2){const x=I.vectors2[Y];X.setVector2(Y,{x:x[0],y:x[1]})}for(Y in I.vectors3){const x=I.vectors3[Y];X.setVector3(Y,{x:x[0],y:x[1],z:x[2]})}for(Y in I.vectors4){const x=I.vectors4[Y];X.setVector4(Y,{x:x[0],y:x[1],z:x[2],w:x[3]})}for(Y in I.quaternions)X.setQuaternion(Y,G.Quaternion.tx(I.quaternions[Y]));for(Y in I.matrices)X.setMatrix(Y,G.Matrix.tx(I.matrices[Y]));for(Y in I.matrixArray)X._matrixArrays[Y]=new Float32Array(I.matrixArray[Y]);for(Y in I.matrices3x3)X.setMatrix3x3(Y,I.matrices3x3[Y]);for(Y in I.matrices2x2)X.setMatrix2x2(Y,I.matrices2x2[Y]);for(Y in I.vectors2Arrays)X.setArray2(Y,I.vectors2Arrays[Y]);for(Y in I.vectors3Arrays)X.setArray3(Y,I.vectors3Arrays[Y]);for(Y in I.vectors4Arrays)X.setArray4(Y,I.vectors4Arrays[Y]);for(Y in I.quaternionsArrays)X.setArray4(Y,I.quaternionsArrays[Y]);return X}static async ParseFromFileAsync(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((X,G)=>{const Y=new W.d;Y.addEventListener("readystatechange",(()=>{if(4==Y.readyState)if(200==Y.status){const x=JSON.parse(Y.responseText),G=this.Parse(x,L||e.e.LastCreatedScene,F);I&&(G.name=I),X(G)}else G("Unable to load the ShaderMaterial")})),Y.open("GET",x),Y.send()}))}static async ParseFromSnippetAsync(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((F,X)=>{const G=new W.d;G.addEventListener("readystatechange",(()=>{if(4==G.readyState)if(200==G.status){const X=JSON.parse(JSON.parse(G.responseText).jsonPayload),Y=JSON.parse(X.shaderMaterial),p=this.Parse(Y,x||e.e.LastCreatedScene,L);p.snippetId=I,F(p)}else X("Unable to load the snippet "+I)})),G.open("GET",this.SnippetUrl+"/"+I.replace(/#/g,"/")),G.send()}))}}H.SnippetUrl="https://snippet.babylonjs.com",H.CreateFromSnippetAsync=H.ParseFromSnippetAsync,(0,B.d)("BABYLON.ShaderMaterial",H)}}]);