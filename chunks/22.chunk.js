"use strict";(self.ksd6jhs1yr=self.ksd6jhs1yr||[]).push([[22],{12631:(C,c,d)=>{d.r(c),d.d(c,{ShaderMaterial:()=>q});var b=d(12431),X=d(12637),P=d(12403),V=d(12471),R=d(12375),p=d(12345),j=d(12704),g=d(12248),k=d(12710),Z=d(12255),U=d(12756),A=d(12750);const u={effect:null,subMesh:null};class q extends k.b{constructor(C,c,d){let b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(C,c,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new P.Matrix,this._cachedWorldViewProjectionMatrix=new P.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=d,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...b}}get shaderPath(){return this._shaderPath}set shaderPath(C){this._shaderPath=C}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(C){-1===this._options.uniforms.indexOf(C)&&this._options.uniforms.push(C)}setTexture(C,c){return-1===this._options.samplers.indexOf(C)&&this._options.samplers.push(C),this._textures[C]=c,this}removeTexture(C){delete this._textures[C]}setTextureArray(C,c){return-1===this._options.samplers.indexOf(C)&&this._options.samplers.push(C),this._checkUniform(C),this._textureArrays[C]=c,this}setExternalTexture(C,c){return-1===this._options.externalTextures.indexOf(C)&&this._options.externalTextures.push(C),this._externalTextures[C]=c,this}setFloat(C,c){return this._checkUniform(C),this._floats[C]=c,this}setInt(C,c){return this._checkUniform(C),this._ints[C]=c,this}setUInt(C,c){return this._checkUniform(C),this._uints[C]=c,this}setFloats(C,c){return this._checkUniform(C),this._floatsArrays[C]=c,this}setColor3(C,c){return this._checkUniform(C),this._colors3[C]=c,this}setColor3Array(C,c){return this._checkUniform(C),this._colors3Arrays[C]=c.reduce(((C,c)=>(C.push(c.r,c.g,c.b),C)),[]),this}setColor4(C,c){return this._checkUniform(C),this._colors4[C]=c,this}setColor4Array(C,c){return this._checkUniform(C),this._colors4Arrays[C]=c.reduce(((C,c)=>(C.push(c.r,c.g,c.b,c.a),C)),[]),this}setVector2(C,c){return this._checkUniform(C),this._vectors2[C]=c,this}setVector3(C,c){return this._checkUniform(C),this._vectors3[C]=c,this}setVector4(C,c){return this._checkUniform(C),this._vectors4[C]=c,this}setQuaternion(C,c){return this._checkUniform(C),this._quaternions[C]=c,this}setQuaternionArray(C,c){return this._checkUniform(C),this._quaternionsArrays[C]=c.reduce(((C,c)=>(c.toArray(C,C.length),C)),[]),this}setMatrix(C,c){return this._checkUniform(C),this._matrices[C]=c,this}setMatrices(C,c){this._checkUniform(C);const d=new Float32Array(16*c.length);for(let b=0;b<c.length;b++){c[b].copyToArray(d,16*b)}return this._matrixArrays[C]=d,this}setMatrix3x3(C,c){return this._checkUniform(C),this._matrices3x3[C]=c,this}setMatrix2x2(C,c){return this._checkUniform(C),this._matrices2x2[C]=c,this}setArray2(C,c){return this._checkUniform(C),this._vectors2Arrays[C]=c,this}setArray3(C,c){return this._checkUniform(C),this._vectors3Arrays[C]=c,this}setArray4(C,c){return this._checkUniform(C),this._vectors4Arrays[C]=c,this}setUniformBuffer(C,c){return-1===this._options.uniformBuffers.indexOf(C)&&this._options.uniformBuffers.push(C),this._uniformBuffers[C]=c,this}setTextureSampler(C,c){return-1===this._options.samplerObjects.indexOf(C)&&this._options.samplerObjects.push(C),this._textureSamplers[C]=c,this}setStorageBuffer(C,c){return-1===this._options.storageBuffers.indexOf(C)&&this._options.storageBuffers.push(C),this._storageBuffers[C]=c,this}setDefine(C,c){const d=C.trimEnd()+" ",b=this.options.defines.findIndex((c=>c===C||c.startsWith(d)));return b>=0&&this.options.defines.splice(b,1),("boolean"!==typeof c||c)&&this.options.defines.push(d+c),this}isReadyForSubMesh(C,c,d){return this.isReady(C,d,c)}isReady(C,c,d){var b;const P=d&&this._storeEffectOnSubMeshes;if(this.isFrozen){const C=P?d._drawWrapper:this._drawWrapper;if(C.effect&&C._wasPreviouslyReady&&C._wasPreviouslyUsingInstances===c)return!0}const R=this.NC(),p=R.getEngine(),g=[],k=[];let Z=null,q=this._shaderPath,B=this._options.uniforms,t=this._options.uniformBuffers,e=this._options.samplers;p.getCaps().multiview&&R.activeCamera&&R.activeCamera.outputRenderTarget&&R.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,g.push("#define MULTIVIEW"),-1!==B.indexOf("viewProjection")&&-1===B.indexOf("viewProjectionR")&&B.push("viewProjectionR"));for(let X=0;X<this._options.defines.length;X++){const C=0===this._options.defines[X].indexOf("#define")?this._options.defines[X]:`#define ${this._options.defines[X]}`;g.push(C)}for(let X=0;X<this._options.attributes.length;X++)k.push(this._options.attributes[X]);if(C&&C.isVerticesDataPresent(V.g.ColorKind)&&(-1===k.indexOf(V.g.ColorKind)&&k.push(V.g.ColorKind),g.push("#define VERTEXCOLOR")),c&&(g.push("#define INSTANCES"),(0,A.eb)(k,this._materialHelperNeedsPreviousMatrices),null!==C&&void 0!==C&&C.hasThinInstances&&(g.push("#define THIN_INSTANCES"),C&&C.isVerticesDataPresent(V.g.ColorInstanceKind)&&(k.push(V.g.ColorInstanceKind),g.push("#define INSTANCESCOLOR")))),C&&C.useBones&&C.computeBonesUsingShaders&&C.skeleton){k.push(V.g.MatricesIndicesKind),k.push(V.g.MatricesWeightsKind),C.numBoneInfluencers>4&&(k.push(V.g.MatricesIndicesExtraKind),k.push(V.g.MatricesWeightsExtraKind));const c=C.skeleton;g.push("#define NUM_BONE_INFLUENCERS "+C.numBoneInfluencers),Z=new j.c,Z.addCPUSkinningFallback(0,C),c.isUsingTextureForMatrices?(g.push("#define BONETEXTURE"),-1===B.indexOf("boneTextureWidth")&&B.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(g.push("#define BonesPerMesh "+(c.bones.length+1)),-1===B.indexOf("mBones")&&B.push("mBones"))}else g.push("#define NUM_BONE_INFLUENCERS 0");let n=0;const W=C?C.morphTargetManager:null;if(W){const c=-1!==g.indexOf("#define UV1"),d=-1!==g.indexOf("#define UV2"),b=-1!==g.indexOf("#define TANGENT"),X=-1!==g.indexOf("#define NORMAL"),P=-1!==g.indexOf("#define VERTEXCOLOR");n=(0,A.H)(W,g,k,C,!0,X,b,c,d,P),W.isUsingTextureForTargets&&(-1===B.indexOf("morphTargetTextureIndices")&&B.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),n>0&&(B=B.slice(),B.push("morphTargetInfluences"),B.push("morphTargetCount"),B.push("morphTargetTextureInfo"),B.push("morphTargetTextureIndices"))}else g.push("#define NUM_MORPH_INFLUENCERS 0");if(C){const c=C.bakedVertexAnimationManager;c&&c.isEnabled&&(g.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===B.indexOf("bakedVertexAnimationSettings")&&B.push("bakedVertexAnimationSettings"),-1===B.indexOf("bakedVertexAnimationTextureSizeInverted")&&B.push("bakedVertexAnimationTextureSizeInverted"),-1===B.indexOf("bakedVertexAnimationTime")&&B.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,A.x)(k,C,g)}for(const X in this._textures)if(!this._textures[X].isReady())return!1;C&&this.needAlphaTestingForMesh(C)&&g.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,U.b)(B),(0,U.j)(this,R,g)),R.fogEnabled&&null!==C&&void 0!==C&&C.applyFog&&R.fogMode!==X.e.FOGMODE_NONE&&(g.push("#define FOG"),-1===B.indexOf("view")&&B.push("view"),-1===B.indexOf("vFogInfos")&&B.push("vFogInfos"),-1===B.indexOf("vFogColor")&&B.push("vFogColor")),this._useLogarithmicDepth&&(g.push("#define LOGARITHMICDEPTH"),-1===B.indexOf("logarithmicDepthConstant")&&B.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(B=B.slice(),t=t.slice(),e=e.slice(),q=this.customShaderNameResolve(this.name,B,t,e,g,k));const E=P?d._getDrawWrapper(void 0,!0):this._drawWrapper,N=(null===E||void 0===E?void 0:E.effect)??null,r=(null===E||void 0===E?void 0:E.defines)??null,M=g.join("\n");let K=N;return r!==M&&(K=p.createEffect(q,{attributes:k,uniformsNames:B,uniformBuffersNames:t,samplers:e,defines:M,fallbacks:Z,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:n},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},p),P?d.setEffect(K,M,this._materialContext):E&&E.setEffect(K,M),this._onEffectCreatedObservable&&(u.effect=K,u.subMesh=d??(null===C||void 0===C?void 0:C.Nc[0])??null,this._onEffectCreatedObservable.notifyObservers(u))),E._wasPreviouslyUsingInstances=!!c,!(null===(b=K)||void 0===b||!b.isReady())&&(N!==K&&R.resetCachedMaterial(),E._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(C,c){const d=c??this.getEffect();if(!d)return;const b=this._options.uniforms;-1!==b.indexOf("world")&&d.setMatrix("world",C);const X=this.NC();-1!==b.indexOf("worldView")&&(C.multiplyToRef(X.getViewMatrix(),this._cachedWorldViewMatrix),d.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==b.indexOf("worldViewProjection")&&(C.multiplyToRef(X.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),d.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==b.indexOf("view")&&d.setMatrix("view",X.getViewMatrix())}bindForSubMesh(C,c,d){var b;this.bind(C,c,null===(b=d._drawWrapperOverride)||void 0===b?void 0:b.effect,d)}bind(C,c,d,b){const X=b&&this._storeEffectOnSubMeshes,P=d??(X?b.effect:this.getEffect());if(!P)return;const V=this.NC();this._activeEffect=P,this.bindOnlyWorldMatrix(C,d);const R=this._options.uniformBuffers;let p=!1;if(P&&R&&R.length>0&&V.getEngine().supportsUniformBuffers)for(let k=0;k<R.length;++k){switch(R[k]){case"Mesh":c&&(c.getMeshUniformBuffer().bindToEffect(P,"Mesh"),c.transferToEffect(C));break;case"Scene":(0,A.r)(P,V.getSceneUniformBuffer()),V.finalizeSceneUbo(),p=!0}}const j=c&&X?this._mustRebind(V,P,b,c.visibility):V.getCachedMaterial()!==this;if(P&&j){let C;for(C in p||-1===this._options.uniforms.indexOf("view")||P.setMatrix("view",V.getViewMatrix()),p||-1===this._options.uniforms.indexOf("projection")||P.setMatrix("projection",V.getProjectionMatrix()),p||-1===this._options.uniforms.indexOf("viewProjection")||(P.setMatrix("viewProjection",V.getTransformMatrix()),this._multiview&&P.setMatrix("viewProjectionR",V._transformMatrixR)),V.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&P.setVector3("cameraPosition",V.activeCamera.globalPosition),(0,A.d)(c,P),(0,U.e)(P,this,V),this._useLogarithmicDepth&&(0,A.o)(X?b.materialDefines:P.defines,P,V),c&&(0,A.g)(V,c,P),this._textures)P.setTexture(C,this._textures[C]);for(C in this._textureArrays)P.setTextureArray(C,this._textureArrays[C]);for(C in this._ints)P.setInt(C,this._ints[C]);for(C in this._uints)P.setUInt(C,this._uints[C]);for(C in this._floats)P.setFloat(C,this._floats[C]);for(C in this._floatsArrays)P.setArray(C,this._floatsArrays[C]);for(C in this._colors3)P.setColor3(C,this._colors3[C]);for(C in this._colors3Arrays)P.setArray3(C,this._colors3Arrays[C]);for(C in this._colors4){const c=this._colors4[C];P.setFloat4(C,c.r,c.g,c.b,c.a)}for(C in this._colors4Arrays)P.setArray4(C,this._colors4Arrays[C]);for(C in this._vectors2)P.setVector2(C,this._vectors2[C]);for(C in this._vectors3)P.setVector3(C,this._vectors3[C]);for(C in this._vectors4)P.setVector4(C,this._vectors4[C]);for(C in this._quaternions)P.setQuaternion(C,this._quaternions[C]);for(C in this._matrices)P.setMatrix(C,this._matrices[C]);for(C in this._matrixArrays)P.setMatrices(C,this._matrixArrays[C]);for(C in this._matrices3x3)P.setMatrix3x3(C,this._matrices3x3[C]);for(C in this._matrices2x2)P.setMatrix2x2(C,this._matrices2x2[C]);for(C in this._vectors2Arrays)P.setArray2(C,this._vectors2Arrays[C]);for(C in this._vectors3Arrays)P.setArray3(C,this._vectors3Arrays[C]);for(C in this._vectors4Arrays)P.setArray4(C,this._vectors4Arrays[C]);for(C in this._quaternionsArrays)P.setArray4(C,this._quaternionsArrays[C]);for(C in this._uniformBuffers){const c=this._uniformBuffers[C].getBuffer();c&&P.bindUniformBuffer(c,C)}const d=V.getEngine(),R=d.setExternalTexture;if(R)for(C in this._externalTextures)R.call(d,C,this._externalTextures[C]);const j=d.setTextureSampler;if(j)for(C in this._textureSamplers)j.call(d,C,this._textureSamplers[C]);const g=d.setStorageBuffer;if(g)for(C in this._storageBuffers)g.call(d,C,this._storageBuffers[C])}if(P&&c&&(j||!this.isFrozen)){(0,A.q)(c,P),c.morphTargetManager&&c.morphTargetManager.isUsingTextureForTargets&&c.morphTargetManager._bind(P);const C=c.bakedVertexAnimationManager;if(C&&C.isEnabled){var g;const C=X?b._drawWrapper:this._drawWrapper;null===(g=c.bakedVertexAnimationManager)||void 0===g||g.bind(P,!!C._wasPreviouslyUsingInstances)}}this._afterBind(c,P,b)}getActiveTextures(){const C=super.getActiveTextures();for(const c in this._textures)C.push(this._textures[c]);for(const c in this._textureArrays){const d=this._textureArrays[c];for(let c=0;c<d.length;c++)C.push(d[c])}return C}hasTexture(C){if(super.hasTexture(C))return!0;for(const c in this._textures)if(this._textures[c]===C)return!0;for(const c in this._textureArrays){const d=this._textureArrays[c];for(let c=0;c<d.length;c++)if(d[c]===C)return!0}return!1}clone(C){const c=b.e.Clone((()=>new q(C,this.NC(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);c.name=C,c.id=C,"object"===typeof c._shaderPath&&(c._shaderPath={...c._shaderPath}),this._options={...this._options};const d=Object.keys(this._options);for(const b of d){const C=this._options[b];Array.isArray(C)&&(this._options[b]=C.slice(0))}this.uc.copyTo(c.uc);for(const b in this._textures)c.setTexture(b,this._textures[b]);for(const b in this._textureArrays)c.setTextureArray(b,this._textureArrays[b]);for(const b in this._externalTextures)c.setExternalTexture(b,this._externalTextures[b]);for(const b in this._ints)c.setInt(b,this._ints[b]);for(const b in this._uints)c.setUInt(b,this._uints[b]);for(const b in this._floats)c.setFloat(b,this._floats[b]);for(const b in this._floatsArrays)c.setFloats(b,this._floatsArrays[b]);for(const b in this._colors3)c.setColor3(b,this._colors3[b]);for(const b in this._colors3Arrays)c._colors3Arrays[b]=this._colors3Arrays[b];for(const b in this._colors4)c.setColor4(b,this._colors4[b]);for(const b in this._colors4Arrays)c._colors4Arrays[b]=this._colors4Arrays[b];for(const b in this._vectors2)c.setVector2(b,this._vectors2[b]);for(const b in this._vectors3)c.setVector3(b,this._vectors3[b]);for(const b in this._vectors4)c.setVector4(b,this._vectors4[b]);for(const b in this._quaternions)c.setQuaternion(b,this._quaternions[b]);for(const b in this._quaternionsArrays)c._quaternionsArrays[b]=this._quaternionsArrays[b];for(const b in this._matrices)c.setMatrix(b,this._matrices[b]);for(const b in this._matrixArrays)c._matrixArrays[b]=this._matrixArrays[b].slice();for(const b in this._matrices3x3)c.setMatrix3x3(b,this._matrices3x3[b]);for(const b in this._matrices2x2)c.setMatrix2x2(b,this._matrices2x2[b]);for(const b in this._vectors2Arrays)c.setArray2(b,this._vectors2Arrays[b]);for(const b in this._vectors3Arrays)c.setArray3(b,this._vectors3Arrays[b]);for(const b in this._vectors4Arrays)c.setArray4(b,this._vectors4Arrays[b]);for(const b in this._uniformBuffers)c.setUniformBuffer(b,this._uniformBuffers[b]);for(const b in this._textureSamplers)c.setTextureSampler(b,this._textureSamplers[b]);for(const b in this._storageBuffers)c.setStorageBuffer(b,this._storageBuffers[b]);return c}dispose(C,c,d){if(c){let C;for(C in this._textures)this._textures[C].dispose();for(C in this._textureArrays){const c=this._textureArrays[C];for(let C=0;C<c.length;C++)c[C].dispose()}}this._textures={},super.dispose(C,c,d)}serialize(){const C=b.e.Serialize(this);let c;for(c in C.customType="BABYLON.ShaderMaterial",C.uniqueId=this.uniqueId,C.options=this._options,C.shaderPath=this._shaderPath,C.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,C.uc=this.uc.serialize(),C.textures={},this._textures)C.textures[c]=this._textures[c].serialize();for(c in C.textureArrays={},this._textureArrays){C.textureArrays[c]=[];const d=this._textureArrays[c];for(let b=0;b<d.length;b++)C.textureArrays[c].push(d[b].serialize())}for(c in C.ints={},this._ints)C.ints[c]=this._ints[c];for(c in C.uints={},this._uints)C.uints[c]=this._uints[c];for(c in C.floats={},this._floats)C.floats[c]=this._floats[c];for(c in C.floatsArrays={},this._floatsArrays)C.floatsArrays[c]=this._floatsArrays[c];for(c in C.colors3={},this._colors3){const d=this._colors3[c];C.colors3[c]=[d.r,d.g,d.b]}for(c in C.colors3Arrays={},this._colors3Arrays)C.colors3Arrays[c]=this._colors3Arrays[c];for(c in C.colors4={},this._colors4){const d=this._colors4[c];C.colors4[c]=[d.r,d.g,d.b,d.a]}for(c in C.colors4Arrays={},this._colors4Arrays)C.colors4Arrays[c]=this._colors4Arrays[c];for(c in C.vectors2={},this._vectors2){const d=this._vectors2[c];C.vectors2[c]=[d.x,d.y]}for(c in C.vectors3={},this._vectors3){const d=this._vectors3[c];C.vectors3[c]=[d.x,d.y,d.z]}for(c in C.vectors4={},this._vectors4){const d=this._vectors4[c];C.vectors4[c]=[d.x,d.y,d.z,d.w]}for(c in C.quaternions={},this._quaternions)C.quaternions[c]=this._quaternions[c].rc();for(c in C.matrices={},this._matrices)C.matrices[c]=this._matrices[c].rc();for(c in C.matrixArray={},this._matrixArrays)C.matrixArray[c]=this._matrixArrays[c];for(c in C.matrices3x3={},this._matrices3x3)C.matrices3x3[c]=this._matrices3x3[c];for(c in C.matrices2x2={},this._matrices2x2)C.matrices2x2[c]=this._matrices2x2[c];for(c in C.vectors2Arrays={},this._vectors2Arrays)C.vectors2Arrays[c]=this._vectors2Arrays[c];for(c in C.vectors3Arrays={},this._vectors3Arrays)C.vectors3Arrays[c]=this._vectors3Arrays[c];for(c in C.vectors4Arrays={},this._vectors4Arrays)C.vectors4Arrays[c]=this._vectors4Arrays[c];for(c in C.quaternionsArrays={},this._quaternionsArrays)C.quaternionsArrays[c]=this._quaternionsArrays[c];return C}static Parse(C,c,d){const X=b.e.Parse((()=>new q(C.name,c,C.shaderPath,C.options,C.storeEffectOnSubMeshes)),C,c,d);let V;for(V in C.uc&&X.uc.parse(C.uc,c,d),C.textures)X.setTexture(V,R.b.Parse(C.textures[V],c,d));for(V in C.textureArrays){const b=C.textureArrays[V],P=[];for(let C=0;C<b.length;C++)P.push(R.b.Parse(b[C],c,d));X.setTextureArray(V,P)}for(V in C.ints)X.setInt(V,C.ints[V]);for(V in C.uints)X.setUInt(V,C.uints[V]);for(V in C.floats)X.setFloat(V,C.floats[V]);for(V in C.floatsArrays)X.setFloats(V,C.floatsArrays[V]);for(V in C.colors3){const c=C.colors3[V];X.setColor3(V,{r:c[0],g:c[1],b:c[2]})}for(V in C.colors3Arrays){const c=C.colors3Arrays[V].reduce(((C,c,d)=>(d%3===0?C.push([c]):C[C.length-1].push(c),C)),[]).map((C=>({r:C[0],g:C[1],b:C[2]})));X.setColor3Array(V,c)}for(V in C.colors4){const c=C.colors4[V];X.setColor4(V,{r:c[0],g:c[1],b:c[2],a:c[3]})}for(V in C.colors4Arrays){const c=C.colors4Arrays[V].reduce(((C,c,d)=>(d%4===0?C.push([c]):C[C.length-1].push(c),C)),[]).map((C=>({r:C[0],g:C[1],b:C[2],a:C[3]})));X.setColor4Array(V,c)}for(V in C.vectors2){const c=C.vectors2[V];X.setVector2(V,{x:c[0],y:c[1]})}for(V in C.vectors3){const c=C.vectors3[V];X.setVector3(V,{x:c[0],y:c[1],z:c[2]})}for(V in C.vectors4){const c=C.vectors4[V];X.setVector4(V,{x:c[0],y:c[1],z:c[2],w:c[3]})}for(V in C.quaternions)X.setQuaternion(V,P.Quaternion.jd(C.quaternions[V]));for(V in C.matrices)X.setMatrix(V,P.Matrix.jd(C.matrices[V]));for(V in C.matrixArray)X._matrixArrays[V]=new Float32Array(C.matrixArray[V]);for(V in C.matrices3x3)X.setMatrix3x3(V,C.matrices3x3[V]);for(V in C.matrices2x2)X.setMatrix2x2(V,C.matrices2x2[V]);for(V in C.vectors2Arrays)X.setArray2(V,C.vectors2Arrays[V]);for(V in C.vectors3Arrays)X.setArray3(V,C.vectors3Arrays[V]);for(V in C.vectors4Arrays)X.setArray4(V,C.vectors4Arrays[V]);for(V in C.quaternionsArrays)X.setArray4(V,C.quaternionsArrays[V]);return X}static async ParseFromFileAsync(C,c,d){let b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((X,P)=>{const V=new g.b;V.addEventListener("readystatechange",(()=>{if(4==V.readyState)if(200==V.status){const c=JSON.parse(V.responseText),P=this.Parse(c,d||Z.c.LastCreatedScene,b);C&&(P.name=C),X(P)}else P("Unable to load the ShaderMaterial")})),V.open("GET",c),V.send()}))}static async ParseFromSnippetAsync(C,c){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((b,X)=>{const P=new g.b;P.addEventListener("readystatechange",(()=>{if(4==P.readyState)if(200==P.status){const X=JSON.parse(JSON.parse(P.responseText).jsonPayload),V=JSON.parse(X.shaderMaterial),R=this.Parse(V,c||Z.c.LastCreatedScene,d);R.snippetId=C,b(R)}else X("Unable to load the snippet "+C)})),P.open("GET",this.SnippetUrl+"/"+C.replace(/#/g,"/")),P.send()}))}}q.SnippetUrl="https://snippet.babylonjs.com",q.CreateFromSnippetAsync=q.ParseFromSnippetAsync,(0,p.e)("BABYLON.ShaderMaterial",q)}}]);