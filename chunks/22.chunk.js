"use strict";(self.vb3rpbgyozo=self.vb3rpbgyozo||[]).push([[22],{12983:(q,I,l)=>{l.r(I),l.d(I,{ShaderMaterial:()=>V});var w=l(12777),t=l(12987),O=l(12747),c=l(12821),a=l(12733),F=l(12711),s=l(13059),Z=l(12607),r=l(13065),x=l(12612),o=l(13116),d=l(13109);const T={effect:null,subMesh:null};class V extends r.c{constructor(q,I,l){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(q,I,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new O.Matrix,this._cachedWorldViewProjectionMatrix=new O.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=l,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...w}}get shaderPath(){return this._shaderPath}set shaderPath(q){this._shaderPath=q}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(q){-1===this._options.uniforms.indexOf(q)&&this._options.uniforms.push(q)}setTexture(q,I){return-1===this._options.samplers.indexOf(q)&&this._options.samplers.push(q),this._textures[q]=I,this}removeTexture(q){delete this._textures[q]}setTextureArray(q,I){return-1===this._options.samplers.indexOf(q)&&this._options.samplers.push(q),this._checkUniform(q),this._textureArrays[q]=I,this}setExternalTexture(q,I){return-1===this._options.externalTextures.indexOf(q)&&this._options.externalTextures.push(q),this._externalTextures[q]=I,this}setFloat(q,I){return this._checkUniform(q),this._floats[q]=I,this}setInt(q,I){return this._checkUniform(q),this._ints[q]=I,this}setUInt(q,I){return this._checkUniform(q),this._uints[q]=I,this}setFloats(q,I){return this._checkUniform(q),this._floatsArrays[q]=I,this}setColor3(q,I){return this._checkUniform(q),this._colors3[q]=I,this}setColor3Array(q,I){return this._checkUniform(q),this._colors3Arrays[q]=I.reduce(((q,I)=>(q.push(I.r,I.g,I.b),q)),[]),this}setColor4(q,I){return this._checkUniform(q),this._colors4[q]=I,this}setColor4Array(q,I){return this._checkUniform(q),this._colors4Arrays[q]=I.reduce(((q,I)=>(q.push(I.r,I.g,I.b,I.a),q)),[]),this}setVector2(q,I){return this._checkUniform(q),this._vectors2[q]=I,this}setVector3(q,I){return this._checkUniform(q),this._vectors3[q]=I,this}setVector4(q,I){return this._checkUniform(q),this._vectors4[q]=I,this}setQuaternion(q,I){return this._checkUniform(q),this._quaternions[q]=I,this}setQuaternionArray(q,I){return this._checkUniform(q),this._quaternionsArrays[q]=I.reduce(((q,I)=>(I.toArray(q,q.length),q)),[]),this}setMatrix(q,I){return this._checkUniform(q),this._matrices[q]=I,this}setMatrices(q,I){this._checkUniform(q);const l=new Float32Array(16*I.length);for(let w=0;w<I.length;w++){I[w].copyToArray(l,16*w)}return this._matrixArrays[q]=l,this}setMatrix3x3(q,I){return this._checkUniform(q),this._matrices3x3[q]=I,this}setMatrix2x2(q,I){return this._checkUniform(q),this._matrices2x2[q]=I,this}setArray2(q,I){return this._checkUniform(q),this._vectors2Arrays[q]=I,this}setArray3(q,I){return this._checkUniform(q),this._vectors3Arrays[q]=I,this}setArray4(q,I){return this._checkUniform(q),this._vectors4Arrays[q]=I,this}setUniformBuffer(q,I){return-1===this._options.uniformBuffers.indexOf(q)&&this._options.uniformBuffers.push(q),this._uniformBuffers[q]=I,this}setTextureSampler(q,I){return-1===this._options.samplerObjects.indexOf(q)&&this._options.samplerObjects.push(q),this._textureSamplers[q]=I,this}setStorageBuffer(q,I){return-1===this._options.storageBuffers.indexOf(q)&&this._options.storageBuffers.push(q),this._storageBuffers[q]=I,this}setDefine(q,I){const l=q.trimEnd()+" ",w=this.options.defines.findIndex((I=>I===q||I.startsWith(l)));return w>=0&&this.options.defines.splice(w,1),("boolean"!==typeof I||I)&&this.options.defines.push(l+I),this}isReadyForSubMesh(q,I,l){return this.isReady(q,l,I)}isReady(q,I,l){var w;const O=l&&this._storeEffectOnSubMeshes;if(this.isFrozen){const q=O?l._drawWrapper:this._drawWrapper;if(q.effect&&q._wasPreviouslyReady&&q._wasPreviouslyUsingInstances===I)return!0}const a=this.Wq(),F=a.getEngine(),Z=[],r=[];let x=null,V=this._shaderPath,U=this._options.uniforms,B=this._options.uniformBuffers,v=this._options.samplers;F.getCaps().multiview&&a.activeCamera&&a.activeCamera.outputRenderTarget&&a.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,Z.push("#define MULTIVIEW"),-1!==U.indexOf("viewProjection")&&-1===U.indexOf("viewProjectionR")&&U.push("viewProjectionR"));for(let t=0;t<this._options.defines.length;t++){const q=0===this._options.defines[t].indexOf("#define")?this._options.defines[t]:`#define ${this._options.defines[t]}`;Z.push(q)}for(let t=0;t<this._options.attributes.length;t++)r.push(this._options.attributes[t]);if(q&&q.isVerticesDataPresent(c.c.ColorKind)&&(-1===r.indexOf(c.c.ColorKind)&&r.push(c.c.ColorKind),Z.push("#define VERTEXCOLOR")),I&&(Z.push("#define INSTANCES"),(0,d.ob)(r,this._materialHelperNeedsPreviousMatrices),null!==q&&void 0!==q&&q.hasThinInstances&&(Z.push("#define THIN_INSTANCES"),q&&q.isVerticesDataPresent(c.c.ColorInstanceKind)&&(r.push(c.c.ColorInstanceKind),Z.push("#define INSTANCESCOLOR")))),q&&q.useBones&&q.computeBonesUsingShaders&&q.skeleton){r.push(c.c.MatricesIndicesKind),r.push(c.c.MatricesWeightsKind),q.numBoneInfluencers>4&&(r.push(c.c.MatricesIndicesExtraKind),r.push(c.c.MatricesWeightsExtraKind));const I=q.skeleton;Z.push("#define NUM_BONE_INFLUENCERS "+q.numBoneInfluencers),x=new s.b,x.addCPUSkinningFallback(0,q),I.isUsingTextureForMatrices?(Z.push("#define BONETEXTURE"),-1===U.indexOf("boneTextureWidth")&&U.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(Z.push("#define BonesPerMesh "+(I.bones.length+1)),-1===U.indexOf("mBones")&&U.push("mBones"))}else Z.push("#define NUM_BONE_INFLUENCERS 0");let k=0;const C=q?q.morphTargetManager:null;if(C){const I=-1!==Z.indexOf("#define UV1"),l=-1!==Z.indexOf("#define UV2"),w=-1!==Z.indexOf("#define TANGENT"),t=-1!==Z.indexOf("#define NORMAL"),O=-1!==Z.indexOf("#define VERTEXCOLOR");k=(0,d.P)(C,Z,r,q,!0,t,w,I,l,O),C.isUsingTextureForTargets&&(-1===U.indexOf("morphTargetTextureIndices")&&U.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),k>0&&(U=U.slice(),U.push("morphTargetInfluences"),U.push("morphTargetCount"),U.push("morphTargetTextureInfo"),U.push("morphTargetTextureIndices"))}else Z.push("#define NUM_MORPH_INFLUENCERS 0");if(q){const I=q.bakedVertexAnimationManager;I&&I.isEnabled&&(Z.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===U.indexOf("bakedVertexAnimationSettings")&&U.push("bakedVertexAnimationSettings"),-1===U.indexOf("bakedVertexAnimationTextureSizeInverted")&&U.push("bakedVertexAnimationTextureSizeInverted"),-1===U.indexOf("bakedVertexAnimationTime")&&U.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,d.E)(r,q,Z)}for(const t in this._textures)if(!this._textures[t].isReady())return!1;q&&this.needAlphaTestingForMesh(q)&&Z.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,o.b)(U),(0,o.k)(this,a,Z)),a.fogEnabled&&null!==q&&void 0!==q&&q.applyFog&&a.fogMode!==t.e.FOGMODE_NONE&&(Z.push("#define FOG"),-1===U.indexOf("view")&&U.push("view"),-1===U.indexOf("vFogInfos")&&U.push("vFogInfos"),-1===U.indexOf("vFogColor")&&U.push("vFogColor")),this._useLogarithmicDepth&&(Z.push("#define LOGARITHMICDEPTH"),-1===U.indexOf("logarithmicDepthConstant")&&U.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(U=U.slice(),B=B.slice(),v=v.slice(),V=this.customShaderNameResolve(this.name,U,B,v,Z,r));const R=O?l._getDrawWrapper(void 0,!0):this._drawWrapper,W=(null===R||void 0===R?void 0:R.effect)??null,e=(null===R||void 0===R?void 0:R.defines)??null,i=Z.join("\n");let S=W;return e!==i&&(S=F.createEffect(V,{attributes:r,uniformsNames:U,uniformBuffersNames:B,samplers:v,defines:i,fallbacks:x,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:k},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},F),O?l.setEffect(S,i,this._materialContext):R&&R.setEffect(S,i),this._onEffectCreatedObservable&&(T.effect=S,T.subMesh=l??(null===q||void 0===q?void 0:q.Tc[0])??null,this._onEffectCreatedObservable.notifyObservers(T))),R._wasPreviouslyUsingInstances=!!I,!(null===(w=S)||void 0===w||!w.isReady())&&(W!==S&&a.resetCachedMaterial(),R._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(q,I){const l=I??this.getEffect();if(!l)return;const w=this._options.uniforms;-1!==w.indexOf("world")&&l.setMatrix("world",q);const t=this.Wq();-1!==w.indexOf("worldView")&&(q.multiplyToRef(t.getViewMatrix(),this._cachedWorldViewMatrix),l.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==w.indexOf("worldViewProjection")&&(q.multiplyToRef(t.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),l.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==w.indexOf("view")&&l.setMatrix("view",t.getViewMatrix())}bindForSubMesh(q,I,l){var w;this.bind(q,I,null===(w=l._drawWrapperOverride)||void 0===w?void 0:w.effect,l)}bind(q,I,l,w){const t=w&&this._storeEffectOnSubMeshes,O=l??(t?w.effect:this.getEffect());if(!O)return;const c=this.Wq();this._activeEffect=O,this.bindOnlyWorldMatrix(q,l);const a=this._options.uniformBuffers;let F=!1;if(O&&a&&a.length>0&&c.getEngine().supportsUniformBuffers)for(let r=0;r<a.length;++r){switch(a[r]){case"Mesh":I&&(I.getMeshUniformBuffer().bindToEffect(O,"Mesh"),I.transferToEffect(q));break;case"Scene":(0,d.t)(O,c.getSceneUniformBuffer()),c.finalizeSceneUbo(),F=!0}}const s=I&&t?this._mustRebind(c,O,w,I.visibility):c.getCachedMaterial()!==this;if(O&&s){let q;for(q in F||-1===this._options.uniforms.indexOf("view")||O.setMatrix("view",c.getViewMatrix()),F||-1===this._options.uniforms.indexOf("projection")||O.setMatrix("projection",c.getProjectionMatrix()),F||-1===this._options.uniforms.indexOf("viewProjection")||(O.setMatrix("viewProjection",c.getTransformMatrix()),this._multiview&&O.setMatrix("viewProjectionR",c._transformMatrixR)),c.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&O.setVector3("cameraPosition",c.activeCamera.globalPosition),(0,d.c)(I,O),(0,o.c)(O,this,c),this._useLogarithmicDepth&&(0,d.l)(t?w.materialDefines:O.defines,O,c),I&&(0,d.f)(c,I,O),this._textures)O.setTexture(q,this._textures[q]);for(q in this._textureArrays)O.setTextureArray(q,this._textureArrays[q]);for(q in this._ints)O.setInt(q,this._ints[q]);for(q in this._uints)O.setUInt(q,this._uints[q]);for(q in this._floats)O.setFloat(q,this._floats[q]);for(q in this._floatsArrays)O.setArray(q,this._floatsArrays[q]);for(q in this._colors3)O.setColor3(q,this._colors3[q]);for(q in this._colors3Arrays)O.setArray3(q,this._colors3Arrays[q]);for(q in this._colors4){const I=this._colors4[q];O.setFloat4(q,I.r,I.g,I.b,I.a)}for(q in this._colors4Arrays)O.setArray4(q,this._colors4Arrays[q]);for(q in this._vectors2)O.setVector2(q,this._vectors2[q]);for(q in this._vectors3)O.setVector3(q,this._vectors3[q]);for(q in this._vectors4)O.setVector4(q,this._vectors4[q]);for(q in this._quaternions)O.setQuaternion(q,this._quaternions[q]);for(q in this._matrices)O.setMatrix(q,this._matrices[q]);for(q in this._matrixArrays)O.setMatrices(q,this._matrixArrays[q]);for(q in this._matrices3x3)O.setMatrix3x3(q,this._matrices3x3[q]);for(q in this._matrices2x2)O.setMatrix2x2(q,this._matrices2x2[q]);for(q in this._vectors2Arrays)O.setArray2(q,this._vectors2Arrays[q]);for(q in this._vectors3Arrays)O.setArray3(q,this._vectors3Arrays[q]);for(q in this._vectors4Arrays)O.setArray4(q,this._vectors4Arrays[q]);for(q in this._quaternionsArrays)O.setArray4(q,this._quaternionsArrays[q]);for(q in this._uniformBuffers){const I=this._uniformBuffers[q].getBuffer();I&&O.bindUniformBuffer(I,q)}const l=c.getEngine(),a=l.setExternalTexture;if(a)for(q in this._externalTextures)a.call(l,q,this._externalTextures[q]);const s=l.setTextureSampler;if(s)for(q in this._textureSamplers)s.call(l,q,this._textureSamplers[q]);const Z=l.setStorageBuffer;if(Z)for(q in this._storageBuffers)Z.call(l,q,this._storageBuffers[q])}if(O&&I&&(s||!this.isFrozen)){(0,d.p)(I,O),I.morphTargetManager&&I.morphTargetManager.isUsingTextureForTargets&&I.morphTargetManager._bind(O);const q=I.bakedVertexAnimationManager;if(q&&q.isEnabled){var Z;const q=t?w._drawWrapper:this._drawWrapper;null===(Z=I.bakedVertexAnimationManager)||void 0===Z||Z.bind(O,!!q._wasPreviouslyUsingInstances)}}this._afterBind(I,O,w)}getActiveTextures(){const q=super.getActiveTextures();for(const I in this._textures)q.push(this._textures[I]);for(const I in this._textureArrays){const l=this._textureArrays[I];for(let I=0;I<l.length;I++)q.push(l[I])}return q}hasTexture(q){if(super.hasTexture(q))return!0;for(const I in this._textures)if(this._textures[I]===q)return!0;for(const I in this._textureArrays){const l=this._textureArrays[I];for(let I=0;I<l.length;I++)if(l[I]===q)return!0}return!1}clone(q){const I=w.c.Clone((()=>new V(q,this.Wq(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);I.name=q,I.id=q,"object"===typeof I._shaderPath&&(I._shaderPath={...I._shaderPath}),this._options={...this._options};const l=Object.keys(this._options);for(const w of l){const q=this._options[w];Array.isArray(q)&&(this._options[w]=q.slice(0))}this.cc.copyTo(I.cc);for(const w in this._textures)I.setTexture(w,this._textures[w]);for(const w in this._textureArrays)I.setTextureArray(w,this._textureArrays[w]);for(const w in this._externalTextures)I.setExternalTexture(w,this._externalTextures[w]);for(const w in this._ints)I.setInt(w,this._ints[w]);for(const w in this._uints)I.setUInt(w,this._uints[w]);for(const w in this._floats)I.setFloat(w,this._floats[w]);for(const w in this._floatsArrays)I.setFloats(w,this._floatsArrays[w]);for(const w in this._colors3)I.setColor3(w,this._colors3[w]);for(const w in this._colors3Arrays)I._colors3Arrays[w]=this._colors3Arrays[w];for(const w in this._colors4)I.setColor4(w,this._colors4[w]);for(const w in this._colors4Arrays)I._colors4Arrays[w]=this._colors4Arrays[w];for(const w in this._vectors2)I.setVector2(w,this._vectors2[w]);for(const w in this._vectors3)I.setVector3(w,this._vectors3[w]);for(const w in this._vectors4)I.setVector4(w,this._vectors4[w]);for(const w in this._quaternions)I.setQuaternion(w,this._quaternions[w]);for(const w in this._quaternionsArrays)I._quaternionsArrays[w]=this._quaternionsArrays[w];for(const w in this._matrices)I.setMatrix(w,this._matrices[w]);for(const w in this._matrixArrays)I._matrixArrays[w]=this._matrixArrays[w].slice();for(const w in this._matrices3x3)I.setMatrix3x3(w,this._matrices3x3[w]);for(const w in this._matrices2x2)I.setMatrix2x2(w,this._matrices2x2[w]);for(const w in this._vectors2Arrays)I.setArray2(w,this._vectors2Arrays[w]);for(const w in this._vectors3Arrays)I.setArray3(w,this._vectors3Arrays[w]);for(const w in this._vectors4Arrays)I.setArray4(w,this._vectors4Arrays[w]);for(const w in this._uniformBuffers)I.setUniformBuffer(w,this._uniformBuffers[w]);for(const w in this._textureSamplers)I.setTextureSampler(w,this._textureSamplers[w]);for(const w in this._storageBuffers)I.setStorageBuffer(w,this._storageBuffers[w]);return I}dispose(q,I,l){if(I){let q;for(q in this._textures)this._textures[q].dispose();for(q in this._textureArrays){const I=this._textureArrays[q];for(let q=0;q<I.length;q++)I[q].dispose()}}this._textures={},super.dispose(q,I,l)}serialize(){const q=w.c.Serialize(this);let I;for(I in q.customType="BABYLON.ShaderMaterial",q.uniqueId=this.uniqueId,q.options=this._options,q.shaderPath=this._shaderPath,q.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,q.cc=this.cc.serialize(),q.textures={},this._textures)q.textures[I]=this._textures[I].serialize();for(I in q.textureArrays={},this._textureArrays){q.textureArrays[I]=[];const l=this._textureArrays[I];for(let w=0;w<l.length;w++)q.textureArrays[I].push(l[w].serialize())}for(I in q.ints={},this._ints)q.ints[I]=this._ints[I];for(I in q.uints={},this._uints)q.uints[I]=this._uints[I];for(I in q.floats={},this._floats)q.floats[I]=this._floats[I];for(I in q.floatsArrays={},this._floatsArrays)q.floatsArrays[I]=this._floatsArrays[I];for(I in q.colors3={},this._colors3){const l=this._colors3[I];q.colors3[I]=[l.r,l.g,l.b]}for(I in q.colors3Arrays={},this._colors3Arrays)q.colors3Arrays[I]=this._colors3Arrays[I];for(I in q.colors4={},this._colors4){const l=this._colors4[I];q.colors4[I]=[l.r,l.g,l.b,l.a]}for(I in q.colors4Arrays={},this._colors4Arrays)q.colors4Arrays[I]=this._colors4Arrays[I];for(I in q.vectors2={},this._vectors2){const l=this._vectors2[I];q.vectors2[I]=[l.x,l.y]}for(I in q.vectors3={},this._vectors3){const l=this._vectors3[I];q.vectors3[I]=[l.x,l.y,l.z]}for(I in q.vectors4={},this._vectors4){const l=this._vectors4[I];q.vectors4[I]=[l.x,l.y,l.z,l.w]}for(I in q.quaternions={},this._quaternions)q.quaternions[I]=this._quaternions[I].Uc();for(I in q.matrices={},this._matrices)q.matrices[I]=this._matrices[I].Uc();for(I in q.matrixArray={},this._matrixArrays)q.matrixArray[I]=this._matrixArrays[I];for(I in q.matrices3x3={},this._matrices3x3)q.matrices3x3[I]=this._matrices3x3[I];for(I in q.matrices2x2={},this._matrices2x2)q.matrices2x2[I]=this._matrices2x2[I];for(I in q.vectors2Arrays={},this._vectors2Arrays)q.vectors2Arrays[I]=this._vectors2Arrays[I];for(I in q.vectors3Arrays={},this._vectors3Arrays)q.vectors3Arrays[I]=this._vectors3Arrays[I];for(I in q.vectors4Arrays={},this._vectors4Arrays)q.vectors4Arrays[I]=this._vectors4Arrays[I];for(I in q.quaternionsArrays={},this._quaternionsArrays)q.quaternionsArrays[I]=this._quaternionsArrays[I];return q}static Parse(q,I,l){const t=w.c.Parse((()=>new V(q.name,I,q.shaderPath,q.options,q.storeEffectOnSubMeshes)),q,I,l);let c;for(c in q.cc&&t.cc.parse(q.cc,I,l),q.textures)t.setTexture(c,a.d.Parse(q.textures[c],I,l));for(c in q.textureArrays){const w=q.textureArrays[c],O=[];for(let q=0;q<w.length;q++)O.push(a.d.Parse(w[q],I,l));t.setTextureArray(c,O)}for(c in q.ints)t.setInt(c,q.ints[c]);for(c in q.uints)t.setUInt(c,q.uints[c]);for(c in q.floats)t.setFloat(c,q.floats[c]);for(c in q.floatsArrays)t.setFloats(c,q.floatsArrays[c]);for(c in q.colors3){const I=q.colors3[c];t.setColor3(c,{r:I[0],g:I[1],b:I[2]})}for(c in q.colors3Arrays){const I=q.colors3Arrays[c].reduce(((q,I,l)=>(l%3===0?q.push([I]):q[q.length-1].push(I),q)),[]).map((q=>({r:q[0],g:q[1],b:q[2]})));t.setColor3Array(c,I)}for(c in q.colors4){const I=q.colors4[c];t.setColor4(c,{r:I[0],g:I[1],b:I[2],a:I[3]})}for(c in q.colors4Arrays){const I=q.colors4Arrays[c].reduce(((q,I,l)=>(l%4===0?q.push([I]):q[q.length-1].push(I),q)),[]).map((q=>({r:q[0],g:q[1],b:q[2],a:q[3]})));t.setColor4Array(c,I)}for(c in q.vectors2){const I=q.vectors2[c];t.setVector2(c,{x:I[0],y:I[1]})}for(c in q.vectors3){const I=q.vectors3[c];t.setVector3(c,{x:I[0],y:I[1],z:I[2]})}for(c in q.vectors4){const I=q.vectors4[c];t.setVector4(c,{x:I[0],y:I[1],z:I[2],w:I[3]})}for(c in q.quaternions)t.setQuaternion(c,O.Quaternion.vI(q.quaternions[c]));for(c in q.matrices)t.setMatrix(c,O.Matrix.vI(q.matrices[c]));for(c in q.matrixArray)t._matrixArrays[c]=new Float32Array(q.matrixArray[c]);for(c in q.matrices3x3)t.setMatrix3x3(c,q.matrices3x3[c]);for(c in q.matrices2x2)t.setMatrix2x2(c,q.matrices2x2[c]);for(c in q.vectors2Arrays)t.setArray2(c,q.vectors2Arrays[c]);for(c in q.vectors3Arrays)t.setArray3(c,q.vectors3Arrays[c]);for(c in q.vectors4Arrays)t.setArray4(c,q.vectors4Arrays[c]);for(c in q.quaternionsArrays)t.setArray4(c,q.quaternionsArrays[c]);return t}static async ParseFromFileAsync(q,I,l){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((t,O)=>{const c=new Z.c;c.addEventListener("readystatechange",(()=>{if(4==c.readyState)if(200==c.status){const I=JSON.parse(c.responseText),O=this.Parse(I,l||x.e.LastCreatedScene,w);q&&(O.name=q),t(O)}else O("Unable to load the ShaderMaterial")})),c.open("GET",I),c.send()}))}static async ParseFromSnippetAsync(q,I){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((w,t)=>{const O=new Z.c;O.addEventListener("readystatechange",(()=>{if(4==O.readyState)if(200==O.status){const t=JSON.parse(JSON.parse(O.responseText).jsonPayload),c=JSON.parse(t.shaderMaterial),a=this.Parse(c,I||x.e.LastCreatedScene,l);a.snippetId=q,w(a)}else t("Unable to load the snippet "+q)})),O.open("GET",this.SnippetUrl+"/"+q.replace(/#/g,"/")),O.send()}))}}V.SnippetUrl="https://snippet.babylonjs.com",V.CreateFromSnippetAsync=V.ParseFromSnippetAsync,(0,F.e)("BABYLON.ShaderMaterial",V)}}]);