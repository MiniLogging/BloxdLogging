"use strict";(self.rsqbdnwe5e=self.rsqbdnwe5e||[]).push([[22],{12615:(N,p,T)=>{T.r(p),T.d(p,{ShaderMaterial:()=>I});var A=T(12409),a=T(12617),C=T(12371),U=T(12451),X=T(12352),y=T(12331),e=T(12700),H=T(12223),M=T(12702),b=T(12231),l=T(12736),k=T(12731);const x={effect:null,subMesh:null};class I extends M.e{constructor(N,p,T){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(N,p,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new C.Matrix,this._cachedWorldViewProjectionMatrix=new C.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=T,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...A}}get shaderPath(){return this._shaderPath}set shaderPath(N){this._shaderPath=N}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(N){-1===this._options.uniforms.indexOf(N)&&this._options.uniforms.push(N)}setTexture(N,p){return-1===this._options.samplers.indexOf(N)&&this._options.samplers.push(N),this._textures[N]=p,this}removeTexture(N){delete this._textures[N]}setTextureArray(N,p){return-1===this._options.samplers.indexOf(N)&&this._options.samplers.push(N),this._checkUniform(N),this._textureArrays[N]=p,this}setExternalTexture(N,p){return-1===this._options.externalTextures.indexOf(N)&&this._options.externalTextures.push(N),this._externalTextures[N]=p,this}setFloat(N,p){return this._checkUniform(N),this._floats[N]=p,this}setInt(N,p){return this._checkUniform(N),this._ints[N]=p,this}setUInt(N,p){return this._checkUniform(N),this._uints[N]=p,this}setFloats(N,p){return this._checkUniform(N),this._floatsArrays[N]=p,this}setColor3(N,p){return this._checkUniform(N),this._colors3[N]=p,this}setColor3Array(N,p){return this._checkUniform(N),this._colors3Arrays[N]=p.reduce(((N,p)=>(N.push(p.r,p.g,p.b),N)),[]),this}setColor4(N,p){return this._checkUniform(N),this._colors4[N]=p,this}setColor4Array(N,p){return this._checkUniform(N),this._colors4Arrays[N]=p.reduce(((N,p)=>(N.push(p.r,p.g,p.b,p.a),N)),[]),this}setVector2(N,p){return this._checkUniform(N),this._vectors2[N]=p,this}setVector3(N,p){return this._checkUniform(N),this._vectors3[N]=p,this}setVector4(N,p){return this._checkUniform(N),this._vectors4[N]=p,this}setQuaternion(N,p){return this._checkUniform(N),this._quaternions[N]=p,this}setQuaternionArray(N,p){return this._checkUniform(N),this._quaternionsArrays[N]=p.reduce(((N,p)=>(p.toArray(N,N.length),N)),[]),this}setMatrix(N,p){return this._checkUniform(N),this._matrices[N]=p,this}setMatrices(N,p){this._checkUniform(N);const T=new Float32Array(16*p.length);for(let A=0;A<p.length;A++){p[A].copyToArray(T,16*A)}return this._matrixArrays[N]=T,this}setMatrix3x3(N,p){return this._checkUniform(N),this._matrices3x3[N]=p,this}setMatrix2x2(N,p){return this._checkUniform(N),this._matrices2x2[N]=p,this}setArray2(N,p){return this._checkUniform(N),this._vectors2Arrays[N]=p,this}setArray3(N,p){return this._checkUniform(N),this._vectors3Arrays[N]=p,this}setArray4(N,p){return this._checkUniform(N),this._vectors4Arrays[N]=p,this}setUniformBuffer(N,p){return-1===this._options.uniformBuffers.indexOf(N)&&this._options.uniformBuffers.push(N),this._uniformBuffers[N]=p,this}setTextureSampler(N,p){return-1===this._options.samplerObjects.indexOf(N)&&this._options.samplerObjects.push(N),this._textureSamplers[N]=p,this}setStorageBuffer(N,p){return-1===this._options.storageBuffers.indexOf(N)&&this._options.storageBuffers.push(N),this._storageBuffers[N]=p,this}setDefine(N,p){const T=N.trimEnd()+" ",A=this.options.defines.findIndex((p=>p===N||p.startsWith(T)));return A>=0&&this.options.defines.splice(A,1),("boolean"!==typeof p||p)&&this.options.defines.push(T+p),this}isReadyForSubMesh(N,p,T){return this.isReady(N,T,p)}isReady(N,p,T){var A;const C=T&&this._storeEffectOnSubMeshes;if(this.isFrozen){const N=C?T._drawWrapper:this._drawWrapper;if(N.effect&&N._wasPreviouslyReady&&N._wasPreviouslyUsingInstances===p)return!0}const X=this.KN(),y=X.getEngine(),H=[],M=[];let b=null,I=this._shaderPath,L=this._options.uniforms,n=this._options.uniformBuffers,w=this._options.samplers;y.getCaps().multiview&&X.activeCamera&&X.activeCamera.outputRenderTarget&&X.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,H.push("#define MULTIVIEW"),-1!==L.indexOf("viewProjection")&&-1===L.indexOf("viewProjectionR")&&L.push("viewProjectionR"));for(let a=0;a<this._options.defines.length;a++){const N=0===this._options.defines[a].indexOf("#define")?this._options.defines[a]:`#define ${this._options.defines[a]}`;H.push(N)}for(let a=0;a<this._options.attributes.length;a++)M.push(this._options.attributes[a]);if(N&&N.isVerticesDataPresent(U.f.ColorKind)&&(-1===M.indexOf(U.f.ColorKind)&&M.push(U.f.ColorKind),H.push("#define VERTEXCOLOR")),p&&(H.push("#define INSTANCES"),(0,k.X)(M,this._materialHelperNeedsPreviousMatrices),null!==N&&void 0!==N&&N.hasThinInstances&&(H.push("#define THIN_INSTANCES"),N&&N.isVerticesDataPresent(U.f.ColorInstanceKind)&&(M.push(U.f.ColorInstanceKind),H.push("#define INSTANCESCOLOR")))),N&&N.useBones&&N.computeBonesUsingShaders&&N.skeleton){M.push(U.f.MatricesIndicesKind),M.push(U.f.MatricesWeightsKind),N.numBoneInfluencers>4&&(M.push(U.f.MatricesIndicesExtraKind),M.push(U.f.MatricesWeightsExtraKind));const p=N.skeleton;H.push("#define NUM_BONE_INFLUENCERS "+N.numBoneInfluencers),b=new e.e,b.addCPUSkinningFallback(0,N),p.isUsingTextureForMatrices?(H.push("#define BONETEXTURE"),-1===L.indexOf("boneTextureWidth")&&L.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(H.push("#define BonesPerMesh "+(p.bones.length+1)),-1===L.indexOf("mBones")&&L.push("mBones"))}else H.push("#define NUM_BONE_INFLUENCERS 0");let g=0;const P=N?N.morphTargetManager:null;if(P){const p=-1!==H.indexOf("#define UV1"),T=-1!==H.indexOf("#define UV2"),A=-1!==H.indexOf("#define TANGENT"),a=-1!==H.indexOf("#define NORMAL"),C=-1!==H.indexOf("#define VERTEXCOLOR");g=(0,k.D)(P,H,M,N,!0,a,A,p,T,C),P.isUsingTextureForTargets&&(-1===L.indexOf("morphTargetTextureIndices")&&L.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),g>0&&(L=L.slice(),L.push("morphTargetInfluences"),L.push("morphTargetCount"),L.push("morphTargetTextureInfo"),L.push("morphTargetTextureIndices"))}else H.push("#define NUM_MORPH_INFLUENCERS 0");if(N){const p=N.bakedVertexAnimationManager;p&&p.isEnabled&&(H.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===L.indexOf("bakedVertexAnimationSettings")&&L.push("bakedVertexAnimationSettings"),-1===L.indexOf("bakedVertexAnimationTextureSizeInverted")&&L.push("bakedVertexAnimationTextureSizeInverted"),-1===L.indexOf("bakedVertexAnimationTime")&&L.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,k.u)(M,N,H)}for(const a in this._textures)if(!this._textures[a].isReady())return!1;N&&this.needAlphaTestingForMesh(N)&&H.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,l.e)(L),(0,l.p)(this,X,H)),X.fogEnabled&&null!==N&&void 0!==N&&N.applyFog&&X.fogMode!==a.c.FOGMODE_NONE&&(H.push("#define FOG"),-1===L.indexOf("view")&&L.push("view"),-1===L.indexOf("vFogInfos")&&L.push("vFogInfos"),-1===L.indexOf("vFogColor")&&L.push("vFogColor")),this._useLogarithmicDepth&&(H.push("#define LOGARITHMICDEPTH"),-1===L.indexOf("logarithmicDepthConstant")&&L.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(L=L.slice(),n=n.slice(),w=w.slice(),I=this.customShaderNameResolve(this.name,L,n,w,H,M));const i=C?T._getDrawWrapper(void 0,!0):this._drawWrapper,K=(null===i||void 0===i?void 0:i.effect)??null,F=(null===i||void 0===i?void 0:i.defines)??null,v=H.join("\n");let W=K;return F!==v&&(W=y.createEffect(I,{attributes:M,uniformsNames:L,uniformBuffersNames:n,samplers:w,defines:v,fallbacks:b,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:g},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},y),C?T.setEffect(W,v,this._materialContext):i&&i.setEffect(W,v),this._onEffectCreatedObservable&&(x.effect=W,x.subMesh=T??(null===N||void 0===N?void 0:N.CX[0])??null,this._onEffectCreatedObservable.notifyObservers(x))),i._wasPreviouslyUsingInstances=!!p,!(null===(A=W)||void 0===A||!A.isReady())&&(K!==W&&X.resetCachedMaterial(),i._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(N,p){const T=p??this.getEffect();if(!T)return;const A=this._options.uniforms;-1!==A.indexOf("world")&&T.setMatrix("world",N);const a=this.KN();-1!==A.indexOf("worldView")&&(N.multiplyToRef(a.getViewMatrix(),this._cachedWorldViewMatrix),T.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==A.indexOf("worldViewProjection")&&(N.multiplyToRef(a.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),T.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==A.indexOf("view")&&T.setMatrix("view",a.getViewMatrix())}bindForSubMesh(N,p,T){var A;this.bind(N,p,null===(A=T._drawWrapperOverride)||void 0===A?void 0:A.effect,T)}bind(N,p,T,A){const a=A&&this._storeEffectOnSubMeshes,C=T??(a?A.effect:this.getEffect());if(!C)return;const U=this.KN();this._activeEffect=C,this.bindOnlyWorldMatrix(N,T);const X=this._options.uniformBuffers;let y=!1;if(C&&X&&X.length>0&&U.getEngine().supportsUniformBuffers)for(let M=0;M<X.length;++M){switch(X[M]){case"Mesh":p&&(p.getMeshUniformBuffer().bindToEffect(C,"Mesh"),p.transferToEffect(N));break;case"Scene":(0,k.m)(C,U.getSceneUniformBuffer()),U.finalizeSceneUbo(),y=!0}}const e=p&&a?this._mustRebind(U,C,A,p.visibility):U.getCachedMaterial()!==this;if(C&&e){let N;for(N in y||-1===this._options.uniforms.indexOf("view")||C.setMatrix("view",U.getViewMatrix()),y||-1===this._options.uniforms.indexOf("projection")||C.setMatrix("projection",U.getProjectionMatrix()),y||-1===this._options.uniforms.indexOf("viewProjection")||(C.setMatrix("viewProjection",U.getTransformMatrix()),this._multiview&&C.setMatrix("viewProjectionR",U._transformMatrixR)),U.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&C.setVector3("cameraPosition",U.activeCamera.globalPosition),(0,k.b)(p,C),(0,l.i)(C,this,U),this._useLogarithmicDepth&&(0,k.h)(a?A.materialDefines:C.defines,C,U),p&&(0,k.c)(U,p,C),this._textures)C.setTexture(N,this._textures[N]);for(N in this._textureArrays)C.setTextureArray(N,this._textureArrays[N]);for(N in this._ints)C.setInt(N,this._ints[N]);for(N in this._uints)C.setUInt(N,this._uints[N]);for(N in this._floats)C.setFloat(N,this._floats[N]);for(N in this._floatsArrays)C.setArray(N,this._floatsArrays[N]);for(N in this._colors3)C.setColor3(N,this._colors3[N]);for(N in this._colors3Arrays)C.setArray3(N,this._colors3Arrays[N]);for(N in this._colors4){const p=this._colors4[N];C.setFloat4(N,p.r,p.g,p.b,p.a)}for(N in this._colors4Arrays)C.setArray4(N,this._colors4Arrays[N]);for(N in this._vectors2)C.setVector2(N,this._vectors2[N]);for(N in this._vectors3)C.setVector3(N,this._vectors3[N]);for(N in this._vectors4)C.setVector4(N,this._vectors4[N]);for(N in this._quaternions)C.setQuaternion(N,this._quaternions[N]);for(N in this._matrices)C.setMatrix(N,this._matrices[N]);for(N in this._matrixArrays)C.setMatrices(N,this._matrixArrays[N]);for(N in this._matrices3x3)C.setMatrix3x3(N,this._matrices3x3[N]);for(N in this._matrices2x2)C.setMatrix2x2(N,this._matrices2x2[N]);for(N in this._vectors2Arrays)C.setArray2(N,this._vectors2Arrays[N]);for(N in this._vectors3Arrays)C.setArray3(N,this._vectors3Arrays[N]);for(N in this._vectors4Arrays)C.setArray4(N,this._vectors4Arrays[N]);for(N in this._quaternionsArrays)C.setArray4(N,this._quaternionsArrays[N]);for(N in this._uniformBuffers){const p=this._uniformBuffers[N].getBuffer();p&&C.bindUniformBuffer(p,N)}const T=U.getEngine(),X=T.setExternalTexture;if(X)for(N in this._externalTextures)X.call(T,N,this._externalTextures[N]);const e=T.setTextureSampler;if(e)for(N in this._textureSamplers)e.call(T,N,this._textureSamplers[N]);const H=T.setStorageBuffer;if(H)for(N in this._storageBuffers)H.call(T,N,this._storageBuffers[N])}if(C&&p&&(e||!this.isFrozen)){(0,k.k)(p,C),p.morphTargetManager&&p.morphTargetManager.isUsingTextureForTargets&&p.morphTargetManager._bind(C);const N=p.bakedVertexAnimationManager;if(N&&N.isEnabled){var H;const N=a?A._drawWrapper:this._drawWrapper;null===(H=p.bakedVertexAnimationManager)||void 0===H||H.bind(C,!!N._wasPreviouslyUsingInstances)}}this._afterBind(p,C,A)}getActiveTextures(){const N=super.getActiveTextures();for(const p in this._textures)N.push(this._textures[p]);for(const p in this._textureArrays){const T=this._textureArrays[p];for(let p=0;p<T.length;p++)N.push(T[p])}return N}hasTexture(N){if(super.hasTexture(N))return!0;for(const p in this._textures)if(this._textures[p]===N)return!0;for(const p in this._textureArrays){const T=this._textureArrays[p];for(let p=0;p<T.length;p++)if(T[p]===N)return!0}return!1}clone(N){const p=A.e.Clone((()=>new I(N,this.KN(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);p.name=N,p.id=N,"object"===typeof p._shaderPath&&(p._shaderPath={...p._shaderPath}),this._options={...this._options};const T=Object.keys(this._options);for(const A of T){const N=this._options[A];Array.isArray(N)&&(this._options[A]=N.slice(0))}this.sU.copyTo(p.sU);for(const A in this._textures)p.setTexture(A,this._textures[A]);for(const A in this._textureArrays)p.setTextureArray(A,this._textureArrays[A]);for(const A in this._externalTextures)p.setExternalTexture(A,this._externalTextures[A]);for(const A in this._ints)p.setInt(A,this._ints[A]);for(const A in this._uints)p.setUInt(A,this._uints[A]);for(const A in this._floats)p.setFloat(A,this._floats[A]);for(const A in this._floatsArrays)p.setFloats(A,this._floatsArrays[A]);for(const A in this._colors3)p.setColor3(A,this._colors3[A]);for(const A in this._colors3Arrays)p._colors3Arrays[A]=this._colors3Arrays[A];for(const A in this._colors4)p.setColor4(A,this._colors4[A]);for(const A in this._colors4Arrays)p._colors4Arrays[A]=this._colors4Arrays[A];for(const A in this._vectors2)p.setVector2(A,this._vectors2[A]);for(const A in this._vectors3)p.setVector3(A,this._vectors3[A]);for(const A in this._vectors4)p.setVector4(A,this._vectors4[A]);for(const A in this._quaternions)p.setQuaternion(A,this._quaternions[A]);for(const A in this._quaternionsArrays)p._quaternionsArrays[A]=this._quaternionsArrays[A];for(const A in this._matrices)p.setMatrix(A,this._matrices[A]);for(const A in this._matrixArrays)p._matrixArrays[A]=this._matrixArrays[A].slice();for(const A in this._matrices3x3)p.setMatrix3x3(A,this._matrices3x3[A]);for(const A in this._matrices2x2)p.setMatrix2x2(A,this._matrices2x2[A]);for(const A in this._vectors2Arrays)p.setArray2(A,this._vectors2Arrays[A]);for(const A in this._vectors3Arrays)p.setArray3(A,this._vectors3Arrays[A]);for(const A in this._vectors4Arrays)p.setArray4(A,this._vectors4Arrays[A]);for(const A in this._uniformBuffers)p.setUniformBuffer(A,this._uniformBuffers[A]);for(const A in this._textureSamplers)p.setTextureSampler(A,this._textureSamplers[A]);for(const A in this._storageBuffers)p.setStorageBuffer(A,this._storageBuffers[A]);return p}dispose(N,p,T){if(p){let N;for(N in this._textures)this._textures[N].dispose();for(N in this._textureArrays){const p=this._textureArrays[N];for(let N=0;N<p.length;N++)p[N].dispose()}}this._textures={},super.dispose(N,p,T)}serialize(){const N=A.e.Serialize(this);let p;for(p in N.customType="BABYLON.ShaderMaterial",N.uniqueId=this.uniqueId,N.options=this._options,N.shaderPath=this._shaderPath,N.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,N.sU=this.sU.serialize(),N.textures={},this._textures)N.textures[p]=this._textures[p].serialize();for(p in N.textureArrays={},this._textureArrays){N.textureArrays[p]=[];const T=this._textureArrays[p];for(let A=0;A<T.length;A++)N.textureArrays[p].push(T[A].serialize())}for(p in N.ints={},this._ints)N.ints[p]=this._ints[p];for(p in N.uints={},this._uints)N.uints[p]=this._uints[p];for(p in N.floats={},this._floats)N.floats[p]=this._floats[p];for(p in N.floatsArrays={},this._floatsArrays)N.floatsArrays[p]=this._floatsArrays[p];for(p in N.colors3={},this._colors3){const T=this._colors3[p];N.colors3[p]=[T.r,T.g,T.b]}for(p in N.colors3Arrays={},this._colors3Arrays)N.colors3Arrays[p]=this._colors3Arrays[p];for(p in N.colors4={},this._colors4){const T=this._colors4[p];N.colors4[p]=[T.r,T.g,T.b,T.a]}for(p in N.colors4Arrays={},this._colors4Arrays)N.colors4Arrays[p]=this._colors4Arrays[p];for(p in N.vectors2={},this._vectors2){const T=this._vectors2[p];N.vectors2[p]=[T.x,T.y]}for(p in N.vectors3={},this._vectors3){const T=this._vectors3[p];N.vectors3[p]=[T.x,T.y,T.z]}for(p in N.vectors4={},this._vectors4){const T=this._vectors4[p];N.vectors4[p]=[T.x,T.y,T.z,T.w]}for(p in N.quaternions={},this._quaternions)N.quaternions[p]=this._quaternions[p].UX();for(p in N.matrices={},this._matrices)N.matrices[p]=this._matrices[p].UX();for(p in N.matrixArray={},this._matrixArrays)N.matrixArray[p]=this._matrixArrays[p];for(p in N.matrices3x3={},this._matrices3x3)N.matrices3x3[p]=this._matrices3x3[p];for(p in N.matrices2x2={},this._matrices2x2)N.matrices2x2[p]=this._matrices2x2[p];for(p in N.vectors2Arrays={},this._vectors2Arrays)N.vectors2Arrays[p]=this._vectors2Arrays[p];for(p in N.vectors3Arrays={},this._vectors3Arrays)N.vectors3Arrays[p]=this._vectors3Arrays[p];for(p in N.vectors4Arrays={},this._vectors4Arrays)N.vectors4Arrays[p]=this._vectors4Arrays[p];for(p in N.quaternionsArrays={},this._quaternionsArrays)N.quaternionsArrays[p]=this._quaternionsArrays[p];return N}static Parse(N,p,T){const a=A.e.Parse((()=>new I(N.name,p,N.shaderPath,N.options,N.storeEffectOnSubMeshes)),N,p,T);let U;for(U in N.sU&&a.sU.parse(N.sU,p,T),N.textures)a.setTexture(U,X.c.Parse(N.textures[U],p,T));for(U in N.textureArrays){const A=N.textureArrays[U],C=[];for(let N=0;N<A.length;N++)C.push(X.c.Parse(A[N],p,T));a.setTextureArray(U,C)}for(U in N.ints)a.setInt(U,N.ints[U]);for(U in N.uints)a.setUInt(U,N.uints[U]);for(U in N.floats)a.setFloat(U,N.floats[U]);for(U in N.floatsArrays)a.setFloats(U,N.floatsArrays[U]);for(U in N.colors3){const p=N.colors3[U];a.setColor3(U,{r:p[0],g:p[1],b:p[2]})}for(U in N.colors3Arrays){const p=N.colors3Arrays[U].reduce(((N,p,T)=>(T%3===0?N.push([p]):N[N.length-1].push(p),N)),[]).map((N=>({r:N[0],g:N[1],b:N[2]})));a.setColor3Array(U,p)}for(U in N.colors4){const p=N.colors4[U];a.setColor4(U,{r:p[0],g:p[1],b:p[2],a:p[3]})}for(U in N.colors4Arrays){const p=N.colors4Arrays[U].reduce(((N,p,T)=>(T%4===0?N.push([p]):N[N.length-1].push(p),N)),[]).map((N=>({r:N[0],g:N[1],b:N[2],a:N[3]})));a.setColor4Array(U,p)}for(U in N.vectors2){const p=N.vectors2[U];a.setVector2(U,{x:p[0],y:p[1]})}for(U in N.vectors3){const p=N.vectors3[U];a.setVector3(U,{x:p[0],y:p[1],z:p[2]})}for(U in N.vectors4){const p=N.vectors4[U];a.setVector4(U,{x:p[0],y:p[1],z:p[2],w:p[3]})}for(U in N.quaternions)a.setQuaternion(U,C.Quaternion.gp(N.quaternions[U]));for(U in N.matrices)a.setMatrix(U,C.Matrix.gp(N.matrices[U]));for(U in N.matrixArray)a._matrixArrays[U]=new Float32Array(N.matrixArray[U]);for(U in N.matrices3x3)a.setMatrix3x3(U,N.matrices3x3[U]);for(U in N.matrices2x2)a.setMatrix2x2(U,N.matrices2x2[U]);for(U in N.vectors2Arrays)a.setArray2(U,N.vectors2Arrays[U]);for(U in N.vectors3Arrays)a.setArray3(U,N.vectors3Arrays[U]);for(U in N.vectors4Arrays)a.setArray4(U,N.vectors4Arrays[U]);for(U in N.quaternionsArrays)a.setArray4(U,N.quaternionsArrays[U]);return a}static async ParseFromFileAsync(N,p,T){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((a,C)=>{const U=new H.b;U.addEventListener("readystatechange",(()=>{if(4==U.readyState)if(200==U.status){const p=JSON.parse(U.responseText),C=this.Parse(p,T||b.b.LastCreatedScene,A);N&&(C.name=N),a(C)}else C("Unable to load the ShaderMaterial")})),U.open("GET",p),U.send()}))}static async ParseFromSnippetAsync(N,p){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((A,a)=>{const C=new H.b;C.addEventListener("readystatechange",(()=>{if(4==C.readyState)if(200==C.status){const a=JSON.parse(JSON.parse(C.responseText).jsonPayload),U=JSON.parse(a.shaderMaterial),X=this.Parse(U,p||b.b.LastCreatedScene,T);X.snippetId=N,A(X)}else a("Unable to load the snippet "+N)})),C.open("GET",this.SnippetUrl+"/"+N.replace(/#/g,"/")),C.send()}))}}I.SnippetUrl="https://snippet.babylonjs.com",I.CreateFromSnippetAsync=I.ParseFromSnippetAsync,(0,y.d)("BABYLON.ShaderMaterial",I)}}]);