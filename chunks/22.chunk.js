"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[22],{11981:(Z,h,V)=>{V.r(h),V.d(h,{ShaderMaterial:()=>b});var v=V(11769),A=V(11983),H=V(11729),K=V(11805),d=V(11713),a=V(11691),n=V(12050),x=V(11596),N=V(12053),D=V(11599),k=V(12099),u=V(12096);const F={effect:null,subMesh:null};class b extends N.b{constructor(Z,h,V){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(Z,h,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new H.Matrix,this._cachedWorldViewProjectionMatrix=new H.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=V,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...v}}get shaderPath(){return this._shaderPath}set shaderPath(Z){this._shaderPath=Z}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(Z){-1===this._options.uniforms.indexOf(Z)&&this._options.uniforms.push(Z)}setTexture(Z,h){return-1===this._options.samplers.indexOf(Z)&&this._options.samplers.push(Z),this._textures[Z]=h,this}removeTexture(Z){delete this._textures[Z]}setTextureArray(Z,h){return-1===this._options.samplers.indexOf(Z)&&this._options.samplers.push(Z),this._checkUniform(Z),this._textureArrays[Z]=h,this}setExternalTexture(Z,h){return-1===this._options.externalTextures.indexOf(Z)&&this._options.externalTextures.push(Z),this._externalTextures[Z]=h,this}setFloat(Z,h){return this._checkUniform(Z),this._floats[Z]=h,this}setInt(Z,h){return this._checkUniform(Z),this._ints[Z]=h,this}setUInt(Z,h){return this._checkUniform(Z),this._uints[Z]=h,this}setFloats(Z,h){return this._checkUniform(Z),this._floatsArrays[Z]=h,this}setColor3(Z,h){return this._checkUniform(Z),this._colors3[Z]=h,this}setColor3Array(Z,h){return this._checkUniform(Z),this._colors3Arrays[Z]=h.reduce(((Z,h)=>(Z.push(h.r,h.g,h.b),Z)),[]),this}setColor4(Z,h){return this._checkUniform(Z),this._colors4[Z]=h,this}setColor4Array(Z,h){return this._checkUniform(Z),this._colors4Arrays[Z]=h.reduce(((Z,h)=>(Z.push(h.r,h.g,h.b,h.a),Z)),[]),this}setVector2(Z,h){return this._checkUniform(Z),this._vectors2[Z]=h,this}setVector3(Z,h){return this._checkUniform(Z),this._vectors3[Z]=h,this}setVector4(Z,h){return this._checkUniform(Z),this._vectors4[Z]=h,this}setQuaternion(Z,h){return this._checkUniform(Z),this._quaternions[Z]=h,this}setQuaternionArray(Z,h){return this._checkUniform(Z),this._quaternionsArrays[Z]=h.reduce(((Z,h)=>(h.toArray(Z,Z.length),Z)),[]),this}setMatrix(Z,h){return this._checkUniform(Z),this._matrices[Z]=h,this}setMatrices(Z,h){this._checkUniform(Z);const V=new Float32Array(16*h.length);for(let v=0;v<h.length;v++){h[v].copyToArray(V,16*v)}return this._matrixArrays[Z]=V,this}setMatrix3x3(Z,h){return this._checkUniform(Z),this._matrices3x3[Z]=h,this}setMatrix2x2(Z,h){return this._checkUniform(Z),this._matrices2x2[Z]=h,this}setArray2(Z,h){return this._checkUniform(Z),this._vectors2Arrays[Z]=h,this}setArray3(Z,h){return this._checkUniform(Z),this._vectors3Arrays[Z]=h,this}setArray4(Z,h){return this._checkUniform(Z),this._vectors4Arrays[Z]=h,this}setUniformBuffer(Z,h){return-1===this._options.uniformBuffers.indexOf(Z)&&this._options.uniformBuffers.push(Z),this._uniformBuffers[Z]=h,this}setTextureSampler(Z,h){return-1===this._options.samplerObjects.indexOf(Z)&&this._options.samplerObjects.push(Z),this._textureSamplers[Z]=h,this}setStorageBuffer(Z,h){return-1===this._options.storageBuffers.indexOf(Z)&&this._options.storageBuffers.push(Z),this._storageBuffers[Z]=h,this}setDefine(Z,h){const V=Z.trimEnd()+" ",v=this.options.defines.findIndex((h=>h===Z||h.startsWith(V)));return v>=0&&this.options.defines.splice(v,1),("boolean"!==typeof h||h)&&this.options.defines.push(V+h),this}isReadyForSubMesh(Z,h,V){return this.isReady(Z,V,h)}isReady(Z,h,V){var v;const H=V&&this._storeEffectOnSubMeshes;if(this.isFrozen){const Z=H?V._drawWrapper:this._drawWrapper;if(Z.effect&&Z._wasPreviouslyReady&&Z._wasPreviouslyUsingInstances===h)return!0}const d=this.CZ(),a=d.getEngine(),x=[],N=[];let D=null,b=this._shaderPath,o=this._options.uniforms,q=this._options.uniformBuffers,X=this._options.samplers;a.getCaps().multiview&&d.activeCamera&&d.activeCamera.outputRenderTarget&&d.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,x.push("#define MULTIVIEW"),-1!==o.indexOf("viewProjection")&&-1===o.indexOf("viewProjectionR")&&o.push("viewProjectionR"));for(let A=0;A<this._options.defines.length;A++){const Z=0===this._options.defines[A].indexOf("#define")?this._options.defines[A]:`#define ${this._options.defines[A]}`;x.push(Z)}for(let A=0;A<this._options.attributes.length;A++)N.push(this._options.attributes[A]);if(Z&&Z.isVerticesDataPresent(K.f.ColorKind)&&(-1===N.indexOf(K.f.ColorKind)&&N.push(K.f.ColorKind),x.push("#define VERTEXCOLOR")),h&&(x.push("#define INSTANCES"),(0,u.fb)(N,this._materialHelperNeedsPreviousMatrices),null!==Z&&void 0!==Z&&Z.hasThinInstances&&(x.push("#define THIN_INSTANCES"),Z&&Z.isVerticesDataPresent(K.f.ColorInstanceKind)&&(N.push(K.f.ColorInstanceKind),x.push("#define INSTANCESCOLOR")))),Z&&Z.useBones&&Z.computeBonesUsingShaders&&Z.skeleton){N.push(K.f.MatricesIndicesKind),N.push(K.f.MatricesWeightsKind),Z.numBoneInfluencers>4&&(N.push(K.f.MatricesIndicesExtraKind),N.push(K.f.MatricesWeightsExtraKind));const h=Z.skeleton;x.push("#define NUM_BONE_INFLUENCERS "+Z.numBoneInfluencers),D=new n.c,D.addCPUSkinningFallback(0,Z),h.isUsingTextureForMatrices?(x.push("#define BONETEXTURE"),-1===o.indexOf("boneTextureWidth")&&o.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(x.push("#define BonesPerMesh "+(h.bones.length+1)),-1===o.indexOf("mBones")&&o.push("mBones"))}else x.push("#define NUM_BONE_INFLUENCERS 0");let E=0;const j=Z?Z.morphTargetManager:null;if(j){const h=-1!==x.indexOf("#define UV1"),V=-1!==x.indexOf("#define UV2"),v=-1!==x.indexOf("#define TANGENT"),A=-1!==x.indexOf("#define NORMAL"),H=-1!==x.indexOf("#define VERTEXCOLOR");E=(0,u.F)(j,x,N,Z,!0,A,v,h,V,H),j.isUsingTextureForTargets&&(-1===o.indexOf("morphTargetTextureIndices")&&o.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),E>0&&(o=o.slice(),o.push("morphTargetInfluences"),o.push("morphTargetCount"),o.push("morphTargetTextureInfo"),o.push("morphTargetTextureIndices"))}else x.push("#define NUM_MORPH_INFLUENCERS 0");if(Z){const h=Z.bakedVertexAnimationManager;h&&h.isEnabled&&(x.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===o.indexOf("bakedVertexAnimationSettings")&&o.push("bakedVertexAnimationSettings"),-1===o.indexOf("bakedVertexAnimationTextureSizeInverted")&&o.push("bakedVertexAnimationTextureSizeInverted"),-1===o.indexOf("bakedVertexAnimationTime")&&o.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,u.y)(N,Z,x)}for(const A in this._textures)if(!this._textures[A].isReady())return!1;Z&&this.needAlphaTestingForMesh(Z)&&x.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,k.c)(o),(0,k.j)(this,d,x)),d.fogEnabled&&null!==Z&&void 0!==Z&&Z.applyFog&&d.fogMode!==A.e.FOGMODE_NONE&&(x.push("#define FOG"),-1===o.indexOf("view")&&o.push("view"),-1===o.indexOf("vFogInfos")&&o.push("vFogInfos"),-1===o.indexOf("vFogColor")&&o.push("vFogColor")),this._useLogarithmicDepth&&(x.push("#define LOGARITHMICDEPTH"),-1===o.indexOf("logarithmicDepthConstant")&&o.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(o=o.slice(),q=q.slice(),X=X.slice(),b=this.customShaderNameResolve(this.name,o,q,X,x,N));const P=H?V._getDrawWrapper(void 0,!0):this._drawWrapper,C=(null===P||void 0===P?void 0:P.effect)??null,l=(null===P||void 0===P?void 0:P.defines)??null,B=x.join("\n");let S=C;return l!==B&&(S=a.createEffect(b,{attributes:N,uniformsNames:o,uniformBuffersNames:q,samplers:X,defines:B,fallbacks:D,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:E},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},a),H?V.setEffect(S,B,this._materialContext):P&&P.setEffect(S,B),this._onEffectCreatedObservable&&(F.effect=S,F.subMesh=V??(null===Z||void 0===Z?void 0:Z.zh[0])??null,this._onEffectCreatedObservable.notifyObservers(F))),P._wasPreviouslyUsingInstances=!!h,!(null===(v=S)||void 0===v||!v.isReady())&&(C!==S&&d.resetCachedMaterial(),P._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(Z,h){const V=h??this.getEffect();if(!V)return;const v=this._options.uniforms;-1!==v.indexOf("world")&&V.setMatrix("world",Z);const A=this.CZ();-1!==v.indexOf("worldView")&&(Z.multiplyToRef(A.getViewMatrix(),this._cachedWorldViewMatrix),V.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==v.indexOf("worldViewProjection")&&(Z.multiplyToRef(A.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),V.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==v.indexOf("view")&&V.setMatrix("view",A.getViewMatrix())}bindForSubMesh(Z,h,V){var v;this.bind(Z,h,null===(v=V._drawWrapperOverride)||void 0===v?void 0:v.effect,V)}bind(Z,h,V,v){const A=v&&this._storeEffectOnSubMeshes,H=V??(A?v.effect:this.getEffect());if(!H)return;const K=this.CZ();this._activeEffect=H,this.bindOnlyWorldMatrix(Z,V);const d=this._options.uniformBuffers;let a=!1;if(H&&d&&d.length>0&&K.getEngine().supportsUniformBuffers)for(let N=0;N<d.length;++N){switch(d[N]){case"Mesh":h&&(h.getMeshUniformBuffer().bindToEffect(H,"Mesh"),h.transferToEffect(Z));break;case"Scene":(0,u.p)(H,K.getSceneUniformBuffer()),K.finalizeSceneUbo(),a=!0}}const n=h&&A?this._mustRebind(K,H,v,h.visibility):K.getCachedMaterial()!==this;if(H&&n){let Z;for(Z in a||-1===this._options.uniforms.indexOf("view")||H.setMatrix("view",K.getViewMatrix()),a||-1===this._options.uniforms.indexOf("projection")||H.setMatrix("projection",K.getProjectionMatrix()),a||-1===this._options.uniforms.indexOf("viewProjection")||(H.setMatrix("viewProjection",K.getTransformMatrix()),this._multiview&&H.setMatrix("viewProjectionR",K._transformMatrixR)),K.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&H.setVector3("cameraPosition",K.activeCamera.globalPosition),(0,u.c)(h,H),(0,k.e)(H,this,K),this._useLogarithmicDepth&&(0,u.k)(A?v.materialDefines:H.defines,H,K),h&&(0,u.d)(K,h,H),this._textures)H.setTexture(Z,this._textures[Z]);for(Z in this._textureArrays)H.setTextureArray(Z,this._textureArrays[Z]);for(Z in this._ints)H.setInt(Z,this._ints[Z]);for(Z in this._uints)H.setUInt(Z,this._uints[Z]);for(Z in this._floats)H.setFloat(Z,this._floats[Z]);for(Z in this._floatsArrays)H.setArray(Z,this._floatsArrays[Z]);for(Z in this._colors3)H.setColor3(Z,this._colors3[Z]);for(Z in this._colors3Arrays)H.setArray3(Z,this._colors3Arrays[Z]);for(Z in this._colors4){const h=this._colors4[Z];H.setFloat4(Z,h.r,h.g,h.b,h.a)}for(Z in this._colors4Arrays)H.setArray4(Z,this._colors4Arrays[Z]);for(Z in this._vectors2)H.setVector2(Z,this._vectors2[Z]);for(Z in this._vectors3)H.setVector3(Z,this._vectors3[Z]);for(Z in this._vectors4)H.setVector4(Z,this._vectors4[Z]);for(Z in this._quaternions)H.setQuaternion(Z,this._quaternions[Z]);for(Z in this._matrices)H.setMatrix(Z,this._matrices[Z]);for(Z in this._matrixArrays)H.setMatrices(Z,this._matrixArrays[Z]);for(Z in this._matrices3x3)H.setMatrix3x3(Z,this._matrices3x3[Z]);for(Z in this._matrices2x2)H.setMatrix2x2(Z,this._matrices2x2[Z]);for(Z in this._vectors2Arrays)H.setArray2(Z,this._vectors2Arrays[Z]);for(Z in this._vectors3Arrays)H.setArray3(Z,this._vectors3Arrays[Z]);for(Z in this._vectors4Arrays)H.setArray4(Z,this._vectors4Arrays[Z]);for(Z in this._quaternionsArrays)H.setArray4(Z,this._quaternionsArrays[Z]);for(Z in this._uniformBuffers){const h=this._uniformBuffers[Z].getBuffer();h&&H.bindUniformBuffer(h,Z)}const V=K.getEngine(),d=V.setExternalTexture;if(d)for(Z in this._externalTextures)d.call(V,Z,this._externalTextures[Z]);const n=V.setTextureSampler;if(n)for(Z in this._textureSamplers)n.call(V,Z,this._textureSamplers[Z]);const x=V.setStorageBuffer;if(x)for(Z in this._storageBuffers)x.call(V,Z,this._storageBuffers[Z])}if(H&&h&&(n||!this.isFrozen)){(0,u.n)(h,H),h.morphTargetManager&&h.morphTargetManager.isUsingTextureForTargets&&h.morphTargetManager._bind(H);const Z=h.bakedVertexAnimationManager;if(Z&&Z.isEnabled){var x;const Z=A?v._drawWrapper:this._drawWrapper;null===(x=h.bakedVertexAnimationManager)||void 0===x||x.bind(H,!!Z._wasPreviouslyUsingInstances)}}this._afterBind(h,H,v)}getActiveTextures(){const Z=super.getActiveTextures();for(const h in this._textures)Z.push(this._textures[h]);for(const h in this._textureArrays){const V=this._textureArrays[h];for(let h=0;h<V.length;h++)Z.push(V[h])}return Z}hasTexture(Z){if(super.hasTexture(Z))return!0;for(const h in this._textures)if(this._textures[h]===Z)return!0;for(const h in this._textureArrays){const V=this._textureArrays[h];for(let h=0;h<V.length;h++)if(V[h]===Z)return!0}return!1}clone(Z){const h=v.b.Clone((()=>new b(Z,this.CZ(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);h.name=Z,h.id=Z,"object"===typeof h._shaderPath&&(h._shaderPath={...h._shaderPath}),this._options={...this._options};const V=Object.keys(this._options);for(const v of V){const Z=this._options[v];Array.isArray(Z)&&(this._options[v]=Z.slice(0))}this.stencil.copyTo(h.stencil);for(const v in this._textures)h.setTexture(v,this._textures[v]);for(const v in this._textureArrays)h.setTextureArray(v,this._textureArrays[v]);for(const v in this._externalTextures)h.setExternalTexture(v,this._externalTextures[v]);for(const v in this._ints)h.setInt(v,this._ints[v]);for(const v in this._uints)h.setUInt(v,this._uints[v]);for(const v in this._floats)h.setFloat(v,this._floats[v]);for(const v in this._floatsArrays)h.setFloats(v,this._floatsArrays[v]);for(const v in this._colors3)h.setColor3(v,this._colors3[v]);for(const v in this._colors3Arrays)h._colors3Arrays[v]=this._colors3Arrays[v];for(const v in this._colors4)h.setColor4(v,this._colors4[v]);for(const v in this._colors4Arrays)h._colors4Arrays[v]=this._colors4Arrays[v];for(const v in this._vectors2)h.setVector2(v,this._vectors2[v]);for(const v in this._vectors3)h.setVector3(v,this._vectors3[v]);for(const v in this._vectors4)h.setVector4(v,this._vectors4[v]);for(const v in this._quaternions)h.setQuaternion(v,this._quaternions[v]);for(const v in this._quaternionsArrays)h._quaternionsArrays[v]=this._quaternionsArrays[v];for(const v in this._matrices)h.setMatrix(v,this._matrices[v]);for(const v in this._matrixArrays)h._matrixArrays[v]=this._matrixArrays[v].slice();for(const v in this._matrices3x3)h.setMatrix3x3(v,this._matrices3x3[v]);for(const v in this._matrices2x2)h.setMatrix2x2(v,this._matrices2x2[v]);for(const v in this._vectors2Arrays)h.setArray2(v,this._vectors2Arrays[v]);for(const v in this._vectors3Arrays)h.setArray3(v,this._vectors3Arrays[v]);for(const v in this._vectors4Arrays)h.setArray4(v,this._vectors4Arrays[v]);for(const v in this._uniformBuffers)h.setUniformBuffer(v,this._uniformBuffers[v]);for(const v in this._textureSamplers)h.setTextureSampler(v,this._textureSamplers[v]);for(const v in this._storageBuffers)h.setStorageBuffer(v,this._storageBuffers[v]);return h}dispose(Z,h,V){if(h){let Z;for(Z in this._textures)this._textures[Z].dispose();for(Z in this._textureArrays){const h=this._textureArrays[Z];for(let Z=0;Z<h.length;Z++)h[Z].dispose()}}this._textures={},super.dispose(Z,h,V)}serialize(){const Z=v.b.Serialize(this);let h;for(h in Z.customType="BABYLON.ShaderMaterial",Z.uniqueId=this.uniqueId,Z.options=this._options,Z.shaderPath=this._shaderPath,Z.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,Z.stencil=this.stencil.serialize(),Z.textures={},this._textures)Z.textures[h]=this._textures[h].serialize();for(h in Z.textureArrays={},this._textureArrays){Z.textureArrays[h]=[];const V=this._textureArrays[h];for(let v=0;v<V.length;v++)Z.textureArrays[h].push(V[v].serialize())}for(h in Z.ints={},this._ints)Z.ints[h]=this._ints[h];for(h in Z.uints={},this._uints)Z.uints[h]=this._uints[h];for(h in Z.floats={},this._floats)Z.floats[h]=this._floats[h];for(h in Z.floatsArrays={},this._floatsArrays)Z.floatsArrays[h]=this._floatsArrays[h];for(h in Z.colors3={},this._colors3){const V=this._colors3[h];Z.colors3[h]=[V.r,V.g,V.b]}for(h in Z.colors3Arrays={},this._colors3Arrays)Z.colors3Arrays[h]=this._colors3Arrays[h];for(h in Z.colors4={},this._colors4){const V=this._colors4[h];Z.colors4[h]=[V.r,V.g,V.b,V.a]}for(h in Z.colors4Arrays={},this._colors4Arrays)Z.colors4Arrays[h]=this._colors4Arrays[h];for(h in Z.vectors2={},this._vectors2){const V=this._vectors2[h];Z.vectors2[h]=[V.x,V.y]}for(h in Z.vectors3={},this._vectors3){const V=this._vectors3[h];Z.vectors3[h]=[V.x,V.y,V.z]}for(h in Z.vectors4={},this._vectors4){const V=this._vectors4[h];Z.vectors4[h]=[V.x,V.y,V.z,V.w]}for(h in Z.quaternions={},this._quaternions)Z.quaternions[h]=this._quaternions[h].mh();for(h in Z.matrices={},this._matrices)Z.matrices[h]=this._matrices[h].mh();for(h in Z.matrixArray={},this._matrixArrays)Z.matrixArray[h]=this._matrixArrays[h];for(h in Z.matrices3x3={},this._matrices3x3)Z.matrices3x3[h]=this._matrices3x3[h];for(h in Z.matrices2x2={},this._matrices2x2)Z.matrices2x2[h]=this._matrices2x2[h];for(h in Z.vectors2Arrays={},this._vectors2Arrays)Z.vectors2Arrays[h]=this._vectors2Arrays[h];for(h in Z.vectors3Arrays={},this._vectors3Arrays)Z.vectors3Arrays[h]=this._vectors3Arrays[h];for(h in Z.vectors4Arrays={},this._vectors4Arrays)Z.vectors4Arrays[h]=this._vectors4Arrays[h];for(h in Z.quaternionsArrays={},this._quaternionsArrays)Z.quaternionsArrays[h]=this._quaternionsArrays[h];return Z}static Parse(Z,h,V){const A=v.b.Parse((()=>new b(Z.name,h,Z.shaderPath,Z.options,Z.storeEffectOnSubMeshes)),Z,h,V);let K;for(K in Z.stencil&&A.stencil.parse(Z.stencil,h,V),Z.textures)A.setTexture(K,d.e.Parse(Z.textures[K],h,V));for(K in Z.textureArrays){const v=Z.textureArrays[K],H=[];for(let Z=0;Z<v.length;Z++)H.push(d.e.Parse(v[Z],h,V));A.setTextureArray(K,H)}for(K in Z.ints)A.setInt(K,Z.ints[K]);for(K in Z.uints)A.setUInt(K,Z.uints[K]);for(K in Z.floats)A.setFloat(K,Z.floats[K]);for(K in Z.floatsArrays)A.setFloats(K,Z.floatsArrays[K]);for(K in Z.colors3){const h=Z.colors3[K];A.setColor3(K,{r:h[0],g:h[1],b:h[2]})}for(K in Z.colors3Arrays){const h=Z.colors3Arrays[K].reduce(((Z,h,V)=>(V%3===0?Z.push([h]):Z[Z.length-1].push(h),Z)),[]).map((Z=>({r:Z[0],g:Z[1],b:Z[2]})));A.setColor3Array(K,h)}for(K in Z.colors4){const h=Z.colors4[K];A.setColor4(K,{r:h[0],g:h[1],b:h[2],a:h[3]})}for(K in Z.colors4Arrays){const h=Z.colors4Arrays[K].reduce(((Z,h,V)=>(V%4===0?Z.push([h]):Z[Z.length-1].push(h),Z)),[]).map((Z=>({r:Z[0],g:Z[1],b:Z[2],a:Z[3]})));A.setColor4Array(K,h)}for(K in Z.vectors2){const h=Z.vectors2[K];A.setVector2(K,{x:h[0],y:h[1]})}for(K in Z.vectors3){const h=Z.vectors3[K];A.setVector3(K,{x:h[0],y:h[1],z:h[2]})}for(K in Z.vectors4){const h=Z.vectors4[K];A.setVector4(K,{x:h[0],y:h[1],z:h[2],w:h[3]})}for(K in Z.quaternions)A.setQuaternion(K,H.Quaternion.eh(Z.quaternions[K]));for(K in Z.matrices)A.setMatrix(K,H.Matrix.eh(Z.matrices[K]));for(K in Z.matrixArray)A._matrixArrays[K]=new Float32Array(Z.matrixArray[K]);for(K in Z.matrices3x3)A.setMatrix3x3(K,Z.matrices3x3[K]);for(K in Z.matrices2x2)A.setMatrix2x2(K,Z.matrices2x2[K]);for(K in Z.vectors2Arrays)A.setArray2(K,Z.vectors2Arrays[K]);for(K in Z.vectors3Arrays)A.setArray3(K,Z.vectors3Arrays[K]);for(K in Z.vectors4Arrays)A.setArray4(K,Z.vectors4Arrays[K]);for(K in Z.quaternionsArrays)A.setArray4(K,Z.quaternionsArrays[K]);return A}static async ParseFromFileAsync(Z,h,V){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((A,H)=>{const K=new x.e;K.addEventListener("readystatechange",(()=>{if(4==K.readyState)if(200==K.status){const h=JSON.parse(K.responseText),H=this.Parse(h,V||D.b.LastCreatedScene,v);Z&&(H.name=Z),A(H)}else H("Unable to load the ShaderMaterial")})),K.open("GET",h),K.send()}))}static async ParseFromSnippetAsync(Z,h){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((v,A)=>{const H=new x.e;H.addEventListener("readystatechange",(()=>{if(4==H.readyState)if(200==H.status){const A=JSON.parse(JSON.parse(H.responseText).jsonPayload),K=JSON.parse(A.shaderMaterial),d=this.Parse(K,h||D.b.LastCreatedScene,V);d.snippetId=Z,v(d)}else A("Unable to load the snippet "+Z)})),H.open("GET",this.SnippetUrl+"/"+Z.replace(/#/g,"/")),H.send()}))}}b.SnippetUrl="https://snippet.babylonjs.com",b.CreateFromSnippetAsync=b.ParseFromSnippetAsync,(0,a.i)("BABYLON.ShaderMaterial",b)}}]);