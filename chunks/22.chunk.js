"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[22],{11445:(Z,x,F)=>{F.r(x),F.d(x,{ShaderMaterial:()=>k});var u=F(11213),G=F(11447),f=F(11179),Y=F(11265),j=F(11157),d=F(11136),t=F(11512),o=F(11031),c=F(11520),s=F(11037),J=F(11572),p=F(11570);const U={effect:null,subMesh:null};class k extends c.b{constructor(Z,x,F){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(Z,x,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new f.Matrix,this._cachedWorldViewProjectionMatrix=new f.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=F,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...u}}get shaderPath(){return this._shaderPath}set shaderPath(Z){this._shaderPath=Z}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(Z){-1===this._options.uniforms.indexOf(Z)&&this._options.uniforms.push(Z)}setTexture(Z,x){return-1===this._options.samplers.indexOf(Z)&&this._options.samplers.push(Z),this._textures[Z]=x,this}removeTexture(Z){delete this._textures[Z]}setTextureArray(Z,x){return-1===this._options.samplers.indexOf(Z)&&this._options.samplers.push(Z),this._checkUniform(Z),this._textureArrays[Z]=x,this}setExternalTexture(Z,x){return-1===this._options.externalTextures.indexOf(Z)&&this._options.externalTextures.push(Z),this._externalTextures[Z]=x,this}setFloat(Z,x){return this._checkUniform(Z),this._floats[Z]=x,this}setInt(Z,x){return this._checkUniform(Z),this._ints[Z]=x,this}setUInt(Z,x){return this._checkUniform(Z),this._uints[Z]=x,this}setFloats(Z,x){return this._checkUniform(Z),this._floatsArrays[Z]=x,this}setColor3(Z,x){return this._checkUniform(Z),this._colors3[Z]=x,this}setColor3Array(Z,x){return this._checkUniform(Z),this._colors3Arrays[Z]=x.reduce(((Z,x)=>(Z.push(x.r,x.g,x.b),Z)),[]),this}setColor4(Z,x){return this._checkUniform(Z),this._colors4[Z]=x,this}setColor4Array(Z,x){return this._checkUniform(Z),this._colors4Arrays[Z]=x.reduce(((Z,x)=>(Z.push(x.r,x.g,x.b,x.a),Z)),[]),this}setVector2(Z,x){return this._checkUniform(Z),this._vectors2[Z]=x,this}setVector3(Z,x){return this._checkUniform(Z),this._vectors3[Z]=x,this}setVector4(Z,x){return this._checkUniform(Z),this._vectors4[Z]=x,this}setQuaternion(Z,x){return this._checkUniform(Z),this._quaternions[Z]=x,this}setQuaternionArray(Z,x){return this._checkUniform(Z),this._quaternionsArrays[Z]=x.reduce(((Z,x)=>(x.toArray(Z,Z.length),Z)),[]),this}setMatrix(Z,x){return this._checkUniform(Z),this._matrices[Z]=x,this}setMatrices(Z,x){this._checkUniform(Z);const F=new Float32Array(16*x.length);for(let u=0;u<x.length;u++){x[u].copyToArray(F,16*u)}return this._matrixArrays[Z]=F,this}setMatrix3x3(Z,x){return this._checkUniform(Z),this._matrices3x3[Z]=x,this}setMatrix2x2(Z,x){return this._checkUniform(Z),this._matrices2x2[Z]=x,this}setArray2(Z,x){return this._checkUniform(Z),this._vectors2Arrays[Z]=x,this}setArray3(Z,x){return this._checkUniform(Z),this._vectors3Arrays[Z]=x,this}setArray4(Z,x){return this._checkUniform(Z),this._vectors4Arrays[Z]=x,this}setUniformBuffer(Z,x){return-1===this._options.uniformBuffers.indexOf(Z)&&this._options.uniformBuffers.push(Z),this._uniformBuffers[Z]=x,this}setTextureSampler(Z,x){return-1===this._options.samplerObjects.indexOf(Z)&&this._options.samplerObjects.push(Z),this._textureSamplers[Z]=x,this}setStorageBuffer(Z,x){return-1===this._options.storageBuffers.indexOf(Z)&&this._options.storageBuffers.push(Z),this._storageBuffers[Z]=x,this}setDefine(Z,x){const F=Z.trimEnd()+" ",u=this.options.defines.findIndex((x=>x===Z||x.startsWith(F)));return u>=0&&this.options.defines.splice(u,1),("boolean"!==typeof x||x)&&this.options.defines.push(F+x),this}isReadyForSubMesh(Z,x,F){return this.isReady(Z,F,x)}isReady(Z,x,F){var u;const f=F&&this._storeEffectOnSubMeshes;if(this.isFrozen){const Z=f?F._drawWrapper:this._drawWrapper;if(Z.effect&&Z._wasPreviouslyReady&&Z._wasPreviouslyUsingInstances===x)return!0}const j=this.KZ(),d=j.getEngine(),o=[],c=[];let s=null,k=this._shaderPath,M=this._options.uniforms,m=this._options.uniformBuffers,C=this._options.samplers;d.getCaps().multiview&&j.activeCamera&&j.activeCamera.outputRenderTarget&&j.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,o.push("#define MULTIVIEW"),-1!==M.indexOf("viewProjection")&&-1===M.indexOf("viewProjectionR")&&M.push("viewProjectionR"));for(let G=0;G<this._options.defines.length;G++){const Z=0===this._options.defines[G].indexOf("#define")?this._options.defines[G]:`#define ${this._options.defines[G]}`;o.push(Z)}for(let G=0;G<this._options.attributes.length;G++)c.push(this._options.attributes[G]);if(Z&&Z.isVerticesDataPresent(Y.f.ColorKind)&&(-1===c.indexOf(Y.f.ColorKind)&&c.push(Y.f.ColorKind),o.push("#define VERTEXCOLOR")),x&&(o.push("#define INSTANCES"),(0,p.ib)(c,this._materialHelperNeedsPreviousMatrices),null!==Z&&void 0!==Z&&Z.hasThinInstances&&(o.push("#define THIN_INSTANCES"),Z&&Z.isVerticesDataPresent(Y.f.ColorInstanceKind)&&(c.push(Y.f.ColorInstanceKind),o.push("#define INSTANCESCOLOR")))),Z&&Z.useBones&&Z.computeBonesUsingShaders&&Z.skeleton){c.push(Y.f.MatricesIndicesKind),c.push(Y.f.MatricesWeightsKind),Z.numBoneInfluencers>4&&(c.push(Y.f.MatricesIndicesExtraKind),c.push(Y.f.MatricesWeightsExtraKind));const x=Z.skeleton;o.push("#define NUM_BONE_INFLUENCERS "+Z.numBoneInfluencers),s=new t.d,s.addCPUSkinningFallback(0,Z),x.isUsingTextureForMatrices?(o.push("#define BONETEXTURE"),-1===M.indexOf("boneTextureWidth")&&M.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(o.push("#define BonesPerMesh "+(x.bones.length+1)),-1===M.indexOf("mBones")&&M.push("mBones"))}else o.push("#define NUM_BONE_INFLUENCERS 0");let L=0;const H=Z?Z.morphTargetManager:null;if(H){const x=-1!==o.indexOf("#define UV1"),F=-1!==o.indexOf("#define UV2"),u=-1!==o.indexOf("#define TANGENT"),G=-1!==o.indexOf("#define NORMAL"),f=-1!==o.indexOf("#define VERTEXCOLOR");L=(0,p.G)(H,o,c,Z,!0,G,u,x,F,f),H.isUsingTextureForTargets&&(-1===M.indexOf("morphTargetTextureIndices")&&M.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),L>0&&(M=M.slice(),M.push("morphTargetInfluences"),M.push("morphTargetCount"),M.push("morphTargetTextureInfo"),M.push("morphTargetTextureIndices"))}else o.push("#define NUM_MORPH_INFLUENCERS 0");if(Z){const x=Z.bakedVertexAnimationManager;x&&x.isEnabled&&(o.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===M.indexOf("bakedVertexAnimationSettings")&&M.push("bakedVertexAnimationSettings"),-1===M.indexOf("bakedVertexAnimationTextureSizeInverted")&&M.push("bakedVertexAnimationTextureSizeInverted"),-1===M.indexOf("bakedVertexAnimationTime")&&M.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,p.y)(c,Z,o)}for(const G in this._textures)if(!this._textures[G].isReady())return!1;Z&&this.needAlphaTestingForMesh(Z)&&o.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,J.b)(M),(0,J.i)(this,j,o)),j.fogEnabled&&null!==Z&&void 0!==Z&&Z.applyFog&&j.fogMode!==G.d.FOGMODE_NONE&&(o.push("#define FOG"),-1===M.indexOf("view")&&M.push("view"),-1===M.indexOf("vFogInfos")&&M.push("vFogInfos"),-1===M.indexOf("vFogColor")&&M.push("vFogColor")),this._useLogarithmicDepth&&(o.push("#define LOGARITHMICDEPTH"),-1===M.indexOf("logarithmicDepthConstant")&&M.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(M=M.slice(),m=m.slice(),C=C.slice(),k=this.customShaderNameResolve(this.name,M,m,C,o,c));const S=f?F._getDrawWrapper(void 0,!0):this._drawWrapper,K=(null===S||void 0===S?void 0:S.effect)??null,y=(null===S||void 0===S?void 0:S.defines)??null,q=o.join("\n");let R=K;return y!==q&&(R=d.createEffect(k,{attributes:c,uniformsNames:M,uniformBuffersNames:m,samplers:C,defines:q,fallbacks:s,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:L},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},d),f?F.setEffect(R,q,this._materialContext):S&&S.setEffect(R,q),this._onEffectCreatedObservable&&(U.effect=R,U.subMesh=F??(null===Z||void 0===Z?void 0:Z.bf[0])??null,this._onEffectCreatedObservable.notifyObservers(U))),S._wasPreviouslyUsingInstances=!!x,!(null===(u=R)||void 0===u||!u.isReady())&&(K!==R&&j.resetCachedMaterial(),S._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(Z,x){const F=x??this.getEffect();if(!F)return;const u=this._options.uniforms;-1!==u.indexOf("world")&&F.setMatrix("world",Z);const G=this.KZ();-1!==u.indexOf("worldView")&&(Z.multiplyToRef(G.getViewMatrix(),this._cachedWorldViewMatrix),F.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==u.indexOf("worldViewProjection")&&(Z.multiplyToRef(G.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),F.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==u.indexOf("view")&&F.setMatrix("view",G.getViewMatrix())}bindForSubMesh(Z,x,F){var u;this.bind(Z,x,null===(u=F._drawWrapperOverride)||void 0===u?void 0:u.effect,F)}bind(Z,x,F,u){const G=u&&this._storeEffectOnSubMeshes,f=F??(G?u.effect:this.getEffect());if(!f)return;const Y=this.KZ();this._activeEffect=f,this.bindOnlyWorldMatrix(Z,F);const j=this._options.uniformBuffers;let d=!1;if(f&&j&&j.length>0&&Y.getEngine().supportsUniformBuffers)for(let c=0;c<j.length;++c){switch(j[c]){case"Mesh":x&&(x.getMeshUniformBuffer().bindToEffect(f,"Mesh"),x.transferToEffect(Z));break;case"Scene":(0,p.o)(f,Y.getSceneUniformBuffer()),Y.finalizeSceneUbo(),d=!0}}const t=x&&G?this._mustRebind(Y,f,u,x.visibility):Y.getCachedMaterial()!==this;if(f&&t){let Z;for(Z in d||-1===this._options.uniforms.indexOf("view")||f.setMatrix("view",Y.getViewMatrix()),d||-1===this._options.uniforms.indexOf("projection")||f.setMatrix("projection",Y.getProjectionMatrix()),d||-1===this._options.uniforms.indexOf("viewProjection")||(f.setMatrix("viewProjection",Y.getTransformMatrix()),this._multiview&&f.setMatrix("viewProjectionR",Y._transformMatrixR)),Y.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&f.setVector3("cameraPosition",Y.activeCamera.globalPosition),(0,p.e)(x,f),(0,J.f)(f,this,Y),this._useLogarithmicDepth&&(0,p.l)(G?u.materialDefines:f.defines,f,Y),x&&(0,p.f)(Y,x,f),this._textures)f.setTexture(Z,this._textures[Z]);for(Z in this._textureArrays)f.setTextureArray(Z,this._textureArrays[Z]);for(Z in this._ints)f.setInt(Z,this._ints[Z]);for(Z in this._uints)f.setUInt(Z,this._uints[Z]);for(Z in this._floats)f.setFloat(Z,this._floats[Z]);for(Z in this._floatsArrays)f.setArray(Z,this._floatsArrays[Z]);for(Z in this._colors3)f.setColor3(Z,this._colors3[Z]);for(Z in this._colors3Arrays)f.setArray3(Z,this._colors3Arrays[Z]);for(Z in this._colors4){const x=this._colors4[Z];f.setFloat4(Z,x.r,x.g,x.b,x.a)}for(Z in this._colors4Arrays)f.setArray4(Z,this._colors4Arrays[Z]);for(Z in this._vectors2)f.setVector2(Z,this._vectors2[Z]);for(Z in this._vectors3)f.setVector3(Z,this._vectors3[Z]);for(Z in this._vectors4)f.setVector4(Z,this._vectors4[Z]);for(Z in this._quaternions)f.setQuaternion(Z,this._quaternions[Z]);for(Z in this._matrices)f.setMatrix(Z,this._matrices[Z]);for(Z in this._matrixArrays)f.setMatrices(Z,this._matrixArrays[Z]);for(Z in this._matrices3x3)f.setMatrix3x3(Z,this._matrices3x3[Z]);for(Z in this._matrices2x2)f.setMatrix2x2(Z,this._matrices2x2[Z]);for(Z in this._vectors2Arrays)f.setArray2(Z,this._vectors2Arrays[Z]);for(Z in this._vectors3Arrays)f.setArray3(Z,this._vectors3Arrays[Z]);for(Z in this._vectors4Arrays)f.setArray4(Z,this._vectors4Arrays[Z]);for(Z in this._quaternionsArrays)f.setArray4(Z,this._quaternionsArrays[Z]);for(Z in this._uniformBuffers){const x=this._uniformBuffers[Z].getBuffer();x&&f.bindUniformBuffer(x,Z)}const F=Y.getEngine(),j=F.setExternalTexture;if(j)for(Z in this._externalTextures)j.call(F,Z,this._externalTextures[Z]);const t=F.setTextureSampler;if(t)for(Z in this._textureSamplers)t.call(F,Z,this._textureSamplers[Z]);const o=F.setStorageBuffer;if(o)for(Z in this._storageBuffers)o.call(F,Z,this._storageBuffers[Z])}if(f&&x&&(t||!this.isFrozen)){(0,p.m)(x,f),x.morphTargetManager&&x.morphTargetManager.isUsingTextureForTargets&&x.morphTargetManager._bind(f);const Z=x.bakedVertexAnimationManager;if(Z&&Z.isEnabled){var o;const Z=G?u._drawWrapper:this._drawWrapper;null===(o=x.bakedVertexAnimationManager)||void 0===o||o.bind(f,!!Z._wasPreviouslyUsingInstances)}}this._afterBind(x,f,u)}getActiveTextures(){const Z=super.getActiveTextures();for(const x in this._textures)Z.push(this._textures[x]);for(const x in this._textureArrays){const F=this._textureArrays[x];for(let x=0;x<F.length;x++)Z.push(F[x])}return Z}hasTexture(Z){if(super.hasTexture(Z))return!0;for(const x in this._textures)if(this._textures[x]===Z)return!0;for(const x in this._textureArrays){const F=this._textureArrays[x];for(let x=0;x<F.length;x++)if(F[x]===Z)return!0}return!1}clone(Z){const x=u.c.Clone((()=>new k(Z,this.KZ(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);x.name=Z,x.id=Z,"object"===typeof x._shaderPath&&(x._shaderPath={...x._shaderPath}),this._options={...this._options};const F=Object.keys(this._options);for(const u of F){const Z=this._options[u];Array.isArray(Z)&&(this._options[u]=Z.slice(0))}this.stencil.copyTo(x.stencil);for(const u in this._textures)x.setTexture(u,this._textures[u]);for(const u in this._textureArrays)x.setTextureArray(u,this._textureArrays[u]);for(const u in this._externalTextures)x.setExternalTexture(u,this._externalTextures[u]);for(const u in this._ints)x.setInt(u,this._ints[u]);for(const u in this._uints)x.setUInt(u,this._uints[u]);for(const u in this._floats)x.setFloat(u,this._floats[u]);for(const u in this._floatsArrays)x.setFloats(u,this._floatsArrays[u]);for(const u in this._colors3)x.setColor3(u,this._colors3[u]);for(const u in this._colors3Arrays)x._colors3Arrays[u]=this._colors3Arrays[u];for(const u in this._colors4)x.setColor4(u,this._colors4[u]);for(const u in this._colors4Arrays)x._colors4Arrays[u]=this._colors4Arrays[u];for(const u in this._vectors2)x.setVector2(u,this._vectors2[u]);for(const u in this._vectors3)x.setVector3(u,this._vectors3[u]);for(const u in this._vectors4)x.setVector4(u,this._vectors4[u]);for(const u in this._quaternions)x.setQuaternion(u,this._quaternions[u]);for(const u in this._quaternionsArrays)x._quaternionsArrays[u]=this._quaternionsArrays[u];for(const u in this._matrices)x.setMatrix(u,this._matrices[u]);for(const u in this._matrixArrays)x._matrixArrays[u]=this._matrixArrays[u].slice();for(const u in this._matrices3x3)x.setMatrix3x3(u,this._matrices3x3[u]);for(const u in this._matrices2x2)x.setMatrix2x2(u,this._matrices2x2[u]);for(const u in this._vectors2Arrays)x.setArray2(u,this._vectors2Arrays[u]);for(const u in this._vectors3Arrays)x.setArray3(u,this._vectors3Arrays[u]);for(const u in this._vectors4Arrays)x.setArray4(u,this._vectors4Arrays[u]);for(const u in this._uniformBuffers)x.setUniformBuffer(u,this._uniformBuffers[u]);for(const u in this._textureSamplers)x.setTextureSampler(u,this._textureSamplers[u]);for(const u in this._storageBuffers)x.setStorageBuffer(u,this._storageBuffers[u]);return x}dispose(Z,x,F){if(x){let Z;for(Z in this._textures)this._textures[Z].dispose();for(Z in this._textureArrays){const x=this._textureArrays[Z];for(let Z=0;Z<x.length;Z++)x[Z].dispose()}}this._textures={},super.dispose(Z,x,F)}serialize(){const Z=u.c.Serialize(this);let x;for(x in Z.customType="BABYLON.ShaderMaterial",Z.uniqueId=this.uniqueId,Z.options=this._options,Z.shaderPath=this._shaderPath,Z.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,Z.stencil=this.stencil.serialize(),Z.textures={},this._textures)Z.textures[x]=this._textures[x].serialize();for(x in Z.textureArrays={},this._textureArrays){Z.textureArrays[x]=[];const F=this._textureArrays[x];for(let u=0;u<F.length;u++)Z.textureArrays[x].push(F[u].serialize())}for(x in Z.ints={},this._ints)Z.ints[x]=this._ints[x];for(x in Z.uints={},this._uints)Z.uints[x]=this._uints[x];for(x in Z.floats={},this._floats)Z.floats[x]=this._floats[x];for(x in Z.floatsArrays={},this._floatsArrays)Z.floatsArrays[x]=this._floatsArrays[x];for(x in Z.colors3={},this._colors3){const F=this._colors3[x];Z.colors3[x]=[F.r,F.g,F.b]}for(x in Z.colors3Arrays={},this._colors3Arrays)Z.colors3Arrays[x]=this._colors3Arrays[x];for(x in Z.colors4={},this._colors4){const F=this._colors4[x];Z.colors4[x]=[F.r,F.g,F.b,F.a]}for(x in Z.colors4Arrays={},this._colors4Arrays)Z.colors4Arrays[x]=this._colors4Arrays[x];for(x in Z.vectors2={},this._vectors2){const F=this._vectors2[x];Z.vectors2[x]=[F.x,F.y]}for(x in Z.vectors3={},this._vectors3){const F=this._vectors3[x];Z.vectors3[x]=[F.x,F.y,F.z]}for(x in Z.vectors4={},this._vectors4){const F=this._vectors4[x];Z.vectors4[x]=[F.x,F.y,F.z,F.w]}for(x in Z.quaternions={},this._quaternions)Z.quaternions[x]=this._quaternions[x].Wf();for(x in Z.matrices={},this._matrices)Z.matrices[x]=this._matrices[x].Wf();for(x in Z.matrixArray={},this._matrixArrays)Z.matrixArray[x]=this._matrixArrays[x];for(x in Z.matrices3x3={},this._matrices3x3)Z.matrices3x3[x]=this._matrices3x3[x];for(x in Z.matrices2x2={},this._matrices2x2)Z.matrices2x2[x]=this._matrices2x2[x];for(x in Z.vectors2Arrays={},this._vectors2Arrays)Z.vectors2Arrays[x]=this._vectors2Arrays[x];for(x in Z.vectors3Arrays={},this._vectors3Arrays)Z.vectors3Arrays[x]=this._vectors3Arrays[x];for(x in Z.vectors4Arrays={},this._vectors4Arrays)Z.vectors4Arrays[x]=this._vectors4Arrays[x];for(x in Z.quaternionsArrays={},this._quaternionsArrays)Z.quaternionsArrays[x]=this._quaternionsArrays[x];return Z}static Parse(Z,x,F){const G=u.c.Parse((()=>new k(Z.name,x,Z.shaderPath,Z.options,Z.storeEffectOnSubMeshes)),Z,x,F);let Y;for(Y in Z.stencil&&G.stencil.parse(Z.stencil,x,F),Z.textures)G.setTexture(Y,j.c.Parse(Z.textures[Y],x,F));for(Y in Z.textureArrays){const u=Z.textureArrays[Y],f=[];for(let Z=0;Z<u.length;Z++)f.push(j.c.Parse(u[Z],x,F));G.setTextureArray(Y,f)}for(Y in Z.ints)G.setInt(Y,Z.ints[Y]);for(Y in Z.uints)G.setUInt(Y,Z.uints[Y]);for(Y in Z.floats)G.setFloat(Y,Z.floats[Y]);for(Y in Z.floatsArrays)G.setFloats(Y,Z.floatsArrays[Y]);for(Y in Z.colors3){const x=Z.colors3[Y];G.setColor3(Y,{r:x[0],g:x[1],b:x[2]})}for(Y in Z.colors3Arrays){const x=Z.colors3Arrays[Y].reduce(((Z,x,F)=>(F%3===0?Z.push([x]):Z[Z.length-1].push(x),Z)),[]).map((Z=>({r:Z[0],g:Z[1],b:Z[2]})));G.setColor3Array(Y,x)}for(Y in Z.colors4){const x=Z.colors4[Y];G.setColor4(Y,{r:x[0],g:x[1],b:x[2],a:x[3]})}for(Y in Z.colors4Arrays){const x=Z.colors4Arrays[Y].reduce(((Z,x,F)=>(F%4===0?Z.push([x]):Z[Z.length-1].push(x),Z)),[]).map((Z=>({r:Z[0],g:Z[1],b:Z[2],a:Z[3]})));G.setColor4Array(Y,x)}for(Y in Z.vectors2){const x=Z.vectors2[Y];G.setVector2(Y,{x:x[0],y:x[1]})}for(Y in Z.vectors3){const x=Z.vectors3[Y];G.setVector3(Y,{x:x[0],y:x[1],z:x[2]})}for(Y in Z.vectors4){const x=Z.vectors4[Y];G.setVector4(Y,{x:x[0],y:x[1],z:x[2],w:x[3]})}for(Y in Z.quaternions)G.setQuaternion(Y,f.Quaternion.Hx(Z.quaternions[Y]));for(Y in Z.matrices)G.setMatrix(Y,f.Matrix.Hx(Z.matrices[Y]));for(Y in Z.matrixArray)G._matrixArrays[Y]=new Float32Array(Z.matrixArray[Y]);for(Y in Z.matrices3x3)G.setMatrix3x3(Y,Z.matrices3x3[Y]);for(Y in Z.matrices2x2)G.setMatrix2x2(Y,Z.matrices2x2[Y]);for(Y in Z.vectors2Arrays)G.setArray2(Y,Z.vectors2Arrays[Y]);for(Y in Z.vectors3Arrays)G.setArray3(Y,Z.vectors3Arrays[Y]);for(Y in Z.vectors4Arrays)G.setArray4(Y,Z.vectors4Arrays[Y]);for(Y in Z.quaternionsArrays)G.setArray4(Y,Z.quaternionsArrays[Y]);return G}static async ParseFromFileAsync(Z,x,F){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((G,f)=>{const Y=new o.b;Y.addEventListener("readystatechange",(()=>{if(4==Y.readyState)if(200==Y.status){const x=JSON.parse(Y.responseText),f=this.Parse(x,F||s.c.LastCreatedScene,u);Z&&(f.name=Z),G(f)}else f("Unable to load the ShaderMaterial")})),Y.open("GET",x),Y.send()}))}static async ParseFromSnippetAsync(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((u,G)=>{const f=new o.b;f.addEventListener("readystatechange",(()=>{if(4==f.readyState)if(200==f.status){const G=JSON.parse(JSON.parse(f.responseText).jsonPayload),Y=JSON.parse(G.shaderMaterial),j=this.Parse(Y,x||s.c.LastCreatedScene,F);j.snippetId=Z,u(j)}else G("Unable to load the snippet "+Z)})),f.open("GET",this.SnippetUrl+"/"+Z.replace(/#/g,"/")),f.send()}))}}k.SnippetUrl="https://snippet.babylonjs.com",k.CreateFromSnippetAsync=k.ParseFromSnippetAsync,(0,d.g)("BABYLON.ShaderMaterial",k)}}]);