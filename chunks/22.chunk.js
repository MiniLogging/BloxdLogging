"use strict";(self.ra6kpa9z1sg=self.ra6kpa9z1sg||[]).push([[22],{13007:(p,b,M)=>{M.r(b),M.d(b,{ShaderMaterial:()=>g});var h=M(12812),Q=M(13013),mp=M(12777),y=M(12847),P=M(12753),w=M(12730),t=M(13087),z=M(12644),x=M(13094),S=M(12652),X=M(13147),c=M(13143);const J={effect:null,subMesh:null};class g extends x.c{constructor(p,b,M){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(p,b,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new mp.Matrix,this._cachedWorldViewProjectionMatrix=new mp.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=M,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...h}}get shaderPath(){return this._shaderPath}set shaderPath(p){this._shaderPath=p}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(p){-1===this._options.uniforms.indexOf(p)&&this._options.uniforms.push(p)}setTexture(p,b){return-1===this._options.samplers.indexOf(p)&&this._options.samplers.push(p),this._textures[p]=b,this}removeTexture(p){delete this._textures[p]}setTextureArray(p,b){return-1===this._options.samplers.indexOf(p)&&this._options.samplers.push(p),this._checkUniform(p),this._textureArrays[p]=b,this}setExternalTexture(p,b){return-1===this._options.externalTextures.indexOf(p)&&this._options.externalTextures.push(p),this._externalTextures[p]=b,this}setFloat(p,b){return this._checkUniform(p),this._floats[p]=b,this}setInt(p,b){return this._checkUniform(p),this._ints[p]=b,this}setUInt(p,b){return this._checkUniform(p),this._uints[p]=b,this}setFloats(p,b){return this._checkUniform(p),this._floatsArrays[p]=b,this}setColor3(p,b){return this._checkUniform(p),this._colors3[p]=b,this}setColor3Array(p,b){return this._checkUniform(p),this._colors3Arrays[p]=b.reduce(((p,b)=>(p.push(b.r,b.g,b.b),p)),[]),this}setColor4(p,b){return this._checkUniform(p),this._colors4[p]=b,this}setColor4Array(p,b){return this._checkUniform(p),this._colors4Arrays[p]=b.reduce(((p,b)=>(p.push(b.r,b.g,b.b,b.a),p)),[]),this}setVector2(p,b){return this._checkUniform(p),this._vectors2[p]=b,this}setVector3(p,b){return this._checkUniform(p),this._vectors3[p]=b,this}setVector4(p,b){return this._checkUniform(p),this._vectors4[p]=b,this}setQuaternion(p,b){return this._checkUniform(p),this._quaternions[p]=b,this}setQuaternionArray(p,b){return this._checkUniform(p),this._quaternionsArrays[p]=b.reduce(((p,b)=>(b.toArray(p,p.length),p)),[]),this}setMatrix(p,b){return this._checkUniform(p),this._matrices[p]=b,this}setMatrices(p,b){this._checkUniform(p);const M=new Float32Array(16*b.length);for(let h=0;h<b.length;h++){b[h].copyToArray(M,16*h)}return this._matrixArrays[p]=M,this}setMatrix3x3(p,b){return this._checkUniform(p),this._matrices3x3[p]=b,this}setMatrix2x2(p,b){return this._checkUniform(p),this._matrices2x2[p]=b,this}setArray2(p,b){return this._checkUniform(p),this._vectors2Arrays[p]=b,this}setArray3(p,b){return this._checkUniform(p),this._vectors3Arrays[p]=b,this}setArray4(p,b){return this._checkUniform(p),this._vectors4Arrays[p]=b,this}setUniformBuffer(p,b){return-1===this._options.uniformBuffers.indexOf(p)&&this._options.uniformBuffers.push(p),this._uniformBuffers[p]=b,this}setTextureSampler(p,b){return-1===this._options.samplerObjects.indexOf(p)&&this._options.samplerObjects.push(p),this._textureSamplers[p]=b,this}setStorageBuffer(p,b){return-1===this._options.storageBuffers.indexOf(p)&&this._options.storageBuffers.push(p),this._storageBuffers[p]=b,this}setDefine(p,b){const M=p.trimEnd()+" ",h=this.options.defines.findIndex((b=>b===p||b.startsWith(M)));return h>=0&&this.options.defines.splice(h,1),("boolean"!==typeof b||b)&&this.options.defines.push(M+b),this}isReadyForSubMesh(p,b,M){return this.isReady(p,M,b)}isReady(p,b,M){var h;const mp=M&&this._storeEffectOnSubMeshes;if(this.isFrozen){const p=mp?M._drawWrapper:this._drawWrapper;if(p.effect&&p._wasPreviouslyReady&&p._wasPreviouslyUsingInstances===b)return!0}const P=this.upp(),w=P.getEngine(),z=[],x=[];let S=null,g=this._shaderPath,f=this._options.uniforms,Y=this._options.uniformBuffers,a=this._options.samplers;w.getCaps().multiview&&P.activeCamera&&P.activeCamera.outputRenderTarget&&P.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,z.push("#define MULTIVIEW"),-1!==f.indexOf("viewProjection")&&-1===f.indexOf("viewProjectionR")&&f.push("viewProjectionR"));for(let Q=0;Q<this._options.defines.length;Q++){const p=0===this._options.defines[Q].indexOf("#define")?this._options.defines[Q]:`#define ${this._options.defines[Q]}`;z.push(p)}for(let Q=0;Q<this._options.attributes.length;Q++)x.push(this._options.attributes[Q]);if(p&&p.isVerticesDataPresent(y.f.ColorKind)&&(-1===x.indexOf(y.f.ColorKind)&&x.push(y.f.ColorKind),z.push("#define VERTEXCOLOR")),b&&(z.push("#define INSTANCES"),(0,c.lb)(x,this._materialHelperNeedsPreviousMatrices),null!==p&&void 0!==p&&p.hasThinInstances&&(z.push("#define THIN_INSTANCES"),p&&p.isVerticesDataPresent(y.f.ColorInstanceKind)&&(x.push(y.f.ColorInstanceKind),z.push("#define INSTANCESCOLOR")))),p&&p.useBones&&p.computeBonesUsingShaders&&p.skeleton){x.push(y.f.MatricesIndicesKind),x.push(y.f.MatricesWeightsKind),p.numBoneInfluencers>4&&(x.push(y.f.MatricesIndicesExtraKind),x.push(y.f.MatricesWeightsExtraKind));const b=p.skeleton;z.push("#define NUM_BONE_INFLUENCERS "+p.numBoneInfluencers),S=new t.d,S.addCPUSkinningFallback(0,p),b.isUsingTextureForMatrices?(z.push("#define BONETEXTURE"),-1===f.indexOf("boneTextureWidth")&&f.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(z.push("#define BonesPerMesh "+(b.bones.length+1)),-1===f.indexOf("mBones")&&f.push("mBones"))}else z.push("#define NUM_BONE_INFLUENCERS 0");let o=0;const l=p?p.morphTargetManager:null;if(l){const b=-1!==z.indexOf("#define UV1"),M=-1!==z.indexOf("#define UV2"),h=-1!==z.indexOf("#define TANGENT"),Q=-1!==z.indexOf("#define NORMAL"),mp=-1!==z.indexOf("#define VERTEXCOLOR");o=(0,c.N)(l,z,x,p,!0,Q,h,b,M,mp),l.isUsingTextureForTargets&&(-1===f.indexOf("morphTargetTextureIndices")&&f.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),o>0&&(f=f.slice(),f.push("morphTargetInfluences"),f.push("morphTargetCount"),f.push("morphTargetTextureInfo"),f.push("morphTargetTextureIndices"))}else z.push("#define NUM_MORPH_INFLUENCERS 0");if(p){const b=p.bakedVertexAnimationManager;b&&b.isEnabled&&(z.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===f.indexOf("bakedVertexAnimationSettings")&&f.push("bakedVertexAnimationSettings"),-1===f.indexOf("bakedVertexAnimationTextureSizeInverted")&&f.push("bakedVertexAnimationTextureSizeInverted"),-1===f.indexOf("bakedVertexAnimationTime")&&f.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,c.E)(x,p,z)}for(const Q in this._textures)if(!this._textures[Q].isReady())return!1;p&&this.needAlphaTestingForMesh(p)&&z.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,X.e)(f),(0,X.o)(this,P,z)),P.fogEnabled&&null!==p&&void 0!==p&&p.applyFog&&P.fogMode!==Q.b.FOGMODE_NONE&&(z.push("#define FOG"),-1===f.indexOf("view")&&f.push("view"),-1===f.indexOf("vFogInfos")&&f.push("vFogInfos"),-1===f.indexOf("vFogColor")&&f.push("vFogColor")),this._useLogarithmicDepth&&(z.push("#define LOGARITHMICDEPTH"),-1===f.indexOf("logarithmicDepthConstant")&&f.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(f=f.slice(),Y=Y.slice(),a=a.slice(),g=this.customShaderNameResolve(this.name,f,Y,a,z,x));const L=mp?M._getDrawWrapper(void 0,!0):this._drawWrapper,u=(null===L||void 0===L?void 0:L.effect)??null,e=(null===L||void 0===L?void 0:L.defines)??null,d=z.join("\n");let I=u;return e!==d&&(I=w.createEffect(g,{attributes:x,uniformsNames:f,uniformBuffersNames:Y,samplers:a,defines:d,fallbacks:S,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:o},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},w),mp?M.setEffect(I,d,this._materialContext):L&&L.setEffect(I,d),this._onEffectCreatedObservable&&(J.effect=I,J.subMesh=M??(null===p||void 0===p?void 0:p.Lb[0])??null,this._onEffectCreatedObservable.notifyObservers(J))),L._wasPreviouslyUsingInstances=!!b,!(null===(h=I)||void 0===h||!h.isReady())&&(u!==I&&P.resetCachedMaterial(),L._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(p,b){const M=b??this.getEffect();if(!M)return;const h=this._options.uniforms;-1!==h.indexOf("world")&&M.setMatrix("world",p);const Q=this.upp();-1!==h.indexOf("worldView")&&(p.multiplyToRef(Q.getViewMatrix(),this._cachedWorldViewMatrix),M.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==h.indexOf("worldViewProjection")&&(p.multiplyToRef(Q.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),M.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==h.indexOf("view")&&M.setMatrix("view",Q.getViewMatrix())}bindForSubMesh(p,b,M){var h;this.bind(p,b,null===(h=M._drawWrapperOverride)||void 0===h?void 0:h.effect,M)}bind(p,b,M,h){const Q=h&&this._storeEffectOnSubMeshes,mp=M??(Q?h.effect:this.getEffect());if(!mp)return;const y=this.upp();this._activeEffect=mp,this.bindOnlyWorldMatrix(p,M);const P=this._options.uniformBuffers;let w=!1;if(mp&&P&&P.length>0&&y.getEngine().supportsUniformBuffers)for(let x=0;x<P.length;++x){switch(P[x]){case"Mesh":b&&(b.getMeshUniformBuffer().bindToEffect(mp,"Mesh"),b.transferToEffect(p));break;case"Scene":(0,c.u)(mp,y.getSceneUniformBuffer()),y.finalizeSceneUbo(),w=!0}}const t=b&&Q?this._mustRebind(y,mp,h,b.visibility):y.getCachedMaterial()!==this;if(mp&&t){let p;for(p in w||-1===this._options.uniforms.indexOf("view")||mp.setMatrix("view",y.getViewMatrix()),w||-1===this._options.uniforms.indexOf("projection")||mp.setMatrix("projection",y.getProjectionMatrix()),w||-1===this._options.uniforms.indexOf("viewProjection")||(mp.setMatrix("viewProjection",y.getTransformMatrix()),this._multiview&&mp.setMatrix("viewProjectionR",y._transformMatrixR)),y.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&mp.setVector3("cameraPosition",y.activeCamera.globalPosition),(0,c.d)(b,mp),(0,X.i)(mp,this,y),this._useLogarithmicDepth&&(0,c.n)(Q?h.materialDefines:mp.defines,mp,y),b&&(0,c.g)(y,b,mp),this._textures)mp.setTexture(p,this._textures[p]);for(p in this._textureArrays)mp.setTextureArray(p,this._textureArrays[p]);for(p in this._ints)mp.setInt(p,this._ints[p]);for(p in this._uints)mp.setUInt(p,this._uints[p]);for(p in this._floats)mp.setFloat(p,this._floats[p]);for(p in this._floatsArrays)mp.setArray(p,this._floatsArrays[p]);for(p in this._colors3)mp.setColor3(p,this._colors3[p]);for(p in this._colors3Arrays)mp.setArray3(p,this._colors3Arrays[p]);for(p in this._colors4){const b=this._colors4[p];mp.setFloat4(p,b.r,b.g,b.b,b.a)}for(p in this._colors4Arrays)mp.setArray4(p,this._colors4Arrays[p]);for(p in this._vectors2)mp.setVector2(p,this._vectors2[p]);for(p in this._vectors3)mp.setVector3(p,this._vectors3[p]);for(p in this._vectors4)mp.setVector4(p,this._vectors4[p]);for(p in this._quaternions)mp.setQuaternion(p,this._quaternions[p]);for(p in this._matrices)mp.setMatrix(p,this._matrices[p]);for(p in this._matrixArrays)mp.setMatrices(p,this._matrixArrays[p]);for(p in this._matrices3x3)mp.setMatrix3x3(p,this._matrices3x3[p]);for(p in this._matrices2x2)mp.setMatrix2x2(p,this._matrices2x2[p]);for(p in this._vectors2Arrays)mp.setArray2(p,this._vectors2Arrays[p]);for(p in this._vectors3Arrays)mp.setArray3(p,this._vectors3Arrays[p]);for(p in this._vectors4Arrays)mp.setArray4(p,this._vectors4Arrays[p]);for(p in this._quaternionsArrays)mp.setArray4(p,this._quaternionsArrays[p]);for(p in this._uniformBuffers){const b=this._uniformBuffers[p].getBuffer();b&&mp.bindUniformBuffer(b,p)}const M=y.getEngine(),P=M.setExternalTexture;if(P)for(p in this._externalTextures)P.call(M,p,this._externalTextures[p]);const t=M.setTextureSampler;if(t)for(p in this._textureSamplers)t.call(M,p,this._textureSamplers[p]);const z=M.setStorageBuffer;if(z)for(p in this._storageBuffers)z.call(M,p,this._storageBuffers[p])}if(mp&&b&&(t||!this.isFrozen)){(0,c.r)(b,mp),b.morphTargetManager&&b.morphTargetManager.isUsingTextureForTargets&&b.morphTargetManager._bind(mp);const p=b.bakedVertexAnimationManager;if(p&&p.isEnabled){var z;const p=Q?h._drawWrapper:this._drawWrapper;null===(z=b.bakedVertexAnimationManager)||void 0===z||z.bind(mp,!!p._wasPreviouslyUsingInstances)}}this._afterBind(b,mp,h)}getActiveTextures(){const p=super.getActiveTextures();for(const b in this._textures)p.push(this._textures[b]);for(const b in this._textureArrays){const M=this._textureArrays[b];for(let b=0;b<M.length;b++)p.push(M[b])}return p}hasTexture(p){if(super.hasTexture(p))return!0;for(const b in this._textures)if(this._textures[b]===p)return!0;for(const b in this._textureArrays){const M=this._textureArrays[b];for(let b=0;b<M.length;b++)if(M[b]===p)return!0}return!1}clone(p){const b=h.e.Clone((()=>new g(p,this.upp(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);b.name=p,b.id=p,"object"===typeof b._shaderPath&&(b._shaderPath={...b._shaderPath}),this._options={...this._options};const M=Object.keys(this._options);for(const h of M){const p=this._options[h];Array.isArray(p)&&(this._options[h]=p.slice(0))}this.cb.copyTo(b.cb);for(const h in this._textures)b.setTexture(h,this._textures[h]);for(const h in this._textureArrays)b.setTextureArray(h,this._textureArrays[h]);for(const h in this._externalTextures)b.setExternalTexture(h,this._externalTextures[h]);for(const h in this._ints)b.setInt(h,this._ints[h]);for(const h in this._uints)b.setUInt(h,this._uints[h]);for(const h in this._floats)b.setFloat(h,this._floats[h]);for(const h in this._floatsArrays)b.setFloats(h,this._floatsArrays[h]);for(const h in this._colors3)b.setColor3(h,this._colors3[h]);for(const h in this._colors3Arrays)b._colors3Arrays[h]=this._colors3Arrays[h];for(const h in this._colors4)b.setColor4(h,this._colors4[h]);for(const h in this._colors4Arrays)b._colors4Arrays[h]=this._colors4Arrays[h];for(const h in this._vectors2)b.setVector2(h,this._vectors2[h]);for(const h in this._vectors3)b.setVector3(h,this._vectors3[h]);for(const h in this._vectors4)b.setVector4(h,this._vectors4[h]);for(const h in this._quaternions)b.setQuaternion(h,this._quaternions[h]);for(const h in this._quaternionsArrays)b._quaternionsArrays[h]=this._quaternionsArrays[h];for(const h in this._matrices)b.setMatrix(h,this._matrices[h]);for(const h in this._matrixArrays)b._matrixArrays[h]=this._matrixArrays[h].slice();for(const h in this._matrices3x3)b.setMatrix3x3(h,this._matrices3x3[h]);for(const h in this._matrices2x2)b.setMatrix2x2(h,this._matrices2x2[h]);for(const h in this._vectors2Arrays)b.setArray2(h,this._vectors2Arrays[h]);for(const h in this._vectors3Arrays)b.setArray3(h,this._vectors3Arrays[h]);for(const h in this._vectors4Arrays)b.setArray4(h,this._vectors4Arrays[h]);for(const h in this._uniformBuffers)b.setUniformBuffer(h,this._uniformBuffers[h]);for(const h in this._textureSamplers)b.setTextureSampler(h,this._textureSamplers[h]);for(const h in this._storageBuffers)b.setStorageBuffer(h,this._storageBuffers[h]);return b}dispose(p,b,M){if(b){let p;for(p in this._textures)this._textures[p].dispose();for(p in this._textureArrays){const b=this._textureArrays[p];for(let p=0;p<b.length;p++)b[p].dispose()}}this._textures={},super.dispose(p,b,M)}serialize(){const p=h.e.Serialize(this);let b;for(b in p.customType="BABYLON.ShaderMaterial",p.uniqueId=this.uniqueId,p.options=this._options,p.shaderPath=this._shaderPath,p.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,p.cb=this.cb.serialize(),p.textures={},this._textures)p.textures[b]=this._textures[b].serialize();for(b in p.textureArrays={},this._textureArrays){p.textureArrays[b]=[];const M=this._textureArrays[b];for(let h=0;h<M.length;h++)p.textureArrays[b].push(M[h].serialize())}for(b in p.ints={},this._ints)p.ints[b]=this._ints[b];for(b in p.uints={},this._uints)p.uints[b]=this._uints[b];for(b in p.floats={},this._floats)p.floats[b]=this._floats[b];for(b in p.floatsArrays={},this._floatsArrays)p.floatsArrays[b]=this._floatsArrays[b];for(b in p.colors3={},this._colors3){const M=this._colors3[b];p.colors3[b]=[M.r,M.g,M.b]}for(b in p.colors3Arrays={},this._colors3Arrays)p.colors3Arrays[b]=this._colors3Arrays[b];for(b in p.colors4={},this._colors4){const M=this._colors4[b];p.colors4[b]=[M.r,M.g,M.b,M.a]}for(b in p.colors4Arrays={},this._colors4Arrays)p.colors4Arrays[b]=this._colors4Arrays[b];for(b in p.vectors2={},this._vectors2){const M=this._vectors2[b];p.vectors2[b]=[M.x,M.y]}for(b in p.vectors3={},this._vectors3){const M=this._vectors3[b];p.vectors3[b]=[M.x,M.y,M.z]}for(b in p.vectors4={},this._vectors4){const M=this._vectors4[b];p.vectors4[b]=[M.x,M.y,M.z,M.w]}for(b in p.quaternions={},this._quaternions)p.quaternions[b]=this._quaternions[b].ub();for(b in p.matrices={},this._matrices)p.matrices[b]=this._matrices[b].ub();for(b in p.matrixArray={},this._matrixArrays)p.matrixArray[b]=this._matrixArrays[b];for(b in p.matrices3x3={},this._matrices3x3)p.matrices3x3[b]=this._matrices3x3[b];for(b in p.matrices2x2={},this._matrices2x2)p.matrices2x2[b]=this._matrices2x2[b];for(b in p.vectors2Arrays={},this._vectors2Arrays)p.vectors2Arrays[b]=this._vectors2Arrays[b];for(b in p.vectors3Arrays={},this._vectors3Arrays)p.vectors3Arrays[b]=this._vectors3Arrays[b];for(b in p.vectors4Arrays={},this._vectors4Arrays)p.vectors4Arrays[b]=this._vectors4Arrays[b];for(b in p.quaternionsArrays={},this._quaternionsArrays)p.quaternionsArrays[b]=this._quaternionsArrays[b];return p}static Parse(p,b,M){const Q=h.e.Parse((()=>new g(p.name,b,p.shaderPath,p.options,p.storeEffectOnSubMeshes)),p,b,M);let y;for(y in p.cb&&Q.cb.parse(p.cb,b,M),p.textures)Q.setTexture(y,P.c.Parse(p.textures[y],b,M));for(y in p.textureArrays){const h=p.textureArrays[y],mp=[];for(let p=0;p<h.length;p++)mp.push(P.c.Parse(h[p],b,M));Q.setTextureArray(y,mp)}for(y in p.ints)Q.setInt(y,p.ints[y]);for(y in p.uints)Q.setUInt(y,p.uints[y]);for(y in p.floats)Q.setFloat(y,p.floats[y]);for(y in p.floatsArrays)Q.setFloats(y,p.floatsArrays[y]);for(y in p.colors3){const b=p.colors3[y];Q.setColor3(y,{r:b[0],g:b[1],b:b[2]})}for(y in p.colors3Arrays){const b=p.colors3Arrays[y].reduce(((p,b,M)=>(M%3===0?p.push([b]):p[p.length-1].push(b),p)),[]).map((p=>({r:p[0],g:p[1],b:p[2]})));Q.setColor3Array(y,b)}for(y in p.colors4){const b=p.colors4[y];Q.setColor4(y,{r:b[0],g:b[1],b:b[2],a:b[3]})}for(y in p.colors4Arrays){const b=p.colors4Arrays[y].reduce(((p,b,M)=>(M%4===0?p.push([b]):p[p.length-1].push(b),p)),[]).map((p=>({r:p[0],g:p[1],b:p[2],a:p[3]})));Q.setColor4Array(y,b)}for(y in p.vectors2){const b=p.vectors2[y];Q.setVector2(y,{x:b[0],y:b[1]})}for(y in p.vectors3){const b=p.vectors3[y];Q.setVector3(y,{x:b[0],y:b[1],z:b[2]})}for(y in p.vectors4){const b=p.vectors4[y];Q.setVector4(y,{x:b[0],y:b[1],z:b[2],w:b[3]})}for(y in p.quaternions)Q.setQuaternion(y,mp.Quaternion.tM(p.quaternions[y]));for(y in p.matrices)Q.setMatrix(y,mp.Matrix.tM(p.matrices[y]));for(y in p.matrixArray)Q._matrixArrays[y]=new Float32Array(p.matrixArray[y]);for(y in p.matrices3x3)Q.setMatrix3x3(y,p.matrices3x3[y]);for(y in p.matrices2x2)Q.setMatrix2x2(y,p.matrices2x2[y]);for(y in p.vectors2Arrays)Q.setArray2(y,p.vectors2Arrays[y]);for(y in p.vectors3Arrays)Q.setArray3(y,p.vectors3Arrays[y]);for(y in p.vectors4Arrays)Q.setArray4(y,p.vectors4Arrays[y]);for(y in p.quaternionsArrays)Q.setArray4(y,p.quaternionsArrays[y]);return Q}static async ParseFromFileAsync(p,b,M){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((Q,mp)=>{const y=new z.e;y.addEventListener("readystatechange",(()=>{if(4==y.readyState)if(200==y.status){const b=JSON.parse(y.responseText),mp=this.Parse(b,M||S.c.LastCreatedScene,h);p&&(mp.name=p),Q(mp)}else mp("Unable to load the ShaderMaterial")})),y.open("GET",b),y.send()}))}static async ParseFromSnippetAsync(p,b){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((h,Q)=>{const mp=new z.e;mp.addEventListener("readystatechange",(()=>{if(4==mp.readyState)if(200==mp.status){const Q=JSON.parse(JSON.parse(mp.responseText).jsonPayload),y=JSON.parse(Q.shaderMaterial),P=this.Parse(y,b||S.c.LastCreatedScene,M);P.snippetId=p,h(P)}else Q("Unable to load the snippet "+p)})),mp.open("GET",this.SnippetUrl+"/"+p.replace(/#/g,"/")),mp.send()}))}}g.SnippetUrl="https://snippet.babylonjs.com",g.CreateFromSnippetAsync=g.ParseFromSnippetAsync,(0,w.c)("BABYLON.ShaderMaterial",g)}}]);