"use strict";(self.hwpa2z1pqte=self.hwpa2z1pqte||[]).push([[22],{13120:(h,R,l)=>{l.r(R),l.d(R,{ShaderMaterial:()=>s});var j=l(12942),a=l(13126),D=l(12900),U=l(12984),F=l(12874),w=l(12852),mh=l(13175),u=l(12741),c=l(13177),J=l(12749),q=l(13226),Q=l(13219);const Y={effect:null,subMesh:null};class s extends c.d{constructor(h,R,l){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(h,R,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new D.Matrix,this._cachedWorldViewProjectionMatrix=new D.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=l,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...j}}get shaderPath(){return this._shaderPath}set shaderPath(h){this._shaderPath=h}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(h){-1===this._options.uniforms.indexOf(h)&&this._options.uniforms.push(h)}setTexture(h,R){return-1===this._options.samplers.indexOf(h)&&this._options.samplers.push(h),this._textures[h]=R,this}removeTexture(h){delete this._textures[h]}setTextureArray(h,R){return-1===this._options.samplers.indexOf(h)&&this._options.samplers.push(h),this._checkUniform(h),this._textureArrays[h]=R,this}setExternalTexture(h,R){return-1===this._options.externalTextures.indexOf(h)&&this._options.externalTextures.push(h),this._externalTextures[h]=R,this}setFloat(h,R){return this._checkUniform(h),this._floats[h]=R,this}setInt(h,R){return this._checkUniform(h),this._ints[h]=R,this}setUInt(h,R){return this._checkUniform(h),this._uints[h]=R,this}setFloats(h,R){return this._checkUniform(h),this._floatsArrays[h]=R,this}setColor3(h,R){return this._checkUniform(h),this._colors3[h]=R,this}setColor3Array(h,R){return this._checkUniform(h),this._colors3Arrays[h]=R.reduce(((h,R)=>(h.push(R.r,R.g,R.b),h)),[]),this}setColor4(h,R){return this._checkUniform(h),this._colors4[h]=R,this}setColor4Array(h,R){return this._checkUniform(h),this._colors4Arrays[h]=R.reduce(((h,R)=>(h.push(R.r,R.g,R.b,R.a),h)),[]),this}setVector2(h,R){return this._checkUniform(h),this._vectors2[h]=R,this}setVector3(h,R){return this._checkUniform(h),this._vectors3[h]=R,this}setVector4(h,R){return this._checkUniform(h),this._vectors4[h]=R,this}setQuaternion(h,R){return this._checkUniform(h),this._quaternions[h]=R,this}setQuaternionArray(h,R){return this._checkUniform(h),this._quaternionsArrays[h]=R.reduce(((h,R)=>(R.toArray(h,h.length),h)),[]),this}setMatrix(h,R){return this._checkUniform(h),this._matrices[h]=R,this}setMatrices(h,R){this._checkUniform(h);const l=new Float32Array(16*R.length);for(let j=0;j<R.length;j++){R[j].copyToArray(l,16*j)}return this._matrixArrays[h]=l,this}setMatrix3x3(h,R){return this._checkUniform(h),this._matrices3x3[h]=R,this}setMatrix2x2(h,R){return this._checkUniform(h),this._matrices2x2[h]=R,this}setArray2(h,R){return this._checkUniform(h),this._vectors2Arrays[h]=R,this}setArray3(h,R){return this._checkUniform(h),this._vectors3Arrays[h]=R,this}setArray4(h,R){return this._checkUniform(h),this._vectors4Arrays[h]=R,this}setUniformBuffer(h,R){return-1===this._options.uniformBuffers.indexOf(h)&&this._options.uniformBuffers.push(h),this._uniformBuffers[h]=R,this}setTextureSampler(h,R){return-1===this._options.samplerObjects.indexOf(h)&&this._options.samplerObjects.push(h),this._textureSamplers[h]=R,this}setStorageBuffer(h,R){return-1===this._options.storageBuffers.indexOf(h)&&this._options.storageBuffers.push(h),this._storageBuffers[h]=R,this}setDefine(h,R){const l=h.trimEnd()+" ",j=this.options.defines.findIndex((R=>R===h||R.startsWith(l)));return j>=0&&this.options.defines.splice(j,1),("boolean"!==typeof R||R)&&this.options.defines.push(l+R),this}isReadyForSubMesh(h,R,l){return this.isReady(h,l,R)}isReady(h,R,l){var j;const D=l&&this._storeEffectOnSubMeshes;if(this.isFrozen){const h=D?l._drawWrapper:this._drawWrapper;if(h.effect&&h._wasPreviouslyReady&&h._wasPreviouslyUsingInstances===R)return!0}const F=this.yh(),w=F.getEngine(),u=[],c=[];let J=null,s=this._shaderPath,t=this._options.uniforms,f=this._options.uniformBuffers,T=this._options.samplers;w.getCaps().multiview&&F.activeCamera&&F.activeCamera.outputRenderTarget&&F.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,u.push("#define MULTIVIEW"),-1!==t.indexOf("viewProjection")&&-1===t.indexOf("viewProjectionR")&&t.push("viewProjectionR"));for(let a=0;a<this._options.defines.length;a++){const h=0===this._options.defines[a].indexOf("#define")?this._options.defines[a]:`#define ${this._options.defines[a]}`;u.push(h)}for(let a=0;a<this._options.attributes.length;a++)c.push(this._options.attributes[a]);if(h&&h.isVerticesDataPresent(U.g.ColorKind)&&(-1===c.indexOf(U.g.ColorKind)&&c.push(U.g.ColorKind),u.push("#define VERTEXCOLOR")),R&&(u.push("#define INSTANCES"),(0,Q.eb)(c,this._materialHelperNeedsPreviousMatrices),null!==h&&void 0!==h&&h.hasThinInstances&&(u.push("#define THIN_INSTANCES"),h&&h.isVerticesDataPresent(U.g.ColorInstanceKind)&&(c.push(U.g.ColorInstanceKind),u.push("#define INSTANCESCOLOR")))),h&&h.useBones&&h.computeBonesUsingShaders&&h.skeleton){c.push(U.g.MatricesIndicesKind),c.push(U.g.MatricesWeightsKind),h.numBoneInfluencers>4&&(c.push(U.g.MatricesIndicesExtraKind),c.push(U.g.MatricesWeightsExtraKind));const R=h.skeleton;u.push("#define NUM_BONE_INFLUENCERS "+h.numBoneInfluencers),J=new mh.d,J.addCPUSkinningFallback(0,h),R.isUsingTextureForMatrices?(u.push("#define BONETEXTURE"),-1===t.indexOf("boneTextureWidth")&&t.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(u.push("#define BonesPerMesh "+(R.bones.length+1)),-1===t.indexOf("mBones")&&t.push("mBones"))}else u.push("#define NUM_BONE_INFLUENCERS 0");let E=0;const x=h?h.morphTargetManager:null;if(x){const R=-1!==u.indexOf("#define UV1"),l=-1!==u.indexOf("#define UV2"),j=-1!==u.indexOf("#define TANGENT"),a=-1!==u.indexOf("#define NORMAL"),D=-1!==u.indexOf("#define VERTEXCOLOR");E=(0,Q.H)(x,u,c,h,!0,a,j,R,l,D),x.isUsingTextureForTargets&&(-1===t.indexOf("morphTargetTextureIndices")&&t.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),E>0&&(t=t.slice(),t.push("morphTargetInfluences"),t.push("morphTargetCount"),t.push("morphTargetTextureInfo"),t.push("morphTargetTextureIndices"))}else u.push("#define NUM_MORPH_INFLUENCERS 0");if(h){const R=h.bakedVertexAnimationManager;R&&R.isEnabled&&(u.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===t.indexOf("bakedVertexAnimationSettings")&&t.push("bakedVertexAnimationSettings"),-1===t.indexOf("bakedVertexAnimationTextureSizeInverted")&&t.push("bakedVertexAnimationTextureSizeInverted"),-1===t.indexOf("bakedVertexAnimationTime")&&t.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,Q.z)(c,h,u)}for(const a in this._textures)if(!this._textures[a].isReady())return!1;h&&this.needAlphaTestingForMesh(h)&&u.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,q.d)(t),(0,q.m)(this,F,u)),F.fogEnabled&&null!==h&&void 0!==h&&h.applyFog&&F.fogMode!==a.e.FOGMODE_NONE&&(u.push("#define FOG"),-1===t.indexOf("view")&&t.push("view"),-1===t.indexOf("vFogInfos")&&t.push("vFogInfos"),-1===t.indexOf("vFogColor")&&t.push("vFogColor")),this._useLogarithmicDepth&&(u.push("#define LOGARITHMICDEPTH"),-1===t.indexOf("logarithmicDepthConstant")&&t.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(t=t.slice(),f=f.slice(),T=T.slice(),s=this.customShaderNameResolve(this.name,t,f,T,u,c));const G=D?l._getDrawWrapper(void 0,!0):this._drawWrapper,p=(null===G||void 0===G?void 0:G.effect)??null,O=(null===G||void 0===G?void 0:G.defines)??null,y=u.join("\n");let v=p;return O!==y&&(v=w.createEffect(s,{attributes:c,uniformsNames:t,uniformBuffersNames:f,samplers:T,defines:y,fallbacks:J,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:E},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},w),D?l.setEffect(v,y,this._materialContext):G&&G.setEffect(v,y),this._onEffectCreatedObservable&&(Y.effect=v,Y.subMesh=l??(null===h||void 0===h?void 0:h.YF[0])??null,this._onEffectCreatedObservable.notifyObservers(Y))),G._wasPreviouslyUsingInstances=!!R,!(null===(j=v)||void 0===j||!j.isReady())&&(p!==v&&F.resetCachedMaterial(),G._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(h,R){const l=R??this.getEffect();if(!l)return;const j=this._options.uniforms;-1!==j.indexOf("world")&&l.setMatrix("world",h);const a=this.yh();-1!==j.indexOf("worldView")&&(h.multiplyToRef(a.getViewMatrix(),this._cachedWorldViewMatrix),l.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==j.indexOf("worldViewProjection")&&(h.multiplyToRef(a.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),l.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==j.indexOf("view")&&l.setMatrix("view",a.getViewMatrix())}bindForSubMesh(h,R,l){var j;this.bind(h,R,null===(j=l._drawWrapperOverride)||void 0===j?void 0:j.effect,l)}bind(h,R,l,j){const a=j&&this._storeEffectOnSubMeshes,D=l??(a?j.effect:this.getEffect());if(!D)return;const U=this.yh();this._activeEffect=D,this.bindOnlyWorldMatrix(h,l);const F=this._options.uniformBuffers;let w=!1;if(D&&F&&F.length>0&&U.getEngine().supportsUniformBuffers)for(let c=0;c<F.length;++c){switch(F[c]){case"Mesh":R&&(R.getMeshUniformBuffer().bindToEffect(D,"Mesh"),R.transferToEffect(h));break;case"Scene":(0,Q.r)(D,U.getSceneUniformBuffer()),U.finalizeSceneUbo(),w=!0}}const mh=R&&a?this._mustRebind(U,D,j,R.visibility):U.getCachedMaterial()!==this;if(D&&mh){let h;for(h in w||-1===this._options.uniforms.indexOf("view")||D.setMatrix("view",U.getViewMatrix()),w||-1===this._options.uniforms.indexOf("projection")||D.setMatrix("projection",U.getProjectionMatrix()),w||-1===this._options.uniforms.indexOf("viewProjection")||(D.setMatrix("viewProjection",U.getTransformMatrix()),this._multiview&&D.setMatrix("viewProjectionR",U._transformMatrixR)),U.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&D.setVector3("cameraPosition",U.activeCamera.globalPosition),(0,Q.d)(R,D),(0,q.f)(D,this,U),this._useLogarithmicDepth&&(0,Q.m)(a?j.materialDefines:D.defines,D,U),R&&(0,Q.g)(U,R,D),this._textures)D.setTexture(h,this._textures[h]);for(h in this._textureArrays)D.setTextureArray(h,this._textureArrays[h]);for(h in this._ints)D.setInt(h,this._ints[h]);for(h in this._uints)D.setUInt(h,this._uints[h]);for(h in this._floats)D.setFloat(h,this._floats[h]);for(h in this._floatsArrays)D.setArray(h,this._floatsArrays[h]);for(h in this._colors3)D.setColor3(h,this._colors3[h]);for(h in this._colors3Arrays)D.setArray3(h,this._colors3Arrays[h]);for(h in this._colors4){const R=this._colors4[h];D.setFloat4(h,R.r,R.g,R.b,R.a)}for(h in this._colors4Arrays)D.setArray4(h,this._colors4Arrays[h]);for(h in this._vectors2)D.setVector2(h,this._vectors2[h]);for(h in this._vectors3)D.setVector3(h,this._vectors3[h]);for(h in this._vectors4)D.setVector4(h,this._vectors4[h]);for(h in this._quaternions)D.setQuaternion(h,this._quaternions[h]);for(h in this._matrices)D.setMatrix(h,this._matrices[h]);for(h in this._matrixArrays)D.setMatrices(h,this._matrixArrays[h]);for(h in this._matrices3x3)D.setMatrix3x3(h,this._matrices3x3[h]);for(h in this._matrices2x2)D.setMatrix2x2(h,this._matrices2x2[h]);for(h in this._vectors2Arrays)D.setArray2(h,this._vectors2Arrays[h]);for(h in this._vectors3Arrays)D.setArray3(h,this._vectors3Arrays[h]);for(h in this._vectors4Arrays)D.setArray4(h,this._vectors4Arrays[h]);for(h in this._quaternionsArrays)D.setArray4(h,this._quaternionsArrays[h]);for(h in this._uniformBuffers){const R=this._uniformBuffers[h].getBuffer();R&&D.bindUniformBuffer(R,h)}const l=U.getEngine(),F=l.setExternalTexture;if(F)for(h in this._externalTextures)F.call(l,h,this._externalTextures[h]);const mh=l.setTextureSampler;if(mh)for(h in this._textureSamplers)mh.call(l,h,this._textureSamplers[h]);const u=l.setStorageBuffer;if(u)for(h in this._storageBuffers)u.call(l,h,this._storageBuffers[h])}if(D&&R&&(mh||!this.isFrozen)){(0,Q.p)(R,D),R.morphTargetManager&&R.morphTargetManager.isUsingTextureForTargets&&R.morphTargetManager._bind(D);const h=R.bakedVertexAnimationManager;if(h&&h.isEnabled){var u;const h=a?j._drawWrapper:this._drawWrapper;null===(u=R.bakedVertexAnimationManager)||void 0===u||u.bind(D,!!h._wasPreviouslyUsingInstances)}}this._afterBind(R,D,j)}getActiveTextures(){const h=super.getActiveTextures();for(const R in this._textures)h.push(this._textures[R]);for(const R in this._textureArrays){const l=this._textureArrays[R];for(let R=0;R<l.length;R++)h.push(l[R])}return h}hasTexture(h){if(super.hasTexture(h))return!0;for(const R in this._textures)if(this._textures[R]===h)return!0;for(const R in this._textureArrays){const l=this._textureArrays[R];for(let R=0;R<l.length;R++)if(l[R]===h)return!0}return!1}clone(h){const R=j.c.Clone((()=>new s(h,this.yh(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);R.name=h,R.id=h,"object"===typeof R._shaderPath&&(R._shaderPath={...R._shaderPath}),this._options={...this._options};const l=Object.keys(this._options);for(const j of l){const h=this._options[j];Array.isArray(h)&&(this._options[j]=h.slice(0))}this.uF.copyTo(R.uF);for(const j in this._textures)R.setTexture(j,this._textures[j]);for(const j in this._textureArrays)R.setTextureArray(j,this._textureArrays[j]);for(const j in this._externalTextures)R.setExternalTexture(j,this._externalTextures[j]);for(const j in this._ints)R.setInt(j,this._ints[j]);for(const j in this._uints)R.setUInt(j,this._uints[j]);for(const j in this._floats)R.setFloat(j,this._floats[j]);for(const j in this._floatsArrays)R.setFloats(j,this._floatsArrays[j]);for(const j in this._colors3)R.setColor3(j,this._colors3[j]);for(const j in this._colors3Arrays)R._colors3Arrays[j]=this._colors3Arrays[j];for(const j in this._colors4)R.setColor4(j,this._colors4[j]);for(const j in this._colors4Arrays)R._colors4Arrays[j]=this._colors4Arrays[j];for(const j in this._vectors2)R.setVector2(j,this._vectors2[j]);for(const j in this._vectors3)R.setVector3(j,this._vectors3[j]);for(const j in this._vectors4)R.setVector4(j,this._vectors4[j]);for(const j in this._quaternions)R.setQuaternion(j,this._quaternions[j]);for(const j in this._quaternionsArrays)R._quaternionsArrays[j]=this._quaternionsArrays[j];for(const j in this._matrices)R.setMatrix(j,this._matrices[j]);for(const j in this._matrixArrays)R._matrixArrays[j]=this._matrixArrays[j].slice();for(const j in this._matrices3x3)R.setMatrix3x3(j,this._matrices3x3[j]);for(const j in this._matrices2x2)R.setMatrix2x2(j,this._matrices2x2[j]);for(const j in this._vectors2Arrays)R.setArray2(j,this._vectors2Arrays[j]);for(const j in this._vectors3Arrays)R.setArray3(j,this._vectors3Arrays[j]);for(const j in this._vectors4Arrays)R.setArray4(j,this._vectors4Arrays[j]);for(const j in this._uniformBuffers)R.setUniformBuffer(j,this._uniformBuffers[j]);for(const j in this._textureSamplers)R.setTextureSampler(j,this._textureSamplers[j]);for(const j in this._storageBuffers)R.setStorageBuffer(j,this._storageBuffers[j]);return R}dispose(h,R,l){if(R){let h;for(h in this._textures)this._textures[h].dispose();for(h in this._textureArrays){const R=this._textureArrays[h];for(let h=0;h<R.length;h++)R[h].dispose()}}this._textures={},super.dispose(h,R,l)}serialize(){const h=j.c.Serialize(this);let R;for(R in h.customType="BABYLON.ShaderMaterial",h.uniqueId=this.uniqueId,h.options=this._options,h.shaderPath=this._shaderPath,h.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,h.uF=this.uF.serialize(),h.textures={},this._textures)h.textures[R]=this._textures[R].serialize();for(R in h.textureArrays={},this._textureArrays){h.textureArrays[R]=[];const l=this._textureArrays[R];for(let j=0;j<l.length;j++)h.textureArrays[R].push(l[j].serialize())}for(R in h.ints={},this._ints)h.ints[R]=this._ints[R];for(R in h.uints={},this._uints)h.uints[R]=this._uints[R];for(R in h.floats={},this._floats)h.floats[R]=this._floats[R];for(R in h.floatsArrays={},this._floatsArrays)h.floatsArrays[R]=this._floatsArrays[R];for(R in h.colors3={},this._colors3){const l=this._colors3[R];h.colors3[R]=[l.r,l.g,l.b]}for(R in h.colors3Arrays={},this._colors3Arrays)h.colors3Arrays[R]=this._colors3Arrays[R];for(R in h.colors4={},this._colors4){const l=this._colors4[R];h.colors4[R]=[l.r,l.g,l.b,l.a]}for(R in h.colors4Arrays={},this._colors4Arrays)h.colors4Arrays[R]=this._colors4Arrays[R];for(R in h.vectors2={},this._vectors2){const l=this._vectors2[R];h.vectors2[R]=[l.x,l.y]}for(R in h.vectors3={},this._vectors3){const l=this._vectors3[R];h.vectors3[R]=[l.x,l.y,l.z]}for(R in h.vectors4={},this._vectors4){const l=this._vectors4[R];h.vectors4[R]=[l.x,l.y,l.z,l.w]}for(R in h.quaternions={},this._quaternions)h.quaternions[R]=this._quaternions[R].sF();for(R in h.matrices={},this._matrices)h.matrices[R]=this._matrices[R].sF();for(R in h.matrixArray={},this._matrixArrays)h.matrixArray[R]=this._matrixArrays[R];for(R in h.matrices3x3={},this._matrices3x3)h.matrices3x3[R]=this._matrices3x3[R];for(R in h.matrices2x2={},this._matrices2x2)h.matrices2x2[R]=this._matrices2x2[R];for(R in h.vectors2Arrays={},this._vectors2Arrays)h.vectors2Arrays[R]=this._vectors2Arrays[R];for(R in h.vectors3Arrays={},this._vectors3Arrays)h.vectors3Arrays[R]=this._vectors3Arrays[R];for(R in h.vectors4Arrays={},this._vectors4Arrays)h.vectors4Arrays[R]=this._vectors4Arrays[R];for(R in h.quaternionsArrays={},this._quaternionsArrays)h.quaternionsArrays[R]=this._quaternionsArrays[R];return h}static Parse(h,R,l){const a=j.c.Parse((()=>new s(h.name,R,h.shaderPath,h.options,h.storeEffectOnSubMeshes)),h,R,l);let U;for(U in h.uF&&a.uF.parse(h.uF,R,l),h.textures)a.setTexture(U,F.b.Parse(h.textures[U],R,l));for(U in h.textureArrays){const j=h.textureArrays[U],D=[];for(let h=0;h<j.length;h++)D.push(F.b.Parse(j[h],R,l));a.setTextureArray(U,D)}for(U in h.ints)a.setInt(U,h.ints[U]);for(U in h.uints)a.setUInt(U,h.uints[U]);for(U in h.floats)a.setFloat(U,h.floats[U]);for(U in h.floatsArrays)a.setFloats(U,h.floatsArrays[U]);for(U in h.colors3){const R=h.colors3[U];a.setColor3(U,{r:R[0],g:R[1],b:R[2]})}for(U in h.colors3Arrays){const R=h.colors3Arrays[U].reduce(((h,R,l)=>(l%3===0?h.push([R]):h[h.length-1].push(R),h)),[]).map((h=>({r:h[0],g:h[1],b:h[2]})));a.setColor3Array(U,R)}for(U in h.colors4){const R=h.colors4[U];a.setColor4(U,{r:R[0],g:R[1],b:R[2],a:R[3]})}for(U in h.colors4Arrays){const R=h.colors4Arrays[U].reduce(((h,R,l)=>(l%4===0?h.push([R]):h[h.length-1].push(R),h)),[]).map((h=>({r:h[0],g:h[1],b:h[2],a:h[3]})));a.setColor4Array(U,R)}for(U in h.vectors2){const R=h.vectors2[U];a.setVector2(U,{x:R[0],y:R[1]})}for(U in h.vectors3){const R=h.vectors3[U];a.setVector3(U,{x:R[0],y:R[1],z:R[2]})}for(U in h.vectors4){const R=h.vectors4[U];a.setVector4(U,{x:R[0],y:R[1],z:R[2],w:R[3]})}for(U in h.quaternions)a.setQuaternion(U,D.Quaternion.GR(h.quaternions[U]));for(U in h.matrices)a.setMatrix(U,D.Matrix.GR(h.matrices[U]));for(U in h.matrixArray)a._matrixArrays[U]=new Float32Array(h.matrixArray[U]);for(U in h.matrices3x3)a.setMatrix3x3(U,h.matrices3x3[U]);for(U in h.matrices2x2)a.setMatrix2x2(U,h.matrices2x2[U]);for(U in h.vectors2Arrays)a.setArray2(U,h.vectors2Arrays[U]);for(U in h.vectors3Arrays)a.setArray3(U,h.vectors3Arrays[U]);for(U in h.vectors4Arrays)a.setArray4(U,h.vectors4Arrays[U]);for(U in h.quaternionsArrays)a.setArray4(U,h.quaternionsArrays[U]);return a}static async ParseFromFileAsync(h,R,l){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((a,D)=>{const U=new u.b;U.addEventListener("readystatechange",(()=>{if(4==U.readyState)if(200==U.status){const R=JSON.parse(U.responseText),D=this.Parse(R,l||J.b.LastCreatedScene,j);h&&(D.name=h),a(D)}else D("Unable to load the ShaderMaterial")})),U.open("GET",R),U.send()}))}static async ParseFromSnippetAsync(h,R){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((j,a)=>{const D=new u.b;D.addEventListener("readystatechange",(()=>{if(4==D.readyState)if(200==D.status){const a=JSON.parse(JSON.parse(D.responseText).jsonPayload),U=JSON.parse(a.shaderMaterial),F=this.Parse(U,R||J.b.LastCreatedScene,l);F.snippetId=h,j(F)}else a("Unable to load the snippet "+h)})),D.open("GET",this.SnippetUrl+"/"+h.replace(/#/g,"/")),D.send()}))}}s.SnippetUrl="https://snippet.babylonjs.com",s.CreateFromSnippetAsync=s.ParseFromSnippetAsync,(0,w.f)("BABYLON.ShaderMaterial",s)}}]);