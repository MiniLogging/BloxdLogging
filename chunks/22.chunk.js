"use strict";(self.qbp2s7qydk=self.qbp2s7qydk||[]).push([[22],{13208:(M,A,O)=>{O.r(A),O.d(A,{ShaderMaterial:()=>w});var S=O(22),z=O(12998),Q=O(13214),X=O(12970),c=O(13043),j=O(12949),B=O(12919),g=O(13271),e=O(12804),T=O(13278),J=O(12811),K=O(13329),G=O(13322);const d={effect:null,subMesh:null};class w extends T.e{constructor(M,A,O){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};super(M,A,!(arguments.length>4&&void 0!==arguments[4])||arguments[4]),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new X.Matrix,this._cachedWorldViewProjectionMatrix=new X.Matrix,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=O,this._options=(0,S.d)({needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1},z)}get shaderPath(){return this._shaderPath}set shaderPath(M){this._shaderPath=M}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(M){-1===this._options.uniforms.indexOf(M)&&this._options.uniforms.push(M)}setTexture(M,A){return-1===this._options.samplers.indexOf(M)&&this._options.samplers.push(M),this._textures[M]=A,this}removeTexture(M){delete this._textures[M]}setTextureArray(M,A){return-1===this._options.samplers.indexOf(M)&&this._options.samplers.push(M),this._checkUniform(M),this._textureArrays[M]=A,this}setExternalTexture(M,A){return-1===this._options.externalTextures.indexOf(M)&&this._options.externalTextures.push(M),this._externalTextures[M]=A,this}setFloat(M,A){return this._checkUniform(M),this._floats[M]=A,this}setInt(M,A){return this._checkUniform(M),this._ints[M]=A,this}setUInt(M,A){return this._checkUniform(M),this._uints[M]=A,this}setFloats(M,A){return this._checkUniform(M),this._floatsArrays[M]=A,this}setColor3(M,A){return this._checkUniform(M),this._colors3[M]=A,this}setColor3Array(M,A){return this._checkUniform(M),this._colors3Arrays[M]=A.reduce(((M,A)=>(M.push(A.r,A.g,A.b),M)),[]),this}setColor4(M,A){return this._checkUniform(M),this._colors4[M]=A,this}setColor4Array(M,A){return this._checkUniform(M),this._colors4Arrays[M]=A.reduce(((M,A)=>(M.push(A.r,A.g,A.b,A.a),M)),[]),this}setVector2(M,A){return this._checkUniform(M),this._vectors2[M]=A,this}setVector3(M,A){return this._checkUniform(M),this._vectors3[M]=A,this}setVector4(M,A){return this._checkUniform(M),this._vectors4[M]=A,this}setQuaternion(M,A){return this._checkUniform(M),this._quaternions[M]=A,this}setQuaternionArray(M,A){return this._checkUniform(M),this._quaternionsArrays[M]=A.reduce(((M,A)=>(A.toArray(M,M.length),M)),[]),this}setMatrix(M,A){return this._checkUniform(M),this._matrices[M]=A,this}setMatrices(M,A){this._checkUniform(M);const O=new Float32Array(16*A.length);for(let S=0;S<A.length;S++){A[S].copyToArray(O,16*S)}return this._matrixArrays[M]=O,this}setMatrix3x3(M,A){return this._checkUniform(M),this._matrices3x3[M]=A,this}setMatrix2x2(M,A){return this._checkUniform(M),this._matrices2x2[M]=A,this}setArray2(M,A){return this._checkUniform(M),this._vectors2Arrays[M]=A,this}setArray3(M,A){return this._checkUniform(M),this._vectors3Arrays[M]=A,this}setArray4(M,A){return this._checkUniform(M),this._vectors4Arrays[M]=A,this}setUniformBuffer(M,A){return-1===this._options.uniformBuffers.indexOf(M)&&this._options.uniformBuffers.push(M),this._uniformBuffers[M]=A,this}setTextureSampler(M,A){return-1===this._options.samplerObjects.indexOf(M)&&this._options.samplerObjects.push(M),this._textureSamplers[M]=A,this}setStorageBuffer(M,A){return-1===this._options.storageBuffers.indexOf(M)&&this._options.storageBuffers.push(M),this._storageBuffers[M]=A,this}setDefine(M,A){const O=M.trimEnd()+" ",S=this.options.defines.findIndex((A=>A===M||A.startsWith(O)));return S>=0&&this.options.defines.splice(S,1),("boolean"!==typeof A||A)&&this.options.defines.push(O+A),this}isReadyForSubMesh(M,A,O){return this.isReady(M,O,A)}isReady(M,A,O){var S,z,X;const j=O&&this._storeEffectOnSubMeshes;if(this.isFrozen){const M=j?O._drawWrapper:this._drawWrapper;if(M.effect&&M._wasPreviouslyReady&&M._wasPreviouslyUsingInstances===A)return!0}const B=this.HM(),e=B.getEngine(),T=[],J=[];let w=null,I=this._shaderPath,b=this._options.uniforms,s=this._options.uniformBuffers,Y=this._options.samplers;e.getCaps().multiview&&B.activeCamera&&B.activeCamera.outputRenderTarget&&B.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,T.push("#define MULTIVIEW"),-1!==b.indexOf("viewProjection")&&-1===b.indexOf("viewProjectionR")&&b.push("viewProjectionR"));for(let Q=0;Q<this._options.defines.length;Q++){const M=0===this._options.defines[Q].indexOf("#define")?this._options.defines[Q]:"#define ".concat(this._options.defines[Q]);T.push(M)}for(let Q=0;Q<this._options.attributes.length;Q++)J.push(this._options.attributes[Q]);if(M&&M.isVerticesDataPresent(c.c.ColorKind)&&(-1===J.indexOf(c.c.ColorKind)&&J.push(c.c.ColorKind),T.push("#define VERTEXCOLOR")),A&&(T.push("#define INSTANCES"),(0,G.ib)(J,this._materialHelperNeedsPreviousMatrices),null!==M&&void 0!==M&&M.hasThinInstances&&(T.push("#define THIN_INSTANCES"),M&&M.isVerticesDataPresent(c.c.ColorInstanceKind)&&(J.push(c.c.ColorInstanceKind),T.push("#define INSTANCESCOLOR")))),M&&M.useBones&&M.computeBonesUsingShaders&&M.skeleton){J.push(c.c.MatricesIndicesKind),J.push(c.c.MatricesWeightsKind),M.numBoneInfluencers>4&&(J.push(c.c.MatricesIndicesExtraKind),J.push(c.c.MatricesWeightsExtraKind));const A=M.skeleton;T.push("#define NUM_BONE_INFLUENCERS "+M.numBoneInfluencers),w=new g.b,w.addCPUSkinningFallback(0,M),A.isUsingTextureForMatrices?(T.push("#define BONETEXTURE"),-1===b.indexOf("boneTextureWidth")&&b.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(T.push("#define BonesPerMesh "+(A.bones.length+1)),-1===b.indexOf("mBones")&&b.push("mBones"))}else T.push("#define NUM_BONE_INFLUENCERS 0");let E=0;const H=M?M.morphTargetManager:null;if(H){const A=-1!==T.indexOf("#define UV1"),O=-1!==T.indexOf("#define UV2"),S=-1!==T.indexOf("#define TANGENT"),z=-1!==T.indexOf("#define NORMAL"),Q=-1!==T.indexOf("#define VERTEXCOLOR");E=(0,G.G)(H,T,J,M,!0,z,S,A,O,Q),H.isUsingTextureForTargets&&(-1===b.indexOf("morphTargetTextureIndices")&&b.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),E>0&&(b=b.slice(),b.push("morphTargetInfluences"),b.push("morphTargetCount"),b.push("morphTargetTextureInfo"),b.push("morphTargetTextureIndices"))}else T.push("#define NUM_MORPH_INFLUENCERS 0");if(M){const A=M.bakedVertexAnimationManager;A&&A.isEnabled&&(T.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===b.indexOf("bakedVertexAnimationSettings")&&b.push("bakedVertexAnimationSettings"),-1===b.indexOf("bakedVertexAnimationTextureSizeInverted")&&b.push("bakedVertexAnimationTextureSizeInverted"),-1===b.indexOf("bakedVertexAnimationTime")&&b.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture")),(0,G.x)(J,M,T)}for(const Q in this._textures)if(!this._textures[Q].isReady())return!1;M&&this.needAlphaTestingForMesh(M)&&T.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&((0,K.b)(b),(0,K.f)(this,B,T)),B.fogEnabled&&null!==M&&void 0!==M&&M.applyFog&&B.fogMode!==Q.b.FOGMODE_NONE&&(T.push("#define FOG"),-1===b.indexOf("view")&&b.push("view"),-1===b.indexOf("vFogInfos")&&b.push("vFogInfos"),-1===b.indexOf("vFogColor")&&b.push("vFogColor")),this._useLogarithmicDepth&&(T.push("#define LOGARITHMICDEPTH"),-1===b.indexOf("logarithmicDepthConstant")&&b.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(b=b.slice(),s=s.slice(),Y=Y.slice(),I=this.customShaderNameResolve(this.name,b,s,Y,T,J));const C=j?O._getDrawWrapper(void 0,!0):this._drawWrapper,f=null!==(S=null===C||void 0===C?void 0:C.effect)&&void 0!==S?S:null,D=null!==(z=null===C||void 0===C?void 0:C.defines)&&void 0!==z?z:null,F=T.join("\n");let N=f;var y;D!==F&&(N=e.createEffect(I,{attributes:J,uniformsNames:b,uniformBuffersNames:s,samplers:Y,defines:F,fallbacks:w,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:E},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},e),j?O.setEffect(N,F,this._materialContext):C&&C.setEffect(N,F),this._onEffectCreatedObservable&&(d.effect=N,d.subMesh=null!==(y=null!==O&&void 0!==O?O:null===M||void 0===M?void 0:M.Bc[0])&&void 0!==y?y:null,this._onEffectCreatedObservable.notifyObservers(d)));return C._wasPreviouslyUsingInstances=!!A,!(null===(X=N)||void 0===X||!X.isReady())&&(f!==N&&B.resetCachedMaterial(),C._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(M,A){const O=null!==A&&void 0!==A?A:this.getEffect();if(!O)return;const S=this._options.uniforms;-1!==S.indexOf("world")&&O.setMatrix("world",M);const z=this.HM();-1!==S.indexOf("worldView")&&(M.multiplyToRef(z.getViewMatrix(),this._cachedWorldViewMatrix),O.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==S.indexOf("worldViewProjection")&&(M.multiplyToRef(z.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),O.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==S.indexOf("view")&&O.setMatrix("view",z.getViewMatrix())}bindForSubMesh(M,A,O){var S;this.bind(M,A,null===(S=O._drawWrapperOverride)||void 0===S?void 0:S.effect,O)}bind(M,A,O,S){const z=S&&this._storeEffectOnSubMeshes,Q=null!==O&&void 0!==O?O:z?S.effect:this.getEffect();if(!Q)return;const X=this.HM();this._activeEffect=Q,this.bindOnlyWorldMatrix(M,O);const c=this._options.uniformBuffers;let j=!1;if(Q&&c&&c.length>0&&X.getEngine().supportsUniformBuffers)for(let e=0;e<c.length;++e){switch(c[e]){case"Mesh":A&&(A.getMeshUniformBuffer().bindToEffect(Q,"Mesh"),A.transferToEffect(M));break;case"Scene":(0,G.o)(Q,X.getSceneUniformBuffer()),X.finalizeSceneUbo(),j=!0}}const B=A&&z?this._mustRebind(X,Q,S,A.visibility):X.getCachedMaterial()!==this;if(Q&&B){let M;for(M in j||-1===this._options.uniforms.indexOf("view")||Q.setMatrix("view",X.getViewMatrix()),j||-1===this._options.uniforms.indexOf("projection")||Q.setMatrix("projection",X.getProjectionMatrix()),j||-1===this._options.uniforms.indexOf("viewProjection")||(Q.setMatrix("viewProjection",X.getTransformMatrix()),this._multiview&&Q.setMatrix("viewProjectionR",X._transformMatrixR)),X.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&Q.setVector3("cameraPosition",X.activeCamera.globalPosition),(0,G.c)(A,Q),(0,K.d)(Q,this,X),this._useLogarithmicDepth&&(0,G.g)(z?S.materialDefines:Q.defines,Q,X),A&&(0,G.d)(X,A,Q),this._textures)Q.setTexture(M,this._textures[M]);for(M in this._textureArrays)Q.setTextureArray(M,this._textureArrays[M]);for(M in this._ints)Q.setInt(M,this._ints[M]);for(M in this._uints)Q.setUInt(M,this._uints[M]);for(M in this._floats)Q.setFloat(M,this._floats[M]);for(M in this._floatsArrays)Q.setArray(M,this._floatsArrays[M]);for(M in this._colors3)Q.setColor3(M,this._colors3[M]);for(M in this._colors3Arrays)Q.setArray3(M,this._colors3Arrays[M]);for(M in this._colors4){const A=this._colors4[M];Q.setFloat4(M,A.r,A.g,A.b,A.a)}for(M in this._colors4Arrays)Q.setArray4(M,this._colors4Arrays[M]);for(M in this._vectors2)Q.setVector2(M,this._vectors2[M]);for(M in this._vectors3)Q.setVector3(M,this._vectors3[M]);for(M in this._vectors4)Q.setVector4(M,this._vectors4[M]);for(M in this._quaternions)Q.setQuaternion(M,this._quaternions[M]);for(M in this._matrices)Q.setMatrix(M,this._matrices[M]);for(M in this._matrixArrays)Q.setMatrices(M,this._matrixArrays[M]);for(M in this._matrices3x3)Q.setMatrix3x3(M,this._matrices3x3[M]);for(M in this._matrices2x2)Q.setMatrix2x2(M,this._matrices2x2[M]);for(M in this._vectors2Arrays)Q.setArray2(M,this._vectors2Arrays[M]);for(M in this._vectors3Arrays)Q.setArray3(M,this._vectors3Arrays[M]);for(M in this._vectors4Arrays)Q.setArray4(M,this._vectors4Arrays[M]);for(M in this._quaternionsArrays)Q.setArray4(M,this._quaternionsArrays[M]);for(M in this._uniformBuffers){const A=this._uniformBuffers[M].getBuffer();A&&Q.bindUniformBuffer(A,M)}const O=X.getEngine(),c=O.setExternalTexture;if(c)for(M in this._externalTextures)c.call(O,M,this._externalTextures[M]);const B=O.setTextureSampler;if(B)for(M in this._textureSamplers)B.call(O,M,this._textureSamplers[M]);const g=O.setStorageBuffer;if(g)for(M in this._storageBuffers)g.call(O,M,this._storageBuffers[M])}if(Q&&A&&(B||!this.isFrozen)){(0,G.k)(A,Q),A.morphTargetManager&&A.morphTargetManager.isUsingTextureForTargets&&A.morphTargetManager._bind(Q);const M=A.bakedVertexAnimationManager;if(M&&M.isEnabled){var g;const M=z?S._drawWrapper:this._drawWrapper;null===(g=A.bakedVertexAnimationManager)||void 0===g||g.bind(Q,!!M._wasPreviouslyUsingInstances)}}this._afterBind(A,Q,S)}getActiveTextures(){const M=super.getActiveTextures();for(const A in this._textures)M.push(this._textures[A]);for(const A in this._textureArrays){const O=this._textureArrays[A];for(let A=0;A<O.length;A++)M.push(O[A])}return M}hasTexture(M){if(super.hasTexture(M))return!0;for(const A in this._textures)if(this._textures[A]===M)return!0;for(const A in this._textureArrays){const O=this._textureArrays[A];for(let A=0;A<O.length;A++)if(O[A]===M)return!0}return!1}clone(M){const A=z.e.Clone((()=>new w(M,this.HM(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);A.name=M,A.id=M,"object"===typeof A._shaderPath&&(A._shaderPath=(0,S.d)({},A._shaderPath)),this._options=(0,S.d)({},this._options);const O=Object.keys(this._options);for(const S of O){const M=this._options[S];Array.isArray(M)&&(this._options[S]=M.slice(0))}this.Sc.copyTo(A.Sc);for(const S in this._textures)A.setTexture(S,this._textures[S]);for(const S in this._textureArrays)A.setTextureArray(S,this._textureArrays[S]);for(const S in this._externalTextures)A.setExternalTexture(S,this._externalTextures[S]);for(const S in this._ints)A.setInt(S,this._ints[S]);for(const S in this._uints)A.setUInt(S,this._uints[S]);for(const S in this._floats)A.setFloat(S,this._floats[S]);for(const S in this._floatsArrays)A.setFloats(S,this._floatsArrays[S]);for(const S in this._colors3)A.setColor3(S,this._colors3[S]);for(const S in this._colors3Arrays)A._colors3Arrays[S]=this._colors3Arrays[S];for(const S in this._colors4)A.setColor4(S,this._colors4[S]);for(const S in this._colors4Arrays)A._colors4Arrays[S]=this._colors4Arrays[S];for(const S in this._vectors2)A.setVector2(S,this._vectors2[S]);for(const S in this._vectors3)A.setVector3(S,this._vectors3[S]);for(const S in this._vectors4)A.setVector4(S,this._vectors4[S]);for(const S in this._quaternions)A.setQuaternion(S,this._quaternions[S]);for(const S in this._quaternionsArrays)A._quaternionsArrays[S]=this._quaternionsArrays[S];for(const S in this._matrices)A.setMatrix(S,this._matrices[S]);for(const S in this._matrixArrays)A._matrixArrays[S]=this._matrixArrays[S].slice();for(const S in this._matrices3x3)A.setMatrix3x3(S,this._matrices3x3[S]);for(const S in this._matrices2x2)A.setMatrix2x2(S,this._matrices2x2[S]);for(const S in this._vectors2Arrays)A.setArray2(S,this._vectors2Arrays[S]);for(const S in this._vectors3Arrays)A.setArray3(S,this._vectors3Arrays[S]);for(const S in this._vectors4Arrays)A.setArray4(S,this._vectors4Arrays[S]);for(const S in this._uniformBuffers)A.setUniformBuffer(S,this._uniformBuffers[S]);for(const S in this._textureSamplers)A.setTextureSampler(S,this._textureSamplers[S]);for(const S in this._storageBuffers)A.setStorageBuffer(S,this._storageBuffers[S]);return A}dispose(M,A,O){if(A){let M;for(M in this._textures)this._textures[M].dispose();for(M in this._textureArrays){const A=this._textureArrays[M];for(let M=0;M<A.length;M++)A[M].dispose()}}this._textures={},super.dispose(M,A,O)}serialize(){const M=z.e.Serialize(this);let A;for(A in M.customType="BABYLON.ShaderMaterial",M.uniqueId=this.uniqueId,M.options=this._options,M.shaderPath=this._shaderPath,M.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,M.Sc=this.Sc.serialize(),M.textures={},this._textures)M.textures[A]=this._textures[A].serialize();for(A in M.textureArrays={},this._textureArrays){M.textureArrays[A]=[];const O=this._textureArrays[A];for(let S=0;S<O.length;S++)M.textureArrays[A].push(O[S].serialize())}for(A in M.ints={},this._ints)M.ints[A]=this._ints[A];for(A in M.uints={},this._uints)M.uints[A]=this._uints[A];for(A in M.floats={},this._floats)M.floats[A]=this._floats[A];for(A in M.floatsArrays={},this._floatsArrays)M.floatsArrays[A]=this._floatsArrays[A];for(A in M.colors3={},this._colors3){const O=this._colors3[A];M.colors3[A]=[O.r,O.g,O.b]}for(A in M.colors3Arrays={},this._colors3Arrays)M.colors3Arrays[A]=this._colors3Arrays[A];for(A in M.colors4={},this._colors4){const O=this._colors4[A];M.colors4[A]=[O.r,O.g,O.b,O.a]}for(A in M.colors4Arrays={},this._colors4Arrays)M.colors4Arrays[A]=this._colors4Arrays[A];for(A in M.vectors2={},this._vectors2){const O=this._vectors2[A];M.vectors2[A]=[O.x,O.y]}for(A in M.vectors3={},this._vectors3){const O=this._vectors3[A];M.vectors3[A]=[O.x,O.y,O.z]}for(A in M.vectors4={},this._vectors4){const O=this._vectors4[A];M.vectors4[A]=[O.x,O.y,O.z,O.w]}for(A in M.quaternions={},this._quaternions)M.quaternions[A]=this._quaternions[A].gc();for(A in M.matrices={},this._matrices)M.matrices[A]=this._matrices[A].gc();for(A in M.matrixArray={},this._matrixArrays)M.matrixArray[A]=this._matrixArrays[A];for(A in M.matrices3x3={},this._matrices3x3)M.matrices3x3[A]=this._matrices3x3[A];for(A in M.matrices2x2={},this._matrices2x2)M.matrices2x2[A]=this._matrices2x2[A];for(A in M.vectors2Arrays={},this._vectors2Arrays)M.vectors2Arrays[A]=this._vectors2Arrays[A];for(A in M.vectors3Arrays={},this._vectors3Arrays)M.vectors3Arrays[A]=this._vectors3Arrays[A];for(A in M.vectors4Arrays={},this._vectors4Arrays)M.vectors4Arrays[A]=this._vectors4Arrays[A];for(A in M.quaternionsArrays={},this._quaternionsArrays)M.quaternionsArrays[A]=this._quaternionsArrays[A];return M}static Parse(M,A,O){const S=z.e.Parse((()=>new w(M.name,A,M.shaderPath,M.options,M.storeEffectOnSubMeshes)),M,A,O);let Q;for(Q in M.Sc&&S.Sc.parse(M.Sc,A,O),M.textures)S.setTexture(Q,j.c.Parse(M.textures[Q],A,O));for(Q in M.textureArrays){const z=M.textureArrays[Q],X=[];for(let M=0;M<z.length;M++)X.push(j.c.Parse(z[M],A,O));S.setTextureArray(Q,X)}for(Q in M.ints)S.setInt(Q,M.ints[Q]);for(Q in M.uints)S.setUInt(Q,M.uints[Q]);for(Q in M.floats)S.setFloat(Q,M.floats[Q]);for(Q in M.floatsArrays)S.setFloats(Q,M.floatsArrays[Q]);for(Q in M.colors3){const A=M.colors3[Q];S.setColor3(Q,{r:A[0],g:A[1],b:A[2]})}for(Q in M.colors3Arrays){const A=M.colors3Arrays[Q].reduce(((M,A,O)=>(O%3===0?M.push([A]):M[M.length-1].push(A),M)),[]).map((M=>({r:M[0],g:M[1],b:M[2]})));S.setColor3Array(Q,A)}for(Q in M.colors4){const A=M.colors4[Q];S.setColor4(Q,{r:A[0],g:A[1],b:A[2],a:A[3]})}for(Q in M.colors4Arrays){const A=M.colors4Arrays[Q].reduce(((M,A,O)=>(O%4===0?M.push([A]):M[M.length-1].push(A),M)),[]).map((M=>({r:M[0],g:M[1],b:M[2],a:M[3]})));S.setColor4Array(Q,A)}for(Q in M.vectors2){const A=M.vectors2[Q];S.setVector2(Q,{x:A[0],y:A[1]})}for(Q in M.vectors3){const A=M.vectors3[Q];S.setVector3(Q,{x:A[0],y:A[1],z:A[2]})}for(Q in M.vectors4){const A=M.vectors4[Q];S.setVector4(Q,{x:A[0],y:A[1],z:A[2],w:A[3]})}for(Q in M.quaternions)S.setQuaternion(Q,X.Quaternion.sA(M.quaternions[Q]));for(Q in M.matrices)S.setMatrix(Q,X.Matrix.sA(M.matrices[Q]));for(Q in M.matrixArray)S._matrixArrays[Q]=new Float32Array(M.matrixArray[Q]);for(Q in M.matrices3x3)S.setMatrix3x3(Q,M.matrices3x3[Q]);for(Q in M.matrices2x2)S.setMatrix2x2(Q,M.matrices2x2[Q]);for(Q in M.vectors2Arrays)S.setArray2(Q,M.vectors2Arrays[Q]);for(Q in M.vectors3Arrays)S.setArray3(Q,M.vectors3Arrays[Q]);for(Q in M.vectors4Arrays)S.setArray4(Q,M.vectors4Arrays[Q]);for(Q in M.quaternionsArrays)S.setArray4(Q,M.quaternionsArrays[Q]);return S}static async ParseFromFileAsync(M,A,O){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"";return await new Promise(((z,Q)=>{const X=new e.b;X.addEventListener("readystatechange",(()=>{if(4==X.readyState)if(200==X.status){const A=JSON.parse(X.responseText),Q=this.Parse(A,O||J.d.LastCreatedScene,S);M&&(Q.name=M),z(Q)}else Q("Unable to load the ShaderMaterial")})),X.open("GET",A),X.send()}))}static async ParseFromSnippetAsync(M,A){let O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";return await new Promise(((S,z)=>{const Q=new e.b;Q.addEventListener("readystatechange",(()=>{if(4==Q.readyState)if(200==Q.status){const z=JSON.parse(JSON.parse(Q.responseText).jsonPayload),X=JSON.parse(z.shaderMaterial),c=this.Parse(X,A||J.d.LastCreatedScene,O);c.snippetId=M,S(c)}else z("Unable to load the snippet "+M)})),Q.open("GET",this.SnippetUrl+"/"+M.replace(/#/g,"/")),Q.send()}))}}w.SnippetUrl="https://snippet.babylonjs.com",w.CreateFromSnippetAsync=w.ParseFromSnippetAsync,(0,B.g)("BABYLON.ShaderMaterial",w)}}]);