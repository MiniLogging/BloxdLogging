"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[63],{14022:(Z,U,n)=>{n.r(U),n.d(U,{FlowGraphPlayAnimationBlock:()=>V});var i=n(12859),B=n(12826),l=n(633),H=n(14015);class V extends i.c{constructor(Z){super(Z,["animationLoop","animationEnd","animationGroupLoop"]),this.config=Z,this.speed=this.registerDataInput("speed",B.s),this.loop=this.registerDataInput("loop",B.e),this.from=this.registerDataInput("from",B.s,0),this.to=this.registerDataInput("to",B.s),this.currentFrame=this.registerDataOutput("currentFrame",B.s),this.currentTime=this.registerDataOutput("currentTime",B.s),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",B.b),this.animationGroup=this.registerDataInput("animationGroup",B.b,null===Z||void 0===Z?void 0:Z.animationGroup),this.animation=this.registerDataInput("animation",B.b),this.object=this.registerDataInput("object",B.b)}_preparePendingTasks(Z){const U=this.animationGroup.getValue(Z),n=this.animation.getValue(Z);if(!U&&!n)return this._reportError(Z,"No animation or animation group provided");{const B=this.currentAnimationGroup.getValue(Z);B&&B!==U&&B.dispose();let l=U;if(n&&!l){const U=this.object.getValue(Z);if(!U)return this._reportError(Z,"No target object provided");const i=Array.isArray(n)?n:[n],B=i[0].name;l=new H.AnimationGroup("flowGraphAnimationGroup-"+B+"-"+U.name,Z.configuration.Rk);let V=!1;const G=Z._getGlobalContextVariable("interpolationAnimations",[]);for(const Z of i)l.addTargetedAnimation(Z,U),-1!==G.indexOf(Z.uniqueId)&&(V=!0);V&&this._checkInterpolationDuplications(Z,i,U)}const V=this.speed.getValue(Z)||1,G=this.from.getValue(Z)??0,R=this.to.getValue(Z)||l.to,d=!isFinite(R)||this.loop.getValue(Z);this.currentAnimationGroup.setValue(l,Z);const F=Z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==F.indexOf(l.uniqueId)&&l.stop();try{l.start(d,V,G,R),l.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(Z))),l.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(Z))),l.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(Z))),l.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(Z))),F.push(l.uniqueId),Z._setGlobalContextVariable("currentlyRunningAnimationGroups",F)}catch(i){this._reportError(Z,i)}}}_reportError(Z,U){super._reportError(Z,U),this.currentFrame.setValue(-1,Z),this.currentTime.setValue(-1,Z)}_executeOnTick(Z){const U=this.currentAnimationGroup.getValue(Z);var n;U&&(this.currentFrame.setValue(U.getCurrentFrame(),Z),this.currentTime.setValue((null===(n=U.animatables[0])||void 0===n?void 0:n.elapsedTime)??0,Z))}_execute(Z){this._startPendingTasks(Z)}_onAnimationGroupEnd(Z){this._removeFromCurrentlyRunning(Z,this.currentAnimationGroup.getValue(Z)),this._resetAfterCanceled(Z),this.done._activateSignal(Z)}_checkInterpolationDuplications(Z,U,n){const i=Z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const B of i){const i=Z.assetsContext.animationGroups.find((Z=>Z.uniqueId===B));if(i)for(const B of i.targetedAnimations)for(const l of U)B.animation.targetProperty===l.targetProperty&&B.target===n&&this._stopAnimationGroup(Z,i)}}_stopAnimationGroup(Z,U){U.stop(!0),U.dispose(),this._removeFromCurrentlyRunning(Z,U)}_removeFromCurrentlyRunning(Z,U){const n=Z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),i=n.indexOf(U.uniqueId);-1!==i&&(n.splice(i,1),Z._setGlobalContextVariable("currentlyRunningAnimationGroups",n))}_cancelPendingTasks(Z){const U=this.currentAnimationGroup.getValue(Z);U&&this._stopAnimationGroup(Z,U)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,l.g)("FlowGraphPlayAnimationBlock",V)}}]);