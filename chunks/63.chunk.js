"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[63],{14025:(P,Q,O)=>{O.r(Q),O.d(Q,{FlowGraphAbsBlock:()=>B,FlowGraphAcosBlock:()=>gP,FlowGraphAcoshBlock:()=>GP,FlowGraphAddBlock:()=>j,FlowGraphAsinBlock:()=>FP,FlowGraphAsinhBlock:()=>LP,FlowGraphAtan2Block:()=>qP,FlowGraphAtanBlock:()=>mP,FlowGraphAtanhBlock:()=>AP,FlowGraphBitwiseAndBlock:()=>HP,FlowGraphBitwiseLeftShiftBlock:()=>IP,FlowGraphBitwiseNotBlock:()=>uP,FlowGraphBitwiseOrBlock:()=>tP,FlowGraphBitwiseRightShiftBlock:()=>lP,FlowGraphBitwiseXorBlock:()=>BP,FlowGraphCeilBlock:()=>S,FlowGraphClampBlock:()=>e,FlowGraphCosBlock:()=>OP,FlowGraphCoshBlock:()=>XP,FlowGraphCubeRootBlock:()=>TP,FlowGraphDegToRadBlock:()=>v,FlowGraphDivideBlock:()=>r,FlowGraphEBlock:()=>T,FlowGraphEqualityBlock:()=>d,FlowGraphExpBlock:()=>jP,FlowGraphFloorBlock:()=>M,FlowGraphFractionBlock:()=>z,FlowGraphGreaterThanBlock:()=>Z,FlowGraphGreaterThanOrEqualBlock:()=>U,FlowGraphInfBlock:()=>u,FlowGraphIsInfinityBlock:()=>k,FlowGraphIsNanBlock:()=>E,FlowGraphLeadingZerosBlock:()=>MP,FlowGraphLessThanBlock:()=>f,FlowGraphLessThanOrEqualBlock:()=>n,FlowGraphLog10Block:()=>rP,FlowGraphLog2Block:()=>WP,FlowGraphLogBlock:()=>wP,FlowGraphMathInterpolationBlock:()=>D,FlowGraphMaxBlock:()=>V,FlowGraphMinBlock:()=>h,FlowGraphModuloBlock:()=>c,FlowGraphMultiplyBlock:()=>W,FlowGraphNaNBlock:()=>H,FlowGraphNegationBlock:()=>a,FlowGraphOneBitsCounterBlock:()=>oP,FlowGraphPiBlock:()=>x,FlowGraphPowerBlock:()=>xP,FlowGraphRadToDegBlock:()=>PP,FlowGraphRandomBlock:()=>K,FlowGraphRoundBlock:()=>o,FlowGraphSaturateBlock:()=>Y,FlowGraphSignBlock:()=>I,FlowGraphSinBlock:()=>QP,FlowGraphSinhBlock:()=>RP,FlowGraphSquareRootBlock:()=>KP,FlowGraphSubtractBlock:()=>w,FlowGraphTanBlock:()=>bP,FlowGraphTanhBlock:()=>CP,FlowGraphTrailingZerosBlock:()=>SP,FlowGraphTruncBlock:()=>l});var b=O(696),F=O(12871),g=O(14033),m=O(14042);class q extends m.e{constructor(P,Q,O,b){super(P,b),this._operation=Q,this._className=O}_doOperation(P){return this._operation(P)}getClassName(){return this._className}}var R=O(751),X=O(14046);class C extends m.e{constructor(P,Q,O,b,F,g,m){super(b,m),this._operation=F,this._className=g,this.a=this.registerDataInput("a",P),this.b=this.registerDataInput("b",Q),this.c=this.registerDataInput("c",O)}_doOperation(P){return this._operation(this.a.getValue(P),this.b.getValue(P),this.c.getValue(P))}getClassName(){return this._className}}var L=O(12867),G=O(12874),A=O(12900);class j extends g.d{constructor(P){super((0,F.K)(null===P||void 0===P?void 0:P.type),(0,F.K)(null===P||void 0===P?void 0:P.type),(0,F.K)(null===P||void 0===P?void 0:P.type),((P,Q)=>this._polymorphicAdd(P,Q)),"FlowGraphAddBlock",P)}_polymorphicAdd(P,Q){const O=(0,A.j)(P),b=(0,A.j)(Q);if((0,A.h)(O,b)||(0,A.d)(O,b)||(0,A.b)(O,b))return P.add(Q);if("Quaternion"===O||"Vector4"===b)return new R.k(P.x,P.y,P.z,P.w).addInPlace(Q);if("Vector4"===O||"Quaternion"===b)return P.add(Q);var F;if(null!==(F=this.config)&&void 0!==F&&F.preventIntegerFloatArithmetic&&typeof P!==typeof Q)throw new Error("Cannot add different types of numbers.");return(0,A.o)(P)+(0,A.o)(Q)}}(0,b.f)("FlowGraphAddBlock",j);class w extends g.d{constructor(P){super((0,F.K)(null===P||void 0===P?void 0:P.type),(0,F.K)(null===P||void 0===P?void 0:P.type),(0,F.K)(null===P||void 0===P?void 0:P.type),((P,Q)=>this._polymorphicSubtract(P,Q)),"FlowGraphSubtractBlock",P)}_polymorphicSubtract(P,Q){const O=(0,A.j)(P),b=(0,A.j)(Q);if((0,A.h)(O,b)||(0,A.b)(O,b)||(0,A.d)(O,b))return P.ae(Q);if("Quaternion"===O||"Vector4"===b)return new R.k(P.x,P.y,P.z,P.w).fk(Q);if("Vector4"===O||"Quaternion"===b)return P.ae(Q);var F;if(null!==(F=this.config)&&void 0!==F&&F.preventIntegerFloatArithmetic&&typeof P!==typeof Q)throw new Error("Cannot add different types of numbers.");return(0,A.o)(P)-(0,A.o)(Q)}}(0,b.f)("FlowGraphSubtractBlock",w);class W extends g.d{constructor(P){super((0,F.K)(null===P||void 0===P?void 0:P.type),(0,F.K)(null===P||void 0===P?void 0:P.type),(0,F.K)(null===P||void 0===P?void 0:P.type),((P,Q)=>this._polymorphicMultiply(P,Q)),"FlowGraphMultiplyBlock",P)}_polymorphicMultiply(P,Q){const O=(0,A.j)(P),b=(0,A.j)(Q);if((0,A.h)(O,b)||(0,A.b)(O,b))return P.multiply(Q);if("Quaternion"===O||"Vector4"===b)return new R.k(P.x,P.y,P.z,P.w).multiplyInPlace(Q);if("Vector4"===O||"Quaternion"===b)return P.multiply(Q);if((0,A.d)(O,b)){var F;if(null!==(F=this.config)&&void 0!==F&&F.useMatrixPerComponent){const b=P.m;for(let P=0;P<b.length;P++)b[P]*=Q.m[P];return"Matrix2D"===O?new G.d(b):"Matrix3D"===O?new G.h(b):R.c.bk(b)}return Q.multiply(P)}var g;if(null!==(g=this.config)&&void 0!==g&&g.preventIntegerFloatArithmetic&&typeof P!==typeof Q)throw new Error("Cannot add different types of numbers.");return(0,A.o)(P)*(0,A.o)(Q)}}(0,b.f)("FlowGraphMultiplyBlock",W);class r extends g.d{constructor(P){super((0,F.K)(null===P||void 0===P?void 0:P.type),(0,F.K)(null===P||void 0===P?void 0:P.type),(0,F.K)(null===P||void 0===P?void 0:P.type),((P,Q)=>this._polymorphicDivide(P,Q)),"FlowGraphDivideBlock",P)}_polymorphicDivide(P,Q){const O=(0,A.j)(P),b=(0,A.j)(Q);if((0,A.h)(O,b)||(0,A.b)(O,b))return P.divide(Q);if("Quaternion"===O||"Quaternion"===b){const O=P.clone();return O.x/=Q.x,O.y/=Q.y,O.z/=Q.z,O.w/=Q.w,O}if("Quaternion"===O||"Vector4"===b)return new R.k(P.x,P.y,P.z,P.w).divideInPlace(Q);if("Vector4"===O||"Quaternion"===b)return P.divide(Q);if((0,A.d)(O,b)){var F;if(null!==(F=this.config)&&void 0!==F&&F.useMatrixPerComponent){const b=P.m;for(let P=0;P<b.length;P++)b[P]/=Q.m[P];return"Matrix2D"===O?new G.d(b):"Matrix3D"===O?new G.h(b):R.c.bk(b)}return P.divide(Q)}var g;if(null!==(g=this.config)&&void 0!==g&&g.preventIntegerFloatArithmetic&&typeof P!==typeof Q)throw new Error("Cannot add different types of numbers.");return(0,A.o)(P)/(0,A.o)(Q)}}(0,b.f)("FlowGraphDivideBlock",r);class K extends q{constructor(P){super(F.o,(P=>this._random(P)),"FlowGraphRandomBlock",P),this.min=this.registerDataInput("min",F.o,(null===P||void 0===P?void 0:P.min)??0),this.max=this.registerDataInput("max",F.o,(null===P||void 0===P?void 0:P.max)??1),null!==P&&void 0!==P&&P.seed&&(this._seed=P.seed)}_isSeed(){return void 0!==(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._seed)}_getRandomValue(){if(this._isSeed(this._seed)){const P=1e4*Math.sin(this._seed++);return P-Math.floor(P)}return Math.random()}_random(P){const Q=this.min.getValue(P),O=this.max.getValue(P);return this._getRandomValue()*(O-Q)+Q}}(0,b.f)("FlowGraphRandomBlock",K);class T extends q{constructor(P){super(F.o,(()=>Math.E),"FlowGraphEBlock",P)}}(0,b.f)("FlowGraphEBlock",T);class x extends q{constructor(P){super(F.o,(()=>Math.PI),"FlowGraphPIBlock",P)}}(0,b.f)("FlowGraphPIBlock",x);class u extends q{constructor(P){super(F.o,(()=>Number.POSITIVE_INFINITY),"FlowGraphInfBlock",P)}}(0,b.f)("FlowGraphInfBlock",u);class H extends q{constructor(P){super(F.o,(()=>Number.NaN),"FlowGraphNaNBlock",P)}}function t(P,Q){switch((0,A.j)(P)){case"FlowGraphInteger":return new L.c(Q(P.value));case"Vector2":return new R.i(Q(P.x),Q(P.y));case"dk":return new R.j(Q(P.x),Q(P.y),Q(P.z));case"Vector4":return new R.k(Q(P.x),Q(P.y),Q(P.z),Q(P.w));case"Quaternion":return new R.d(Q(P.x),Q(P.y),Q(P.z),Q(P.w));case"Matrix":return R.c.bk(P.m.map(Q));case"Matrix2D":return new G.d(P.m.map(Q));case"Matrix3D":return new G.h(P.m.map(Q));default:return Q(P)}}(0,b.f)("FlowGraphNaNBlock",H);class B extends X.b{constructor(P){super(F.o,F.o,(P=>this._polymorphicAbs(P)),"FlowGraphAbsBlock",P)}_polymorphicAbs(P){return t(P,Math.abs)}}(0,b.f)("FlowGraphAbsBlock",B);class I extends X.b{constructor(P){super(F.o,F.o,(P=>this._polymorphicSign(P)),"FlowGraphSignBlock",P)}_polymorphicSign(P){return t(P,Math.sign)}}(0,b.f)("FlowGraphSignBlock",I);class l extends X.b{constructor(P){super(F.o,F.o,(P=>this._polymorphicTrunc(P)),"FlowGraphTruncBlock",P)}_polymorphicTrunc(P){return t(P,Math.trunc)}}(0,b.f)("FlowGraphTruncBlock",l);class M extends X.b{constructor(P){super(F.o,F.o,(P=>this._polymorphicFloor(P)),"FlowGraphFloorBlock",P)}_polymorphicFloor(P){return t(P,Math.floor)}}(0,b.f)("FlowGraphFloorBlock",M);class S extends X.b{constructor(P){super(F.d,F.d,(P=>this._polymorphicCeiling(P)),"FlowGraphCeilBlock",P)}_polymorphicCeiling(P){return t(P,Math.ceil)}}(0,b.f)("FlowGraphCeilBlock",S);class o extends X.b{constructor(P){super(F.d,F.d,(P=>this._polymorphicRound(P)),"FlowGraphRoundBlock",P)}_polymorphicRound(P){return t(P,(P=>{var Q;return P<0&&null!==(Q=this.config)&&void 0!==Q&&Q.roundHalfAwayFromZero?-Math.round(-P):Math.round(P)}))}}(0,b.f)("FlowGraphRoundBlock",o);class z extends X.b{constructor(P){super(F.d,F.d,(P=>this._polymorphicFraction(P)),"FlowGraphFractBlock",P)}_polymorphicFraction(P){return t(P,(P=>P-Math.floor(P)))}}(0,b.f)("FlowGraphFractBlock",z);class a extends X.b{constructor(P){super(F.d,F.d,(P=>this._polymorphicNeg(P)),"FlowGraphNegationBlock",P)}_polymorphicNeg(P){return t(P,(P=>-P))}}function y(P,Q,O){switch((0,A.j)(P)){case"FlowGraphInteger":return new L.c(O(P.value,Q.value));case"Vector2":return new R.i(O(P.x,Q.x),O(P.y,Q.y));case"dk":return new R.j(O(P.x,Q.x),O(P.y,Q.y),O(P.z,Q.z));case"Vector4":return new R.k(O(P.x,Q.x),O(P.y,Q.y),O(P.z,Q.z),O(P.w,Q.w));case"Quaternion":return new R.d(O(P.x,Q.x),O(P.y,Q.y),O(P.z,Q.z),O(P.w,Q.w));case"Matrix":return R.c.bk(P.m.map(((P,b)=>O(P,Q.m[b]))));case"Matrix2D":return new G.d(P.m.map(((P,b)=>O(P,Q.m[b]))));case"Matrix3D":return new G.h(P.m.map(((P,b)=>O(P,Q.m[b]))));default:return O((0,A.o)(P),(0,A.o)(Q))}}(0,b.f)("FlowGraphNegationBlock",a);class c extends g.d{constructor(P){super(F.d,F.d,F.d,((P,Q)=>this._polymorphicRemainder(P,Q)),"FlowGraphModuloBlock",P)}_polymorphicRemainder(P,Q){return y(P,Q,((P,Q)=>P%Q))}}(0,b.f)("FlowGraphModuloBlock",c);class h extends g.d{constructor(P){super(F.d,F.d,F.d,((P,Q)=>this._polymorphicMin(P,Q)),"FlowGraphMinBlock",P)}_polymorphicMin(P,Q){return y(P,Q,Math.min)}}(0,b.f)("FlowGraphMinBlock",h);class V extends g.d{constructor(P){super(F.d,F.d,F.d,((P,Q)=>this._polymorphicMax(P,Q)),"FlowGraphMaxBlock",P)}_polymorphicMax(P,Q){return y(P,Q,Math.max)}}function s(P,Q,O){return Math.min(Math.max(P,Math.min(Q,O)),Math.max(Q,O))}function J(P,Q,O,b){switch((0,A.j)(P)){case"FlowGraphInteger":return new L.c(b(P.value,Q.value,O.value));case"Vector2":return new R.i(b(P.x,Q.x,O.x),b(P.y,Q.y,O.y));case"dk":return new R.j(b(P.x,Q.x,O.x),b(P.y,Q.y,O.y),b(P.z,Q.z,O.z));case"Vector4":return new R.k(b(P.x,Q.x,O.x),b(P.y,Q.y,O.y),b(P.z,Q.z,O.z),b(P.w,Q.w,O.w));case"Quaternion":return new R.d(b(P.x,Q.x,O.x),b(P.y,Q.y,O.y),b(P.z,Q.z,O.z),b(P.w,Q.w,O.w));case"Matrix":return R.c.bk(P.m.map(((P,F)=>b(P,Q.m[F],O.m[F]))));case"Matrix2D":return new G.d(P.m.map(((P,F)=>b(P,Q.m[F],O.m[F]))));case"Matrix3D":return new G.h(P.m.map(((P,F)=>b(P,Q.m[F],O.m[F]))));default:return b((0,A.o)(P),(0,A.o)(Q),(0,A.o)(O))}}(0,b.f)("FlowGraphMaxBlock",V);class e extends C{constructor(P){super(F.d,F.d,F.d,F.d,((P,Q,O)=>this._polymorphicClamp(P,Q,O)),"FlowGraphClampBlock",P)}_polymorphicClamp(P,Q,O){return J(P,Q,O,s)}}function i(P){return Math.min(Math.max(P,0),1)}(0,b.f)("FlowGraphClampBlock",e);class Y extends X.b{constructor(P){super(F.d,F.d,(P=>this._polymorphicSaturate(P)),"FlowGraphSaturateBlock",P)}_polymorphicSaturate(P){return t(P,i)}}function p(P,Q,O){return(1-O)*P+O*Q}(0,b.f)("FlowGraphSaturateBlock",Y);class D extends C{constructor(P){super(F.d,F.d,F.d,F.d,((P,Q,O)=>this._polymorphicInterpolate(P,Q,O)),"FlowGraphMathInterpolationBlock",P)}_polymorphicInterpolate(P,Q,O){return J(P,Q,O,p)}}(0,b.f)("FlowGraphMathInterpolationBlock",D);class d extends g.d{constructor(P){super(F.d,F.d,F.g,((P,Q)=>this._polymorphicEq(P,Q)),"FlowGraphEqualityBlock",P)}_polymorphicEq(P,Q){const O=(0,A.j)(P),b=(0,A.j)(Q);return typeof P===typeof Q&&((0,A.h)(O,b)||(0,A.d)(O,b)||(0,A.b)(O,b)?P.equals(Q):P===Q)}}function N(P,Q,O){if((0,A.s)(P)&&(0,A.s)(Q))return O((0,A.o)(P),(0,A.o)(Q));throw new Error(`Cannot compare ${P} and ${Q}`)}(0,b.f)("FlowGraphEqualityBlock",d);class f extends g.d{constructor(P){super(F.d,F.d,F.g,((P,Q)=>this._polymorphicLessThan(P,Q)),"FlowGraphLessThanBlock",P)}_polymorphicLessThan(P,Q){return N(P,Q,((P,Q)=>P<Q))}}(0,b.f)("FlowGraphLessThanBlock",f);class n extends g.d{constructor(P){super(F.d,F.d,F.g,((P,Q)=>this._polymorphicLessThanOrEqual(P,Q)),"FlowGraphLessThanOrEqualBlock",P)}_polymorphicLessThanOrEqual(P,Q){return N(P,Q,((P,Q)=>P<=Q))}}(0,b.f)("FlowGraphLessThanOrEqualBlock",n);class Z extends g.d{constructor(P){super(F.d,F.d,F.g,((P,Q)=>this._polymorphicGreaterThan(P,Q)),"FlowGraphGreaterThanBlock",P)}_polymorphicGreaterThan(P,Q){return N(P,Q,((P,Q)=>P>Q))}}(0,b.f)("FlowGraphGreaterThanBlock",Z);class U extends g.d{constructor(P){super(F.d,F.d,F.g,((P,Q)=>this._polymorphicGreaterThanOrEqual(P,Q)),"FlowGraphGreaterThanOrEqualBlock",P)}_polymorphicGreaterThanOrEqual(P,Q){return N(P,Q,((P,Q)=>P>=Q))}}(0,b.f)("FlowGraphGreaterThanOrEqualBlock",U);class E extends X.b{constructor(P){super(F.d,F.g,(P=>this._polymorphicIsNan(P)),"FlowGraphIsNaNBlock",P)}_polymorphicIsNan(P){if((0,A.s)(P,!0))return isNaN((0,A.o)(P));throw new Error(`Cannot get NaN of ${P}`)}}(0,b.f)("FlowGraphIsNaNBlock",E);class k extends X.b{constructor(P){super(F.d,F.g,(P=>this._polymorphicIsInf(P)),"FlowGraphIsInfBlock",P)}_polymorphicIsInf(P){if((0,A.s)(P))return!isFinite((0,A.o)(P));throw new Error(`Cannot get isInf of ${P}`)}}(0,b.f)("FlowGraphIsInfBlock",k);class v extends X.b{constructor(P){super(F.d,F.d,(P=>this._polymorphicDegToRad(P)),"FlowGraphDegToRadBlock",P)}_degToRad(P){return P*Math.PI/180}_polymorphicDegToRad(P){return t(P,this._degToRad)}}(0,b.f)("FlowGraphDegToRadBlock",v);class PP extends X.b{constructor(P){super(F.d,F.d,(P=>this._polymorphicRadToDeg(P)),"FlowGraphRadToDegBlock",P)}_radToDeg(P){return 180*P/Math.PI}_polymorphicRadToDeg(P){return t(P,this._radToDeg)}}(0,b.f)("FlowGraphRadToDegBlock",PP);class QP extends X.b{constructor(P){super(F.o,F.o,(P=>this._polymorphicSin(P)),"FlowGraphSinBlock",P)}_polymorphicSin(P){return t(P,Math.sin)}}class OP extends X.b{constructor(P){super(F.o,F.o,(P=>this._polymorphicCos(P)),"FlowGraphCosBlock",P)}_polymorphicCos(P){return t(P,Math.cos)}}class bP extends X.b{constructor(P){super(F.o,F.o,(P=>this._polymorphicTan(P)),"FlowGraphTanBlock",P)}_polymorphicTan(P){return t(P,Math.tan)}}class FP extends X.b{constructor(P){super(F.o,F.o,(P=>this._polymorphicAsin(P)),"FlowGraphASinBlock",P)}_polymorphicAsin(P){return t(P,Math.asin)}}(0,b.f)("FlowGraphASinBlock",FP);class gP extends X.b{constructor(P){super(F.o,F.o,(P=>this._polymorphicAcos(P)),"FlowGraphACosBlock",P)}_polymorphicAcos(P){return t(P,Math.acos)}}(0,b.f)("FlowGraphACosBlock",gP);class mP extends X.b{constructor(P){super(F.o,F.o,(P=>this._polymorphicAtan(P)),"FlowGraphATanBlock",P)}_polymorphicAtan(P){return t(P,Math.atan)}}(0,b.f)("FlowGraphATanBlock",mP);class qP extends g.d{constructor(P){super(F.d,F.d,F.d,((P,Q)=>this._polymorphicAtan2(P,Q)),"FlowGraphATan2Block",P)}_polymorphicAtan2(P,Q){return y(P,Q,Math.atan2)}}(0,b.f)("FlowGraphATan2Block",qP);class RP extends X.b{constructor(P){super(F.d,F.d,(P=>this._polymorphicSinh(P)),"FlowGraphSinhBlock",P)}_polymorphicSinh(P){return t(P,Math.sinh)}}(0,b.f)("FlowGraphSinhBlock",RP);class XP extends X.b{constructor(P){super(F.d,F.d,(P=>this._polymorphicCosh(P)),"FlowGraphCoshBlock",P)}_polymorphicCosh(P){return t(P,Math.cosh)}}(0,b.f)("FlowGraphCoshBlock",XP);class CP extends X.b{constructor(P){super(F.d,F.d,(P=>this._polymorphicTanh(P)),"FlowGraphTanhBlock",P)}_polymorphicTanh(P){return t(P,Math.tanh)}}(0,b.f)("FlowGraphTanhBlock",CP);class LP extends X.b{constructor(P){super(F.d,F.o,(P=>this._polymorphicAsinh(P)),"FlowGraphASinhBlock",P)}_polymorphicAsinh(P){return t(P,Math.asinh)}}(0,b.f)("FlowGraphASinhBlock",LP);class GP extends X.b{constructor(P){super(F.d,F.o,(P=>this._polymorphicAcosh(P)),"FlowGraphACoshBlock",P)}_polymorphicAcosh(P){return t(P,Math.acosh)}}(0,b.f)("FlowGraphACoshBlock",GP);class AP extends X.b{constructor(P){super(F.d,F.o,(P=>this._polymorphicAtanh(P)),"FlowGraphATanhBlock",P)}_polymorphicAtanh(P){return t(P,Math.atanh)}}(0,b.f)("FlowGraphATanhBlock",AP);class jP extends X.b{constructor(P){super(F.d,F.o,(P=>this._polymorphicExp(P)),"FlowGraphExponentialBlock",P)}_polymorphicExp(P){return t(P,Math.exp)}}(0,b.f)("FlowGraphExponentialBlock",jP);class wP extends X.b{constructor(P){super(F.d,F.o,(P=>this._polymorphicLog(P)),"FlowGraphLogBlock",P)}_polymorphicLog(P){return t(P,Math.log)}}(0,b.f)("FlowGraphLogBlock",wP);class WP extends X.b{constructor(P){super(F.d,F.o,(P=>this._polymorphicLog2(P)),"FlowGraphLog2Block",P)}_polymorphicLog2(P){return t(P,Math.log2)}}(0,b.f)("FlowGraphLog2Block",WP);class rP extends X.b{constructor(P){super(F.d,F.o,(P=>this._polymorphicLog10(P)),"FlowGraphLog10Block",P)}_polymorphicLog10(P){return t(P,Math.log10)}}(0,b.f)("FlowGraphLog10Block",rP);class KP extends X.b{constructor(P){super(F.d,F.o,(P=>this._polymorphicSqrt(P)),"FlowGraphSquareRootBlock",P)}_polymorphicSqrt(P){return t(P,Math.sqrt)}}(0,b.f)("FlowGraphSquareRootBlock",KP);class TP extends X.b{constructor(P){super(F.d,F.o,(P=>this._polymorphicCubeRoot(P)),"FlowGraphCubeRootBlock",P)}_polymorphicCubeRoot(P){return t(P,Math.cbrt)}}(0,b.f)("FlowGraphCubeRootBlock",TP);class xP extends g.d{constructor(P){super(F.d,F.o,F.o,((P,Q)=>this._polymorphicPow(P,Q)),"FlowGraphPowerBlock",P)}_polymorphicPow(P,Q){return y(P,Q,Math.pow)}}(0,b.f)("FlowGraphPowerBlock",xP);class uP extends X.b{constructor(P){super((0,F.K)((null===P||void 0===P?void 0:P.valueType)||"FlowGraphInteger"),(0,F.K)((null===P||void 0===P?void 0:P.valueType)||"FlowGraphInteger"),(P=>"boolean"===typeof P?!P:"number"===typeof P?~P:new L.c(~P.value)),"FlowGraphBitwiseNotBlock",P)}}(0,b.f)("FlowGraphBitwiseNotBlock",uP);class HP extends g.d{constructor(P){super((0,F.K)((null===P||void 0===P?void 0:P.valueType)||"FlowGraphInteger"),(0,F.K)((null===P||void 0===P?void 0:P.valueType)||"FlowGraphInteger"),(0,F.K)((null===P||void 0===P?void 0:P.valueType)||"FlowGraphInteger"),((P,Q)=>{if("boolean"===typeof P&&"boolean"===typeof Q)return P&&Q;if("number"===typeof P&&"number"===typeof Q)return P&Q;if("object"===typeof P&&"object"===typeof Q)return new L.c(P.value&Q.value);throw new Error(`Cannot perform bitwise AND on ${P} and ${Q}`)}),"FlowGraphBitwiseAndBlock",P)}}(0,b.f)("FlowGraphBitwiseAndBlock",HP);class tP extends g.d{constructor(P){super((0,F.K)((null===P||void 0===P?void 0:P.valueType)||"FlowGraphInteger"),(0,F.K)((null===P||void 0===P?void 0:P.valueType)||"FlowGraphInteger"),(0,F.K)((null===P||void 0===P?void 0:P.valueType)||"FlowGraphInteger"),((P,Q)=>{if("boolean"===typeof P&&"boolean"===typeof Q)return P||Q;if("number"===typeof P&&"number"===typeof Q)return P|Q;if("object"===typeof P&&"object"===typeof Q)return new L.c(P.value|Q.value);throw new Error(`Cannot perform bitwise OR on ${P} and ${Q}`)}),"FlowGraphBitwiseOrBlock",P)}}(0,b.f)("FlowGraphBitwiseOrBlock",tP);class BP extends g.d{constructor(P){super((0,F.K)((null===P||void 0===P?void 0:P.valueType)||"FlowGraphInteger"),(0,F.K)((null===P||void 0===P?void 0:P.valueType)||"FlowGraphInteger"),(0,F.K)((null===P||void 0===P?void 0:P.valueType)||"FlowGraphInteger"),((P,Q)=>{if("boolean"===typeof P&&"boolean"===typeof Q)return P!==Q;if("number"===typeof P&&"number"===typeof Q)return P^Q;if("object"===typeof P&&"object"===typeof Q)return new L.c(P.value^Q.value);throw new Error(`Cannot perform bitwise XOR on ${P} and ${Q}`)}),"FlowGraphBitwiseXorBlock",P)}}(0,b.f)("FlowGraphBitwiseXorBlock",BP);class IP extends g.d{constructor(P){super(F.h,F.h,F.h,((P,Q)=>new L.c(P.value<<Q.value)),"FlowGraphBitwiseLeftShiftBlock",P)}}(0,b.f)("FlowGraphBitwiseLeftShiftBlock",IP);class lP extends g.d{constructor(P){super(F.h,F.h,F.h,((P,Q)=>new L.c(P.value>>Q.value)),"FlowGraphBitwiseRightShiftBlock",P)}}(0,b.f)("FlowGraphBitwiseRightShiftBlock",lP);class MP extends X.b{constructor(P){super(F.h,F.h,(P=>new L.c(Math.clz32(P.value))),"FlowGraphLeadingZerosBlock",P)}}(0,b.f)("FlowGraphLeadingZerosBlock",MP);class SP extends X.b{constructor(P){super(F.h,F.h,(P=>new L.c(P.value?31-Math.clz32(P.value&-P.value):32)),"FlowGraphTrailingZerosBlock",P)}}(0,b.f)("FlowGraphTrailingZerosBlock",SP);class oP extends X.b{constructor(P){super(F.h,F.h,(P=>new L.c(function(P){let Q=0;for(;P;)Q+=1&P,P>>=1;return Q}(P.value))),"FlowGraphOneBitsCounterBlock",P)}}(0,b.f)("FlowGraphOneBitsCounterBlock",oP)},14033:(P,Q,O)=>{O.d(Q,{d:()=>F});var b=O(14042);class F extends b.e{constructor(P,Q,O,b,F,g){super(O,g),this._operation=b,this._className=F,this.a=this.registerDataInput("a",P),this.b=this.registerDataInput("b",Q)}_doOperation(P){const Q=this.a.getValue(P),O=this.b.getValue(P);return this._operation(Q,O)}getClassName(){return this._className}}},14042:(P,Q,O)=>{O.d(Q,{e:()=>q});var b=O(12885),F=O(12871);const g="cachedOperationValue",m="cachedExecutionId";class q extends b.c{constructor(P,Q){super(Q),this.value=this.registerDataOutput("value",P),this.isValid=this.registerDataOutput("isValid",F.g)}_updateOutputs(P){const Q=P._getExecutionVariable(this,m,-1),O=P._getExecutionVariable(this,g,null);if(void 0!==O&&null!==O&&Q===P.executionId)this.isValid.setValue(!0,P),this.value.setValue(O,P);else try{const Q=this._doOperation(P);if(void 0===Q||null===Q)return void this.isValid.setValue(!1,P);P._setExecutionVariable(this,g,Q),P._setExecutionVariable(this,m,P.executionId),this.value.setValue(Q,P),this.isValid.setValue(!0,P)}catch(b){this.isValid.setValue(!1,P)}}}},14046:(P,Q,O)=>{O.d(Q,{b:()=>F});var b=O(14042);class F extends b.e{constructor(P,Q,O,b,F){super(Q,F),this._operation=O,this._className=b,this.a=this.registerDataInput("a",P)}_doOperation(P){return this._operation(this.a.getValue(P))}getClassName(){return this._className}}}}]);