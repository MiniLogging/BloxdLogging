"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[63],{13755:(W,F,c)=>{c.r(F),c.d(F,{FlowGraphAbsBlock:()=>C,FlowGraphAcosBlock:()=>ZW,FlowGraphAcoshBlock:()=>NW,FlowGraphAddBlock:()=>y,FlowGraphAsinBlock:()=>YW,FlowGraphAsinhBlock:()=>jW,FlowGraphAtan2Block:()=>AW,FlowGraphAtanBlock:()=>wW,FlowGraphAtanhBlock:()=>qW,FlowGraphBitwiseAndBlock:()=>DW,FlowGraphBitwiseLeftShiftBlock:()=>nW,FlowGraphBitwiseNotBlock:()=>GW,FlowGraphBitwiseOrBlock:()=>vW,FlowGraphBitwiseRightShiftBlock:()=>XW,FlowGraphBitwiseXorBlock:()=>CW,FlowGraphCeilBlock:()=>S,FlowGraphClampBlock:()=>r,FlowGraphCosBlock:()=>cW,FlowGraphCoshBlock:()=>sW,FlowGraphCubeRootBlock:()=>OW,FlowGraphDegToRadBlock:()=>h,FlowGraphDivideBlock:()=>I,FlowGraphEBlock:()=>O,FlowGraphEqualityBlock:()=>p,FlowGraphExpBlock:()=>yW,FlowGraphFloorBlock:()=>g,FlowGraphFractionBlock:()=>o,FlowGraphGreaterThanBlock:()=>J,FlowGraphGreaterThanOrEqualBlock:()=>B,FlowGraphInfBlock:()=>G,FlowGraphIsInfinityBlock:()=>l,FlowGraphIsNanBlock:()=>a,FlowGraphLeadingZerosBlock:()=>gW,FlowGraphLessThanBlock:()=>M,FlowGraphLessThanOrEqualBlock:()=>Q,FlowGraphLog10Block:()=>IW,FlowGraphLog2Block:()=>eW,FlowGraphLogBlock:()=>iW,FlowGraphMathInterpolationBlock:()=>P,FlowGraphMaxBlock:()=>H,FlowGraphMinBlock:()=>L,FlowGraphModuloBlock:()=>d,FlowGraphMultiplyBlock:()=>e,FlowGraphNaNBlock:()=>D,FlowGraphNegationBlock:()=>K,FlowGraphOneBitsCounterBlock:()=>UW,FlowGraphPiBlock:()=>z,FlowGraphPowerBlock:()=>zW,FlowGraphRadToDegBlock:()=>WW,FlowGraphRandomBlock:()=>E,FlowGraphRoundBlock:()=>U,FlowGraphSaturateBlock:()=>R,FlowGraphSignBlock:()=>n,FlowGraphSinBlock:()=>FW,FlowGraphSinhBlock:()=>uW,FlowGraphSquareRootBlock:()=>EW,FlowGraphSubtractBlock:()=>i,FlowGraphTanBlock:()=>TW,FlowGraphTanhBlock:()=>xW,FlowGraphTrailingZerosBlock:()=>SW,FlowGraphTruncBlock:()=>X});var T=c(642),Y=c(12517),Z=c(13763),w=c(13768);class A extends w.d{constructor(W,F,c,T){super(W,T),this._operation=F,this._className=c}_doOperation(W){return this._operation(W)}getClassName(){return this._className}}var u=c(694),s=c(13772);class x extends w.d{constructor(W,F,c,T,Y,Z,w){super(T,w),this._operation=Y,this._className=Z,this.a=this.registerDataInput("a",W),this.b=this.registerDataInput("b",F),this.c=this.registerDataInput("c",c)}_doOperation(W){return this._operation(this.a.getValue(W),this.b.getValue(W),this.c.getValue(W))}getClassName(){return this._className}}var j=c(12512),N=c(12523),q=c(12554);class y extends Z.c{constructor(W){super((0,Y.F)(null===W||void 0===W?void 0:W.type),(0,Y.F)(null===W||void 0===W?void 0:W.type),(0,Y.F)(null===W||void 0===W?void 0:W.type),((W,F)=>this._polymorphicAdd(W,F)),"FlowGraphAddBlock",W)}_polymorphicAdd(W,F){const c=(0,q.l)(W),T=(0,q.l)(F);if((0,q.i)(c,T)||(0,q.h)(c,T)||(0,q.e)(c,T))return W.add(F);if("Quaternion"===c||"Vector4"===T)return new u.m(W.x,W.y,W.z,W.w).addInPlace(F);if("Vector4"===c||"Quaternion"===T)return W.add(F);var Y;if(null!==(Y=this.config)&&void 0!==Y&&Y.preventIntegerFloatArithmetic&&typeof W!==typeof F)throw new Error("Cannot add different types of numbers.");return(0,q.s)(W)+(0,q.s)(F)}}(0,T.h)("FlowGraphAddBlock",y);class i extends Z.c{constructor(W){super((0,Y.F)(null===W||void 0===W?void 0:W.type),(0,Y.F)(null===W||void 0===W?void 0:W.type),(0,Y.F)(null===W||void 0===W?void 0:W.type),((W,F)=>this._polymorphicSubtract(W,F)),"FlowGraphSubtractBlock",W)}_polymorphicSubtract(W,F){const c=(0,q.l)(W),T=(0,q.l)(F);if((0,q.i)(c,T)||(0,q.e)(c,T)||(0,q.h)(c,T))return W.Bg(F);if("Quaternion"===c||"Vector4"===T)return new u.m(W.x,W.y,W.z,W.w).Ri(F);if("Vector4"===c||"Quaternion"===T)return W.Bg(F);var Y;if(null!==(Y=this.config)&&void 0!==Y&&Y.preventIntegerFloatArithmetic&&typeof W!==typeof F)throw new Error("Cannot add different types of numbers.");return(0,q.s)(W)-(0,q.s)(F)}}(0,T.h)("FlowGraphSubtractBlock",i);class e extends Z.c{constructor(W){super((0,Y.F)(null===W||void 0===W?void 0:W.type),(0,Y.F)(null===W||void 0===W?void 0:W.type),(0,Y.F)(null===W||void 0===W?void 0:W.type),((W,F)=>this._polymorphicMultiply(W,F)),"FlowGraphMultiplyBlock",W)}_polymorphicMultiply(W,F){const c=(0,q.l)(W),T=(0,q.l)(F);if((0,q.i)(c,T)||(0,q.e)(c,T))return W.multiply(F);if("Quaternion"===c||"Vector4"===T)return new u.m(W.x,W.y,W.z,W.w).multiplyInPlace(F);if("Vector4"===c||"Quaternion"===T)return W.multiply(F);if((0,q.h)(c,T)){var Y;if(null!==(Y=this.config)&&void 0!==Y&&Y.useMatrixPerComponent){const T=W.m;for(let W=0;W<T.length;W++)T[W]*=F.m[W];return"Matrix2D"===c?new N.b(T):"Matrix3D"===c?new N.f(T):u.b.mi(T)}return F.multiply(W)}var Z;if(null!==(Z=this.config)&&void 0!==Z&&Z.preventIntegerFloatArithmetic&&typeof W!==typeof F)throw new Error("Cannot add different types of numbers.");return(0,q.s)(W)*(0,q.s)(F)}}(0,T.h)("FlowGraphMultiplyBlock",e);class I extends Z.c{constructor(W){super((0,Y.F)(null===W||void 0===W?void 0:W.type),(0,Y.F)(null===W||void 0===W?void 0:W.type),(0,Y.F)(null===W||void 0===W?void 0:W.type),((W,F)=>this._polymorphicDivide(W,F)),"FlowGraphDivideBlock",W)}_polymorphicDivide(W,F){const c=(0,q.l)(W),T=(0,q.l)(F);if((0,q.i)(c,T)||(0,q.e)(c,T))return W.divide(F);if("Quaternion"===c||"Quaternion"===T){const c=W.clone();return c.x/=F.x,c.y/=F.y,c.z/=F.z,c.w/=F.w,c}if("Quaternion"===c||"Vector4"===T)return new u.m(W.x,W.y,W.z,W.w).divideInPlace(F);if("Vector4"===c||"Quaternion"===T)return W.divide(F);if((0,q.h)(c,T)){var Y;if(null!==(Y=this.config)&&void 0!==Y&&Y.useMatrixPerComponent){const T=W.m;for(let W=0;W<T.length;W++)T[W]/=F.m[W];return"Matrix2D"===c?new N.b(T):"Matrix3D"===c?new N.f(T):u.b.mi(T)}return W.divide(F)}var Z;if(null!==(Z=this.config)&&void 0!==Z&&Z.preventIntegerFloatArithmetic&&typeof W!==typeof F)throw new Error("Cannot add different types of numbers.");return(0,q.s)(W)/(0,q.s)(F)}}(0,T.h)("FlowGraphDivideBlock",I);class E extends A{constructor(W){super(Y.n,(W=>this._random(W)),"FlowGraphRandomBlock",W),this.min=this.registerDataInput("min",Y.n,(null===W||void 0===W?void 0:W.min)??0),this.max=this.registerDataInput("max",Y.n,(null===W||void 0===W?void 0:W.max)??1),null!==W&&void 0!==W&&W.seed&&(this._seed=W.seed)}_isSeed(){return void 0!==(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._seed)}_getRandomValue(){if(this._isSeed(this._seed)){const W=1e4*Math.sin(this._seed++);return W-Math.floor(W)}return Math.random()}_random(W){const F=this.min.getValue(W),c=this.max.getValue(W);return this._getRandomValue()*(c-F)+F}}(0,T.h)("FlowGraphRandomBlock",E);class O extends A{constructor(W){super(Y.n,(()=>Math.E),"FlowGraphEBlock",W)}}(0,T.h)("FlowGraphEBlock",O);class z extends A{constructor(W){super(Y.n,(()=>Math.PI),"FlowGraphPIBlock",W)}}(0,T.h)("FlowGraphPIBlock",z);class G extends A{constructor(W){super(Y.n,(()=>Number.POSITIVE_INFINITY),"FlowGraphInfBlock",W)}}(0,T.h)("FlowGraphInfBlock",G);class D extends A{constructor(W){super(Y.n,(()=>Number.NaN),"FlowGraphNaNBlock",W)}}function v(W,F){switch((0,q.l)(W)){case"FlowGraphInteger":return new j.c(F(W.value));case"Vector2":return new u.j(F(W.x),F(W.y));case"oi":return new u.l(F(W.x),F(W.y),F(W.z));case"Vector4":return new u.m(F(W.x),F(W.y),F(W.z),F(W.w));case"Quaternion":return new u.e(F(W.x),F(W.y),F(W.z),F(W.w));case"Matrix":return u.b.mi(W.m.map(F));case"Matrix2D":return new N.b(W.m.map(F));case"Matrix3D":return new N.f(W.m.map(F));default:return F(W)}}(0,T.h)("FlowGraphNaNBlock",D);class C extends s.b{constructor(W){super(Y.n,Y.n,(W=>this._polymorphicAbs(W)),"FlowGraphAbsBlock",W)}_polymorphicAbs(W){return v(W,Math.abs)}}(0,T.h)("FlowGraphAbsBlock",C);class n extends s.b{constructor(W){super(Y.n,Y.n,(W=>this._polymorphicSign(W)),"FlowGraphSignBlock",W)}_polymorphicSign(W){return v(W,Math.sign)}}(0,T.h)("FlowGraphSignBlock",n);class X extends s.b{constructor(W){super(Y.n,Y.n,(W=>this._polymorphicTrunc(W)),"FlowGraphTruncBlock",W)}_polymorphicTrunc(W){return v(W,Math.trunc)}}(0,T.h)("FlowGraphTruncBlock",X);class g extends s.b{constructor(W){super(Y.n,Y.n,(W=>this._polymorphicFloor(W)),"FlowGraphFloorBlock",W)}_polymorphicFloor(W){return v(W,Math.floor)}}(0,T.h)("FlowGraphFloorBlock",g);class S extends s.b{constructor(W){super(Y.c,Y.c,(W=>this._polymorphicCeiling(W)),"FlowGraphCeilBlock",W)}_polymorphicCeiling(W){return v(W,Math.ceil)}}(0,T.h)("FlowGraphCeilBlock",S);class U extends s.b{constructor(W){super(Y.c,Y.c,(W=>this._polymorphicRound(W)),"FlowGraphRoundBlock",W)}_polymorphicRound(W){return v(W,(W=>{var F;return W<0&&null!==(F=this.config)&&void 0!==F&&F.roundHalfAwayFromZero?-Math.round(-W):Math.round(W)}))}}(0,T.h)("FlowGraphRoundBlock",U);class o extends s.b{constructor(W){super(Y.c,Y.c,(W=>this._polymorphicFraction(W)),"FlowGraphFractBlock",W)}_polymorphicFraction(W){return v(W,(W=>W-Math.floor(W)))}}(0,T.h)("FlowGraphFractBlock",o);class K extends s.b{constructor(W){super(Y.c,Y.c,(W=>this._polymorphicNeg(W)),"FlowGraphNegationBlock",W)}_polymorphicNeg(W){return v(W,(W=>-W))}}function V(W,F,c){switch((0,q.l)(W)){case"FlowGraphInteger":return new j.c(c(W.value,F.value));case"Vector2":return new u.j(c(W.x,F.x),c(W.y,F.y));case"oi":return new u.l(c(W.x,F.x),c(W.y,F.y),c(W.z,F.z));case"Vector4":return new u.m(c(W.x,F.x),c(W.y,F.y),c(W.z,F.z),c(W.w,F.w));case"Quaternion":return new u.e(c(W.x,F.x),c(W.y,F.y),c(W.z,F.z),c(W.w,F.w));case"Matrix":return u.b.mi(W.m.map(((W,T)=>c(W,F.m[T]))));case"Matrix2D":return new N.b(W.m.map(((W,T)=>c(W,F.m[T]))));case"Matrix3D":return new N.f(W.m.map(((W,T)=>c(W,F.m[T]))));default:return c((0,q.s)(W),(0,q.s)(F))}}(0,T.h)("FlowGraphNegationBlock",K);class d extends Z.c{constructor(W){super(Y.c,Y.c,Y.c,((W,F)=>this._polymorphicRemainder(W,F)),"FlowGraphModuloBlock",W)}_polymorphicRemainder(W,F){return V(W,F,((W,F)=>W%F))}}(0,T.h)("FlowGraphModuloBlock",d);class L extends Z.c{constructor(W){super(Y.c,Y.c,Y.c,((W,F)=>this._polymorphicMin(W,F)),"FlowGraphMinBlock",W)}_polymorphicMin(W,F){return V(W,F,Math.min)}}(0,T.h)("FlowGraphMinBlock",L);class H extends Z.c{constructor(W){super(Y.c,Y.c,Y.c,((W,F)=>this._polymorphicMax(W,F)),"FlowGraphMaxBlock",W)}_polymorphicMax(W,F){return V(W,F,Math.max)}}function k(W,F,c){return Math.min(Math.max(W,Math.min(F,c)),Math.max(F,c))}function m(W,F,c,T){switch((0,q.l)(W)){case"FlowGraphInteger":return new j.c(T(W.value,F.value,c.value));case"Vector2":return new u.j(T(W.x,F.x,c.x),T(W.y,F.y,c.y));case"oi":return new u.l(T(W.x,F.x,c.x),T(W.y,F.y,c.y),T(W.z,F.z,c.z));case"Vector4":return new u.m(T(W.x,F.x,c.x),T(W.y,F.y,c.y),T(W.z,F.z,c.z),T(W.w,F.w,c.w));case"Quaternion":return new u.e(T(W.x,F.x,c.x),T(W.y,F.y,c.y),T(W.z,F.z,c.z),T(W.w,F.w,c.w));case"Matrix":return u.b.mi(W.m.map(((W,Y)=>T(W,F.m[Y],c.m[Y]))));case"Matrix2D":return new N.b(W.m.map(((W,Y)=>T(W,F.m[Y],c.m[Y]))));case"Matrix3D":return new N.f(W.m.map(((W,Y)=>T(W,F.m[Y],c.m[Y]))));default:return T((0,q.s)(W),(0,q.s)(F),(0,q.s)(c))}}(0,T.h)("FlowGraphMaxBlock",H);class r extends x{constructor(W){super(Y.c,Y.c,Y.c,Y.c,((W,F,c)=>this._polymorphicClamp(W,F,c)),"FlowGraphClampBlock",W)}_polymorphicClamp(W,F,c){return m(W,F,c,k)}}function b(W){return Math.min(Math.max(W,0),1)}(0,T.h)("FlowGraphClampBlock",r);class R extends s.b{constructor(W){super(Y.c,Y.c,(W=>this._polymorphicSaturate(W)),"FlowGraphSaturateBlock",W)}_polymorphicSaturate(W){return v(W,b)}}function f(W,F,c){return(1-c)*W+c*F}(0,T.h)("FlowGraphSaturateBlock",R);class P extends x{constructor(W){super(Y.c,Y.c,Y.c,Y.c,((W,F,c)=>this._polymorphicInterpolate(W,F,c)),"FlowGraphMathInterpolationBlock",W)}_polymorphicInterpolate(W,F,c){return m(W,F,c,f)}}(0,T.h)("FlowGraphMathInterpolationBlock",P);class p extends Z.c{constructor(W){super(Y.c,Y.c,Y.e,((W,F)=>this._polymorphicEq(W,F)),"FlowGraphEqualityBlock",W)}_polymorphicEq(W,F){const c=(0,q.l)(W),T=(0,q.l)(F);return typeof W===typeof F&&((0,q.i)(c,T)||(0,q.h)(c,T)||(0,q.e)(c,T)?W.equals(F):W===F)}}function t(W,F,c){if((0,q.u)(W)&&(0,q.u)(F))return c((0,q.s)(W),(0,q.s)(F));throw new Error(`Cannot compare ${W} and ${F}`)}(0,T.h)("FlowGraphEqualityBlock",p);class M extends Z.c{constructor(W){super(Y.c,Y.c,Y.e,((W,F)=>this._polymorphicLessThan(W,F)),"FlowGraphLessThanBlock",W)}_polymorphicLessThan(W,F){return t(W,F,((W,F)=>W<F))}}(0,T.h)("FlowGraphLessThanBlock",M);class Q extends Z.c{constructor(W){super(Y.c,Y.c,Y.e,((W,F)=>this._polymorphicLessThanOrEqual(W,F)),"FlowGraphLessThanOrEqualBlock",W)}_polymorphicLessThanOrEqual(W,F){return t(W,F,((W,F)=>W<=F))}}(0,T.h)("FlowGraphLessThanOrEqualBlock",Q);class J extends Z.c{constructor(W){super(Y.c,Y.c,Y.e,((W,F)=>this._polymorphicGreaterThan(W,F)),"FlowGraphGreaterThanBlock",W)}_polymorphicGreaterThan(W,F){return t(W,F,((W,F)=>W>F))}}(0,T.h)("FlowGraphGreaterThanBlock",J);class B extends Z.c{constructor(W){super(Y.c,Y.c,Y.e,((W,F)=>this._polymorphicGreaterThanOrEqual(W,F)),"FlowGraphGreaterThanOrEqualBlock",W)}_polymorphicGreaterThanOrEqual(W,F){return t(W,F,((W,F)=>W>=F))}}(0,T.h)("FlowGraphGreaterThanOrEqualBlock",B);class a extends s.b{constructor(W){super(Y.c,Y.e,(W=>this._polymorphicIsNan(W)),"FlowGraphIsNaNBlock",W)}_polymorphicIsNan(W){if((0,q.u)(W,!0))return isNaN((0,q.s)(W));throw new Error(`Cannot get NaN of ${W}`)}}(0,T.h)("FlowGraphIsNaNBlock",a);class l extends s.b{constructor(W){super(Y.c,Y.e,(W=>this._polymorphicIsInf(W)),"FlowGraphIsInfBlock",W)}_polymorphicIsInf(W){if((0,q.u)(W))return!isFinite((0,q.s)(W));throw new Error(`Cannot get isInf of ${W}`)}}(0,T.h)("FlowGraphIsInfBlock",l);class h extends s.b{constructor(W){super(Y.c,Y.c,(W=>this._polymorphicDegToRad(W)),"FlowGraphDegToRadBlock",W)}_degToRad(W){return W*Math.PI/180}_polymorphicDegToRad(W){return v(W,this._degToRad)}}(0,T.h)("FlowGraphDegToRadBlock",h);class WW extends s.b{constructor(W){super(Y.c,Y.c,(W=>this._polymorphicRadToDeg(W)),"FlowGraphRadToDegBlock",W)}_radToDeg(W){return 180*W/Math.PI}_polymorphicRadToDeg(W){return v(W,this._radToDeg)}}(0,T.h)("FlowGraphRadToDegBlock",WW);class FW extends s.b{constructor(W){super(Y.n,Y.n,(W=>this._polymorphicSin(W)),"FlowGraphSinBlock",W)}_polymorphicSin(W){return v(W,Math.sin)}}class cW extends s.b{constructor(W){super(Y.n,Y.n,(W=>this._polymorphicCos(W)),"FlowGraphCosBlock",W)}_polymorphicCos(W){return v(W,Math.cos)}}class TW extends s.b{constructor(W){super(Y.n,Y.n,(W=>this._polymorphicTan(W)),"FlowGraphTanBlock",W)}_polymorphicTan(W){return v(W,Math.tan)}}class YW extends s.b{constructor(W){super(Y.n,Y.n,(W=>this._polymorphicAsin(W)),"FlowGraphASinBlock",W)}_polymorphicAsin(W){return v(W,Math.asin)}}(0,T.h)("FlowGraphASinBlock",YW);class ZW extends s.b{constructor(W){super(Y.n,Y.n,(W=>this._polymorphicAcos(W)),"FlowGraphACosBlock",W)}_polymorphicAcos(W){return v(W,Math.acos)}}(0,T.h)("FlowGraphACosBlock",ZW);class wW extends s.b{constructor(W){super(Y.n,Y.n,(W=>this._polymorphicAtan(W)),"FlowGraphATanBlock",W)}_polymorphicAtan(W){return v(W,Math.atan)}}(0,T.h)("FlowGraphATanBlock",wW);class AW extends Z.c{constructor(W){super(Y.c,Y.c,Y.c,((W,F)=>this._polymorphicAtan2(W,F)),"FlowGraphATan2Block",W)}_polymorphicAtan2(W,F){return V(W,F,Math.atan2)}}(0,T.h)("FlowGraphATan2Block",AW);class uW extends s.b{constructor(W){super(Y.c,Y.c,(W=>this._polymorphicSinh(W)),"FlowGraphSinhBlock",W)}_polymorphicSinh(W){return v(W,Math.sinh)}}(0,T.h)("FlowGraphSinhBlock",uW);class sW extends s.b{constructor(W){super(Y.c,Y.c,(W=>this._polymorphicCosh(W)),"FlowGraphCoshBlock",W)}_polymorphicCosh(W){return v(W,Math.cosh)}}(0,T.h)("FlowGraphCoshBlock",sW);class xW extends s.b{constructor(W){super(Y.c,Y.c,(W=>this._polymorphicTanh(W)),"FlowGraphTanhBlock",W)}_polymorphicTanh(W){return v(W,Math.tanh)}}(0,T.h)("FlowGraphTanhBlock",xW);class jW extends s.b{constructor(W){super(Y.c,Y.n,(W=>this._polymorphicAsinh(W)),"FlowGraphASinhBlock",W)}_polymorphicAsinh(W){return v(W,Math.asinh)}}(0,T.h)("FlowGraphASinhBlock",jW);class NW extends s.b{constructor(W){super(Y.c,Y.n,(W=>this._polymorphicAcosh(W)),"FlowGraphACoshBlock",W)}_polymorphicAcosh(W){return v(W,Math.acosh)}}(0,T.h)("FlowGraphACoshBlock",NW);class qW extends s.b{constructor(W){super(Y.c,Y.n,(W=>this._polymorphicAtanh(W)),"FlowGraphATanhBlock",W)}_polymorphicAtanh(W){return v(W,Math.atanh)}}(0,T.h)("FlowGraphATanhBlock",qW);class yW extends s.b{constructor(W){super(Y.c,Y.n,(W=>this._polymorphicExp(W)),"FlowGraphExponentialBlock",W)}_polymorphicExp(W){return v(W,Math.exp)}}(0,T.h)("FlowGraphExponentialBlock",yW);class iW extends s.b{constructor(W){super(Y.c,Y.n,(W=>this._polymorphicLog(W)),"FlowGraphLogBlock",W)}_polymorphicLog(W){return v(W,Math.log)}}(0,T.h)("FlowGraphLogBlock",iW);class eW extends s.b{constructor(W){super(Y.c,Y.n,(W=>this._polymorphicLog2(W)),"FlowGraphLog2Block",W)}_polymorphicLog2(W){return v(W,Math.log2)}}(0,T.h)("FlowGraphLog2Block",eW);class IW extends s.b{constructor(W){super(Y.c,Y.n,(W=>this._polymorphicLog10(W)),"FlowGraphLog10Block",W)}_polymorphicLog10(W){return v(W,Math.log10)}}(0,T.h)("FlowGraphLog10Block",IW);class EW extends s.b{constructor(W){super(Y.c,Y.n,(W=>this._polymorphicSqrt(W)),"FlowGraphSquareRootBlock",W)}_polymorphicSqrt(W){return v(W,Math.sqrt)}}(0,T.h)("FlowGraphSquareRootBlock",EW);class OW extends s.b{constructor(W){super(Y.c,Y.n,(W=>this._polymorphicCubeRoot(W)),"FlowGraphCubeRootBlock",W)}_polymorphicCubeRoot(W){return v(W,Math.cbrt)}}(0,T.h)("FlowGraphCubeRootBlock",OW);class zW extends Z.c{constructor(W){super(Y.c,Y.n,Y.n,((W,F)=>this._polymorphicPow(W,F)),"FlowGraphPowerBlock",W)}_polymorphicPow(W,F){return V(W,F,Math.pow)}}(0,T.h)("FlowGraphPowerBlock",zW);class GW extends s.b{constructor(W){super((0,Y.F)((null===W||void 0===W?void 0:W.valueType)||"FlowGraphInteger"),(0,Y.F)((null===W||void 0===W?void 0:W.valueType)||"FlowGraphInteger"),(W=>"boolean"===typeof W?!W:"number"===typeof W?~W:new j.c(~W.value)),"FlowGraphBitwiseNotBlock",W)}}(0,T.h)("FlowGraphBitwiseNotBlock",GW);class DW extends Z.c{constructor(W){super((0,Y.F)((null===W||void 0===W?void 0:W.valueType)||"FlowGraphInteger"),(0,Y.F)((null===W||void 0===W?void 0:W.valueType)||"FlowGraphInteger"),(0,Y.F)((null===W||void 0===W?void 0:W.valueType)||"FlowGraphInteger"),((W,F)=>{if("boolean"===typeof W&&"boolean"===typeof F)return W&&F;if("number"===typeof W&&"number"===typeof F)return W&F;if("object"===typeof W&&"object"===typeof F)return new j.c(W.value&F.value);throw new Error(`Cannot perform bitwise AND on ${W} and ${F}`)}),"FlowGraphBitwiseAndBlock",W)}}(0,T.h)("FlowGraphBitwiseAndBlock",DW);class vW extends Z.c{constructor(W){super((0,Y.F)((null===W||void 0===W?void 0:W.valueType)||"FlowGraphInteger"),(0,Y.F)((null===W||void 0===W?void 0:W.valueType)||"FlowGraphInteger"),(0,Y.F)((null===W||void 0===W?void 0:W.valueType)||"FlowGraphInteger"),((W,F)=>{if("boolean"===typeof W&&"boolean"===typeof F)return W||F;if("number"===typeof W&&"number"===typeof F)return W|F;if("object"===typeof W&&"object"===typeof F)return new j.c(W.value|F.value);throw new Error(`Cannot perform bitwise OR on ${W} and ${F}`)}),"FlowGraphBitwiseOrBlock",W)}}(0,T.h)("FlowGraphBitwiseOrBlock",vW);class CW extends Z.c{constructor(W){super((0,Y.F)((null===W||void 0===W?void 0:W.valueType)||"FlowGraphInteger"),(0,Y.F)((null===W||void 0===W?void 0:W.valueType)||"FlowGraphInteger"),(0,Y.F)((null===W||void 0===W?void 0:W.valueType)||"FlowGraphInteger"),((W,F)=>{if("boolean"===typeof W&&"boolean"===typeof F)return W!==F;if("number"===typeof W&&"number"===typeof F)return W^F;if("object"===typeof W&&"object"===typeof F)return new j.c(W.value^F.value);throw new Error(`Cannot perform bitwise XOR on ${W} and ${F}`)}),"FlowGraphBitwiseXorBlock",W)}}(0,T.h)("FlowGraphBitwiseXorBlock",CW);class nW extends Z.c{constructor(W){super(Y.f,Y.f,Y.f,((W,F)=>new j.c(W.value<<F.value)),"FlowGraphBitwiseLeftShiftBlock",W)}}(0,T.h)("FlowGraphBitwiseLeftShiftBlock",nW);class XW extends Z.c{constructor(W){super(Y.f,Y.f,Y.f,((W,F)=>new j.c(W.value>>F.value)),"FlowGraphBitwiseRightShiftBlock",W)}}(0,T.h)("FlowGraphBitwiseRightShiftBlock",XW);class gW extends s.b{constructor(W){super(Y.f,Y.f,(W=>new j.c(Math.clz32(W.value))),"FlowGraphLeadingZerosBlock",W)}}(0,T.h)("FlowGraphLeadingZerosBlock",gW);class SW extends s.b{constructor(W){super(Y.f,Y.f,(W=>new j.c(W.value?31-Math.clz32(W.value&-W.value):32)),"FlowGraphTrailingZerosBlock",W)}}(0,T.h)("FlowGraphTrailingZerosBlock",SW);class UW extends s.b{constructor(W){super(Y.f,Y.f,(W=>new j.c(function(W){let F=0;for(;W;)F+=1&W,W>>=1;return F}(W.value))),"FlowGraphOneBitsCounterBlock",W)}}(0,T.h)("FlowGraphOneBitsCounterBlock",UW)},13763:(W,F,c)=>{c.d(F,{c:()=>Y});var T=c(13768);class Y extends T.d{constructor(W,F,c,T,Y,Z){super(c,Z),this._operation=T,this._className=Y,this.a=this.registerDataInput("a",W),this.b=this.registerDataInput("b",F)}_doOperation(W){const F=this.a.getValue(W),c=this.b.getValue(W);return this._operation(F,c)}getClassName(){return this._className}}},13768:(W,F,c)=>{c.d(F,{d:()=>A});var T=c(12543),Y=c(12517);const Z="cachedOperationValue",w="cachedExecutionId";class A extends T.d{constructor(W,F){super(F),this.value=this.registerDataOutput("value",W),this.isValid=this.registerDataOutput("isValid",Y.e)}_updateOutputs(W){const F=W._getExecutionVariable(this,w,-1),c=W._getExecutionVariable(this,Z,null);if(void 0!==c&&null!==c&&F===W.executionId)this.isValid.setValue(!0,W),this.value.setValue(c,W);else try{const F=this._doOperation(W);if(void 0===F||null===F)return void this.isValid.setValue(!1,W);W._setExecutionVariable(this,Z,F),W._setExecutionVariable(this,w,W.executionId),this.value.setValue(F,W),this.isValid.setValue(!0,W)}catch(T){this.isValid.setValue(!1,W)}}}},13772:(W,F,c)=>{c.d(F,{b:()=>Y});var T=c(13768);class Y extends T.d{constructor(W,F,c,T,Y){super(F,Y),this._operation=c,this._className=T,this.a=this.registerDataInput("a",W)}_doOperation(W){return this._operation(this.a.getValue(W))}getClassName(){return this._className}}}}]);