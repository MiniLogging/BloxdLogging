"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[63],{14102:(t,q,S)=>{S.r(q),S.d(q,{FlowGraphPlayAnimationBlock:()=>r});var o=S(12974),B=S(12927),z=S(622),L=S(14100);class r extends o.b{constructor(t){super(t,["animationLoop","animationEnd","animationGroupLoop"]),this.config=t,this.speed=this.registerDataInput("speed",B.v),this.loop=this.registerDataInput("loop",B.f),this.from=this.registerDataInput("from",B.v,0),this.to=this.registerDataInput("to",B.v),this.currentFrame=this.registerDataOutput("currentFrame",B.v),this.currentTime=this.registerDataOutput("currentTime",B.v),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",B.b),this.animationGroup=this.registerDataInput("animationGroup",B.b,null===t||void 0===t?void 0:t.animationGroup),this.animation=this.registerDataInput("animation",B.b),this.object=this.registerDataInput("object",B.b)}_preparePendingTasks(t){const q=this.animationGroup.getValue(t),S=this.animation.getValue(t);if(!q&&!S)return this._reportError(t,"No animation or animation group provided");{const B=this.currentAnimationGroup.getValue(t);B&&B!==q&&B.dispose();let z=q;if(S&&!z){const q=this.object.getValue(t);if(!q)return this._reportError(t,"No target object provided");const o=Array.isArray(S)?S:[S],B=o[0].name;z=new L.AnimationGroup("flowGraphAnimationGroup-"+B+"-"+q.name,t.configuration.Tk);let r=!1;const e=t._getGlobalContextVariable("interpolationAnimations",[]);for(const t of o)z.addTargetedAnimation(t,q),-1!==e.indexOf(t.uniqueId)&&(r=!0);r&&this._checkInterpolationDuplications(t,o,q)}const r=this.speed.getValue(t)||1,e=this.from.getValue(t)??0,C=this.to.getValue(t)||z.to,Z=!isFinite(C)||this.loop.getValue(t);this.currentAnimationGroup.setValue(z,t);const b=t._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==b.indexOf(z.uniqueId)&&z.stop();try{z.start(Z,r,e,C),z.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(t))),z.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(t))),z.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(t))),z.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(t))),b.push(z.uniqueId),t._setGlobalContextVariable("currentlyRunningAnimationGroups",b)}catch(o){this._reportError(t,o)}}}_reportError(t,q){super._reportError(t,q),this.currentFrame.setValue(-1,t),this.currentTime.setValue(-1,t)}_executeOnTick(t){const q=this.currentAnimationGroup.getValue(t);var S;q&&(this.currentFrame.setValue(q.getCurrentFrame(),t),this.currentTime.setValue((null===(S=q.animatables[0])||void 0===S?void 0:S.elapsedTime)??0,t))}_execute(t){this._startPendingTasks(t)}_onAnimationGroupEnd(t){this._removeFromCurrentlyRunning(t,this.currentAnimationGroup.getValue(t)),this._resetAfterCanceled(t),this.done._activateSignal(t)}_checkInterpolationDuplications(t,q,S){const o=t._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const B of o){const o=t.assetsContext.animationGroups.find((t=>t.uniqueId===B));if(o)for(const B of o.targetedAnimations)for(const z of q)B.animation.targetProperty===z.targetProperty&&B.target===S&&this._stopAnimationGroup(t,o)}}_stopAnimationGroup(t,q){q.stop(!0),q.dispose(),this._removeFromCurrentlyRunning(t,q)}_removeFromCurrentlyRunning(t,q){const S=t._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),o=S.indexOf(q.uniqueId);-1!==o&&(S.splice(o,1),t._setGlobalContextVariable("currentlyRunningAnimationGroups",S))}_cancelPendingTasks(t){const q=this.currentAnimationGroup.getValue(t);q&&this._stopAnimationGroup(t,q)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,z.c)("FlowGraphPlayAnimationBlock",r)}}]);