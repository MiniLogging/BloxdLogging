"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[63],{14250:(Q,X,C)=>{C.r(X),C.d(X,{FlowGraphPlayAnimationBlock:()=>O});var l=C(13111),h=C(13063),M=C(620),f=C(14242);class O extends l.c{constructor(Q){super(Q,["animationLoop","animationEnd","animationGroupLoop"]),this.config=Q,this.speed=this.registerDataInput("speed",h.p),this.loop=this.registerDataInput("loop",h.e),this.from=this.registerDataInput("from",h.p,0),this.to=this.registerDataInput("to",h.p),this.currentFrame=this.registerDataOutput("currentFrame",h.p),this.currentTime=this.registerDataOutput("currentTime",h.p),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",h.d),this.animationGroup=this.registerDataInput("animationGroup",h.d,null===Q||void 0===Q?void 0:Q.animationGroup),this.animation=this.registerDataInput("animation",h.d),this.object=this.registerDataInput("object",h.d)}_preparePendingTasks(Q){const X=this.animationGroup.getValue(Q),C=this.animation.getValue(Q);if(!X&&!C)return this._reportError(Q,"No animation or animation group provided");{const h=this.currentAnimationGroup.getValue(Q);h&&h!==X&&h.dispose();let M=X;if(C&&!M){const X=this.object.getValue(Q);if(!X)return this._reportError(Q,"No target object provided");const l=Array.isArray(C)?C:[C],h=l[0].name;M=new f.AnimationGroup("flowGraphAnimationGroup-"+h+"-"+X.name,Q.configuration.ld);let O=!1;const m=Q._getGlobalContextVariable("interpolationAnimations",[]);for(const Q of l)M.addTargetedAnimation(Q,X),-1!==m.indexOf(Q.uniqueId)&&(O=!0);O&&this._checkInterpolationDuplications(Q,l,X)}const O=this.speed.getValue(Q)||1,m=this.from.getValue(Q)??0,W=this.to.getValue(Q)||M.to,U=!isFinite(W)||this.loop.getValue(Q);this.currentAnimationGroup.setValue(M,Q);const L=Q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==L.indexOf(M.uniqueId)&&M.stop();try{M.start(U,O,m,W),M.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(Q))),M.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(Q))),M.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(Q))),M.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(Q))),L.push(M.uniqueId),Q._setGlobalContextVariable("currentlyRunningAnimationGroups",L)}catch(l){this._reportError(Q,l)}}}_reportError(Q,X){super._reportError(Q,X),this.currentFrame.setValue(-1,Q),this.currentTime.setValue(-1,Q)}_executeOnTick(Q){const X=this.currentAnimationGroup.getValue(Q);var C;X&&(this.currentFrame.setValue(X.getCurrentFrame(),Q),this.currentTime.setValue((null===(C=X.animatables[0])||void 0===C?void 0:C.elapsedTime)??0,Q))}_execute(Q){this._startPendingTasks(Q)}_onAnimationGroupEnd(Q){this._removeFromCurrentlyRunning(Q,this.currentAnimationGroup.getValue(Q)),this._resetAfterCanceled(Q),this.done._activateSignal(Q)}_checkInterpolationDuplications(Q,X,C){const l=Q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const h of l){const l=Q.assetsContext.animationGroups.find((Q=>Q.uniqueId===h));if(l)for(const h of l.targetedAnimations)for(const M of X)h.animation.targetProperty===M.targetProperty&&h.target===C&&this._stopAnimationGroup(Q,l)}}_stopAnimationGroup(Q,X){X.stop(!0),X.dispose(),this._removeFromCurrentlyRunning(Q,X)}_removeFromCurrentlyRunning(Q,X){const C=Q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),l=C.indexOf(X.uniqueId);-1!==l&&(C.splice(l,1),Q._setGlobalContextVariable("currentlyRunningAnimationGroups",C))}_cancelPendingTasks(Q){const X=this.currentAnimationGroup.getValue(Q);X&&this._stopAnimationGroup(Q,X)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,M.g)("FlowGraphPlayAnimationBlock",O)}}]);