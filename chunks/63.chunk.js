"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[63],{13923:(U,W,l)=>{l.r(W),l.d(W,{FlowGraphPlayAnimationBlock:()=>B});var M=l(12761),t=l(12704),L=l(655),p=l(13914);class B extends M.b{constructor(U){super(U,["animationLoop","animationEnd","animationGroupLoop"]),this.config=U,this.speed=this.registerDataInput("speed",t.s),this.loop=this.registerDataInput("loop",t.h),this.from=this.registerDataInput("from",t.s,0),this.to=this.registerDataInput("to",t.s),this.currentFrame=this.registerDataOutput("currentFrame",t.s),this.currentTime=this.registerDataOutput("currentTime",t.s),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",t.d),this.animationGroup=this.registerDataInput("animationGroup",t.d,null===U||void 0===U?void 0:U.animationGroup),this.animation=this.registerDataInput("animation",t.d),this.object=this.registerDataInput("object",t.d)}_preparePendingTasks(U){const W=this.animationGroup.getValue(U),l=this.animation.getValue(U);if(!W&&!l)return this._reportError(U,"No animation or animation group provided");{const t=this.currentAnimationGroup.getValue(U);t&&t!==W&&t.dispose();let L=W;if(l&&!L){const W=this.object.getValue(U);if(!W)return this._reportError(U,"No target object provided");const M=Array.isArray(l)?l:[l],t=M[0].name;L=new p.AnimationGroup("flowGraphAnimationGroup-"+t+"-"+W.name,U.configuration.Gd);let B=!1;const k=U._getGlobalContextVariable("interpolationAnimations",[]);for(const U of M)L.addTargetedAnimation(U,W),-1!==k.indexOf(U.uniqueId)&&(B=!0);B&&this._checkInterpolationDuplications(U,M,W)}const B=this.speed.getValue(U)||1,k=this.from.getValue(U)??0,A=this.to.getValue(U)||L.to,q=!isFinite(A)||this.loop.getValue(U);this.currentAnimationGroup.setValue(L,U);const y=U._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==y.indexOf(L.uniqueId)&&L.stop();try{L.start(q,B,k,A),L.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(U))),L.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(U))),L.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(U))),L.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(U))),y.push(L.uniqueId),U._setGlobalContextVariable("currentlyRunningAnimationGroups",y)}catch(M){this._reportError(U,M)}}}_reportError(U,W){super._reportError(U,W),this.currentFrame.setValue(-1,U),this.currentTime.setValue(-1,U)}_executeOnTick(U){const W=this.currentAnimationGroup.getValue(U);var l;W&&(this.currentFrame.setValue(W.getCurrentFrame(),U),this.currentTime.setValue((null===(l=W.animatables[0])||void 0===l?void 0:l.elapsedTime)??0,U))}_execute(U){this._startPendingTasks(U)}_onAnimationGroupEnd(U){this._removeFromCurrentlyRunning(U,this.currentAnimationGroup.getValue(U)),this._resetAfterCanceled(U),this.done._activateSignal(U)}_checkInterpolationDuplications(U,W,l){const M=U._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const t of M){const M=U.assetsContext.animationGroups.find((U=>U.uniqueId===t));if(M)for(const t of M.targetedAnimations)for(const L of W)t.animation.targetProperty===L.targetProperty&&t.target===l&&this._stopAnimationGroup(U,M)}}_stopAnimationGroup(U,W){W.stop(!0),W.dispose(),this._removeFromCurrentlyRunning(U,W)}_removeFromCurrentlyRunning(U,W){const l=U._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),M=l.indexOf(W.uniqueId);-1!==M&&(l.splice(M,1),U._setGlobalContextVariable("currentlyRunningAnimationGroups",l))}_cancelPendingTasks(U){const W=this.currentAnimationGroup.getValue(U);W&&this._stopAnimationGroup(U,W)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,L.f)("FlowGraphPlayAnimationBlock",B)}}]);