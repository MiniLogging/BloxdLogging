"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[63],{14147:(v,d,Q)=>{Q.r(d),Q.d(d,{FlowGraphPlayAnimationBlock:()=>F});var n=Q(12962),T=Q(12908),L=Q(591),e=Q(14138);class F extends n.b{constructor(v){super(v,["animationLoop","animationEnd","animationGroupLoop"]),this.config=v,this.speed=this.registerDataInput("speed",T.u),this.loop=this.registerDataInput("loop",T.f),this.from=this.registerDataInput("from",T.u,0),this.to=this.registerDataInput("to",T.u),this.currentFrame=this.registerDataOutput("currentFrame",T.u),this.currentTime=this.registerDataOutput("currentTime",T.u),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",T.c),this.animationGroup=this.registerDataInput("animationGroup",T.c,null===v||void 0===v?void 0:v.animationGroup),this.animation=this.registerDataInput("animation",T.c),this.object=this.registerDataInput("object",T.c)}_preparePendingTasks(v){const d=this.animationGroup.getValue(v),Q=this.animation.getValue(v);if(!d&&!Q)return this._reportError(v,"No animation or animation group provided");{const T=this.currentAnimationGroup.getValue(v);T&&T!==d&&T.dispose();let L=d;if(Q&&!L){const d=this.object.getValue(v);if(!d)return this._reportError(v,"No target object provided");const n=Array.isArray(Q)?Q:[Q],T=n[0].name;L=new e.AnimationGroup("flowGraphAnimationGroup-"+T+"-"+d.name,v.configuration.yd);let F=!1;const r=v._getGlobalContextVariable("interpolationAnimations",[]);for(const v of n)L.addTargetedAnimation(v,d),-1!==r.indexOf(v.uniqueId)&&(F=!0);F&&this._checkInterpolationDuplications(v,n,d)}const F=this.speed.getValue(v)||1,r=this.from.getValue(v)??0,C=this.to.getValue(v)||L.to,u=!isFinite(C)||this.loop.getValue(v);this.currentAnimationGroup.setValue(L,v);const y=v._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==y.indexOf(L.uniqueId)&&L.stop();try{L.start(u,F,r,C),L.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(v))),L.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(v))),L.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(v))),L.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(v))),y.push(L.uniqueId),v._setGlobalContextVariable("currentlyRunningAnimationGroups",y)}catch(n){this._reportError(v,n)}}}_reportError(v,d){super._reportError(v,d),this.currentFrame.setValue(-1,v),this.currentTime.setValue(-1,v)}_executeOnTick(v){const d=this.currentAnimationGroup.getValue(v);var Q;d&&(this.currentFrame.setValue(d.getCurrentFrame(),v),this.currentTime.setValue((null===(Q=d.animatables[0])||void 0===Q?void 0:Q.elapsedTime)??0,v))}_execute(v){this._startPendingTasks(v)}_onAnimationGroupEnd(v){this._removeFromCurrentlyRunning(v,this.currentAnimationGroup.getValue(v)),this._resetAfterCanceled(v),this.done._activateSignal(v)}_checkInterpolationDuplications(v,d,Q){const n=v._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const T of n){const n=v.assetsContext.animationGroups.find((v=>v.uniqueId===T));if(n)for(const T of n.targetedAnimations)for(const L of d)T.animation.targetProperty===L.targetProperty&&T.target===Q&&this._stopAnimationGroup(v,n)}}_stopAnimationGroup(v,d){d.stop(!0),d.dispose(),this._removeFromCurrentlyRunning(v,d)}_removeFromCurrentlyRunning(v,d){const Q=v._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),n=Q.indexOf(d.uniqueId);-1!==n&&(Q.splice(n,1),v._setGlobalContextVariable("currentlyRunningAnimationGroups",Q))}_cancelPendingTasks(v){const d=this.currentAnimationGroup.getValue(v);d&&this._stopAnimationGroup(v,d)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,L.f)("FlowGraphPlayAnimationBlock",F)}}]);