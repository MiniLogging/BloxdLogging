"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[63],{14415:(R,x,H)=>{H.r(x),H.d(x,{FlowGraphPlayAnimationBlock:()=>D});var k=H(13299),c=H(13246),t=H(610),A=H(14406);class D extends k.b{constructor(R){super(R,["animationLoop","animationEnd","animationGroupLoop"]),this.config=R,this.speed=this.registerDataInput("speed",c.m),this.loop=this.registerDataInput("loop",c.c),this.from=this.registerDataInput("from",c.m,0),this.to=this.registerDataInput("to",c.m),this.currentFrame=this.registerDataOutput("currentFrame",c.m),this.currentTime=this.registerDataOutput("currentTime",c.m),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",c.b),this.animationGroup=this.registerDataInput("animationGroup",c.b,null===R||void 0===R?void 0:R.animationGroup),this.animation=this.registerDataInput("animation",c.b),this.object=this.registerDataInput("object",c.b)}_preparePendingTasks(R){const x=this.animationGroup.getValue(R),H=this.animation.getValue(R);if(!x&&!H)return this._reportError(R,"No animation or animation group provided");{const c=this.currentAnimationGroup.getValue(R);c&&c!==x&&c.dispose();let t=x;if(H&&!t){const x=this.object.getValue(R);if(!x)return this._reportError(R,"No target object provided");const k=Array.isArray(H)?H:[H],c=k[0].name;t=new A.AnimationGroup("flowGraphAnimationGroup-"+c+"-"+x.name,R.configuration.Yk);let D=!1;const U=R._getGlobalContextVariable("interpolationAnimations",[]);for(const R of k)t.addTargetedAnimation(R,x),-1!==U.indexOf(R.uniqueId)&&(D=!0);D&&this._checkInterpolationDuplications(R,k,x)}const D=this.speed.getValue(R)||1,U=this.from.getValue(R)??0,J=this.to.getValue(R)||t.to,V=!isFinite(J)||this.loop.getValue(R);this.currentAnimationGroup.setValue(t,R);const n=R._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==n.indexOf(t.uniqueId)&&t.stop();try{t.start(V,D,U,J),t.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(R))),t.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(R))),t.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(R))),t.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(R))),n.push(t.uniqueId),R._setGlobalContextVariable("currentlyRunningAnimationGroups",n)}catch(k){this._reportError(R,k)}}}_reportError(R,x){super._reportError(R,x),this.currentFrame.setValue(-1,R),this.currentTime.setValue(-1,R)}_executeOnTick(R){const x=this.currentAnimationGroup.getValue(R);var H;x&&(this.currentFrame.setValue(x.getCurrentFrame(),R),this.currentTime.setValue((null===(H=x.animatables[0])||void 0===H?void 0:H.elapsedTime)??0,R))}_execute(R){this._startPendingTasks(R)}_onAnimationGroupEnd(R){this._removeFromCurrentlyRunning(R,this.currentAnimationGroup.getValue(R)),this._resetAfterCanceled(R),this.done._activateSignal(R)}_checkInterpolationDuplications(R,x,H){const k=R._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const c of k){const k=R.assetsContext.animationGroups.find((R=>R.uniqueId===c));if(k)for(const c of k.targetedAnimations)for(const t of x)c.animation.targetProperty===t.targetProperty&&c.target===H&&this._stopAnimationGroup(R,k)}}_stopAnimationGroup(R,x){x.stop(!0),x.dispose(),this._removeFromCurrentlyRunning(R,x)}_removeFromCurrentlyRunning(R,x){const H=R._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),k=H.indexOf(x.uniqueId);-1!==k&&(H.splice(k,1),R._setGlobalContextVariable("currentlyRunningAnimationGroups",H))}_cancelPendingTasks(R){const x=this.currentAnimationGroup.getValue(R);x&&this._stopAnimationGroup(R,x)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,t.h)("FlowGraphPlayAnimationBlock",D)}}]);