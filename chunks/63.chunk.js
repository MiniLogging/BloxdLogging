"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[63],{13711:(L,j,P)=>{P.r(j),P.d(j,{FlowGraphPlayAnimationBlock:()=>u});var A=P(12546),R=P(12510),o=P(606),Y=P(13709);class u extends A.b{constructor(L){super(L,["animationLoop","animationEnd","animationGroupLoop"]),this.config=L,this.speed=this.registerDataInput("speed",R.p),this.loop=this.registerDataInput("loop",R.e),this.from=this.registerDataInput("from",R.p,0),this.to=this.registerDataInput("to",R.p),this.currentFrame=this.registerDataOutput("currentFrame",R.p),this.currentTime=this.registerDataOutput("currentTime",R.p),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",R.d),this.animationGroup=this.registerDataInput("animationGroup",R.d,null===L||void 0===L?void 0:L.animationGroup),this.animation=this.registerDataInput("animation",R.d),this.object=this.registerDataInput("object",R.d)}_preparePendingTasks(L){const j=this.animationGroup.getValue(L),P=this.animation.getValue(L);if(!j&&!P)return this._reportError(L,"No animation or animation group provided");{const R=this.currentAnimationGroup.getValue(L);R&&R!==j&&R.dispose();let o=j;if(P&&!o){const j=this.object.getValue(L);if(!j)return this._reportError(L,"No target object provided");const A=Array.isArray(P)?P:[P],R=A[0].name;o=new Y.AnimationGroup("flowGraphAnimationGroup-"+R+"-"+j.name,L.configuration.Rk);let u=!1;const a=L._getGlobalContextVariable("interpolationAnimations",[]);for(const L of A)o.addTargetedAnimation(L,j),-1!==a.indexOf(L.uniqueId)&&(u=!0);u&&this._checkInterpolationDuplications(L,A,j)}const u=this.speed.getValue(L)||1,a=this.from.getValue(L)??0,D=this.to.getValue(L)||o.to,S=!isFinite(D)||this.loop.getValue(L);this.currentAnimationGroup.setValue(o,L);const g=L._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==g.indexOf(o.uniqueId)&&o.stop();try{o.start(S,u,a,D),o.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(L))),o.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(L))),o.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(L))),o.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(L))),g.push(o.uniqueId),L._setGlobalContextVariable("currentlyRunningAnimationGroups",g)}catch(A){this._reportError(L,A)}}}_reportError(L,j){super._reportError(L,j),this.currentFrame.setValue(-1,L),this.currentTime.setValue(-1,L)}_executeOnTick(L){const j=this.currentAnimationGroup.getValue(L);var P;j&&(this.currentFrame.setValue(j.getCurrentFrame(),L),this.currentTime.setValue((null===(P=j.animatables[0])||void 0===P?void 0:P.elapsedTime)??0,L))}_execute(L){this._startPendingTasks(L)}_onAnimationGroupEnd(L){this._removeFromCurrentlyRunning(L,this.currentAnimationGroup.getValue(L)),this._resetAfterCanceled(L),this.done._activateSignal(L)}_checkInterpolationDuplications(L,j,P){const A=L._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const R of A){const A=L.assetsContext.animationGroups.find((L=>L.uniqueId===R));if(A)for(const R of A.targetedAnimations)for(const o of j)R.animation.targetProperty===o.targetProperty&&R.target===P&&this._stopAnimationGroup(L,A)}}_stopAnimationGroup(L,j){j.stop(!0),j.dispose(),this._removeFromCurrentlyRunning(L,j)}_removeFromCurrentlyRunning(L,j){const P=L._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),A=P.indexOf(j.uniqueId);-1!==A&&(P.splice(A,1),L._setGlobalContextVariable("currentlyRunningAnimationGroups",P))}_cancelPendingTasks(L){const j=this.currentAnimationGroup.getValue(L);j&&this._stopAnimationGroup(L,j)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,o.h)("FlowGraphPlayAnimationBlock",u)}}]);