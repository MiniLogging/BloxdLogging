"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10176:(b,G,i)=>{i.r(G),i.d(G,{_DDSTextureLoader:()=>V});var g=i(1499),c=i(1532);class V{constructor(){this.supportCascades=!0}loadCubeData(b,G,i,V){const z=G.getEngine();let E,Z=!1,Y=1e3;if(Array.isArray(b))for(let g=0;g<b.length;g++){const i=b[g];E=c.d.GetDDSInfo(i),G.width=E.width,G.height=E.height,Z=(E.isRGB||E.isLuminance||E.mipmapCount>1)&&G.generateMipMaps,z._unpackFlipY(E.isCompressed),c.d.UploadDDSLevels(z,G,i,E,Z,6,-1,g),E.isFourCC||1!==E.mipmapCount?Y=E.mipmapCount-1:z.generateMipMapsForCubemap(G)}else{const V=b;E=c.d.GetDDSInfo(V),G.width=E.width,G.height=E.height,i&&(E.sphericalPolynomial=new g.i),Z=(E.isRGB||E.isLuminance||E.mipmapCount>1)&&G.generateMipMaps,z._unpackFlipY(E.isCompressed),c.d.UploadDDSLevels(z,G,V,E,Z,6),E.isFourCC||1!==E.mipmapCount?Y=E.mipmapCount-1:z.generateMipMapsForCubemap(G,!1)}z._setCubeMapTextureParams(G,Z,Y),G.isReady=!0,G.onLoadedObservable.notifyObservers(G),G.onLoadedObservable.clear(),V&&V({isDDS:!0,width:G.width,info:E,data:b,texture:G})}loadData(b,G,i){const g=c.d.GetDDSInfo(b),V=(g.isRGB||g.isLuminance||g.mipmapCount>1)&&G.generateMipMaps&&Math.max(g.width,g.height)>>g.mipmapCount-1===1;i(g.width,g.height,V,g.isFourCC,(()=>{c.d.UploadDDSLevels(G.getEngine(),G,b,g,V,1)}))}}}}]);