"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10654:(t,b,Y)=>{Y.r(b),Y.d(b,{_DDSTextureLoader:()=>F});var o=Y(1558),x=Y(1574);class F{constructor(){this.supportCascades=!0}loadCubeData(t,b,Y,F){const r=b.getEngine();let R,d=!1,E=1e3;if(Array.isArray(t))for(let o=0;o<t.length;o++){const Y=t[o];R=x.d.GetDDSInfo(Y),b.width=R.width,b.height=R.height,d=(R.isRGB||R.isLuminance||R.mipmapCount>1)&&b.generateMipMaps,r._unpackFlipY(R.isCompressed),x.d.UploadDDSLevels(r,b,Y,R,d,6,-1,o),R.isFourCC||1!==R.mipmapCount?E=R.mipmapCount-1:r.generateMipMapsForCubemap(b)}else{const F=t;R=x.d.GetDDSInfo(F),b.width=R.width,b.height=R.height,Y&&(R.sphericalPolynomial=new o.i),d=(R.isRGB||R.isLuminance||R.mipmapCount>1)&&b.generateMipMaps,r._unpackFlipY(R.isCompressed),x.d.UploadDDSLevels(r,b,F,R,d,6),R.isFourCC||1!==R.mipmapCount?E=R.mipmapCount-1:r.generateMipMapsForCubemap(b,!1)}r._setCubeMapTextureParams(b,d,E),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),F&&F({isDDS:!0,width:b.width,info:R,data:t,texture:b})}loadData(t,b,Y){const o=x.d.GetDDSInfo(t),F=(o.isRGB||o.isLuminance||o.mipmapCount>1)&&b.generateMipMaps&&Math.max(o.width,o.height)>>o.mipmapCount-1===1;Y(o.width,o.height,F,o.isFourCC,(()=>{x.d.UploadDDSLevels(b.getEngine(),b,t,o,F,1)}))}}}}]);