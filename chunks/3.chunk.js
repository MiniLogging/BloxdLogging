"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3,6],{2454:(W,F,c)=>{var T=c(613),Y=c(520),Z=c(551),w=c(649),A=c(581),u=c(625);A.d.prototype._partialLoadFile=function(W,F,c,T){let Y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(W,(W=>{c[F]=W,c._internalCount++,6===c._internalCount&&T(c)}),void 0,void 0,!0,((W,F)=>{Y&&W&&Y(W.status+" "+W.statusText,F)}))},A.d.prototype._cascadeLoadFiles=function(W,F,c){let T=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const Y=[];Y._internalCount=0;for(let Z=0;Z<6;Z++)this._partialLoadFile(c[Z],Z,Y,F,T)},A.d.prototype._cascadeLoadImgs=function(W,F,c,T){let Y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,Z=arguments.length>5?arguments[5]:void 0;const w=[];w._internalCount=0;for(let A=0;A<6;A++)this._partialLoadImg(T[A],A,w,W,F,c,Y,Z)},A.d.prototype._partialLoadImg=function(W,F,c,T,Y,A){let u=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,s=arguments.length>7?arguments[7]:void 0;const x=(0,w.b)();(0,Z.u)(W,(W=>{c[F]=W,c._internalCount++,T&&T.removePendingData(x),6===c._internalCount&&A&&A(Y,c)}),((W,F)=>{T&&T.removePendingData(x),u&&u(W,F)}),T?T.offlineProvider:null,s),T&&T.addPendingData(x)},A.d.prototype.createCubeTextureBase=function(W,F,c,Z){let w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,s=arguments.length>6?arguments[6]:void 0,x=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,j=arguments.length>8&&void 0!==arguments[8]&&arguments[8],N=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,q=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,y=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,i=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,e=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,I=arguments.length>14&&void 0!==arguments[14]&&arguments[14],E=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const O=y||new T.d(this,7);O.isCube=!0,O.url=W,O.generateMipMaps=!Z,O._lodGenerationScale=N,O._lodGenerationOffset=q,O._useSRGBBuffer=!!I&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!Z),O!==y&&(O.label=W.substring(0,60)),this._doNotHandleContextLost||(O._extension=x,O._files=c,O._buffer=E);const z=W;this._transformTextureUrl&&!y&&(W=this._transformTextureUrl(W));const G=x??function(W){const F=W.split("?")[0],c=F.lastIndexOf(".");return c>-1?F.substring(c).toLowerCase():""}(W),D=(0,u.c)(G),v=(W,F)=>{O.dispose(),A?A(W,F):W&&Y.e.Warn(W)},C=(T,A)=>{W===z?T&&v(T.status+" "+T.statusText,A):(Y.e.Warn(`Failed to load ${W}, falling back to the ${z}`),this.createCubeTextureBase(z,F,c,!!Z,w,v,s,x,j,N,q,O,i,e,I,E))};if(D)D.then((T=>{const Y=W=>{i&&i(O,W),T.loadCubeData(W,O,j,w,((W,F)=>{v(W,F)}))};E?Y(E):c&&6===c.length?T.supportCascades?this._cascadeLoadFiles(F,(W=>Y(W.map((W=>new Uint8Array(W))))),c,v):v("Textures type does not support cascades."):this._loadFile(W,(W=>Y(new Uint8Array(W))),void 0,void 0,!0,C)}));else{if(!c||0===c.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(F,O,((W,F)=>{e&&e(W,F)}),c,v)}return this._internalTexturesCache.push(O),O}},2289:(W,F,c)=>{c.r(F),c.d(F,{_DDSTextureLoader:()=>Z});var T=c(2297),Y=c(2314);class Z{constructor(){this.supportCascades=!0}loadCubeData(W,F,c,Z){const w=F.getEngine();let A,u=!1,s=1e3;if(Array.isArray(W))for(let T=0;T<W.length;T++){const c=W[T];A=Y.DDSTools.GetDDSInfo(c),F.width=A.width,F.height=A.height,u=(A.isRGB||A.isLuminance||A.mipmapCount>1)&&F.generateMipMaps,w._unpackFlipY(A.isCompressed),Y.DDSTools.UploadDDSLevels(w,F,c,A,u,6,-1,T),A.isFourCC||1!==A.mipmapCount?s=A.mipmapCount-1:w.generateMipMapsForCubemap(F)}else{const Z=W;A=Y.DDSTools.GetDDSInfo(Z),F.width=A.width,F.height=A.height,c&&(A.sphericalPolynomial=new T.e),u=(A.isRGB||A.isLuminance||A.mipmapCount>1)&&F.generateMipMaps,w._unpackFlipY(A.isCompressed),Y.DDSTools.UploadDDSLevels(w,F,Z,A,u,6),A.isFourCC||1!==A.mipmapCount?s=A.mipmapCount-1:w.generateMipMapsForCubemap(F,!1)}w._setCubeMapTextureParams(F,u,s),F.isReady=!0,F.onLoadedObservable.notifyObservers(F),F.onLoadedObservable.clear(),Z&&Z({isDDS:!0,width:F.width,info:A,data:W,texture:F})}loadData(W,F,c){const T=Y.DDSTools.GetDDSInfo(W),Z=(T.isRGB||T.isLuminance||T.mipmapCount>1)&&F.generateMipMaps&&Math.max(T.width,T.height)>>T.mipmapCount-1===1;c(T.width,T.height,Z,T.isFourCC,(()=>{Y.DDSTools.UploadDDSLevels(F.getEngine(),F,W,T,Z,1)}))}}},2314:(W,F,c)=>{c.d(F,{DDSTools:()=>y});var T=c(712),Y=c(520),Z=c(2320),w=c(2328);c(2454);const A=131072,u=131072;function s(W){return W.charCodeAt(0)+(W.charCodeAt(1)<<8)+(W.charCodeAt(2)<<16)+(W.charCodeAt(3)<<24)}const x=s("DXT1"),j=s("DXT3"),N=s("DXT5"),q=s("DX10");class y{static GetDDSInfo(W){const F=new Int32Array(W.buffer,W.byteOffset,31),c=new Int32Array(W.buffer,W.byteOffset,35);let T=1;F[2]&A&&(T=Math.max(1,F[7]));const Y=F[21],Z=Y===q?c[32]:0;let w=0;switch(Y){case 113:w=2;break;case 116:w=1;break;case q:if(10===Z){w=2;break}if(2===Z){w=1;break}}return{width:F[4],height:F[3],mipmapCount:T,isFourCC:4===(4&F[20]),isRGB:64===(64&F[20]),isLuminance:(F[20]&u)===u,isCube:512===(512&F[28]),isCompressed:Y===x||Y===j||Y===N,dxgiFormat:Z,textureType:w}}static _GetHalfFloatAsFloatRGBAArrayBuffer(W,F,c,T,Y,Z){const A=new Float32Array(T),u=new Uint16Array(Y,c);let s=0;for(let x=0;x<F;x++)for(let F=0;F<W;F++){const c=4*(F+x*W);A[s]=(0,w.g)(u[c]),A[s+1]=(0,w.g)(u[c+1]),A[s+2]=(0,w.g)(u[c+2]),y.StoreLODInAlphaChannel?A[s+3]=Z:A[s+3]=(0,w.g)(u[c+3]),s+=4}return A}static _GetHalfFloatRGBAArrayBuffer(W,F,c,T,Y,Z){if(y.StoreLODInAlphaChannel){const A=new Uint16Array(T),u=new Uint16Array(Y,c);let s=0;for(let c=0;c<F;c++)for(let F=0;F<W;F++){const T=4*(F+c*W);A[s]=u[T],A[s+1]=u[T+1],A[s+2]=u[T+2],A[s+3]=(0,w.l)(Z),s+=4}return A}return new Uint16Array(Y,c,T)}static _GetFloatRGBAArrayBuffer(W,F,c,T,Y,Z){if(y.StoreLODInAlphaChannel){const w=new Float32Array(T),A=new Float32Array(Y,c);let u=0;for(let c=0;c<F;c++)for(let F=0;F<W;F++){const T=4*(F+c*W);w[u]=A[T],w[u+1]=A[T+1],w[u+2]=A[T+2],w[u+3]=Z,u+=4}return w}return new Float32Array(Y,c,T)}static _GetFloatAsHalfFloatRGBAArrayBuffer(W,F,c,T,Y,Z){const A=new Uint16Array(T),u=new Float32Array(Y,c);let s=0;for(let x=0;x<F;x++)for(let F=0;F<W;F++)A[s]=(0,w.l)(u[s]),A[s+1]=(0,w.l)(u[s+1]),A[s+2]=(0,w.l)(u[s+2]),y.StoreLODInAlphaChannel?A[s+3]=(0,w.l)(Z):A[s+3]=(0,w.l)(u[s+3]),s+=4;return A}static _GetFloatAsUIntRGBAArrayBuffer(W,F,c,Y,Z,w){const A=new Uint8Array(Y),u=new Float32Array(Z,c);let s=0;for(let x=0;x<F;x++)for(let F=0;F<W;F++){const c=4*(F+x*W);A[s]=255*(0,T.c)(u[c]),A[s+1]=255*(0,T.c)(u[c+1]),A[s+2]=255*(0,T.c)(u[c+2]),y.StoreLODInAlphaChannel?A[s+3]=w:A[s+3]=255*(0,T.c)(u[c+3]),s+=4}return A}static _GetHalfFloatAsUIntRGBAArrayBuffer(W,F,c,Y,Z,A){const u=new Uint8Array(Y),s=new Uint16Array(Z,c);let x=0;for(let j=0;j<F;j++)for(let F=0;F<W;F++){const c=4*(F+j*W);u[x]=255*(0,T.c)((0,w.g)(s[c])),u[x+1]=255*(0,T.c)((0,w.g)(s[c+1])),u[x+2]=255*(0,T.c)((0,w.g)(s[c+2])),y.StoreLODInAlphaChannel?u[x+3]=A:u[x+3]=255*(0,T.c)((0,w.g)(s[c+3])),x+=4}return u}static _GetRGBAArrayBuffer(W,F,c,T,Y,Z,w,A,u){const s=new Uint8Array(T),x=new Uint8Array(Y,c);let j=0;for(let N=0;N<F;N++)for(let F=0;F<W;F++){const c=4*(F+N*W);s[j]=x[c+Z],s[j+1]=x[c+w],s[j+2]=x[c+A],s[j+3]=x[c+u],j+=4}return s}static _ExtractLongWordOrder(W){return 0===W||255===W||-16777216===W?0:1+y._ExtractLongWordOrder(W>>8)}static _GetRGBArrayBuffer(W,F,c,T,Y,Z,w,A){const u=new Uint8Array(T),s=new Uint8Array(Y,c);let x=0;for(let j=0;j<F;j++)for(let F=0;F<W;F++){const c=3*(F+j*W);u[x]=s[c+Z],u[x+1]=s[c+w],u[x+2]=s[c+A],x+=3}return u}static _GetLuminanceArrayBuffer(W,F,c,T,Y){const Z=new Uint8Array(T),w=new Uint8Array(Y,c);let A=0;for(let u=0;u<F;u++)for(let F=0;F<W;F++){const c=F+u*W;Z[A]=w[c],A++}return Z}static UploadDDSLevels(W,F,c,T,w,u){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,i=arguments.length>7?arguments[7]:void 0,e=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],I=null;T.sphericalPolynomial&&(I=[]);const E=!!W.getCaps().s3tc;F.generateMipMaps=w;const O=new Int32Array(c.buffer,c.byteOffset,31);let z,G,D,v,C,n,X,g=0,S=0,U=1;if(542327876!==O[0])return void Y.e.Error("Invalid magic number in DDS header");if(!T.isFourCC&&!T.isRGB&&!T.isLuminance)return void Y.e.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(T.isCompressed&&!E)return void Y.e.Error("Compressed textures are not supported on this platform.");let o=O[22];v=O[1]+4;let K=!1;if(T.isFourCC)switch(z=O[21],z){case x:U=8,S=33777;break;case j:U=16,S=33778;break;case N:U=16,S=33779;break;case 113:K=!0,o=64;break;case 116:K=!0,o=128;break;case q:{v+=20;let W=!1;switch(T.dxgiFormat){case 10:K=!0,o=64,W=!0;break;case 2:K=!0,o=128,W=!0;break;case 88:T.isRGB=!0,T.isFourCC=!1,o=32,W=!0}if(W)break}default:return void Y.e.Error(["Unsupported FourCC code:",(V=z,String.fromCharCode(255&V,V>>8&255,V>>16&255,V>>24&255))])}var V;const d=y._ExtractLongWordOrder(O[23]),L=y._ExtractLongWordOrder(O[24]),H=y._ExtractLongWordOrder(O[25]),k=y._ExtractLongWordOrder(O[26]);K&&(S=W._getRGBABufferInternalSizedFormat(T.textureType)),n=1,O[2]&A&&!1!==w&&(n=Math.max(1,O[7]));const m=i||0,r=W.getCaps();for(let Y=m;Y<u;Y++){for(G=O[4],D=O[3],X=0;X<n;++X){if(-1===s||s===X){const Z=-1===s?X:0;if(!T.isCompressed&&T.isFourCC){F.format=5,g=G*D*4;let T=null;if(W._badOS||W._badDesktopOS||!r.textureHalfFloat&&!r.textureFloat)128===o?(T=y._GetFloatAsUIntRGBAArrayBuffer(G,D,c.byteOffset+v,g,c.buffer,Z),I&&0==Z&&I.push(y._GetFloatRGBAArrayBuffer(G,D,c.byteOffset+v,g,c.buffer,Z))):64===o&&(T=y._GetHalfFloatAsUIntRGBAArrayBuffer(G,D,c.byteOffset+v,g,c.buffer,Z),I&&0==Z&&I.push(y._GetHalfFloatAsFloatRGBAArrayBuffer(G,D,c.byteOffset+v,g,c.buffer,Z))),F.type=0;else{const W=r.textureFloat&&(e&&r.textureFloatLinearFiltering||!e),Y=r.textureHalfFloat&&(e&&r.textureHalfFloatLinearFiltering||!e),w=(128===o||64===o&&!Y)&&W?1:(64===o||128===o&&!W)&&Y?2:0;let A,u=null;if(128===o)switch(w){case 1:A=y._GetFloatRGBAArrayBuffer,u=null;break;case 2:A=y._GetFloatAsHalfFloatRGBAArrayBuffer,u=y._GetFloatRGBAArrayBuffer;break;case 0:A=y._GetFloatAsUIntRGBAArrayBuffer,u=y._GetFloatRGBAArrayBuffer}else switch(w){case 1:A=y._GetHalfFloatAsFloatRGBAArrayBuffer,u=null;break;case 2:A=y._GetHalfFloatRGBAArrayBuffer,u=y._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:A=y._GetHalfFloatAsUIntRGBAArrayBuffer,u=y._GetHalfFloatAsFloatRGBAArrayBuffer}F.type=w,T=A(G,D,c.byteOffset+v,g,c.buffer,Z),I&&0==Z&&I.push(u?u(G,D,c.byteOffset+v,g,c.buffer,Z):T)}T&&W._uploadDataToTextureDirectly(F,T,Y,Z)}else if(T.isRGB)F.type=0,24===o?(F.format=4,g=G*D*3,C=y._GetRGBArrayBuffer(G,D,c.byteOffset+v,g,c.buffer,d,L,H),W._uploadDataToTextureDirectly(F,C,Y,Z)):(F.format=5,g=G*D*4,C=y._GetRGBAArrayBuffer(G,D,c.byteOffset+v,g,c.buffer,d,L,H,k),W._uploadDataToTextureDirectly(F,C,Y,Z));else if(T.isLuminance){const T=W._getUnpackAlignement(),w=G;g=Math.floor((G+T-1)/T)*T*(D-1)+w,C=y._GetLuminanceArrayBuffer(G,D,c.byteOffset+v,g,c.buffer),F.format=1,F.type=0,W._uploadDataToTextureDirectly(F,C,Y,Z)}else g=Math.max(4,G)/4*Math.max(4,D)/4*U,C=new Uint8Array(c.buffer,c.byteOffset+v,g),F.type=0,W._uploadCompressedDataToTextureDirectly(F,S,G,D,C,Y,Z)}v+=o?G*D*(o/8):g,G*=.5,D*=.5,G=Math.max(1,G),D=Math.max(1,D)}if(void 0!==i)break}I&&I.length>0?T.sphericalPolynomial=Z.b.ConvertCubeMapToSphericalPolynomial({size:O[4],right:I[0],left:I[1],up:I[2],down:I[3],front:I[4],back:I[5],format:5,type:1,gammaSpace:!1}):T.sphericalPolynomial=void 0}}y.StoreLODInAlphaChannel=!1}}]);