"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10085:(V,H,t)=>{t.r(H),t.d(H,{_DDSTextureLoader:()=>h});var I=t(1430),Z=t(1449);class h{constructor(){this.supportCascades=!0}loadCubeData(V,H,t,h){const f=H.getEngine();let m,K=!1,E=1e3;if(Array.isArray(V))for(let I=0;I<V.length;I++){const t=V[I];m=Z.b.GetDDSInfo(t),H.width=m.width,H.height=m.height,K=(m.isRGB||m.isLuminance||m.mipmapCount>1)&&H.generateMipMaps,f._unpackFlipY(m.isCompressed),Z.b.UploadDDSLevels(f,H,t,m,K,6,-1,I),m.isFourCC||1!==m.mipmapCount?E=m.mipmapCount-1:f.generateMipMapsForCubemap(H)}else{const h=V;m=Z.b.GetDDSInfo(h),H.width=m.width,H.height=m.height,t&&(m.sphericalPolynomial=new I.f),K=(m.isRGB||m.isLuminance||m.mipmapCount>1)&&H.generateMipMaps,f._unpackFlipY(m.isCompressed),Z.b.UploadDDSLevels(f,H,h,m,K,6),m.isFourCC||1!==m.mipmapCount?E=m.mipmapCount-1:f.generateMipMapsForCubemap(H,!1)}f._setCubeMapTextureParams(H,K,E),H.isReady=!0,H.onLoadedObservable.notifyObservers(H),H.onLoadedObservable.clear(),h&&h({isDDS:!0,width:H.width,info:m,data:V,texture:H})}loadData(V,H,t){const I=Z.b.GetDDSInfo(V),h=(I.isRGB||I.isLuminance||I.mipmapCount>1)&&H.generateMipMaps&&Math.max(I.width,I.height)>>I.mipmapCount-1===1;t(I.width,I.height,h,I.isFourCC,(()=>{Z.b.UploadDDSLevels(H.getEngine(),H,V,I,h,1)}))}}}}]);