"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10839:(Q,z,I)=>{I.r(z),I.d(z,{_DDSTextureLoader:()=>T});var P=I(1474),w=I(1497);class T{constructor(){this.supportCascades=!0}loadCubeData(Q,z,I,T){const A=z.getEngine();let e,m=!1,f=1e3;if(Array.isArray(Q))for(let P=0;P<Q.length;P++){const I=Q[P];e=w.e.GetDDSInfo(I),z.width=e.width,z.height=e.height,m=(e.isRGB||e.isLuminance||e.mipmapCount>1)&&z.generateMipMaps,A._unpackFlipY(e.isCompressed),w.e.UploadDDSLevels(A,z,I,e,m,6,-1,P),e.isFourCC||1!==e.mipmapCount?f=e.mipmapCount-1:A.generateMipMapsForCubemap(z)}else{const T=Q;e=w.e.GetDDSInfo(T),z.width=e.width,z.height=e.height,I&&(e.sphericalPolynomial=new P.h),m=(e.isRGB||e.isLuminance||e.mipmapCount>1)&&z.generateMipMaps,A._unpackFlipY(e.isCompressed),w.e.UploadDDSLevels(A,z,T,e,m,6),e.isFourCC||1!==e.mipmapCount?f=e.mipmapCount-1:A.generateMipMapsForCubemap(z,!1)}A._setCubeMapTextureParams(z,m,f),z.isReady=!0,z.onLoadedObservable.notifyObservers(z),z.onLoadedObservable.clear(),T&&T({isDDS:!0,width:z.width,info:e,data:Q,texture:z})}loadData(Q,z,I){const P=w.e.GetDDSInfo(Q),T=(P.isRGB||P.isLuminance||P.mipmapCount>1)&&z.generateMipMaps&&Math.max(P.width,P.height)>>P.mipmapCount-1===1;I(P.width,P.height,T,P.isFourCC,(()=>{w.e.UploadDDSLevels(z.getEngine(),z,Q,P,T,1)}))}}}}]);