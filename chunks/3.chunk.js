"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10879:(F,e,a)=>{a.r(e),a.d(e,{_DDSTextureLoader:()=>z});var k=a(1480),h=a(1509);class z{constructor(){this.supportCascades=!0}loadCubeData(F,e,a,z){const x=e.getEngine();let t,H=!1,p=1e3;if(Array.isArray(F))for(let k=0;k<F.length;k++){const a=F[k];t=h.e.GetDDSInfo(a),e.width=t.width,e.height=t.height,H=(t.isRGB||t.isLuminance||t.mipmapCount>1)&&e.generateMipMaps,x._unpackFlipY(t.isCompressed),h.e.UploadDDSLevels(x,e,a,t,H,6,-1,k),t.isFourCC||1!==t.mipmapCount?p=t.mipmapCount-1:x.generateMipMapsForCubemap(e)}else{const z=F;t=h.e.GetDDSInfo(z),e.width=t.width,e.height=t.height,a&&(t.sphericalPolynomial=new k.c),H=(t.isRGB||t.isLuminance||t.mipmapCount>1)&&e.generateMipMaps,x._unpackFlipY(t.isCompressed),h.e.UploadDDSLevels(x,e,z,t,H,6),t.isFourCC||1!==t.mipmapCount?p=t.mipmapCount-1:x.generateMipMapsForCubemap(e,!1)}x._setCubeMapTextureParams(e,H,p),e.isReady=!0,e.onLoadedObservable.notifyObservers(e),e.onLoadedObservable.clear(),z&&z({isDDS:!0,width:e.width,info:t,data:F,texture:e})}loadData(F,e,a){const k=h.e.GetDDSInfo(F),z=(k.isRGB||k.isLuminance||k.mipmapCount>1)&&e.generateMipMaps&&Math.max(k.width,k.height)>>k.mipmapCount-1===1;a(k.width,k.height,z,k.isFourCC,(()=>{h.e.UploadDDSLevels(e.getEngine(),e,F,k,z,1)}))}}}}]);