"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10355:(d,m,g)=>{g.r(m),g.d(m,{_DDSTextureLoader:()=>D});var V=g(1454),u=g(1477);class D{constructor(){this.supportCascades=!0}loadCubeData(d,m,g,D){const j=m.getEngine();let z,s=!1,U=1e3;if(Array.isArray(d))for(let V=0;V<d.length;V++){const g=d[V];z=u.e.GetDDSInfo(g),m.width=z.width,m.height=z.height,s=(z.isRGB||z.isLuminance||z.mipmapCount>1)&&m.generateMipMaps,j._unpackFlipY(z.isCompressed),u.e.UploadDDSLevels(j,m,g,z,s,6,-1,V),z.isFourCC||1!==z.mipmapCount?U=z.mipmapCount-1:j.generateMipMapsForCubemap(m)}else{const D=d;z=u.e.GetDDSInfo(D),m.width=z.width,m.height=z.height,g&&(z.sphericalPolynomial=new V.f),s=(z.isRGB||z.isLuminance||z.mipmapCount>1)&&m.generateMipMaps,j._unpackFlipY(z.isCompressed),u.e.UploadDDSLevels(j,m,D,z,s,6),z.isFourCC||1!==z.mipmapCount?U=z.mipmapCount-1:j.generateMipMapsForCubemap(m,!1)}j._setCubeMapTextureParams(m,s,U),m.isReady=!0,m.onLoadedObservable.notifyObservers(m),m.onLoadedObservable.clear(),D&&D({isDDS:!0,width:m.width,info:z,data:d,texture:m})}loadData(d,m,g){const V=u.e.GetDDSInfo(d),D=(V.isRGB||V.isLuminance||V.mipmapCount>1)&&m.generateMipMaps&&Math.max(V.width,V.height)>>V.mipmapCount-1===1;g(V.width,V.height,D,V.isFourCC,(()=>{u.e.UploadDDSLevels(m.getEngine(),m,d,V,D,1)}))}}}}]);