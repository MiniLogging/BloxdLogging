"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{11095:(L,i,P)=>{P.r(i),P.d(i,{_DDSTextureLoader:()=>M});var D=P(1492),V=P(1522);class M{constructor(){this.supportCascades=!0}loadCubeData(L,i,P,M){const a=i.getEngine();let w,O=!1,U=1e3;if(Array.isArray(L))for(let D=0;D<L.length;D++){const P=L[D];w=V.b.GetDDSInfo(P),i.width=w.width,i.height=w.height,O=(w.isRGB||w.isLuminance||w.mipmapCount>1)&&i.generateMipMaps,a._unpackFlipY(w.isCompressed),V.b.UploadDDSLevels(a,i,P,w,O,6,-1,D),w.isFourCC||1!==w.mipmapCount?U=w.mipmapCount-1:a.generateMipMapsForCubemap(i)}else{const M=L;w=V.b.GetDDSInfo(M),i.width=w.width,i.height=w.height,P&&(w.sphericalPolynomial=new D.f),O=(w.isRGB||w.isLuminance||w.mipmapCount>1)&&i.generateMipMaps,a._unpackFlipY(w.isCompressed),V.b.UploadDDSLevels(a,i,M,w,O,6),w.isFourCC||1!==w.mipmapCount?U=w.mipmapCount-1:a.generateMipMapsForCubemap(i,!1)}a._setCubeMapTextureParams(i,O,U),i.isReady=!0,i.onLoadedObservable.notifyObservers(i),i.onLoadedObservable.clear(),M&&M({isDDS:!0,width:i.width,info:w,data:L,texture:i})}loadData(L,i,P){const D=V.b.GetDDSInfo(L),M=(D.isRGB||D.isLuminance||D.mipmapCount>1)&&i.generateMipMaps&&Math.max(D.width,D.height)>>D.mipmapCount-1===1;P(D.width,D.height,M,D.isFourCC,(()=>{V.b.UploadDDSLevels(i.getEngine(),i,L,D,M,1)}))}}}}]);