"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3,6],{2147:(v,d,Q)=>{var n=Q(573),T=Q(482),L=Q(512),e=Q(593),F=Q(544),r=Q(578);F.d.prototype._partialLoadFile=function(v,d,Q,n){let T=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(v,(v=>{Q[d]=v,Q._internalCount++,6===Q._internalCount&&n(Q)}),void 0,void 0,!0,((v,d)=>{T&&v&&T(v.status+" "+v.statusText,d)}))},F.d.prototype._cascadeLoadFiles=function(v,d,Q){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const T=[];T._internalCount=0;for(let L=0;L<6;L++)this._partialLoadFile(Q[L],L,T,d,n)},F.d.prototype._cascadeLoadImgs=function(v,d,Q,n){let T=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,L=arguments.length>5?arguments[5]:void 0;const e=[];e._internalCount=0;for(let F=0;F<6;F++)this._partialLoadImg(n[F],F,e,v,d,Q,T,L)},F.d.prototype._partialLoadImg=function(v,d,Q,n,T,F){let r=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,C=arguments.length>7?arguments[7]:void 0;const u=(0,e.e)();(0,L.v)(v,(v=>{Q[d]=v,Q._internalCount++,n&&n.removePendingData(u),6===Q._internalCount&&F&&F(T,Q)}),((v,d)=>{n&&n.removePendingData(u),r&&r(v,d)}),n?n.offlineProvider:null,C),n&&n.addPendingData(u)},F.d.prototype.createCubeTextureBase=function(v,d,Q,L){let e=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,F=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,C=arguments.length>6?arguments[6]:void 0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,y=arguments.length>8&&void 0!==arguments[8]&&arguments[8],z=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,B=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,X=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,m=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,V=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,h=arguments.length>14&&void 0!==arguments[14]&&arguments[14],S=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const A=X||new n.b(this,7);A.isCube=!0,A.url=v,A.generateMipMaps=!L,A._lodGenerationScale=z,A._lodGenerationOffset=B,A._useSRGBBuffer=!!h&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!L),A!==X&&(A.label=v.substring(0,60)),this._doNotHandleContextLost||(A._extension=u,A._files=Q,A._buffer=S);const f=v;this._transformTextureUrl&&!X&&(v=this._transformTextureUrl(v));const P=u??function(v){const d=v.split("?")[0],Q=d.lastIndexOf(".");return Q>-1?d.substring(Q).toLowerCase():""}(v),O=(0,r.e)(P),J=(v,d)=>{A.dispose(),F?F(v,d):v&&T.d.Warn(v)},K=(n,F)=>{v===f?n&&J(n.status+" "+n.statusText,F):(T.d.Warn(`Failed to load ${v}, falling back to the ${f}`),this.createCubeTextureBase(f,d,Q,!!L,e,J,C,u,y,z,B,A,m,V,h,S))};if(O)O.then((n=>{const T=v=>{m&&m(A,v),n.loadCubeData(v,A,y,e,((v,d)=>{J(v,d)}))};S?T(S):Q&&6===Q.length?n.supportCascades?this._cascadeLoadFiles(d,(v=>T(v.map((v=>new Uint8Array(v))))),Q,J):J("Textures type does not support cascades."):this._loadFile(v,(v=>T(new Uint8Array(v))),void 0,void 0,!0,K)}));else{if(!Q||0===Q.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(d,A,((v,d)=>{V&&V(v,d)}),Q,J)}return this._internalTexturesCache.push(A),A}},2005:(v,d,Q)=>{Q.r(d),Q.d(d,{_DDSTextureLoader:()=>L});var n=Q(2007),T=Q(2024);class L{constructor(){this.supportCascades=!0}loadCubeData(v,d,Q,L){const e=d.getEngine();let F,r=!1,C=1e3;if(Array.isArray(v))for(let n=0;n<v.length;n++){const Q=v[n];F=T.DDSTools.GetDDSInfo(Q),d.width=F.width,d.height=F.height,r=(F.isRGB||F.isLuminance||F.mipmapCount>1)&&d.generateMipMaps,e._unpackFlipY(F.isCompressed),T.DDSTools.UploadDDSLevels(e,d,Q,F,r,6,-1,n),F.isFourCC||1!==F.mipmapCount?C=F.mipmapCount-1:e.generateMipMapsForCubemap(d)}else{const L=v;F=T.DDSTools.GetDDSInfo(L),d.width=F.width,d.height=F.height,Q&&(F.sphericalPolynomial=new n.e),r=(F.isRGB||F.isLuminance||F.mipmapCount>1)&&d.generateMipMaps,e._unpackFlipY(F.isCompressed),T.DDSTools.UploadDDSLevels(e,d,L,F,r,6),F.isFourCC||1!==F.mipmapCount?C=F.mipmapCount-1:e.generateMipMapsForCubemap(d,!1)}e._setCubeMapTextureParams(d,r,C),d.isReady=!0,d.onLoadedObservable.notifyObservers(d),d.onLoadedObservable.clear(),L&&L({isDDS:!0,width:d.width,info:F,data:v,texture:d})}loadData(v,d,Q){const n=T.DDSTools.GetDDSInfo(v),L=(n.isRGB||n.isLuminance||n.mipmapCount>1)&&d.generateMipMaps&&Math.max(n.width,n.height)>>n.mipmapCount-1===1;Q(n.width,n.height,L,n.isFourCC,(()=>{T.DDSTools.UploadDDSLevels(d.getEngine(),d,v,n,L,1)}))}}},2024:(v,d,Q)=>{Q.d(d,{DDSTools:()=>X});var n=Q(664),T=Q(482),L=Q(2029),e=Q(2033);Q(2147);const F=131072,r=131072;function C(v){return v.charCodeAt(0)+(v.charCodeAt(1)<<8)+(v.charCodeAt(2)<<16)+(v.charCodeAt(3)<<24)}const u=C("DXT1"),y=C("DXT3"),z=C("DXT5"),B=C("DX10");class X{static GetDDSInfo(v){const d=new Int32Array(v.buffer,v.byteOffset,31),Q=new Int32Array(v.buffer,v.byteOffset,35);let n=1;d[2]&F&&(n=Math.max(1,d[7]));const T=d[21],L=T===B?Q[32]:0;let e=0;switch(T){case 113:e=2;break;case 116:e=1;break;case B:if(10===L){e=2;break}if(2===L){e=1;break}}return{width:d[4],height:d[3],mipmapCount:n,isFourCC:4===(4&d[20]),isRGB:64===(64&d[20]),isLuminance:(d[20]&r)===r,isCube:512===(512&d[28]),isCompressed:T===u||T===y||T===z,dxgiFormat:L,textureType:e}}static _GetHalfFloatAsFloatRGBAArrayBuffer(v,d,Q,n,T,L){const F=new Float32Array(n),r=new Uint16Array(T,Q);let C=0;for(let u=0;u<d;u++)for(let d=0;d<v;d++){const Q=4*(d+u*v);F[C]=(0,e.e)(r[Q]),F[C+1]=(0,e.e)(r[Q+1]),F[C+2]=(0,e.e)(r[Q+2]),X.StoreLODInAlphaChannel?F[C+3]=L:F[C+3]=(0,e.e)(r[Q+3]),C+=4}return F}static _GetHalfFloatRGBAArrayBuffer(v,d,Q,n,T,L){if(X.StoreLODInAlphaChannel){const F=new Uint16Array(n),r=new Uint16Array(T,Q);let C=0;for(let Q=0;Q<d;Q++)for(let d=0;d<v;d++){const n=4*(d+Q*v);F[C]=r[n],F[C+1]=r[n+1],F[C+2]=r[n+2],F[C+3]=(0,e.l)(L),C+=4}return F}return new Uint16Array(T,Q,n)}static _GetFloatRGBAArrayBuffer(v,d,Q,n,T,L){if(X.StoreLODInAlphaChannel){const e=new Float32Array(n),F=new Float32Array(T,Q);let r=0;for(let Q=0;Q<d;Q++)for(let d=0;d<v;d++){const n=4*(d+Q*v);e[r]=F[n],e[r+1]=F[n+1],e[r+2]=F[n+2],e[r+3]=L,r+=4}return e}return new Float32Array(T,Q,n)}static _GetFloatAsHalfFloatRGBAArrayBuffer(v,d,Q,n,T,L){const F=new Uint16Array(n),r=new Float32Array(T,Q);let C=0;for(let u=0;u<d;u++)for(let d=0;d<v;d++)F[C]=(0,e.l)(r[C]),F[C+1]=(0,e.l)(r[C+1]),F[C+2]=(0,e.l)(r[C+2]),X.StoreLODInAlphaChannel?F[C+3]=(0,e.l)(L):F[C+3]=(0,e.l)(r[C+3]),C+=4;return F}static _GetFloatAsUIntRGBAArrayBuffer(v,d,Q,T,L,e){const F=new Uint8Array(T),r=new Float32Array(L,Q);let C=0;for(let u=0;u<d;u++)for(let d=0;d<v;d++){const Q=4*(d+u*v);F[C]=255*(0,n.Clamp)(r[Q]),F[C+1]=255*(0,n.Clamp)(r[Q+1]),F[C+2]=255*(0,n.Clamp)(r[Q+2]),X.StoreLODInAlphaChannel?F[C+3]=e:F[C+3]=255*(0,n.Clamp)(r[Q+3]),C+=4}return F}static _GetHalfFloatAsUIntRGBAArrayBuffer(v,d,Q,T,L,F){const r=new Uint8Array(T),C=new Uint16Array(L,Q);let u=0;for(let y=0;y<d;y++)for(let d=0;d<v;d++){const Q=4*(d+y*v);r[u]=255*(0,n.Clamp)((0,e.e)(C[Q])),r[u+1]=255*(0,n.Clamp)((0,e.e)(C[Q+1])),r[u+2]=255*(0,n.Clamp)((0,e.e)(C[Q+2])),X.StoreLODInAlphaChannel?r[u+3]=F:r[u+3]=255*(0,n.Clamp)((0,e.e)(C[Q+3])),u+=4}return r}static _GetRGBAArrayBuffer(v,d,Q,n,T,L,e,F,r){const C=new Uint8Array(n),u=new Uint8Array(T,Q);let y=0;for(let z=0;z<d;z++)for(let d=0;d<v;d++){const Q=4*(d+z*v);C[y]=u[Q+L],C[y+1]=u[Q+e],C[y+2]=u[Q+F],C[y+3]=u[Q+r],y+=4}return C}static _ExtractLongWordOrder(v){return 0===v||255===v||-16777216===v?0:1+X._ExtractLongWordOrder(v>>8)}static _GetRGBArrayBuffer(v,d,Q,n,T,L,e,F){const r=new Uint8Array(n),C=new Uint8Array(T,Q);let u=0;for(let y=0;y<d;y++)for(let d=0;d<v;d++){const Q=3*(d+y*v);r[u]=C[Q+L],r[u+1]=C[Q+e],r[u+2]=C[Q+F],u+=3}return r}static _GetLuminanceArrayBuffer(v,d,Q,n,T){const L=new Uint8Array(n),e=new Uint8Array(T,Q);let F=0;for(let r=0;r<d;r++)for(let d=0;d<v;d++){const Q=d+r*v;L[F]=e[Q],F++}return L}static UploadDDSLevels(v,d,Q,n,e,r){let C=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,m=arguments.length>7?arguments[7]:void 0,V=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],h=null;n.sphericalPolynomial&&(h=[]);const S=!!v.getCaps().s3tc;d.generateMipMaps=e;const A=new Int32Array(Q.buffer,Q.byteOffset,31);let f,P,O,J,K,o,g,R=0,M=0,Y=1;if(542327876!==A[0])return void T.d.Error("Invalid magic number in DDS header");if(!n.isFourCC&&!n.isRGB&&!n.isLuminance)return void T.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(n.isCompressed&&!S)return void T.d.Error("Compressed textures are not supported on this platform.");let D=A[22];J=A[1]+4;let i=!1;if(n.isFourCC)switch(f=A[21],f){case u:Y=8,M=33777;break;case y:Y=16,M=33778;break;case z:Y=16,M=33779;break;case 113:i=!0,D=64;break;case 116:i=!0,D=128;break;case B:{J+=20;let v=!1;switch(n.dxgiFormat){case 10:i=!0,D=64,v=!0;break;case 2:i=!0,D=128,v=!0;break;case 88:n.isRGB=!0,n.isFourCC=!1,D=32,v=!0}if(v)break}default:return void T.d.Error(["Unsupported FourCC code:",(Z=f,String.fromCharCode(255&Z,Z>>8&255,Z>>16&255,Z>>24&255))])}var Z;const j=X._ExtractLongWordOrder(A[23]),x=X._ExtractLongWordOrder(A[24]),k=X._ExtractLongWordOrder(A[25]),t=X._ExtractLongWordOrder(A[26]);i&&(M=v._getRGBABufferInternalSizedFormat(n.textureType)),o=1,A[2]&F&&!1!==e&&(o=Math.max(1,A[7]));const p=m||0,W=v.getCaps();for(let T=p;T<r;T++){for(P=A[4],O=A[3],g=0;g<o;++g){if(-1===C||C===g){const L=-1===C?g:0;if(!n.isCompressed&&n.isFourCC){d.format=5,R=P*O*4;let n=null;if(v._badOS||v._badDesktopOS||!W.textureHalfFloat&&!W.textureFloat)128===D?(n=X._GetFloatAsUIntRGBAArrayBuffer(P,O,Q.byteOffset+J,R,Q.buffer,L),h&&0==L&&h.push(X._GetFloatRGBAArrayBuffer(P,O,Q.byteOffset+J,R,Q.buffer,L))):64===D&&(n=X._GetHalfFloatAsUIntRGBAArrayBuffer(P,O,Q.byteOffset+J,R,Q.buffer,L),h&&0==L&&h.push(X._GetHalfFloatAsFloatRGBAArrayBuffer(P,O,Q.byteOffset+J,R,Q.buffer,L))),d.type=0;else{const v=W.textureFloat&&(V&&W.textureFloatLinearFiltering||!V),T=W.textureHalfFloat&&(V&&W.textureHalfFloatLinearFiltering||!V),e=(128===D||64===D&&!T)&&v?1:(64===D||128===D&&!v)&&T?2:0;let F,r=null;if(128===D)switch(e){case 1:F=X._GetFloatRGBAArrayBuffer,r=null;break;case 2:F=X._GetFloatAsHalfFloatRGBAArrayBuffer,r=X._GetFloatRGBAArrayBuffer;break;case 0:F=X._GetFloatAsUIntRGBAArrayBuffer,r=X._GetFloatRGBAArrayBuffer}else switch(e){case 1:F=X._GetHalfFloatAsFloatRGBAArrayBuffer,r=null;break;case 2:F=X._GetHalfFloatRGBAArrayBuffer,r=X._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:F=X._GetHalfFloatAsUIntRGBAArrayBuffer,r=X._GetHalfFloatAsFloatRGBAArrayBuffer}d.type=e,n=F(P,O,Q.byteOffset+J,R,Q.buffer,L),h&&0==L&&h.push(r?r(P,O,Q.byteOffset+J,R,Q.buffer,L):n)}n&&v._uploadDataToTextureDirectly(d,n,T,L)}else if(n.isRGB)d.type=0,24===D?(d.format=4,R=P*O*3,K=X._GetRGBArrayBuffer(P,O,Q.byteOffset+J,R,Q.buffer,j,x,k),v._uploadDataToTextureDirectly(d,K,T,L)):(d.format=5,R=P*O*4,K=X._GetRGBAArrayBuffer(P,O,Q.byteOffset+J,R,Q.buffer,j,x,k,t),v._uploadDataToTextureDirectly(d,K,T,L));else if(n.isLuminance){const n=v._getUnpackAlignement(),e=P;R=Math.floor((P+n-1)/n)*n*(O-1)+e,K=X._GetLuminanceArrayBuffer(P,O,Q.byteOffset+J,R,Q.buffer),d.format=1,d.type=0,v._uploadDataToTextureDirectly(d,K,T,L)}else R=Math.max(4,P)/4*Math.max(4,O)/4*Y,K=new Uint8Array(Q.buffer,Q.byteOffset+J,R),d.type=0,v._uploadCompressedDataToTextureDirectly(d,M,P,O,K,T,L)}J+=D?P*O*(D/8):R,P*=.5,O*=.5,P=Math.max(1,P),O=Math.max(1,O)}if(void 0!==m)break}h&&h.length>0?n.sphericalPolynomial=L.d.ConvertCubeMapToSphericalPolynomial({size:A[4],right:h[0],left:h[1],up:h[2],down:h[3],front:h[4],back:h[5],format:5,type:1,gammaSpace:!1}):n.sphericalPolynomial=void 0}}X.StoreLODInAlphaChannel=!1}}]);