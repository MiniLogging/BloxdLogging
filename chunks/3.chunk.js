"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10205:(q,X,Q)=>{Q.r(X),Q.d(X,{_DDSTextureLoader:()=>u});var y=Q(1485),x=Q(1510);class u{constructor(){this.supportCascades=!0}loadCubeData(q,X,Q,u){const H=X.getEngine();let b,D=!1,a=1e3;if(Array.isArray(q))for(let y=0;y<q.length;y++){const Q=q[y];b=x.c.GetDDSInfo(Q),X.width=b.width,X.height=b.height,D=(b.isRGB||b.isLuminance||b.mipmapCount>1)&&X.generateMipMaps,H._unpackFlipY(b.isCompressed),x.c.UploadDDSLevels(H,X,Q,b,D,6,-1,y),b.isFourCC||1!==b.mipmapCount?a=b.mipmapCount-1:H.generateMipMapsForCubemap(X)}else{const u=q;b=x.c.GetDDSInfo(u),X.width=b.width,X.height=b.height,Q&&(b.sphericalPolynomial=new y.d),D=(b.isRGB||b.isLuminance||b.mipmapCount>1)&&X.generateMipMaps,H._unpackFlipY(b.isCompressed),x.c.UploadDDSLevels(H,X,u,b,D,6),b.isFourCC||1!==b.mipmapCount?a=b.mipmapCount-1:H.generateMipMapsForCubemap(X,!1)}H._setCubeMapTextureParams(X,D,a),X.isReady=!0,X.onLoadedObservable.notifyObservers(X),X.onLoadedObservable.clear(),u&&u({isDDS:!0,width:X.width,info:b,data:q,texture:X})}loadData(q,X,Q){const y=x.c.GetDDSInfo(q),u=(y.isRGB||y.isLuminance||y.mipmapCount>1)&&X.generateMipMaps&&Math.max(y.width,y.height)>>y.mipmapCount-1===1;Q(y.width,y.height,u,y.isFourCC,(()=>{x.c.UploadDDSLevels(X.getEngine(),X,q,y,u,1)}))}}}}]);