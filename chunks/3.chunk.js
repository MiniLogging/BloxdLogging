"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10905:(D,j,W)=>{W.r(j),W.d(j,{_DDSTextureLoader:()=>k});var Q=W(1503),C=W(1530);class k{constructor(){this.supportCascades=!0}loadCubeData(D,j,W,k){const M=j.getEngine();let O,E=!1,f=1e3;if(Array.isArray(D))for(let Q=0;Q<D.length;Q++){const W=D[Q];O=C.c.GetDDSInfo(W),j.width=O.width,j.height=O.height,E=(O.isRGB||O.isLuminance||O.mipmapCount>1)&&j.generateMipMaps,M._unpackFlipY(O.isCompressed),C.c.UploadDDSLevels(M,j,W,O,E,6,-1,Q),O.isFourCC||1!==O.mipmapCount?f=O.mipmapCount-1:M.generateMipMapsForCubemap(j)}else{const k=D;O=C.c.GetDDSInfo(k),j.width=O.width,j.height=O.height,W&&(O.sphericalPolynomial=new Q.h),E=(O.isRGB||O.isLuminance||O.mipmapCount>1)&&j.generateMipMaps,M._unpackFlipY(O.isCompressed),C.c.UploadDDSLevels(M,j,k,O,E,6),O.isFourCC||1!==O.mipmapCount?f=O.mipmapCount-1:M.generateMipMapsForCubemap(j,!1)}M._setCubeMapTextureParams(j,E,f),j.isReady=!0,j.onLoadedObservable.notifyObservers(j),j.onLoadedObservable.clear(),k&&k({isDDS:!0,width:j.width,info:O,data:D,texture:j})}loadData(D,j,W){const Q=C.c.GetDDSInfo(D),k=(Q.isRGB||Q.isLuminance||Q.mipmapCount>1)&&j.generateMipMaps&&Math.max(Q.width,Q.height)>>Q.mipmapCount-1===1;W(Q.width,Q.height,k,Q.isFourCC,(()=>{C.c.UploadDDSLevels(j.getEngine(),j,D,Q,k,1)}))}}}}]);