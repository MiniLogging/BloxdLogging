"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10123:(I,k,i)=>{i.r(k),i.d(k,{_DDSTextureLoader:()=>H});var d=i(1459),u=i(1483);class H{constructor(){this.supportCascades=!0}loadCubeData(I,k,i,H){const Y=k.getEngine();let x,j=!1,l=1e3;if(Array.isArray(I))for(let d=0;d<I.length;d++){const i=I[d];x=u.d.GetDDSInfo(i),k.width=x.width,k.height=x.height,j=(x.isRGB||x.isLuminance||x.mipmapCount>1)&&k.generateMipMaps,Y._unpackFlipY(x.isCompressed),u.d.UploadDDSLevels(Y,k,i,x,j,6,-1,d),x.isFourCC||1!==x.mipmapCount?l=x.mipmapCount-1:Y.generateMipMapsForCubemap(k)}else{const H=I;x=u.d.GetDDSInfo(H),k.width=x.width,k.height=x.height,i&&(x.sphericalPolynomial=new d.d),j=(x.isRGB||x.isLuminance||x.mipmapCount>1)&&k.generateMipMaps,Y._unpackFlipY(x.isCompressed),u.d.UploadDDSLevels(Y,k,H,x,j,6),x.isFourCC||1!==x.mipmapCount?l=x.mipmapCount-1:Y.generateMipMapsForCubemap(k,!1)}Y._setCubeMapTextureParams(k,j,l),k.isReady=!0,k.onLoadedObservable.notifyObservers(k),k.onLoadedObservable.clear(),H&&H({isDDS:!0,width:k.width,info:x,data:I,texture:k})}loadData(I,k,i){const d=u.d.GetDDSInfo(I),H=(d.isRGB||d.isLuminance||d.mipmapCount>1)&&k.generateMipMaps&&Math.max(d.width,d.height)>>d.mipmapCount-1===1;i(d.width,d.height,H,d.isFourCC,(()=>{u.d.UploadDDSLevels(k.getEngine(),k,I,d,H,1)}))}}}}]);