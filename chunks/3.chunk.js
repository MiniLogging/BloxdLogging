"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{2083:(Y,d,t)=>{t.d(d,{b:()=>D});var x=t(513),C=t(686),U=t(2077),y=t(2092),B=t(2098),W=t(702),o=t(650),f=t(590),F=t(531);f.b.prototype.setDepthStencilTexture=function(Y,d){this._engine.setDepthStencilTexture(this._samplers[Y],this._uniforms[Y],d,Y)};class D extends U.d{get renderList(){return this._renderList}set renderList(Y){this._renderList!==Y&&(this._unObserveRenderList&&(this._unObserveRenderList(),this._unObserveRenderList=null),Y&&(this._unObserveRenderList=(0,W.k)(Y,this._renderListHasChanged)),this._renderList=Y)}get postProcesses(){return this._postProcesses}get _prePassEnabled(){return!!this._prePassRenderTarget&&this._prePassRenderTarget.enabled}set onAfterUnbind(Y){this._onAfterUnbindObserver&&this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=this.onAfterUnbindObservable.add(Y)}set onBeforeRender(Y){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(Y)}set onAfterRender(Y){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(Y)}set onClear(Y){this._onClearObserver&&this.onClearObservable.remove(this._onClearObserver),this._onClearObserver=this.onClearObservable.add(Y)}get renderPassIds(){return this._renderPassIds}get currentRefreshId(){return this._currentRefreshId}setMaterialForRendering(Y,d){let t;t=Array.isArray(Y)?Y:[Y];for(let x=0;x<t.length;++x)for(let Y=0;Y<this._renderPassIds.length;++Y)t[x].setMaterialForRenderPass(this._renderPassIds[Y],void 0!==d?Array.isArray(d)?d[Y]:d:void 0)}get isMulti(){var Y;return(null===(Y=this._renderTarget)||void 0===Y?void 0:Y.isMulti)??!1}get renderTargetOptions(){return this._renderTargetOptions}get renderTarget(){return this._renderTarget}_onRatioRescale(){this._sizeRatio&&this.resize(this._initialSizeParameter)}set boundingBoxSize(Y){if(this._boundingBoxSize&&this._boundingBoxSize.equals(Y))return;this._boundingBoxSize=Y;const d=this.va();d&&d.markAllMaterialsAsDirty(1)}get boundingBoxSize(){return this._boundingBoxSize}get depthStencilTexture(){var Y;return(null===(Y=this._renderTarget)||void 0===Y?void 0:Y._depthStencilTexture)??null}constructor(Y,d,t){let y,W=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,F=arguments.length>6&&void 0!==arguments[6]&&arguments[6],D=arguments.length>7&&void 0!==arguments[7]?arguments[7]:U.d.TRILINEAR_SAMPLINGMODE,b=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],m=arguments.length>9&&void 0!==arguments[9]&&arguments[9],M=arguments.length>10&&void 0!==arguments[10]&&arguments[10],J=arguments.length>11&&void 0!==arguments[11]?arguments[11]:5,g=arguments.length>12&&void 0!==arguments[12]&&arguments[12],T=arguments.length>13?arguments[13]:void 0,s=arguments.length>14?arguments[14]:void 0,l=arguments.length>15&&void 0!==arguments[15]&&arguments[15],h=arguments.length>16&&void 0!==arguments[16]&&arguments[16],Z=!0;if("object"===typeof W){const Y=W;W=!!Y.generateMipMaps,o=Y.doNotChangeAspectRatio??!0,f=Y.type??0,F=!!Y.isCube,D=Y.samplingMode??U.d.TRILINEAR_SAMPLINGMODE,b=Y.generateDepthBuffer??!0,m=!!Y.generateStencilBuffer,M=!!Y.isMulti,J=Y.format??5,g=!!Y.delayAllocation,T=Y.samples,s=Y.creationFlags,l=!!Y.noColorAttachment,h=!!Y.useSRGBBuffer,y=Y.colorAttachment,Z=Y.gammaSpace??Z}if(super(null,t,!W,void 0,D,void 0,void 0,void 0,void 0,J),this._unObserveRenderList=null,this._renderListHasChanged=(Y,d)=>{const t=this._renderList?this._renderList.length:0;var x;(0===d&&t>0||0===t)&&(null===(x=this.va())||void 0===x||x.meshes.forEach((Y=>{Y._markSubMeshesAsLightDirty()})))},this.particleSystemList=null,this.renderParticles=!0,this.renderSprites=!1,this.forceLayerMaskCheck=!1,this.ignoreCameraViewport=!1,this.onBeforeBindObservable=new x.b,this.onAfterUnbindObservable=new x.b,this.onBeforeRenderObservable=new x.b,this.onAfterRenderObservable=new x.b,this.onClearObservable=new x.b,this.onResizeObservable=new x.b,this._cleared=!1,this.skipInitialClear=!1,this._currentRefreshId=-1,this._refreshRate=1,this._samples=1,this._canRescale=!0,this._renderTarget=null,this.boundingBoxPosition=C.k.Zero(),this._dumpToolsLoading=!1,!(t=this.va()))return;const N=this.va().getEngine();this._gammaSpace=Z,this._coordinatesMode=U.d.PROJECTION_MODE,this.renderList=[],this.name=Y,this.isRenderTarget=!0,this._initialSizeParameter=d,this._renderPassIds=[],this._isCubeData=F,this._processSizeParameter(d),this.renderPassId=this._renderPassIds[0],this._resizeObserver=N.onResizeObservable.add((()=>{})),this._generateMipMaps=!!W,this._doNotChangeAspectRatio=o,this._renderingManager=new B.e(t),this._renderingManager._useSceneAutoClearSetup=!0,M||(this._renderTargetOptions={generateMipMaps:W,type:f,format:this._format??void 0,samplingMode:this.samplingMode,generateDepthBuffer:b,generateStencilBuffer:m,samples:T,creationFlags:s,noColorAttachment:l,useSRGBBuffer:h,colorAttachment:y,label:this.name},this.samplingMode===U.d.NEAREST_SAMPLINGMODE&&(this.wrapU=U.d.CLAMP_ADDRESSMODE,this.wrapV=U.d.CLAMP_ADDRESSMODE),g||(F?(this._renderTarget=t.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions),this.coordinatesMode=U.d.INVCUBIC_MODE,this._textureMatrix=C.b.Identity()):this._renderTarget=t.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,void 0!==T&&(this.samples=T)))}createDepthStencilTexture(){var Y;let d=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],x=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:14,y=arguments.length>5?arguments[5]:void 0;null===(Y=this._renderTarget)||void 0===Y||Y.createDepthStencilTexture(d,t,x,C,U,y)}_releaseRenderPassId(){if(this._scene){const Y=this._scene.getEngine();for(let d=0;d<this._renderPassIds.length;++d)Y.releaseRenderPassId(this._renderPassIds[d])}this._renderPassIds=[]}_createRenderPassId(){this._releaseRenderPassId();const Y=this._scene.getEngine(),d=this._isCubeData?6:this.getRenderLayers()||1;for(let t=0;t<d;++t)this._renderPassIds[t]=Y.createRenderPassId(`RenderTargetTexture - ${this.name}#${t}`)}_processSizeParameter(Y){let d=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(Y.ratio){this._sizeRatio=Y.ratio;const d=this._getEngine();this._size={width:this._bestReflectionRenderTargetDimension(d.getRenderWidth(),this._sizeRatio),height:this._bestReflectionRenderTargetDimension(d.getRenderHeight(),this._sizeRatio)}}else this._size=Y;d&&this._createRenderPassId()}get samples(){var Y;return(null===(Y=this._renderTarget)||void 0===Y?void 0:Y.samples)??this._samples}set samples(Y){this._renderTarget&&(this._samples=this._renderTarget.setSamples(Y))}resetRefreshCounter(){this._currentRefreshId=-1}get refreshRate(){return this._refreshRate}set refreshRate(Y){this._refreshRate=Y,this.resetRefreshCounter()}addPostProcess(Y){if(!this._postProcessManager){const Y=this.va();if(!Y)return;this._postProcessManager=new y.c(Y),this._postProcesses=new Array}this._postProcesses.push(Y),this._postProcesses[0].Hl=!1}clearPostProcesses(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this._postProcesses){if(Y)for(const Y of this._postProcesses)Y.dispose();this._postProcesses=[]}}removePostProcess(Y){if(!this._postProcesses)return;const d=this._postProcesses.indexOf(Y);-1!==d&&(this._postProcesses.splice(d,1),this._postProcesses.length>0&&(this._postProcesses[0].Hl=!1))}_shouldRender(){return-1===this._currentRefreshId||this.refreshRate===this._currentRefreshId?(this._currentRefreshId=1,!0):(this._currentRefreshId++,!1)}getRenderSize(){return this.getRenderWidth()}getRenderWidth(){return this._size.width?this._size.width:this._size}getRenderHeight(){return this._size.width?this._size.height:this._size}getRenderLayers(){const Y=this._size.layers;if(Y)return Y;const d=this._size.depth;return d||0}disableRescaling(){this._canRescale=!1}get canRescale(){return this._canRescale}scale(Y){const d=Math.max(1,this.getRenderSize()*Y);this.resize(d)}getReflectionTextureMatrix(){return this.isCube?this._textureMatrix:super.getReflectionTextureMatrix()}resize(Y){var d;const t=this.isCube;null===(d=this._renderTarget)||void 0===d||d.dispose(),this._renderTarget=null;const x=this.va();x&&(this._processSizeParameter(Y,!1),this._renderTarget=t?x.getEngine().createRenderTargetCubeTexture(this.getRenderSize(),this._renderTargetOptions):x.getEngine().createRenderTargetTexture(this._size,this._renderTargetOptions),this._texture=this._renderTarget.texture,void 0!==this._renderTargetOptions.samples&&(this.samples=this._renderTargetOptions.samples),this.onResizeObservable.hasObservers()&&this.onResizeObservable.notifyObservers(this))}render(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0],d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._render(Y,d)}isReadyForRendering(){return this._dumpToolsLoading||(this._dumpToolsLoading=!0,t.e(9).then(t.bind(t,2220)).then((Y=>this._dumpTools=Y))),this._render(!1,!1,!0)}_render(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0],d=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const x=this.va();if(!x)return t;const C=x.getEngine();if(void 0!==this.useCameraPostProcesses&&(Y=this.useCameraPostProcesses),this._waitingRenderList){if(!this.renderListPredicate){this.renderList=[];for(let Y=0;Y<this._waitingRenderList.length;Y++){const d=this._waitingRenderList[Y],t=x.getMeshById(d);t&&this.renderList.push(t)}}this._waitingRenderList=void 0}if(this.renderListPredicate){this.renderList?this.renderList.length=0:this.renderList=[];const Y=this.va();if(!Y)return t;const d=Y.meshes;for(let t=0;t<d.length;t++){const Y=d[t];this.renderListPredicate(Y)&&this.renderList.push(Y)}}const U=C.currentRenderPassId;this.onBeforeBindObservable.notifyObservers(this);const y=this.activeCamera??x.activeCamera,B=x.activeCamera;y&&(y!==x.activeCamera&&(x.setTransformMatrix(y.getViewMatrix(),y.getProjectionMatrix(!0)),x.activeCamera=y),C.setViewport(y.rigParent?y.rigParent.viewport:y.viewport,this.getRenderWidth(),this.getRenderHeight())),this._defaultRenderListPrepared=!1;let W=t;if(t){x.getViewMatrix()||x.updateTransformMatrix();const Y=this.is2DArray||this.is3D?this.getRenderLayers():this.isCube?6:1;for(let U=0;U<Y&&W;U++){let Y=null;const d=this.renderList?this.renderList:x.getActiveMeshes().data,y=this.renderList?this.renderList.length:x.getActiveMeshes().length;C.currentRenderPassId=this._renderPassIds[U],this.onBeforeRenderObservable.notifyObservers(U),this.getCustomRenderList&&(Y=this.getCustomRenderList(U,d,y)),Y||(Y=d),this._doNotChangeAspectRatio||x.updateTransformMatrix(!0);for(let x=0;x<Y.length&&W;++x){const d=Y[x];if(d.isEnabled()&&!d.isBlocked&&d.isVisible&&d.sk)if(this.customIsReadyFunction){if(!this.customIsReadyFunction(d,this.refreshRate,t)){W=!1;continue}}else if(!d.isReady(!0)){W=!1;continue}}this.onAfterRenderObservable.notifyObservers(U),(this.is2DArray||this.is3D||this.isCube)&&(x.incrementRenderId(),x.resetCachedMaterial())}const d=this.particleSystemList||x.Dk;for(const t of d)t.isReady()||(W=!1)}else if(!this.is2DArray&&!this.is3D||this.isMulti)if(this.isCube&&!this.isMulti)for(let o=0;o<6;o++)this._renderToTarget(o,Y,d,void 0,y),x.incrementRenderId(),x.resetCachedMaterial();else this._renderToTarget(0,Y,d,void 0,y);else for(let o=0;o<this.getRenderLayers();o++)this._renderToTarget(0,Y,d,o,y),x.incrementRenderId(),x.resetCachedMaterial();return this.onAfterUnbindObservable.notifyObservers(this),C.currentRenderPassId=U,x.activeCamera=B,B&&(this.activeCamera&&this.activeCamera!==x.activeCamera&&x.setTransformMatrix(B.getViewMatrix(),B.getProjectionMatrix(!0)),C.setViewport(B.viewport)),x.resetCachedMaterial(),W}_bestReflectionRenderTargetDimension(Y,d){const t=Y*d,x=(0,o.m)(t+16384/(128+t));return Math.min((0,o.c)(Y),x)}_prepareRenderingManager(Y,d,t,x){const C=this.va();if(!C)return;this._renderingManager.reset();const U=C.getRenderId();for(let B=0;B<d;B++){const d=Y[B];if(d&&!d.isBlocked){if(this.customIsReadyFunction){if(!this.customIsReadyFunction(d,this.refreshRate,!1)){this.resetRefreshCounter();continue}}else if(!d.isReady(0===this.refreshRate)){this.resetRefreshCounter();continue}if(!d._internalAbstractMeshDataInfo._currentLODIsUpToDate&&t&&(d._internalAbstractMeshDataInfo._currentLOD=C.customLODSelector?C.customLODSelector(d,t):d.getLOD(t),d._internalAbstractMeshDataInfo._currentLODIsUpToDate=!0),!d._internalAbstractMeshDataInfo._currentLOD)continue;let Y,y=d._internalAbstractMeshDataInfo._currentLOD;if(y!==d&&0!==y.billboardMode&&y.dk(),y._preActivateForIntermediateRendering(U),Y=!(!x||!t)&&0===(d.layerMask&t.layerMask),d.isEnabled()&&d.isVisible&&d.sk&&!Y){if(y!==d&&y._activate(U,!0),d._activate(U,!0)&&d.sk.length){d.isAnInstance?d._internalAbstractMeshDataInfo._actAsRegularMesh&&(y=d):y._internalAbstractMeshDataInfo._onlyForInstancesIntermediate=!1,y._internalAbstractMeshDataInfo._isActiveIntermediate=!0,C._prepareSkeleton(y);for(let Y=0;Y<y.sk.length;Y++){const d=y.sk[Y];this._renderingManager.dispatch(d,y)}}d._postActivate()}}}const y=this.particleSystemList||C.Dk;for(let B=0;B<y.length;B++){const Y=y[B],d=Y.j;Y.isStarted()&&d&&(!d.position||d.isEnabled())&&this._renderingManager.dispatchParticles(Y)}}_bindFrameBuffer(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const t=this.va();if(!t)return;const x=t.getEngine();this._renderTarget&&x.bindFramebuffer(this._renderTarget,this.isCube?Y:void 0,void 0,void 0,this.ignoreCameraViewport,0,d)}_unbindFrameBuffer(Y,d){this._renderTarget&&Y.unBindFramebuffer(this._renderTarget,this.isCube,(()=>{this.onAfterRenderObservable.notifyObservers(d)}))}_prepareFrame(Y,d,t,x){this._postProcessManager?this._prePassEnabled||this._postProcessManager._prepareFrame(this._texture,this._postProcesses):x&&Y.postProcessManager._prepareFrame(this._texture)||this._bindFrameBuffer(d,t)}_renderToTarget(Y,d,t){var x,C;let U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const B=this.va();if(!B)return;const W=B.getEngine();this._prepareFrame(B,Y,U,d),null===(x=W._debugPushGroup)||void 0===x||x.call(W,`render to face #${Y} layer #${U}`,2),this.is2DArray||this.is3D?(W.currentRenderPassId=this._renderPassIds[U],this.onBeforeRenderObservable.notifyObservers(U)):(W.currentRenderPassId=this._renderPassIds[Y],this.onBeforeRenderObservable.notifyObservers(Y));if(W.snapshotRendering&&1===W.snapshotRenderingMode)this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(W):this.skipInitialClear||W.clear(this.clearColor||B.clearColor,!0,!0,!0);else{var o;let x=null;const C=this.renderList?this.renderList:B.getActiveMeshes().data,f=this.renderList?this.renderList.length:B.getActiveMeshes().length;this.getCustomRenderList&&(x=this.getCustomRenderList(this.is2DArray||this.is3D?U:Y,C,f)),x?this._prepareRenderingManager(x,x.length,y,this.forceLayerMaskCheck):(this._defaultRenderListPrepared||(this._prepareRenderingManager(C,f,y,!this.renderList||this.forceLayerMaskCheck),this._defaultRenderListPrepared=!0),x=C);for(const d of B._beforeRenderTargetClearStage)d.action(this,Y,U);this.onClearObservable.hasObservers()?this.onClearObservable.notifyObservers(W):this.skipInitialClear||W.clear(this.clearColor||B.clearColor,!0,!0,!0),this._doNotChangeAspectRatio||B.updateTransformMatrix(!0);for(const d of B._beforeRenderTargetDrawStage)d.action(this,Y,U);this._renderingManager.render(this.customRenderFunction,x,this.renderParticles,this.renderSprites);for(const d of B._afterRenderTargetDrawStage)d.action(this,Y,U);const D=(null===(o=this._texture)||void 0===o?void 0:o.generateMipMaps)??!1;this._texture&&(this._texture.generateMipMaps=!1),this._postProcessManager?this._postProcessManager._finalizeFrame(!1,this._renderTarget??void 0,Y,this._postProcesses,this.ignoreCameraViewport):d&&B.postProcessManager._finalizeFrame(!1,this._renderTarget??void 0,Y);for(const d of B._afterRenderTargetPostProcessStage)d.action(this,Y,U);this._texture&&(this._texture.generateMipMaps=D),this._doNotChangeAspectRatio||B.updateTransformMatrix(!0),t&&(this._dumpTools?this._dumpTools.DumpFramebuffer(this.getRenderWidth(),this.getRenderHeight(),W):F.c.Error("dumpTools module is still being loaded. To speed up the process import dump tools directly in your project"))}null===(C=W._debugPopGroup)||void 0===C||C.call(W,2),this._unbindFrameBuffer(W,Y),this._texture&&this.isCube&&5===Y&&W.generateMipMapsForCubemap(this._texture,!0)}setRenderingOrder(Y){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;this._renderingManager.setRenderingOrder(Y,d,t,x)}setRenderingAutoClearDepthStencil(Y,d){this._renderingManager.setRenderingAutoClearDepthStencil(Y,d),this._renderingManager._useSceneAutoClearSetup=!1}clone(){const Y=this.getSize(),d=new D(this.name,Y,this.va(),this._renderTargetOptions.generateMipMaps,this._doNotChangeAspectRatio,this._renderTargetOptions.type,this.isCube,this._renderTargetOptions.samplingMode,this._renderTargetOptions.generateDepthBuffer,this._renderTargetOptions.generateStencilBuffer,void 0,this._renderTargetOptions.format,void 0,this._renderTargetOptions.samples);return d.wi=this.wi,d.level=this.level,d.coordinatesMode=this.coordinatesMode,this.renderList&&(d.renderList=this.renderList.slice(0)),d}serialize(){if(!this.name)return null;const Y=super.serialize();if(Y.renderTargetSize=this.getRenderSize(),Y.renderList=[],this.renderList)for(let d=0;d<this.renderList.length;d++)Y.renderList.push(this.renderList[d].id);return Y}disposeFramebufferObjects(){var Y;null===(Y=this._renderTarget)||void 0===Y||Y.dispose(!0)}releaseInternalTexture(){var Y;null===(Y=this._renderTarget)||void 0===Y||Y.releaseTextures(),this._texture=null}dispose(){var Y;this.onResizeObservable.clear(),this.onClearObservable.clear(),this.onAfterRenderObservable.clear(),this.onAfterUnbindObservable.clear(),this.onBeforeBindObservable.clear(),this.onBeforeRenderObservable.clear(),this._postProcessManager&&(this._postProcessManager.dispose(),this._postProcessManager=null),this._prePassRenderTarget&&this._prePassRenderTarget.dispose(),this._releaseRenderPassId(),this.clearPostProcesses(!0),this._resizeObserver&&(this.va().getEngine().onResizeObservable.remove(this._resizeObserver),this._resizeObserver=null),this.renderList=null;const d=this.va();if(!d)return;let t=d.customRenderTargets.indexOf(this);t>=0&&d.customRenderTargets.splice(t,1);for(const x of d.cameras)t=x.customRenderTargets.indexOf(this),t>=0&&x.customRenderTargets.splice(t,1);null===(Y=this._renderTarget)||void 0===Y||Y.dispose(),this._renderTarget=null,this._texture=null,super.dispose()}_rebuild(){this.refreshRate===D.REFRESHRATE_RENDER_ONCE&&(this.refreshRate=D.REFRESHRATE_RENDER_ONCE),this._postProcessManager&&this._postProcessManager._rebuild()}freeRenderingGroups(){this._renderingManager&&this._renderingManager.freeRenderingGroups()}getViewCount(){return 1}}D.REFRESHRATE_RENDER_ONCE=0,D.REFRESHRATE_RENDER_ONEVERYFRAME=1,D.REFRESHRATE_RENDER_ONEVERYTWOFRAMES=2,U.d._CreateRenderTargetTexture=(Y,d,t,x,C)=>new D(Y,d,t,x)},2111:(Y,d,t)=>{t.d(d,{b:()=>o,e:()=>f});var x=t(749),C=t(731),U=t(513),y=t(590),B=t(801);t(2115);const W={xa:[1,1,-1,1,-1,-1,1,-1],indices:[0,1,2,0,2,3]};class o{constructor(Y){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:W;this._fullscreenViewport=new C.b(0,0,1,1);const t=d.xa??W.xa,U=d.indices??W.indices;this.Xj=Y,this._vertexBuffers={[x.d.PositionKind]:new x.d(Y,t,x.d.PositionKind,!1,!1,2)},this._indexBuffer=Y.createIndexBuffer(U),this._onContextRestoredObserver=Y.onContextRestoredObservable.add((()=>{this._indexBuffer=Y.createIndexBuffer(U);for(const Y in this._vertexBuffers){this._vertexBuffers[Y]._rebuild()}}))}setViewport(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._fullscreenViewport;this.Xj.setViewport(Y)}bindBuffers(Y){this.Xj.bindBuffers(this._vertexBuffers,this._indexBuffer,Y)}applyEffectWrapper(Y){this.Xj.setState(!0),this.Xj.depthCullingState.depthTest=!1,this.Xj.stencilState.stencilTest=!1,this.Xj.enableEffect(Y.drawWrapper),this.bindBuffers(Y.effect),Y.onApplyObservable.notifyObservers({})}saveStates(){this._savedStateDepthTest=this.Xj.depthCullingState.depthTest,this._savedStateStencilTest=this.Xj.stencilState.stencilTest}restoreStates(){this.Xj.depthCullingState.depthTest=this._savedStateDepthTest,this.Xj.stencilState.stencilTest=this._savedStateStencilTest}draw(){this.Xj.drawElementsType(0,0,6)}_isRenderTargetTexture(Y){return void 0!==Y.renderTarget}render(Y){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(!Y.effect.isReady())return;this.saveStates(),this.setViewport();const t=null===d?null:this._isRenderTargetTexture(d)?d.renderTarget:d;t&&this.Xj.bindFramebuffer(t),this.applyEffectWrapper(Y),this.draw(),t&&this.Xj.unBindFramebuffer(t),this.restoreStates()}dispose(){const Y=this._vertexBuffers[x.d.PositionKind];Y&&(Y.dispose(),delete this._vertexBuffers[x.d.PositionKind]),this._indexBuffer&&this.Xj._releaseBuffer(this._indexBuffer),this._onContextRestoredObserver&&(this.Xj.onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null)}}class f{static RegisterShaderCodeProcessing(Y,d){d?f._CustomShaderCodeProcessing[Y??""]=d:delete f._CustomShaderCodeProcessing[Y??""]}static _GetShaderCodeProcessing(Y){return f._CustomShaderCodeProcessing[Y]??f._CustomShaderCodeProcessing[""]}get name(){return this.options.name}set name(Y){this.options.name=Y}isReady(){var Y;return(null===(Y=this._drawWrapper.effect)||void 0===Y?void 0:Y.isReady())??!1}get drawWrapper(){return this._drawWrapper}get effect(){return this._drawWrapper.effect}set effect(Y){this._drawWrapper.effect=Y}constructor(Y){this.alphaMode=0,this.onEffectCreatedObservable=new U.b(void 0,!0),this.onApplyObservable=new U.b,this._shadersLoaded=!1,this._webGPUReady=!1,this._importPromises=[],this.options={...Y,name:Y.name||"effectWrapper",Xj:Y.Xj,uniforms:Y.uniforms||Y.uniformNames||[],uniformNames:void 0,samplers:Y.samplers||Y.samplerNames||[],samplerNames:void 0,attributeNames:Y.attributeNames||["position"],uniformBuffers:Y.uniformBuffers||[],defines:Y.defines||"",useShaderStore:Y.useShaderStore||!1,vertexUrl:Y.vertexUrl||Y.vertexShader||"postprocess",vertexShader:void 0,fragmentShader:Y.fragmentShader||"pass",indexParameters:Y.indexParameters,blockCompilation:Y.blockCompilation||!1,shaderLanguage:Y.shaderLanguage||0,onCompiled:Y.onCompiled||void 0,extraInitializations:Y.extraInitializations||void 0,extraInitializationsAsync:Y.extraInitializationsAsync||void 0,useAsPostProcess:Y.useAsPostProcess??!1},this.options.uniformNames=this.options.uniforms,this.options.samplerNames=this.options.samplers,this.options.vertexShader=this.options.vertexUrl,this.options.useAsPostProcess&&(-1===this.options.samplers.indexOf("textureSampler")&&this.options.samplers.push("textureSampler"),-1===this.options.uniforms.indexOf("scale")&&this.options.uniforms.push("scale")),Y.vertexUrl||Y.vertexShader?this._shaderPath={vertexSource:this.options.vertexShader}:(this.options.useAsPostProcess||(this.options.uniforms.push("scale"),this.onApplyObservable.add((()=>{this.effect.setFloat2("scale",1,1)}))),this._shaderPath={vertex:this.options.vertexShader}),this._shaderPath.fragmentSource=this.options.fragmentShader,this._shaderPath.spectorName=this.options.name,this.options.useShaderStore&&(this._shaderPath.fragment=this._shaderPath.fragmentSource,this._shaderPath.vertex||(this._shaderPath.vertex=this._shaderPath.vertexSource),delete this._shaderPath.fragmentSource,delete this._shaderPath.vertexSource),this.onApplyObservable.add((()=>{this.bind()})),this.options.useShaderStore||(this._onContextRestoredObserver=this.options.Xj.onContextRestoredObservable.add((()=>{this.effect._pipelineContext=null,this.effect._prepareEffect()}))),this._drawWrapper=new B.b(this.options.Xj),this._webGPUReady=1===this.options.shaderLanguage;const d=Array.isArray(this.options.defines)?this.options.defines.join("\n"):this.options.defines;this._postConstructor(this.options.blockCompilation,d,this.options.extraInitializations)}_gatherImports(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0],d=arguments.length>1?arguments[1]:void 0;this.options.useAsPostProcess&&(Y&&this._webGPUReady?d.push(Promise.all([t.e(36).then(t.bind(t,12875))])):d.push(Promise.all([Promise.resolve().then(t.bind(t,2115))])))}_postConstructor(Y){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2?arguments[2]:void 0,x=arguments.length>3?arguments[3]:void 0;this._importPromises.length=0,x&&this._importPromises.push(...x);const C=this.options.Xj.isWebGPU&&!f.ForceGLSL;this._gatherImports(C,this._importPromises),void 0!==t&&t(C,this._importPromises),C&&this._webGPUReady&&(this.options.shaderLanguage=1),Y||this.updateEffect(d)}updateEffect(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,x=arguments.length>3?arguments[3]:void 0,C=arguments.length>4?arguments[4]:void 0,U=arguments.length>5?arguments[5]:void 0,B=arguments.length>6?arguments[6]:void 0,W=arguments.length>7?arguments[7]:void 0;const o=f._GetShaderCodeProcessing(this.name);if(null!==o&&void 0!==o&&o.defineCustomBindings){var F,D;const x=(null===(F=d)||void 0===F?void 0:F.slice())??[];x.push(...this.options.uniforms);const C=(null===(D=t)||void 0===D?void 0:D.slice())??[];C.push(...this.options.samplers),Y=o.defineCustomBindings(this.name,Y,x,C),d=x,t=C}this.options.defines=Y||"";const b=this._shadersLoaded||0===this._importPromises.length?void 0:async()=>{await Promise.all(this._importPromises),this._shadersLoaded=!0};let m;m=this.options.extraInitializationsAsync?async()=>{null===b||void 0===b||b(),await this.options.extraInitializationsAsync}:b,this.options.useShaderStore?this._drawWrapper.effect=this.options.Xj.createEffect({vertex:B??this._shaderPath.vertex,fragment:W??this._shaderPath.fragment},{attributes:this.options.attributeNames,uniformsNames:d||this.options.uniforms,uniformBuffersNames:this.options.uniformBuffers,samplers:t||this.options.samplers,defines:null!==Y?Y:"",fallbacks:null,onCompiled:C??this.options.onCompiled,onError:U??null,indexParameters:x||this.options.indexParameters,processCodeAfterIncludes:null!==o&&void 0!==o&&o.processCodeAfterIncludes?(Y,d)=>o.processCodeAfterIncludes(this.name,Y,d):null,processFinalCode:null!==o&&void 0!==o&&o.processFinalCode?(Y,d)=>o.processFinalCode(this.name,Y,d):null,shaderLanguage:this.options.shaderLanguage,extraInitializationsAsync:m},this.options.Xj):this._drawWrapper.effect=new y.b(this._shaderPath,this.options.attributeNames,d||this.options.uniforms,t||this.options.samplerNames,this.options.Xj,Y,void 0,C||this.options.onCompiled,void 0,void 0,void 0,this.options.shaderLanguage,m),this.onEffectCreatedObservable.notifyObservers(this._drawWrapper.effect)}bind(){var Y,d;this.options.useAsPostProcess&&(this.options.Xj.setAlphaMode(this.alphaMode),this.drawWrapper.effect.setFloat2("scale",1,1)),null===(Y=f._GetShaderCodeProcessing(this.name))||void 0===Y||null===(d=Y.bindCustomBindings)||void 0===d||d.call(Y,this.name,this._drawWrapper.effect)}dispose(){this._onContextRestoredObserver&&(this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=null),this.onEffectCreatedObservable.clear(),this.effect.dispose()}}f.ForceGLSL=!1,f._CustomShaderCodeProcessing={}},2048:(Y,d,t)=>{t.d(d,{d:()=>x.b,h:()=>x.d,i:()=>x.g,k:()=>x.k});t(856),t(728),t(694),t(735),t(2051),t(743),t(2055);var x=t(686);t(731)},2051:(Y,d,t)=>{t.d(d,{d:()=>B,f:()=>f,h:()=>F});var x,C=t(705),U=t(686),y=t(694);!function(Y){Y[Y.CW=0]="CW",Y[Y.CCW=1]="CCW"}(x||(x={}));class B{static Interpolate(Y,d,t,x,C){const U=1-3*x+3*d,y=3*x-6*d,B=3*d;let W=Y;for(let o=0;o<5;o++){const d=W*W;W-=(U*(d*W)+y*d+B*W-Y)*(1/(3*U*d+2*y*W+B)),W=Math.min(1,Math.max(0,W))}return 3*Math.pow(1-W,2)*W*t+3*(1-W)*Math.pow(W,2)*C+Math.pow(W,3)}}class W{constructor(Y){this._radians=Y,this._radians<0&&(this._radians+=2*Math.PI)}degrees(){return 180*this._radians/Math.PI}radians(){return this._radians}static BetweenTwoPoints(Y,d){const t=d.ae(Y),x=Math.atan2(t.y,t.x);return new W(x)}static BetweenTwoVectors(Y,d){let t=Y.lengthSquared()*d.lengthSquared();if(0===t)return new W(Math.PI/2);t=Math.sqrt(t);let x=Y.dot(d)/t;x=(0,C.b)(x,-1,1);const U=Math.acos(x);return new W(U)}static FromRadians(Y){return new W(Y)}static FromDegrees(Y){return new W(Y*Math.PI/180)}}class o{constructor(Y,d,t){this.startPoint=Y,this.midPoint=d,this.endPoint=t;const x=Math.pow(d.x,2)+Math.pow(d.y,2),C=(Math.pow(Y.x,2)+Math.pow(Y.y,2)-x)/2,y=(x-Math.pow(t.x,2)-Math.pow(t.y,2))/2,B=(Y.x-d.x)*(d.y-t.y)-(d.x-t.x)*(Y.y-d.y);this.centerPoint=new U.i((C*(d.y-t.y)-y*(Y.y-d.y))/B,((Y.x-d.x)*y-(d.x-t.x)*C)/B),this.radius=this.centerPoint.ae(this.startPoint).length(),this.startAngle=W.BetweenTwoPoints(this.centerPoint,this.startPoint);const o=this.startAngle.degrees();let f=W.BetweenTwoPoints(this.centerPoint,this.midPoint).degrees(),F=W.BetweenTwoPoints(this.centerPoint,this.endPoint).degrees();f-o>180&&(f-=360),f-o<-180&&(f+=360),F-f>180&&(F-=360),F-f<-180&&(F+=360),this.orientation=f-o<0?0:1,this.angle=W.FromDegrees(0===this.orientation?o-F:F-o)}}class f{constructor(Y,d){this._points=new Array,this._length=0,this.closed=!1,this._points.push(new U.i(Y,d))}addLineTo(Y,d){if(this.closed)return this;const t=new U.i(Y,d),x=this._points[this._points.length-1];return this._points.push(t),this._length+=t.ae(x).length(),this}addArcTo(Y,d,t,x){let C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:36;if(this.closed)return this;const y=this._points[this._points.length-1],B=new U.i(Y,d),W=new U.i(t,x),f=new o(y,B,W);let F=f.angle.radians()/C;0===f.orientation&&(F*=-1);let D=f.startAngle.radians()+F;for(let U=0;U<C;U++){const Y=Math.cos(D)*f.radius+f.centerPoint.x,d=Math.sin(D)*f.radius+f.centerPoint.y;this.addLineTo(Y,d),D+=F}return this}addQuadraticCurveTo(Y,d,t,x){let C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:36;if(this.closed)return this;const U=(Y,d,t,x)=>(1-Y)*(1-Y)*d+2*Y*(1-Y)*t+Y*Y*x,y=this._points[this._points.length-1];for(let B=0;B<=C;B++){const W=B/C,o=U(W,y.x,Y,t),f=U(W,y.y,d,x);this.addLineTo(o,f)}return this}addBezierCurveTo(Y,d,t,x,C,U){let y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:36;if(this.closed)return this;const B=(Y,d,t,x,C)=>(1-Y)*(1-Y)*(1-Y)*d+3*Y*(1-Y)*(1-Y)*t+3*Y*Y*(1-Y)*x+Y*Y*Y*C,W=this._points[this._points.length-1];for(let o=0;o<=y;o++){const f=o/y,F=B(f,W.x,Y,t,C),D=B(f,W.y,d,x,U);this.addLineTo(F,D)}return this}isPointInside(Y){let d=!1;const t=this._points.length;for(let x=t-1,C=0;C<t;x=C++){let t=this._points[x],U=this._points[C],y=U.x-t.x,B=U.y-t.y;if(Math.abs(B)>Number.EPSILON){if(B<0&&(t=this._points[C],y=-y,U=this._points[x],B=-B),Y.y<t.y||Y.y>U.y)continue;if(Y.y===t.y&&Y.x===t.x)return!0;{const x=B*(Y.x-t.x)-y*(Y.y-t.y);if(0===x)return!0;if(x<0)continue;d=!d}}else{if(Y.y!==t.y)continue;if(U.x<=Y.x&&Y.x<=t.x||t.x<=Y.x&&Y.x<=U.x)return!0}}return d}close(){return this.closed=!0,this}length(){let Y=this._length;if(this.closed){const d=this._points[this._points.length-1];Y+=this._points[0].ae(d).length()}return Y}area(){const Y=this._points.length;let d=0;for(let t=Y-1,x=0;x<Y;t=x++)d+=this._points[t].x*this._points[x].y-this._points[x].x*this._points[t].y;return.5*d}getPoints(){return this._points}getPointAtLengthPosition(Y){if(Y<0||Y>1)return U.i.Zero();const d=Y*this.length();let t=0;for(let x=0;x<this._points.length;x++){const Y=(x+1)%this._points.length,C=this._points[x],y=this._points[Y].ae(C),B=y.length()+t;if(d>=t&&d<=B){const Y=y.normalize(),x=d-t;return new U.i(C.x+Y.x*x,C.y+Y.y*x)}t=B}return U.i.Zero()}static StartingAt(Y,d){return new f(Y,d)}}class F{constructor(Y){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2?arguments[2]:void 0,x=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.path=Y,this._curve=new Array,this._distances=new Array,this._tangents=new Array,this._normals=new Array,this._binormals=new Array,this._pointAtData={id:0,point:U.k.Zero(),previousPointArrayIndex:0,position:0,subPosition:0,interpolateReady:!1,interpolationMatrix:U.b.Identity()};for(let C=0;C<Y.length;C++)this._curve[C]=Y[C].clone();this._raw=t||!1,this._alignTangentsWithPath=x,this._compute(d,x)}getCurve(){return this._curve}getPoints(){return this._curve}length(){return this._distances[this._distances.length-1]}getTangents(){return this._tangents}getNormals(){return this._normals}getBinormals(){return this._binormals}getDistances(){return this._distances}getPointAt(Y){return this._updatePointAtData(Y).point}getTangentAt(Y){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this._updatePointAtData(Y,d),d?U.k.TransformCoordinates(U.k.Forward(),this._pointAtData.interpolationMatrix):this._tangents[this._pointAtData.previousPointArrayIndex]}getNormalAt(Y){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this._updatePointAtData(Y,d),d?U.k.TransformCoordinates(U.k.Right(),this._pointAtData.interpolationMatrix):this._normals[this._pointAtData.previousPointArrayIndex]}getBinormalAt(Y){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return this._updatePointAtData(Y,d),d?U.k.TransformCoordinates(U.k.UpReadOnly,this._pointAtData.interpolationMatrix):this._binormals[this._pointAtData.previousPointArrayIndex]}getDistanceAt(Y){return this.length()*Y}getPreviousPointIndexAt(Y){return this._updatePointAtData(Y),this._pointAtData.previousPointArrayIndex}getSubPositionAt(Y){return this._updatePointAtData(Y),this._pointAtData.subPosition}getClosestPositionTo(Y){let d=Number.MAX_VALUE,t=0;for(let x=0;x<this._curve.length-1;x++){const C=this._curve[x+0],y=this._curve[x+1].ae(C).normalize(),B=this._distances[x+1]-this._distances[x+0],W=Math.min(Math.max(U.k.Dot(y,Y.ae(C).normalize()),0)*U.k.Distance(C,Y)/B,1),o=U.k.Distance(C.add(y.scale(W*B)),Y);o<d&&(d=o,t=(this._distances[x+0]+B*W)/this.length())}return t}slice(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(Y<0&&(Y=1- -1*Y%1),d<0&&(d=1- -1*d%1),Y>d){const t=Y;Y=d,d=t}const t=this.getCurve(),x=this.getPointAt(Y);let C=this.getPreviousPointIndexAt(Y);const U=this.getPointAt(d),y=this.getPreviousPointIndexAt(d)+1,B=[];return 0!==Y&&(C++,B.push(x)),B.push(...t.slice(C,y)),1===d&&1!==Y||B.push(U),new F(B,this.getNormalAt(Y),this._raw,this._alignTangentsWithPath)}update(Y){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];for(let x=0;x<Y.length;x++)this._curve[x].x=Y[x].x,this._curve[x].y=Y[x].y,this._curve[x].z=Y[x].z;return this._compute(d,t),this}_compute(Y){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const t=this._curve.length;if(t<2)return;this._tangents[0]=this._getFirstNonNullVector(0),this._raw||this._tangents[0].normalize(),this._tangents[t-1]=this._curve[t-1].ae(this._curve[t-2]),this._raw||this._tangents[t-1].normalize();const x=this._tangents[0],C=this._normalVector(x,Y);let y,B,W,o,f;this._normals[0]=C,this._raw||this._normals[0].normalize(),this._binormals[0]=U.k.Cross(x,this._normals[0]),this._raw||this._binormals[0].normalize(),this._distances[0]=0;for(let F=1;F<t;F++)y=this._getLastNonNullVector(F),F<t-1&&(B=this._getFirstNonNullVector(F),this._tangents[F]=d?B:y.add(B),this._tangents[F].normalize()),this._distances[F]=this._distances[F-1]+this._curve[F].ae(this._curve[F-1]).length(),W=this._tangents[F],f=this._binormals[F-1],this._normals[F]=U.k.Cross(f,W),this._raw||(0===this._normals[F].length()?(o=this._normals[F-1],this._normals[F]=o.clone()):this._normals[F].normalize()),this._binormals[F]=U.k.Cross(W,this._normals[F]),this._raw||this._binormals[F].normalize();this._pointAtData.id=NaN}_getFirstNonNullVector(Y){let d=1,t=this._curve[Y+d].ae(this._curve[Y]);for(;0===t.length()&&Y+d+1<this._curve.length;)d++,t=this._curve[Y+d].ae(this._curve[Y]);return t}_getLastNonNullVector(Y){let d=1,t=this._curve[Y].ae(this._curve[Y-d]);for(;0===t.length()&&Y>d+1;)d++,t=this._curve[Y].ae(this._curve[Y-d]);return t}_normalVector(Y,d){let t,x=Y.length();if(0===x&&(x=1),void 0===d||null===d){let d;d=(0,C.v)(Math.abs(Y.y)/x,1,y.c)?(0,C.v)(Math.abs(Y.x)/x,1,y.c)?(0,C.v)(Math.abs(Y.z)/x,1,y.c)?U.k.Zero():new U.k(0,0,1):new U.k(1,0,0):new U.k(0,-1,0),t=U.k.Cross(Y,d)}else t=U.k.Cross(Y,d),U.k.CrossToRef(t,Y,t);return t.normalize(),t}_updatePointAtData(Y){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this._pointAtData.id===Y)return this._pointAtData.interpolateReady||this._updateInterpolationMatrix(),this._pointAtData;this._pointAtData.id=Y;const t=this.getPoints();if(Y<=0)return this._setPointAtData(0,0,t[0],0,d);if(Y>=1)return this._setPointAtData(1,1,t[t.length-1],t.length-1,d);let x,C=t[0],y=0;const B=Y*this.length();for(let W=1;W<t.length;W++){x=t[W];const o=U.k.Distance(C,x);if(y+=o,y===B)return this._setPointAtData(Y,1,x,W,d);if(y>B){const t=(y-B)/o,U=C.ae(x),f=x.add(U.scaleInPlace(t));return this._setPointAtData(Y,1-t,f,W-1,d)}C=x}return this._pointAtData}_setPointAtData(Y,d,t,x,C){return this._pointAtData.point=t,this._pointAtData.position=Y,this._pointAtData.subPosition=d,this._pointAtData.previousPointArrayIndex=x,this._pointAtData.interpolateReady=C,C&&this._updateInterpolationMatrix(),this._pointAtData}_updateInterpolationMatrix(){this._pointAtData.interpolationMatrix=U.b.Identity();const Y=this._pointAtData.previousPointArrayIndex;if(Y!==this._tangents.length-1){const d=Y+1,t=this._tangents[Y].clone(),x=this._normals[Y].clone(),C=this._binormals[Y].clone(),y=this._tangents[d].clone(),B=this._normals[d].clone(),W=this._binormals[d].clone(),o=U.d.RotationQuaternionFromAxis(x,C,t),f=U.d.RotationQuaternionFromAxis(B,W,y);U.d.Slerp(o,f,this._pointAtData.subPosition).toRotationMatrix(this._pointAtData.interpolationMatrix)}}}},2043:(Y,d,t)=>{t.d(d,{e:()=>o,i:()=>f});var x=t(686),C=t(2048);const U=[Math.sqrt(1/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(3/(4*Math.PI)),-Math.sqrt(3/(4*Math.PI)),Math.sqrt(15/(4*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(5/(16*Math.PI)),-Math.sqrt(15/(4*Math.PI)),Math.sqrt(15/(16*Math.PI))],y=[()=>1,Y=>Y.y,Y=>Y.z,Y=>Y.x,Y=>Y.x*Y.y,Y=>Y.y*Y.z,Y=>3*Y.z*Y.z-1,Y=>Y.x*Y.z,Y=>Y.x*Y.x-Y.y*Y.y],B=(Y,d)=>U[Y]*y[Y](d),W=[Math.PI,2*Math.PI/3,2*Math.PI/3,2*Math.PI/3,Math.PI/4,Math.PI/4,Math.PI/4,Math.PI/4,Math.PI/4];class o{constructor(){this.preScaled=!1,this.l00=x.k.Zero(),this.l1_1=x.k.Zero(),this.l10=x.k.Zero(),this.l11=x.k.Zero(),this.l2_2=x.k.Zero(),this.l2_1=x.k.Zero(),this.l20=x.k.Zero(),this.l21=x.k.Zero(),this.l22=x.k.Zero()}addLight(Y,d,t){C.i.gk[0].set(d.r,d.g,d.b);const x=C.i.gk[0],U=C.i.gk[1];x.scaleToRef(t,U),U.scaleToRef(B(0,Y),C.i.gk[2]),this.l00.addInPlace(C.i.gk[2]),U.scaleToRef(B(1,Y),C.i.gk[2]),this.l1_1.addInPlace(C.i.gk[2]),U.scaleToRef(B(2,Y),C.i.gk[2]),this.l10.addInPlace(C.i.gk[2]),U.scaleToRef(B(3,Y),C.i.gk[2]),this.l11.addInPlace(C.i.gk[2]),U.scaleToRef(B(4,Y),C.i.gk[2]),this.l2_2.addInPlace(C.i.gk[2]),U.scaleToRef(B(5,Y),C.i.gk[2]),this.l2_1.addInPlace(C.i.gk[2]),U.scaleToRef(B(6,Y),C.i.gk[2]),this.l20.addInPlace(C.i.gk[2]),U.scaleToRef(B(7,Y),C.i.gk[2]),this.l21.addInPlace(C.i.gk[2]),U.scaleToRef(B(8,Y),C.i.gk[2]),this.l22.addInPlace(C.i.gk[2])}scaleInPlace(Y){this.l00.scaleInPlace(Y),this.l1_1.scaleInPlace(Y),this.l10.scaleInPlace(Y),this.l11.scaleInPlace(Y),this.l2_2.scaleInPlace(Y),this.l2_1.scaleInPlace(Y),this.l20.scaleInPlace(Y),this.l21.scaleInPlace(Y),this.l22.scaleInPlace(Y)}convertIncidentRadianceToIrradiance(){this.l00.scaleInPlace(W[0]),this.l1_1.scaleInPlace(W[1]),this.l10.scaleInPlace(W[2]),this.l11.scaleInPlace(W[3]),this.l2_2.scaleInPlace(W[4]),this.l2_1.scaleInPlace(W[5]),this.l20.scaleInPlace(W[6]),this.l21.scaleInPlace(W[7]),this.l22.scaleInPlace(W[8])}convertIrradianceToLambertianRadiance(){this.scaleInPlace(1/Math.PI)}preScaleForRendering(){this.preScaled=!0,this.l00.scaleInPlace(U[0]),this.l1_1.scaleInPlace(U[1]),this.l10.scaleInPlace(U[2]),this.l11.scaleInPlace(U[3]),this.l2_2.scaleInPlace(U[4]),this.l2_1.scaleInPlace(U[5]),this.l20.scaleInPlace(U[6]),this.l21.scaleInPlace(U[7]),this.l22.scaleInPlace(U[8])}updateFromArray(Y){return x.k.FromArrayToRef(Y[0],0,this.l00),x.k.FromArrayToRef(Y[1],0,this.l1_1),x.k.FromArrayToRef(Y[2],0,this.l10),x.k.FromArrayToRef(Y[3],0,this.l11),x.k.FromArrayToRef(Y[4],0,this.l2_2),x.k.FromArrayToRef(Y[5],0,this.l2_1),x.k.FromArrayToRef(Y[6],0,this.l20),x.k.FromArrayToRef(Y[7],0,this.l21),x.k.FromArrayToRef(Y[8],0,this.l22),this}updateFromFloatsArray(Y){return x.k.FromFloatsToRef(Y[0],Y[1],Y[2],this.l00),x.k.FromFloatsToRef(Y[3],Y[4],Y[5],this.l1_1),x.k.FromFloatsToRef(Y[6],Y[7],Y[8],this.l10),x.k.FromFloatsToRef(Y[9],Y[10],Y[11],this.l11),x.k.FromFloatsToRef(Y[12],Y[13],Y[14],this.l2_2),x.k.FromFloatsToRef(Y[15],Y[16],Y[17],this.l2_1),x.k.FromFloatsToRef(Y[18],Y[19],Y[20],this.l20),x.k.FromFloatsToRef(Y[21],Y[22],Y[23],this.l21),x.k.FromFloatsToRef(Y[24],Y[25],Y[26],this.l22),this}static ek(Y){return(new o).updateFromArray(Y)}static FromPolynomial(Y){const d=new o;return d.l00=Y.xx.scale(.376127).add(Y.yy.scale(.376127)).add(Y.zz.scale(.376126)),d.l1_1=Y.y.scale(.977204),d.l10=Y.z.scale(.977204),d.l11=Y.x.scale(.977204),d.l2_2=Y.xy.scale(1.16538),d.l2_1=Y.yz.scale(1.16538),d.l20=Y.zz.scale(1.34567).ae(Y.xx.scale(.672834)).ae(Y.yy.scale(.672834)),d.l21=Y.zx.scale(1.16538),d.l22=Y.xx.scale(1.16538).ae(Y.yy.scale(1.16538)),d.l1_1.scaleInPlace(-1),d.l11.scaleInPlace(-1),d.l2_1.scaleInPlace(-1),d.l21.scaleInPlace(-1),d.scaleInPlace(Math.PI),d}}class f{constructor(){this.x=x.k.Zero(),this.y=x.k.Zero(),this.z=x.k.Zero(),this.xx=x.k.Zero(),this.yy=x.k.Zero(),this.zz=x.k.Zero(),this.xy=x.k.Zero(),this.yz=x.k.Zero(),this.zx=x.k.Zero()}get preScaledHarmonics(){return this._harmonics||(this._harmonics=o.FromPolynomial(this)),this._harmonics.preScaled||this._harmonics.preScaleForRendering(),this._harmonics}addAmbient(Y){C.i.gk[0].md(Y.r,Y.g,Y.b);const d=C.i.gk[0];this.xx.addInPlace(d),this.yy.addInPlace(d),this.zz.addInPlace(d)}scaleInPlace(Y){this.x.scaleInPlace(Y),this.y.scaleInPlace(Y),this.z.scaleInPlace(Y),this.xx.scaleInPlace(Y),this.yy.scaleInPlace(Y),this.zz.scaleInPlace(Y),this.yz.scaleInPlace(Y),this.zx.scaleInPlace(Y),this.xy.scaleInPlace(Y)}updateFromHarmonics(Y){return this._harmonics=Y,this.x.p(Y.l11),this.x.scaleInPlace(1.02333).scaleInPlace(-1),this.y.p(Y.l1_1),this.y.scaleInPlace(1.02333).scaleInPlace(-1),this.z.p(Y.l10),this.z.scaleInPlace(1.02333),this.xx.p(Y.l00),C.i.gk[0].p(Y.l20).scaleInPlace(.247708),C.i.gk[1].p(Y.l22).scaleInPlace(.429043),this.xx.scaleInPlace(.886277).ik(C.i.gk[0]).addInPlace(C.i.gk[1]),this.yy.p(Y.l00),this.yy.scaleInPlace(.886277).ik(C.i.gk[0]).ik(C.i.gk[1]),this.zz.p(Y.l00),C.i.gk[0].p(Y.l20).scaleInPlace(.495417),this.zz.scaleInPlace(.886277).addInPlace(C.i.gk[0]),this.yz.p(Y.l2_1),this.yz.scaleInPlace(.858086).scaleInPlace(-1),this.zx.p(Y.l21),this.zx.scaleInPlace(.858086).scaleInPlace(-1),this.xy.p(Y.l2_2),this.xy.scaleInPlace(.858086),this.scaleInPlace(1/Math.PI),this}static FromHarmonics(Y){return(new f).updateFromHarmonics(Y)}static ek(Y){const d=new f;return x.k.FromArrayToRef(Y[0],0,d.x),x.k.FromArrayToRef(Y[1],0,d.y),x.k.FromArrayToRef(Y[2],0,d.z),x.k.FromArrayToRef(Y[3],0,d.xx),x.k.FromArrayToRef(Y[4],0,d.yy),x.k.FromArrayToRef(Y[5],0,d.zz),x.k.FromArrayToRef(Y[6],0,d.yz),x.k.FromArrayToRef(Y[7],0,d.zx),x.k.FromArrayToRef(Y[8],0,d.xy),d}}},2066:(Y,d,t)=>{t.d(d,{d:()=>o});var x=t(686),C=t(705),U=t(2043),y=t(694),B=t(728);class W{constructor(Y,d,t,x){this.name=Y,this.worldAxisForNormal=d,this.worldAxisForFileX=t,this.worldAxisForFileY=x}}class o{static ConvertCubeMapTextureToSphericalPolynomial(Y){var d;if(!Y.isCube)return null;null===(d=Y.va())||void 0===d||d.getEngine().flushFramebuffer();const t=Y.getSize().width,x=Y.readPixels(0,void 0,void 0,!1),C=Y.readPixels(1,void 0,void 0,!1);let U,y;Y.isRenderTarget?(U=Y.readPixels(3,void 0,void 0,!1),y=Y.readPixels(2,void 0,void 0,!1)):(U=Y.readPixels(2,void 0,void 0,!1),y=Y.readPixels(3,void 0,void 0,!1));const B=Y.readPixels(4,void 0,void 0,!1),W=Y.readPixels(5,void 0,void 0,!1),o=Y.gammaSpace;let f=0;return 1!=Y.textureType&&2!=Y.textureType||(f=1),new Promise((Y=>{Promise.all([C,x,U,y,B,W]).then((d=>{let[x,C,U,y,B,W]=d;const F={size:t,right:C,left:x,up:U,down:y,front:B,back:W,format:5,type:f,gammaSpace:o};Y(this.ConvertCubeMapToSphericalPolynomial(F))}))}))}static _AreaElement(Y,d){return Math.atan2(Y*d,Math.sqrt(Y*Y+d*d+1))}static ConvertCubeMapToSphericalPolynomial(Y){const d=new U.e;let t=0;const x=2/Y.size,W=x,o=.5*x,f=o-1;for(let U=0;U<6;U++){const F=this._FileFaces[U],D=Y[F.name];let b=f;const m=5===Y.format?4:3;for(let U=0;U<Y.size;U++){let M=f;for(let W=0;W<Y.size;W++){const f=F.worldAxisForFileX.scale(M).add(F.worldAxisForFileY.scale(b)).add(F.worldAxisForNormal);f.normalize();const J=this._AreaElement(M-o,b-o)-this._AreaElement(M-o,b+o)-this._AreaElement(M+o,b-o)+this._AreaElement(M+o,b+o);let g=D[U*Y.size*m+W*m+0],T=D[U*Y.size*m+W*m+1],s=D[U*Y.size*m+W*m+2];isNaN(g)&&(g=0),isNaN(T)&&(T=0),isNaN(s)&&(s=0),0===Y.type&&(g/=255,T/=255,s/=255),Y.gammaSpace&&(g=Math.pow((0,C.b)(g),y.i),T=Math.pow((0,C.b)(T),y.i),s=Math.pow((0,C.b)(s),y.i));const l=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const Y=Math.max(g,T,s);if(Y>l){const d=l/Y;g*=d,T*=d,s*=d}}else g=(0,C.b)(g,0,l),T=(0,C.b)(T,0,l),s=(0,C.b)(s,0,l);const h=new B.e(g,T,s);d.addLight(f,h,J),t+=J,M+=x}b+=W}}const F=6*(4*Math.PI)/6/t;return d.scaleInPlace(F),d.convertIncidentRadianceToIrradiance(),d.convertIrradianceToLambertianRadiance(),U.i.FromHarmonics(d)}}o._FileFaces=[new W("right",new x.k(1,0,0),new x.k(0,0,-1),new x.k(0,-1,0)),new W("left",new x.k(-1,0,0),new x.k(0,0,1),new x.k(0,-1,0)),new W("up",new x.k(0,1,0),new x.k(1,0,0),new x.k(0,0,1)),new W("down",new x.k(0,-1,0),new x.k(1,0,0),new x.k(0,0,-1)),new W("front",new x.k(0,0,1),new x.k(1,0,0),new x.k(0,-1,0)),new W("back",new x.k(0,0,-1),new x.k(-1,0,0),new x.k(0,-1,0))],o.MAX_HDRI_VALUE=4096,o.PRESERVE_CLAMPED_COLORS=!1},2075:(Y,d,t)=>{t.d(d,{e:()=>W,f:()=>D,g:()=>F});t(2077),t(2083);var x=t(2107),C=t(586),U=t(637),y=t(720);class B extends x.b{getClassName(){return"PassPostProcess"}constructor(Y,d){super(Y,"pass",null,null,d,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0,arguments.length>5?arguments[5]:void 0,void 0,arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,void 0,null,arguments.length>7&&void 0!==arguments[7]&&arguments[7])}_gatherImports(Y,d){Y?(this._webGPUReady=!0,d.push(Promise.all([t.e(32).then(t.bind(t,12849))]))):d.push(Promise.all([t.e(33).then(t.bind(t,12857))])),super._gatherImports(Y,d)}static _Parse(Y,d,t,x){return y.e.Parse((()=>new B(Y.name,Y.options,d,Y.renderTargetSamplingMode,Y._engine,Y.reusable)),Y,t,x)}}(0,U.f)("BABYLON.PassPostProcess",B);x.b;function W(Y,d,t,C,U,y,B,W){const o=d.getEngine();return d.isReady=!1,U=U??d.samplingMode,C=C??d.type,y=y??d.format,B=B??d.width,W=W??d.height,-1===C&&(C=0),new Promise((f=>{const F=new x.b("postprocess",Y,null,null,1,null,U,o,!1,void 0,C,void 0,null,!1,y);F.externalTextureSamplerBinding=!0;const D=o.createRenderTargetTexture({width:B,height:W},{generateDepthBuffer:!1,generateMipMaps:!1,generateStencilBuffer:!1,samplingMode:U,type:C,format:y});F.onEffectCreatedObservable.addOnce((Y=>{Y.executeWhenCompiled((()=>{F.onApply=Y=>{Y._bindTexture("textureSampler",d),Y.setFloat2("scale",1,1)},t.postProcessManager.directRender([F],D,!0),o.restoreDefaultFramebuffer(),o._releaseTexture(d),F&&F.dispose(),D._swapAndDie(d),d.type=C,d.format=5,d.isReady=!0,f(d)}))}))}))}let o,f;function F(Y){o||(o=new Float32Array(1),f=new Int32Array(o.buffer)),o[0]=Y;const d=f[0];let t=d>>16&32768,x=d>>12&2047;const C=d>>23&255;return C<103?t:C>142?(t|=31744,t|=(255==C?0:1)&&8388607&d,t):C<113?(x|=2048,t|=(x>>114-C)+(x>>113-C&1),t):(t|=C-112<<10|x>>1,t+=1&x,t)}function D(Y){const d=(32768&Y)>>15,t=(31744&Y)>>10,x=1023&Y;return 0===t?(d?-1:1)*Math.pow(2,-14)*(x/Math.pow(2,10)):31==t?x?NaN:1/0*(d?-1:1):(d?-1:1)*Math.pow(2,t-15)*(1+x/Math.pow(2,10))}C.d._RescalePostProcessFactory=Y=>new B("rescale",1,null,2,Y,!1,0)},2107:(Y,d,t)=>{t.d(d,{b:()=>m});var x=t(670),C=t(681),U=t(513),y=t(686),B=t(590),W=t(673),o=t(720),f=t(637),F=t(586),D=t(650),b=t(2111);F.d.prototype.setTextureFromPostProcess=function(Y,d,t){var x;let C=null;d&&(d._forcedOutputTexture?C=d._forcedOutputTexture:d._textures.data[d._currentRenderTextureInd]&&(C=d._textures.data[d._currentRenderTextureInd])),this._bindTexture(Y,(null===(x=C)||void 0===x?void 0:x.texture)??null,t)},F.d.prototype.setTextureFromPostProcessOutput=function(Y,d,t){var x;this._bindTexture(Y,(null===d||void 0===d||null===(x=d._outputTexture)||void 0===x?void 0:x.texture)??null,t)},B.b.prototype.setTextureFromPostProcess=function(Y,d){this._engine.setTextureFromPostProcess(this._samplers[Y],d,Y)},B.b.prototype.setTextureFromPostProcessOutput=function(Y,d){this._engine.setTextureFromPostProcessOutput(this._samplers[Y],d,Y)};class m{static get ForceGLSL(){return b.e.ForceGLSL}static set ForceGLSL(Y){b.e.ForceGLSL=Y}static RegisterShaderCodeProcessing(Y,d){b.e.RegisterShaderCodeProcessing(Y,d)}get name(){return this._effectWrapper.name}set name(Y){this._effectWrapper.name=Y}get alphaMode(){return this._effectWrapper.alphaMode}set alphaMode(Y){this._effectWrapper.alphaMode=Y}get samples(){return this._samples}set samples(Y){this._samples=Math.min(Y,this._engine.getCaps().maxMSAASamples),this._textures.forEach((Y=>{Y.setSamples(this._samples)}))}get shaderLanguage(){return this._shaderLanguage}getEffectName(){return this._fragmentUrl}set onActivate(Y){this._onActivateObserver&&this.onActivateObservable.remove(this._onActivateObserver),Y&&(this._onActivateObserver=this.onActivateObservable.add(Y))}set onSizeChanged(Y){this._onSizeChangedObserver&&this.onSizeChangedObservable.remove(this._onSizeChangedObserver),this._onSizeChangedObserver=this.onSizeChangedObservable.add(Y)}set onApply(Y){this._onApplyObserver&&this.onApplyObservable.remove(this._onApplyObserver),this._onApplyObserver=this.onApplyObservable.add(Y)}set onBeforeRender(Y){this._onBeforeRenderObserver&&this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),this._onBeforeRenderObserver=this.onBeforeRenderObservable.add(Y)}set onAfterRender(Y){this._onAfterRenderObserver&&this.onAfterRenderObservable.remove(this._onAfterRenderObserver),this._onAfterRenderObserver=this.onAfterRenderObservable.add(Y)}get inputTexture(){return this._textures.data[this._currentRenderTextureInd]}set inputTexture(Y){this._forcedOutputTexture=Y}restoreDefaultInputTexture(){this._forcedOutputTexture&&(this._forcedOutputTexture=null,this.markTextureDirty())}getCamera(){return this._camera}get texelSize(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.texelSize:(this._forcedOutputTexture&&this._texelSize.md(1/this._forcedOutputTexture.width,1/this._forcedOutputTexture.height),this._texelSize)}constructor(Y,d,t,x,B,W){var o;let f=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1,F=arguments.length>7?arguments[7]:void 0,D=arguments.length>8?arguments[8]:void 0,M=arguments.length>9&&void 0!==arguments[9]?arguments[9]:null,J=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,g=arguments.length>11&&void 0!==arguments[11]?arguments[11]:"postprocess",T=arguments.length>12?arguments[12]:void 0,s=arguments.length>13&&void 0!==arguments[13]&&arguments[13],l=arguments.length>14&&void 0!==arguments[14]?arguments[14]:5,h=arguments.length>15?arguments[15]:void 0,Z=arguments.length>16?arguments[16]:void 0;this._parentContainer=null,this.width=-1,this.height=-1,this.nodeMaterialSource=null,this._outputTexture=null,this.Hl=!0,this.forceAutoClearInAlphaMode=!1,this.animations=[],this.enablePixelPerfectMode=!1,this.forceFullscreenViewport=!0,this.scaleMode=1,this.alwaysForcePOT=!1,this._samples=1,this.adaptScaleToCurrentViewport=!1,this._webGPUReady=!1,this._reusable=!1,this._renderId=0,this.externalTextureSamplerBinding=!1,this._textures=new C.f(2),this._textureCache=[],this._currentRenderTextureInd=0,this._scaleRatio=new y.i(1,1),this._texelSize=y.i.Zero(),this.onActivateObservable=new U.b,this.onSizeChangedObservable=new U.b,this.onApplyObservable=new U.b,this.onBeforeRenderObservable=new U.b,this.onAfterRenderObservable=new U.b;let N,w=1,K=null;if(t&&!Array.isArray(t)){const Y=t;t=Y.uniforms??null,x=Y.samplers??null,w=Y.size??1,W=Y.camera??null,f=Y.samplingMode??1,F=Y.Xj,D=Y.reusable,M=Array.isArray(Y.defines)?Y.defines.join("\n"):Y.defines??null,J=Y.textureType??0,g=Y.vertexUrl??"postprocess",T=Y.indexParameters,s=Y.blockCompilation??!1,l=Y.textureFormat??5,h=Y.shaderLanguage??0,K=Y.uniformBuffers??null,Z=Y.extraInitializations,N=Y.effectWrapper}else B&&(w="number"===typeof B?B:{width:B.width,height:B.height});const P=!!N;if(this._effectWrapper=N??new b.e({name:Y,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:d,Xj:F||(null===(o=W)||void 0===o?void 0:o.va().getEngine()),uniforms:t,samplers:x,uniformBuffers:K,defines:M,vertexUrl:g,indexParameters:T,blockCompilation:s,shaderLanguage:h,extraInitializations:Z}),this.name=Y,this.onEffectCreatedObservable=this._effectWrapper.onEffectCreatedObservable,null!=W?(this._camera=W,this._scene=W.va(),W.attachPostProcess(this),this._engine=this._scene.getEngine(),this._scene.postProcesses.push(this),this.uniqueId=this._scene.getUniqueId()):F&&(this._engine=F,this._engine.postProcesses.push(this)),this._options=w,this.renderTargetSamplingMode=f||1,this._reusable=D||!1,this._textureType=J,this._textureFormat=l,this._shaderLanguage=h||0,this._samplers=x||[],-1===this._samplers.indexOf("textureSampler")&&this._samplers.push("textureSampler"),this._fragmentUrl=d,this._vertexUrl=g,this._parameters=t||[],-1===this._parameters.indexOf("scale")&&this._parameters.push("scale"),this._uniformBuffers=K||[],this._indexParameters=T,!P){this._webGPUReady=1===this._shaderLanguage;const Y=[];this._gatherImports(this._engine.isWebGPU&&!m.ForceGLSL,Y),this._effectWrapper._webGPUReady=this._webGPUReady,this._effectWrapper._postConstructor(s,M,Z,Y)}}_gatherImports(){let Y=arguments.length>1?arguments[1]:void 0;arguments.length>0&&void 0!==arguments[0]&&arguments[0]&&this._webGPUReady?Y.push(Promise.all([t.e(36).then(t.bind(t,12875))])):Y.push(Promise.all([Promise.resolve().then(t.bind(t,2115))]))}getClassName(){return"PostProcess"}getEngine(){return this._engine}getEffect(){return this._effectWrapper.drawWrapper.effect}shareOutputWith(Y){return this._disposeTextures(),this._shareOutputWithPostProcess=Y,this}useOwnOutput(){0==this._textures.length&&(this._textures=new C.f(2)),this._shareOutputWithPostProcess=null}updateEffect(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,x=arguments.length>3?arguments[3]:void 0,C=arguments.length>4?arguments[4]:void 0,U=arguments.length>5?arguments[5]:void 0,y=arguments.length>6?arguments[6]:void 0,B=arguments.length>7?arguments[7]:void 0;this._effectWrapper.updateEffect(Y,d,t,x,C,U,y,B),this._postProcessDefines=Array.isArray(this._effectWrapper.options.defines)?this._effectWrapper.options.defines.join("\n"):this._effectWrapper.options.defines}isReusable(){return this._reusable}markTextureDirty(){this.width=-1}_createRenderTargetTexture(Y,d){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;for(let C=0;C<this._textureCache.length;C++)if(this._textureCache[C].texture.width===Y.width&&this._textureCache[C].texture.height===Y.height&&this._textureCache[C].postProcessChannel===t&&this._textureCache[C].texture._generateDepthBuffer===d.generateDepthBuffer&&this._textureCache[C].texture.samples===d.samples)return this._textureCache[C].texture;const x=this._engine.createRenderTargetTexture(Y,d);return this._textureCache.push({texture:x,postProcessChannel:t,lastUsedRenderId:-1}),x}_flushTextureCache(){const Y=this._renderId;for(let d=this._textureCache.length-1;d>=0;d--)if(Y-this._textureCache[d].lastUsedRenderId>100){let Y=!1;for(let t=0;t<this._textures.length;t++)if(this._textures.data[t]===this._textureCache[d].texture){Y=!0;break}Y||(this._textureCache[d].texture.dispose(),this._textureCache.splice(d,1))}}resize(Y,d){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,x=arguments.length>3&&void 0!==arguments[3]&&arguments[3],C=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this._textures.length>0&&this._textures.reset(),this.width=Y,this.height=d;let U=null;if(t)for(let W=0;W<t._postProcesses.length;W++)if(null!==t._postProcesses[W]){U=t._postProcesses[W];break}const y={width:this.width,height:this.height},B={generateMipMaps:x,generateDepthBuffer:C||U===this,generateStencilBuffer:(C||U===this)&&this._engine.isStencilEnable,samplingMode:this.renderTargetSamplingMode,type:this._textureType,format:this._textureFormat,samples:this._samples,label:"PostProcessRTT-"+this.name};this._textures.push(this._createRenderTargetTexture(y,B,0)),this._reusable&&this._textures.push(this._createRenderTargetTexture(y,B,1)),this._texelSize.md(1/this.width,1/this.height),this.onSizeChangedObservable.notifyObservers(this)}_getTarget(){let Y;if(this._shareOutputWithPostProcess)Y=this._shareOutputWithPostProcess.inputTexture;else if(this._forcedOutputTexture)Y=this._forcedOutputTexture,this.width=this._forcedOutputTexture.width,this.height=this._forcedOutputTexture.height;else{let d;Y=this.inputTexture;for(let t=0;t<this._textureCache.length;t++)if(this._textureCache[t].texture===Y){d=this._textureCache[t];break}d&&(d.lastUsedRenderId=this._renderId)}return Y}activate(Y){var d,t;let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,C=arguments.length>2?arguments[2]:void 0;const U=(Y=Y||this._camera).va(),y=U.getEngine(),B=y.getCaps().maxTextureSize,W=(x?x.width:this._engine.getRenderWidth(!0))*this._options|0,o=(x?x.height:this._engine.getRenderHeight(!0))*this._options|0;let f=this._options.width||W,F=this._options.height||o;const b=7!==this.renderTargetSamplingMode&&1!==this.renderTargetSamplingMode&&2!==this.renderTargetSamplingMode;let m=null;if(!this._shareOutputWithPostProcess&&!this._forcedOutputTexture){if(this.adaptScaleToCurrentViewport){const Y=y.currentViewport;Y&&(f*=Y.width,F*=Y.height)}(b||this.alwaysForcePOT)&&(this._options.width||(f=y.needPOTTextures?(0,D.g)(f,B,this.scaleMode):f),this._options.height||(F=y.needPOTTextures?(0,D.g)(F,B,this.scaleMode):F)),this.width===f&&this.height===F&&(m=this._getTarget())||this.resize(f,F,Y,b,C),this._textures.forEach((Y=>{Y.samples!==this.samples&&this._engine.updateRenderTargetTextureSampleCount(Y,this.samples)})),this._flushTextureCache(),this._renderId++}return m||(m=this._getTarget()),this.enablePixelPerfectMode?(this._scaleRatio.md(W/f,o/F),this._engine.bindFramebuffer(m,0,W,o,this.forceFullscreenViewport)):(this._scaleRatio.md(1,1),this._engine.bindFramebuffer(m,0,void 0,void 0,this.forceFullscreenViewport)),null===(d=(t=this._engine)._debugInsertMarker)||void 0===d||d.call(t,`post process ${this.name} input`),this.onActivateObservable.notifyObservers(Y),this.Hl&&(0===this.alphaMode||this.forceAutoClearInAlphaMode)&&this._engine.clear(this.clearColor?this.clearColor:U.clearColor,U._allowPostProcessClearColor,!0,!0),this._reusable&&(this._currentRenderTextureInd=(this._currentRenderTextureInd+1)%2),m}get isSupported(){return this._effectWrapper.drawWrapper.effect.isSupported}get aspectRatio(){return this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.aspectRatio:this._forcedOutputTexture?this._forcedOutputTexture.width/this._forcedOutputTexture.height:this.width/this.height}isReady(){return this._effectWrapper.isReady()}apply(){if(!this._effectWrapper.isReady())return null;let Y;var d;(this._engine.enableEffect(this._effectWrapper.drawWrapper),this._engine.setState(!1),this._engine.setDepthBuffer(!1),this._engine.setDepthWrite(!1),this.alphaConstants&&this.getEngine().setAlphaConstants(this.alphaConstants.r,this.alphaConstants.g,this.alphaConstants.b,this.alphaConstants.a),Y=this._shareOutputWithPostProcess?this._shareOutputWithPostProcess.inputTexture:this._forcedOutputTexture?this._forcedOutputTexture:this.inputTexture,this.externalTextureSamplerBinding)||this._effectWrapper.drawWrapper.effect._bindTexture("textureSampler",null===(d=Y)||void 0===d?void 0:d.texture);return this._effectWrapper.drawWrapper.effect.setVector2("scale",this._scaleRatio),this.onApplyObservable.notifyObservers(this._effectWrapper.drawWrapper.effect),this._effectWrapper.bind(),this._effectWrapper.drawWrapper.effect}_disposeTextures(){this._shareOutputWithPostProcess||this._forcedOutputTexture?this._disposeTextureCache():(this._disposeTextureCache(),this._textures.dispose())}_disposeTextureCache(){for(let Y=this._textureCache.length-1;Y>=0;Y--)this._textureCache[Y].texture.dispose();this._textureCache.length=0}setPrePassRenderer(Y){return!!this._prePassEffectConfiguration&&(this._prePassEffectConfiguration=Y.addEffectConfiguration(this._prePassEffectConfiguration),this._prePassEffectConfiguration.enabled=!0,!0)}dispose(Y){let d;if(Y=Y||this._camera,this._disposeTextures(),this._scene&&(d=this._scene.postProcesses.indexOf(this),-1!==d&&this._scene.postProcesses.splice(d,1)),this._parentContainer){const Y=this._parentContainer.postProcesses.indexOf(this);Y>-1&&this._parentContainer.postProcesses.splice(Y,1),this._parentContainer=null}if(d=this._engine.postProcesses.indexOf(this),-1!==d&&this._engine.postProcesses.splice(d,1),Y){if(Y.detachPostProcess(this),d=Y._postProcesses.indexOf(this),0===d&&Y._postProcesses.length>0){const Y=this._camera._getFirstPostProcess();Y&&Y.markTextureDirty()}this.onActivateObservable.clear(),this.onAfterRenderObservable.clear(),this.onApplyObservable.clear(),this.onBeforeRenderObservable.clear(),this.onSizeChangedObservable.clear(),this.onEffectCreatedObservable.clear()}}serialize(){const Y=o.e.Serialize(this),d=this.getCamera()||this._scene&&this._scene.activeCamera;return Y.customType="BABYLON."+this.getClassName(),Y.cameraId=d?d.id:null,Y.reusable=this._reusable,Y.textureType=this._textureType,Y.fragmentUrl=this._fragmentUrl,Y.parameters=this._parameters,Y.samplers=this._samplers,Y.uniformBuffers=this._uniformBuffers,Y.options=this._options,Y.defines=this._postProcessDefines,Y.textureFormat=this._textureFormat,Y.vertexUrl=this._vertexUrl,Y.indexParameters=this._indexParameters,Y}clone(){const Y=this.serialize();Y._engine=this._engine,Y.cameraId=null;const d=m.Parse(Y,this._scene,"");return d?(d.onActivateObservable=this.onActivateObservable.clone(),d.onSizeChangedObservable=this.onSizeChangedObservable.clone(),d.onApplyObservable=this.onApplyObservable.clone(),d.onBeforeRenderObservable=this.onBeforeRenderObservable.clone(),d.onAfterRenderObservable=this.onAfterRenderObservable.clone(),d._prePassEffectConfiguration=this._prePassEffectConfiguration,d):null}static Parse(Y,d,t){const x=(0,f.d)(Y.customType);if(!x||!x._Parse)return null;const C=d?d.getCameraById(Y.cameraId):null;return x._Parse(Y,C,d,t)}static _Parse(Y,d,t,x){return o.e.Parse((()=>new m(Y.name,Y.fragmentUrl,Y.parameters,Y.samplers,Y.options,d,Y.renderTargetSamplingMode,Y._engine,Y.reusable,Y.defines,Y.textureType,Y.vertexUrl,Y.indexParameters,!1,Y.textureFormat)),Y,t,x)}}(0,x.e)([(0,W.P)()],m.prototype,"uniqueId",void 0),(0,x.e)([(0,W.P)()],m.prototype,"name",null),(0,x.e)([(0,W.P)()],m.prototype,"width",void 0),(0,x.e)([(0,W.P)()],m.prototype,"height",void 0),(0,x.e)([(0,W.P)()],m.prototype,"renderTargetSamplingMode",void 0),(0,x.e)([(0,W.p)()],m.prototype,"clearColor",void 0),(0,x.e)([(0,W.P)()],m.prototype,"Hl",void 0),(0,x.e)([(0,W.P)()],m.prototype,"forceAutoClearInAlphaMode",void 0),(0,x.e)([(0,W.P)()],m.prototype,"alphaMode",null),(0,x.e)([(0,W.P)()],m.prototype,"alphaConstants",void 0),(0,x.e)([(0,W.P)()],m.prototype,"enablePixelPerfectMode",void 0),(0,x.e)([(0,W.P)()],m.prototype,"forceFullscreenViewport",void 0),(0,x.e)([(0,W.P)()],m.prototype,"scaleMode",void 0),(0,x.e)([(0,W.P)()],m.prototype,"alwaysForcePOT",void 0),(0,x.e)([(0,W.P)("samples")],m.prototype,"_samples",void 0),(0,x.e)([(0,W.P)()],m.prototype,"adaptScaleToCurrentViewport",void 0),(0,f.f)("BABYLON.PostProcess",m)},2092:(Y,d,t)=>{t.d(d,{c:()=>U});var x=t(749),C=t(513);class U{constructor(Y){this._vertexBuffers={},this.onBeforeRenderObservable=new C.b,this._scene=Y}_prepareBuffers(){if(this._vertexBuffers[x.d.PositionKind])return;const Y=[];Y.push(1,1),Y.push(-1,1),Y.push(-1,-1),Y.push(1,-1),this._vertexBuffers[x.d.PositionKind]=new x.d(this._scene.getEngine(),Y,x.d.PositionKind,!1,!1,2),this._buildIndexBuffer()}_buildIndexBuffer(){const Y=[];Y.push(0),Y.push(1),Y.push(2),Y.push(0),Y.push(2),Y.push(3),this._indexBuffer=this._scene.getEngine().createIndexBuffer(Y)}_rebuild(){const Y=this._vertexBuffers[x.d.PositionKind];Y&&(Y._rebuild(),this._buildIndexBuffer())}_prepareFrame(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const t=this._scene.activeCamera;return!!t&&(d=d||t._postProcesses.filter((Y=>null!=Y)),!(!d||0===d.length||!this._scene.postProcessesEnabled)&&(d[0].activate(t,Y,null!==d&&void 0!==d),!0))}directRender(Y){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,U=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const y=this._scene.getEngine();for(let W=0;W<Y.length;W++){var B;if(W<Y.length-1)Y[W+1].activate(this._scene.activeCamera,null===d||void 0===d?void 0:d.texture);else d?y.bindFramebuffer(d,x,void 0,void 0,t,C):U||y.restoreDefaultFramebuffer(),null===(B=y._debugInsertMarker)||void 0===B||B.call(y,`post process ${Y[W].name} output`);const o=Y[W],f=o.apply();f&&(o.onBeforeRenderObservable.notifyObservers(f),this._prepareBuffers(),y.bindBuffers(this._vertexBuffers,this._indexBuffer,f),y.drawElementsType(0,0,6),o.onAfterRenderObservable.notifyObservers(f))}y.setDepthBuffer(!0),y.setDepthWrite(!0)}_finalizeFrame(Y,d,t,x){let C=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const U=this._scene.activeCamera;if(!U)return;if(this.onBeforeRenderObservable.notifyObservers(this),0===(x=x||U._postProcesses.filter((Y=>null!=Y))).length||!this._scene.postProcessesEnabled)return;const y=this._scene.getEngine();for(let W=0,o=x.length;W<o;W++){const f=x[W];var B;if(W<o-1)f._outputTexture=x[W+1].activate(U,null===d||void 0===d?void 0:d.texture);else d?(y.bindFramebuffer(d,t,void 0,void 0,C),f._outputTexture=d):(y.restoreDefaultFramebuffer(),f._outputTexture=null),null===(B=y._debugInsertMarker)||void 0===B||B.call(y,`post process ${x[W].name} output`);if(Y)break;const F=f.apply();F&&(f.onBeforeRenderObservable.notifyObservers(F),this._prepareBuffers(),y.bindBuffers(this._vertexBuffers,this._indexBuffer,F),y.drawElementsType(0,0,6),f.onAfterRenderObservable.notifyObservers(F))}y.setDepthBuffer(!0),y.setDepthWrite(!0),y.setAlphaMode(0)}dispose(){const Y=this._vertexBuffers[x.d.PositionKind];Y&&(Y.dispose(),this._vertexBuffers[x.d.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)}}},2098:(Y,d,t)=>{t.d(d,{e:()=>B});var x=t(681),C=t(686);class U{set opaqueSortCompareFn(Y){this._opaqueSortCompareFn=Y||U.PainterSortCompare,this._renderOpaque=this._renderOpaqueSorted}set alphaTestSortCompareFn(Y){this._alphaTestSortCompareFn=Y||U.PainterSortCompare,this._renderAlphaTest=this._renderAlphaTestSorted}set transparentSortCompareFn(Y){this._transparentSortCompareFn=Y||U.defaultTransparentSortCompare,this._renderTransparent=this._renderTransparentSorted}constructor(Y,d){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.index=Y,this._opaqueSubMeshes=new x.f(256),this._transparentSubMeshes=new x.f(256),this._alphaTestSubMeshes=new x.f(256),this._depthOnlySubMeshes=new x.f(256),this._particleSystems=new x.f(256),this._spriteManagers=new x.f(256),this._empty=!0,this._edgesRenderers=new x.d(16),this._scene=d,this.opaqueSortCompareFn=t,this.alphaTestSortCompareFn=C,this.transparentSortCompareFn=U}render(Y,d,t,x){if(Y)return void Y(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,this._depthOnlySubMeshes);const C=this._scene.getEngine();0!==this._depthOnlySubMeshes.length&&(C.setColorWrite(!1),this._renderAlphaTest(this._depthOnlySubMeshes),C.setColorWrite(!0)),0!==this._opaqueSubMeshes.length&&this._renderOpaque(this._opaqueSubMeshes),0!==this._alphaTestSubMeshes.length&&this._renderAlphaTest(this._alphaTestSubMeshes);const U=C.getStencilBuffer();if(C.setStencilBuffer(!1),d&&this._renderSprites(),t&&this._renderParticles(x),this.onBeforeTransparentRendering&&this.onBeforeTransparentRendering(),0!==this._transparentSubMeshes.length||this._scene.useOrderIndependentTransparency){if(C.setStencilBuffer(U),this._scene.useOrderIndependentTransparency){const Y=this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);Y.length&&this._renderTransparent(Y)}else this._renderTransparent(this._transparentSubMeshes);C.setAlphaMode(0)}if(C.setStencilBuffer(!1),this._edgesRenderers.length){for(let Y=0;Y<this._edgesRenderers.length;Y++)this._edgesRenderers.data[Y].render();C.setAlphaMode(0)}C.setStencilBuffer(U)}_renderOpaqueSorted(Y){U._RenderSorted(Y,this._opaqueSortCompareFn,this._scene.activeCamera,!1)}_renderAlphaTestSorted(Y){U._RenderSorted(Y,this._alphaTestSortCompareFn,this._scene.activeCamera,!1)}_renderTransparentSorted(Y){U._RenderSorted(Y,this._transparentSortCompareFn,this._scene.activeCamera,!0)}static _RenderSorted(Y,d,t,x){let y,B=0;const W=t?t.globalPosition:U._ZeroVector;if(x)for(;B<Y.length;B++)y=Y.data[B],y._alphaIndex=y.getMesh().alphaIndex,y._distanceToCamera=C.k.Distance(y.getBoundingInfo().boundingSphere.centerWorld,W);const o=Y.length===Y.data.length?Y.data:Y.data.slice(0,Y.length);d&&o.sort(d);const f=o[0].getMesh().va();for(B=0;B<o.length;B++)if(y=o[B],!f._activeMeshesFrozenButKeepClipping||y.isInFrustum(f._frustumPlanes)){if(x){const Y=y.Ha();if(Y&&Y.needDepthPrePass){const d=Y.va().getEngine();d.setColorWrite(!1),d.setAlphaMode(0),y.render(!1),d.setColorWrite(!0)}}y.render(x)}}static defaultTransparentSortCompare(Y,d){return Y._alphaIndex>d._alphaIndex?1:Y._alphaIndex<d._alphaIndex?-1:U.backToFrontSortCompare(Y,d)}static backToFrontSortCompare(Y,d){return Y._distanceToCamera<d._distanceToCamera?1:Y._distanceToCamera>d._distanceToCamera?-1:0}static frontToBackSortCompare(Y,d){return Y._distanceToCamera<d._distanceToCamera?-1:Y._distanceToCamera>d._distanceToCamera?1:0}static PainterSortCompare(Y,d){const t=Y.getMesh(),x=d.getMesh();return t.material&&x.material?t.material.uniqueId-x.material.uniqueId:t.uniqueId-x.uniqueId}prepare(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset(),this._depthOnlySubMeshes.reset(),this._particleSystems.reset(),this.prepareSprites(),this._edgesRenderers.reset(),this._empty=!0}prepareSprites(){this._spriteManagers.reset()}dispose(){this._opaqueSubMeshes.dispose(),this._transparentSubMeshes.dispose(),this._alphaTestSubMeshes.dispose(),this._depthOnlySubMeshes.dispose(),this._particleSystems.dispose(),this._spriteManagers.dispose(),this._edgesRenderers.dispose()}dispatch(Y,d,t){void 0===d&&(d=Y.getMesh()),void 0===t&&(t=Y.Ha()),null!==t&&void 0!==t&&(t.needAlphaBlendingForMesh(d)?this._transparentSubMeshes.push(Y):t.needAlphaTesting()?(t.needDepthPrePass&&this._depthOnlySubMeshes.push(Y),this._alphaTestSubMeshes.push(Y)):(t.needDepthPrePass&&this._depthOnlySubMeshes.push(Y),this._opaqueSubMeshes.push(Y)),d._renderingGroup=this,d._edgesRenderer&&d.isEnabled()&&d.isVisible&&d._edgesRenderer.isEnabled&&this._edgesRenderers.pushNoDuplicate(d._edgesRenderer),this._empty=!1)}dispatchSprites(Y){this._spriteManagers.push(Y),this._empty=!1}dispatchParticles(Y){this._particleSystems.push(Y),this._empty=!1}_renderParticles(Y){if(0===this._particleSystems.length)return;const d=this._scene.activeCamera;this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);for(let t=0;t<this._particleSystems.length;t++){const x=this._particleSystems.data[t];if(0===(d&&d.layerMask&x.layerMask))continue;const C=x.j;C.position&&Y&&-1===Y.indexOf(C)||this._scene._activeParticles.addCount(x.render(),!1)}this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)}_renderSprites(){if(!this._scene.spritesEnabled||0===this._spriteManagers.length)return;const Y=this._scene.activeCamera;this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);for(let d=0;d<this._spriteManagers.length;d++){const t=this._spriteManagers.data[d];0!==(Y&&Y.layerMask&t.layerMask)&&t.render()}this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)}}U._ZeroVector=C.k.Zero();class y{}class B{get maintainStateBetweenFrames(){return this._maintainStateBetweenFrames}set maintainStateBetweenFrames(Y){Y!==this._maintainStateBetweenFrames&&(this._maintainStateBetweenFrames=Y,this._maintainStateBetweenFrames||this.restoreDispachedFlags())}restoreDispachedFlags(){for(const Y of this._scene.meshes)if(Y.sk)for(const d of Y.sk)d._wasDispatched=!1;if(this._scene.spriteManagers)for(const Y of this._scene.spriteManagers)Y._wasDispatched=!1;for(const Y of this._scene.Dk)Y._wasDispatched=!1}constructor(Y){this._useSceneAutoClearSetup=!1,this._renderingGroups=new Array,this._autoClearDepthStencil={},this._customOpaqueSortCompareFn={},this._customAlphaTestSortCompareFn={},this._customTransparentSortCompareFn={},this._renderingGroupInfo=new y,this._maintainStateBetweenFrames=!1,this._scene=Y;for(let d=B.MIN_RENDERINGGROUPS;d<B.MAX_RENDERINGGROUPS;d++)this._autoClearDepthStencil[d]={Hl:!0,depth:!0,stencil:!0}}getRenderingGroup(Y){const d=Y||0;return this._prepareRenderingGroup(d),this._renderingGroups[d]}_clearDepthStencilBuffer(){let Y=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],d=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this._depthStencilBufferAlreadyCleaned||(this._scene.getEngine().clear(null,!1,Y,d),this._depthStencilBufferAlreadyCleaned=!0)}render(Y,d,t,x){const C=this._renderingGroupInfo;if(C.Ue=this._scene,C.camera=this._scene.activeCamera,this._scene.spriteManagers&&x)for(let U=0;U<this._scene.spriteManagers.length;U++){const Y=this._scene.spriteManagers[U];this.dispatchSprites(Y)}for(let U=B.MIN_RENDERINGGROUPS;U<B.MAX_RENDERINGGROUPS;U++){this._depthStencilBufferAlreadyCleaned=U===B.MIN_RENDERINGGROUPS;const y=this._renderingGroups[U];if(!y||y._empty)continue;const W=1<<U;if(C.renderingGroupId=U,this._scene.onBeforeRenderingGroupObservable.notifyObservers(C,W),B.AUTOCLEAR){const Y=this._useSceneAutoClearSetup?this._scene.getAutoClearDepthStencilSetup(U):this._autoClearDepthStencil[U];Y&&Y.Hl&&this._clearDepthStencilBuffer(Y.depth,Y.stencil)}for(const Y of this._scene._beforeRenderingGroupDrawStage)Y.action(U);y.render(Y,x,t,d);for(const Y of this._scene._afterRenderingGroupDrawStage)Y.action(U);this._scene.onAfterRenderingGroupObservable.notifyObservers(C,W)}}reset(){if(!this.maintainStateBetweenFrames)for(let Y=B.MIN_RENDERINGGROUPS;Y<B.MAX_RENDERINGGROUPS;Y++){const d=this._renderingGroups[Y];d&&d.prepare()}}resetSprites(){if(!this.maintainStateBetweenFrames)for(let Y=B.MIN_RENDERINGGROUPS;Y<B.MAX_RENDERINGGROUPS;Y++){const d=this._renderingGroups[Y];d&&d.prepareSprites()}}dispose(){this.freeRenderingGroups(),this._renderingGroups.length=0,this._renderingGroupInfo=null}freeRenderingGroups(){for(let Y=B.MIN_RENDERINGGROUPS;Y<B.MAX_RENDERINGGROUPS;Y++){const d=this._renderingGroups[Y];d&&d.dispose()}}_prepareRenderingGroup(Y){void 0===this._renderingGroups[Y]&&(this._renderingGroups[Y]=new U(Y,this._scene,this._customOpaqueSortCompareFn[Y],this._customAlphaTestSortCompareFn[Y],this._customTransparentSortCompareFn[Y]))}dispatchSprites(Y){this.maintainStateBetweenFrames&&Y._wasDispatched||(Y._wasDispatched=!0,this.getRenderingGroup(Y.renderingGroupId).dispatchSprites(Y))}dispatchParticles(Y){this.maintainStateBetweenFrames&&Y._wasDispatched||(Y._wasDispatched=!0,this.getRenderingGroup(Y.renderingGroupId).dispatchParticles(Y))}dispatch(Y,d,t){void 0===d&&(d=Y.getMesh()),this.maintainStateBetweenFrames&&Y._wasDispatched||(Y._wasDispatched=!0,this.getRenderingGroup(d.renderingGroupId).dispatch(Y,d,t))}setRenderingOrder(Y){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this._customOpaqueSortCompareFn[Y]=d,this._customAlphaTestSortCompareFn[Y]=t,this._customTransparentSortCompareFn[Y]=x,this._renderingGroups[Y]){const d=this._renderingGroups[Y];d.opaqueSortCompareFn=this._customOpaqueSortCompareFn[Y],d.alphaTestSortCompareFn=this._customAlphaTestSortCompareFn[Y],d.transparentSortCompareFn=this._customTransparentSortCompareFn[Y]}}setRenderingAutoClearDepthStencil(Y,d){let t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],x=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._autoClearDepthStencil[Y]={Hl:d,depth:t,stencil:x}}getAutoClearDepthStencilSetup(Y){return this._autoClearDepthStencil[Y]}}B.MAX_RENDERINGGROUPS=4,B.MIN_RENDERINGGROUPS=0,B.AUTOCLEAR=!0},2115:(Y,d,t)=>{t.r(d),t.d(d,{postprocessVertexShader:()=>U});const x="postprocessVertexShader",C="attribute vec2 position;uniform vec2 scale;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvUV=(position*madd+madd)*scale;gl_Position=vec4(position,0.0,1.0);\n#define CUSTOM_VERTEX_MAIN_END\n}";t(592).b.ShadersStore[x]=C;const U={name:x,shader:C}}}]);