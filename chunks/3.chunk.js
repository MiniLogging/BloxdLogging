"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3,6],{2402:(Z,U,n)=>{var i=n(615),B=n(513),l=n(551),H=n(640),V=n(585),G=n(626);V.b.prototype._partialLoadFile=function(Z,U,n,i){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(Z,(Z=>{n[U]=Z,n._internalCount++,6===n._internalCount&&i(n)}),void 0,void 0,!0,((Z,U)=>{B&&Z&&B(Z.status+" "+Z.statusText,U)}))},V.b.prototype._cascadeLoadFiles=function(Z,U,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const B=[];B._internalCount=0;for(let l=0;l<6;l++)this._partialLoadFile(n[l],l,B,U,i)},V.b.prototype._cascadeLoadImgs=function(Z,U,n,i){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,l=arguments.length>5?arguments[5]:void 0;const H=[];H._internalCount=0;for(let V=0;V<6;V++)this._partialLoadImg(i[V],V,H,Z,U,n,B,l)},V.b.prototype._partialLoadImg=function(Z,U,n,i,B,V){let G=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,R=arguments.length>7?arguments[7]:void 0;const d=(0,H.e)();(0,l.s)(Z,(Z=>{n[U]=Z,n._internalCount++,i&&i.removePendingData(d),6===n._internalCount&&V&&V(B,n)}),((Z,U)=>{i&&i.removePendingData(d),G&&G(Z,U)}),i?i.offlineProvider:null,R),i&&i.addPendingData(d)},V.b.prototype.createCubeTextureBase=function(Z,U,n,l){let H=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,V=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,R=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,F=arguments.length>8&&void 0!==arguments[8]&&arguments[8],y=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,S=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,q=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,c=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,s=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,z=arguments.length>14&&void 0!==arguments[14]&&arguments[14],O=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const E=q||new i.b(this,7);E.isCube=!0,E.url=Z,E.generateMipMaps=!l,E._lodGenerationScale=y,E._lodGenerationOffset=S,E._useSRGBBuffer=!!z&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!l),E!==q&&(E.label=Z.substring(0,60)),this._doNotHandleContextLost||(E._extension=d,E._files=n,E._buffer=O);const t=Z;this._transformTextureUrl&&!q&&(Z=this._transformTextureUrl(Z));const p=d??function(Z){const U=Z.split("?")[0],n=U.lastIndexOf(".");return n>-1?U.substring(n).toLowerCase():""}(Z),K=(0,G.c)(p),C=(Z,U)=>{E.dispose(),V?V(Z,U):Z&&B.c.Warn(Z)},D=(i,V)=>{Z===t?i&&C(i.status+" "+i.statusText,V):(B.c.Warn(`Failed to load ${Z}, falling back to the ${t}`),this.createCubeTextureBase(t,U,n,!!l,H,C,R,d,F,y,S,E,c,s,z,O))};if(K)K.then((i=>{const B=Z=>{c&&c(E,Z),i.loadCubeData(Z,E,F,H,((Z,U)=>{C(Z,U)}))};O?B(O):n&&6===n.length?i.supportCascades?this._cascadeLoadFiles(U,(Z=>B(Z.map((Z=>new Uint8Array(Z))))),n,C):C("Textures type does not support cascades."):this._loadFile(Z,(Z=>B(new Uint8Array(Z))),void 0,void 0,!0,D)}));else{if(!n||0===n.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(U,E,((Z,U)=>{s&&s(Z,U)}),n,C)}return this._internalTexturesCache.push(E),E}},2270:(Z,U,n)=>{n.r(U),n.d(U,{_DDSTextureLoader:()=>l});var i=n(2274),B=n(2290);class l{constructor(){this.supportCascades=!0}loadCubeData(Z,U,n,l){const H=U.getEngine();let V,G=!1,R=1e3;if(Array.isArray(Z))for(let i=0;i<Z.length;i++){const n=Z[i];V=B.DDSTools.GetDDSInfo(n),U.width=V.width,U.height=V.height,G=(V.isRGB||V.isLuminance||V.mipmapCount>1)&&U.generateMipMaps,H._unpackFlipY(V.isCompressed),B.DDSTools.UploadDDSLevels(H,U,n,V,G,6,-1,i),V.isFourCC||1!==V.mipmapCount?R=V.mipmapCount-1:H.generateMipMapsForCubemap(U)}else{const l=Z;V=B.DDSTools.GetDDSInfo(l),U.width=V.width,U.height=V.height,n&&(V.sphericalPolynomial=new i.f),G=(V.isRGB||V.isLuminance||V.mipmapCount>1)&&U.generateMipMaps,H._unpackFlipY(V.isCompressed),B.DDSTools.UploadDDSLevels(H,U,l,V,G,6),V.isFourCC||1!==V.mipmapCount?R=V.mipmapCount-1:H.generateMipMapsForCubemap(U,!1)}H._setCubeMapTextureParams(U,G,R),U.isReady=!0,U.onLoadedObservable.notifyObservers(U),U.onLoadedObservable.clear(),l&&l({isDDS:!0,width:U.width,info:V,data:Z,texture:U})}loadData(Z,U,n){const i=B.DDSTools.GetDDSInfo(Z),l=(i.isRGB||i.isLuminance||i.mipmapCount>1)&&U.generateMipMaps&&Math.max(i.width,i.height)>>i.mipmapCount-1===1;n(i.width,i.height,l,i.isFourCC,(()=>{B.DDSTools.UploadDDSLevels(U.getEngine(),U,Z,i,l,1)}))}}},2290:(Z,U,n)=>{n.d(U,{DDSTools:()=>q});var i=n(718),B=n(513),l=n(2296),H=n(2301);n(2402);const V=131072,G=131072;function R(Z){return Z.charCodeAt(0)+(Z.charCodeAt(1)<<8)+(Z.charCodeAt(2)<<16)+(Z.charCodeAt(3)<<24)}const d=R("DXT1"),F=R("DXT3"),y=R("DXT5"),S=R("DX10");class q{static GetDDSInfo(Z){const U=new Int32Array(Z.buffer,Z.byteOffset,31),n=new Int32Array(Z.buffer,Z.byteOffset,35);let i=1;U[2]&V&&(i=Math.max(1,U[7]));const B=U[21],l=B===S?n[32]:0;let H=0;switch(B){case 113:H=2;break;case 116:H=1;break;case S:if(10===l){H=2;break}if(2===l){H=1;break}}return{width:U[4],height:U[3],mipmapCount:i,isFourCC:4===(4&U[20]),isRGB:64===(64&U[20]),isLuminance:(U[20]&G)===G,isCube:512===(512&U[28]),isCompressed:B===d||B===F||B===y,dxgiFormat:l,textureType:H}}static _GetHalfFloatAsFloatRGBAArrayBuffer(Z,U,n,i,B,l){const V=new Float32Array(i),G=new Uint16Array(B,n);let R=0;for(let d=0;d<U;d++)for(let U=0;U<Z;U++){const n=4*(U+d*Z);V[R]=(0,H.i)(G[n]),V[R+1]=(0,H.i)(G[n+1]),V[R+2]=(0,H.i)(G[n+2]),q.StoreLODInAlphaChannel?V[R+3]=l:V[R+3]=(0,H.i)(G[n+3]),R+=4}return V}static _GetHalfFloatRGBAArrayBuffer(Z,U,n,i,B,l){if(q.StoreLODInAlphaChannel){const V=new Uint16Array(i),G=new Uint16Array(B,n);let R=0;for(let n=0;n<U;n++)for(let U=0;U<Z;U++){const i=4*(U+n*Z);V[R]=G[i],V[R+1]=G[i+1],V[R+2]=G[i+2],V[R+3]=(0,H.p)(l),R+=4}return V}return new Uint16Array(B,n,i)}static _GetFloatRGBAArrayBuffer(Z,U,n,i,B,l){if(q.StoreLODInAlphaChannel){const H=new Float32Array(i),V=new Float32Array(B,n);let G=0;for(let n=0;n<U;n++)for(let U=0;U<Z;U++){const i=4*(U+n*Z);H[G]=V[i],H[G+1]=V[i+1],H[G+2]=V[i+2],H[G+3]=l,G+=4}return H}return new Float32Array(B,n,i)}static _GetFloatAsHalfFloatRGBAArrayBuffer(Z,U,n,i,B,l){const V=new Uint16Array(i),G=new Float32Array(B,n);let R=0;for(let d=0;d<U;d++)for(let U=0;U<Z;U++)V[R]=(0,H.p)(G[R]),V[R+1]=(0,H.p)(G[R+1]),V[R+2]=(0,H.p)(G[R+2]),q.StoreLODInAlphaChannel?V[R+3]=(0,H.p)(l):V[R+3]=(0,H.p)(G[R+3]),R+=4;return V}static _GetFloatAsUIntRGBAArrayBuffer(Z,U,n,B,l,H){const V=new Uint8Array(B),G=new Float32Array(l,n);let R=0;for(let d=0;d<U;d++)for(let U=0;U<Z;U++){const n=4*(U+d*Z);V[R]=255*(0,i.Clamp)(G[n]),V[R+1]=255*(0,i.Clamp)(G[n+1]),V[R+2]=255*(0,i.Clamp)(G[n+2]),q.StoreLODInAlphaChannel?V[R+3]=H:V[R+3]=255*(0,i.Clamp)(G[n+3]),R+=4}return V}static _GetHalfFloatAsUIntRGBAArrayBuffer(Z,U,n,B,l,V){const G=new Uint8Array(B),R=new Uint16Array(l,n);let d=0;for(let F=0;F<U;F++)for(let U=0;U<Z;U++){const n=4*(U+F*Z);G[d]=255*(0,i.Clamp)((0,H.i)(R[n])),G[d+1]=255*(0,i.Clamp)((0,H.i)(R[n+1])),G[d+2]=255*(0,i.Clamp)((0,H.i)(R[n+2])),q.StoreLODInAlphaChannel?G[d+3]=V:G[d+3]=255*(0,i.Clamp)((0,H.i)(R[n+3])),d+=4}return G}static _GetRGBAArrayBuffer(Z,U,n,i,B,l,H,V,G){const R=new Uint8Array(i),d=new Uint8Array(B,n);let F=0;for(let y=0;y<U;y++)for(let U=0;U<Z;U++){const n=4*(U+y*Z);R[F]=d[n+l],R[F+1]=d[n+H],R[F+2]=d[n+V],R[F+3]=d[n+G],F+=4}return R}static _ExtractLongWordOrder(Z){return 0===Z||255===Z||-16777216===Z?0:1+q._ExtractLongWordOrder(Z>>8)}static _GetRGBArrayBuffer(Z,U,n,i,B,l,H,V){const G=new Uint8Array(i),R=new Uint8Array(B,n);let d=0;for(let F=0;F<U;F++)for(let U=0;U<Z;U++){const n=3*(U+F*Z);G[d]=R[n+l],G[d+1]=R[n+H],G[d+2]=R[n+V],d+=3}return G}static _GetLuminanceArrayBuffer(Z,U,n,i,B){const l=new Uint8Array(i),H=new Uint8Array(B,n);let V=0;for(let G=0;G<U;G++)for(let U=0;U<Z;U++){const n=U+G*Z;l[V]=H[n],V++}return l}static UploadDDSLevels(Z,U,n,i,H,G){let R=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,c=arguments.length>7?arguments[7]:void 0,s=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],z=null;i.sphericalPolynomial&&(z=[]);const O=!!Z.getCaps().s3tc;U.generateMipMaps=H;const E=new Int32Array(n.buffer,n.byteOffset,31);let t,p,K,C,D,u,j,v=0,X=0,h=1;if(542327876!==E[0])return void B.c.Error("Invalid magic number in DDS header");if(!i.isFourCC&&!i.isRGB&&!i.isLuminance)return void B.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(i.isCompressed&&!O)return void B.c.Error("Compressed textures are not supported on this platform.");let P=E[22];C=E[1]+4;let T=!1;if(i.isFourCC)switch(t=E[21],t){case d:h=8,X=33777;break;case F:h=16,X=33778;break;case y:h=16,X=33779;break;case 113:T=!0,P=64;break;case 116:T=!0,P=128;break;case S:{C+=20;let Z=!1;switch(i.dxgiFormat){case 10:T=!0,P=64,Z=!0;break;case 2:T=!0,P=128,Z=!0;break;case 88:i.isRGB=!0,i.isFourCC=!1,P=32,Z=!0}if(Z)break}default:return void B.c.Error(["Unsupported FourCC code:",(x=t,String.fromCharCode(255&x,x>>8&255,x>>16&255,x>>24&255))])}var x;const w=q._ExtractLongWordOrder(E[23]),o=q._ExtractLongWordOrder(E[24]),N=q._ExtractLongWordOrder(E[25]),J=q._ExtractLongWordOrder(E[26]);T&&(X=Z._getRGBABufferInternalSizedFormat(i.textureType)),u=1,E[2]&V&&!1!==H&&(u=Math.max(1,E[7]));const W=c||0,a=Z.getCaps();for(let B=W;B<G;B++){for(p=E[4],K=E[3],j=0;j<u;++j){if(-1===R||R===j){const l=-1===R?j:0;if(!i.isCompressed&&i.isFourCC){U.format=5,v=p*K*4;let i=null;if(Z._badOS||Z._badDesktopOS||!a.textureHalfFloat&&!a.textureFloat)128===P?(i=q._GetFloatAsUIntRGBAArrayBuffer(p,K,n.byteOffset+C,v,n.buffer,l),z&&0==l&&z.push(q._GetFloatRGBAArrayBuffer(p,K,n.byteOffset+C,v,n.buffer,l))):64===P&&(i=q._GetHalfFloatAsUIntRGBAArrayBuffer(p,K,n.byteOffset+C,v,n.buffer,l),z&&0==l&&z.push(q._GetHalfFloatAsFloatRGBAArrayBuffer(p,K,n.byteOffset+C,v,n.buffer,l))),U.type=0;else{const Z=a.textureFloat&&(s&&a.textureFloatLinearFiltering||!s),B=a.textureHalfFloat&&(s&&a.textureHalfFloatLinearFiltering||!s),H=(128===P||64===P&&!B)&&Z?1:(64===P||128===P&&!Z)&&B?2:0;let V,G=null;if(128===P)switch(H){case 1:V=q._GetFloatRGBAArrayBuffer,G=null;break;case 2:V=q._GetFloatAsHalfFloatRGBAArrayBuffer,G=q._GetFloatRGBAArrayBuffer;break;case 0:V=q._GetFloatAsUIntRGBAArrayBuffer,G=q._GetFloatRGBAArrayBuffer}else switch(H){case 1:V=q._GetHalfFloatAsFloatRGBAArrayBuffer,G=null;break;case 2:V=q._GetHalfFloatRGBAArrayBuffer,G=q._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:V=q._GetHalfFloatAsUIntRGBAArrayBuffer,G=q._GetHalfFloatAsFloatRGBAArrayBuffer}U.type=H,i=V(p,K,n.byteOffset+C,v,n.buffer,l),z&&0==l&&z.push(G?G(p,K,n.byteOffset+C,v,n.buffer,l):i)}i&&Z._uploadDataToTextureDirectly(U,i,B,l)}else if(i.isRGB)U.type=0,24===P?(U.format=4,v=p*K*3,D=q._GetRGBArrayBuffer(p,K,n.byteOffset+C,v,n.buffer,w,o,N),Z._uploadDataToTextureDirectly(U,D,B,l)):(U.format=5,v=p*K*4,D=q._GetRGBAArrayBuffer(p,K,n.byteOffset+C,v,n.buffer,w,o,N,J),Z._uploadDataToTextureDirectly(U,D,B,l));else if(i.isLuminance){const i=Z._getUnpackAlignement(),H=p;v=Math.floor((p+i-1)/i)*i*(K-1)+H,D=q._GetLuminanceArrayBuffer(p,K,n.byteOffset+C,v,n.buffer),U.format=1,U.type=0,Z._uploadDataToTextureDirectly(U,D,B,l)}else v=Math.max(4,p)/4*Math.max(4,K)/4*h,D=new Uint8Array(n.buffer,n.byteOffset+C,v),U.type=0,Z._uploadCompressedDataToTextureDirectly(U,X,p,K,D,B,l)}C+=P?p*K*(P/8):v,p*=.5,K*=.5,p=Math.max(1,p),K=Math.max(1,K)}if(void 0!==c)break}z&&z.length>0?i.sphericalPolynomial=l.b.ConvertCubeMapToSphericalPolynomial({size:E[4],right:z[0],left:z[1],up:z[2],down:z[3],front:z[4],back:z[5],format:5,type:1,gammaSpace:!1}):i.sphericalPolynomial=void 0}}q.StoreLODInAlphaChannel=!1}}]);