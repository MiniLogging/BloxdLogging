"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10677:(V,n,O)=>{O.r(n),O.d(n,{_DDSTextureLoader:()=>f});var H=O(1511),g=O(1542);class f{constructor(){this.supportCascades=!0}loadCubeData(V,n,O,f){const x=n.getEngine();let c,e=!1,U=1e3;if(Array.isArray(V))for(let H=0;H<V.length;H++){const O=V[H];c=g.c.GetDDSInfo(O),n.width=c.width,n.height=c.height,e=(c.isRGB||c.isLuminance||c.mipmapCount>1)&&n.generateMipMaps,x._unpackFlipY(c.isCompressed),g.c.UploadDDSLevels(x,n,O,c,e,6,-1,H),c.isFourCC||1!==c.mipmapCount?U=c.mipmapCount-1:x.generateMipMapsForCubemap(n)}else{const f=V;c=g.c.GetDDSInfo(f),n.width=c.width,n.height=c.height,O&&(c.sphericalPolynomial=new H.h),e=(c.isRGB||c.isLuminance||c.mipmapCount>1)&&n.generateMipMaps,x._unpackFlipY(c.isCompressed),g.c.UploadDDSLevels(x,n,f,c,e,6),c.isFourCC||1!==c.mipmapCount?U=c.mipmapCount-1:x.generateMipMapsForCubemap(n,!1)}x._setCubeMapTextureParams(n,e,U),n.isReady=!0,n.onLoadedObservable.notifyObservers(n),n.onLoadedObservable.clear(),f&&f({isDDS:!0,width:n.width,info:c,data:V,texture:n})}loadData(V,n,O){const H=g.c.GetDDSInfo(V),f=(H.isRGB||H.isLuminance||H.mipmapCount>1)&&n.generateMipMaps&&Math.max(H.width,H.height)>>H.mipmapCount-1===1;O(H.width,H.height,f,H.isFourCC,(()=>{g.c.UploadDDSLevels(n.getEngine(),n,V,H,f,1)}))}}}}]);