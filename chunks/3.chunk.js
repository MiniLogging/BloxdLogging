"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3,6],{2414:(J,T,b)=>{var q=b(615),t=b(519),j=b(556),B=b(644),Y=b(581),C=b(632);Y.b.prototype._partialLoadFile=function(J,T,b,q){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(J,(J=>{b[T]=J,b._internalCount++,6===b._internalCount&&q(b)}),void 0,void 0,!0,((J,T)=>{t&&J&&t(J.status+" "+J.statusText,T)}))},Y.b.prototype._cascadeLoadFiles=function(J,T,b){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const t=[];t._internalCount=0;for(let j=0;j<6;j++)this._partialLoadFile(b[j],j,t,T,q)},Y.b.prototype._cascadeLoadImgs=function(J,T,b,q){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,j=arguments.length>5?arguments[5]:void 0;const B=[];B._internalCount=0;for(let Y=0;Y<6;Y++)this._partialLoadImg(q[Y],Y,B,J,T,b,t,j)},Y.b.prototype._partialLoadImg=function(J,T,b,q,t,Y){let C=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,F=arguments.length>7?arguments[7]:void 0;const A=(0,B.e)();(0,j.o)(J,(J=>{b[T]=J,b._internalCount++,q&&q.removePendingData(A),6===b._internalCount&&Y&&Y(t,b)}),((J,T)=>{q&&q.removePendingData(A),C&&C(J,T)}),q?q.offlineProvider:null,F),q&&q.addPendingData(A)},Y.b.prototype.createCubeTextureBase=function(J,T,b,j){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,F=arguments.length>6?arguments[6]:void 0,A=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,a=arguments.length>8&&void 0!==arguments[8]&&arguments[8],P=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,v=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,G=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,x=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,I=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,u=arguments.length>14&&void 0!==arguments[14]&&arguments[14],U=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const K=G||new q.d(this,7);K.isCube=!0,K.url=J,K.generateMipMaps=!j,K._lodGenerationScale=P,K._lodGenerationOffset=v,K._useSRGBBuffer=!!u&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!j),K!==G&&(K.label=J.substring(0,60)),this._doNotHandleContextLost||(K._extension=A,K._files=b,K._buffer=U);const E=J;this._transformTextureUrl&&!G&&(J=this._transformTextureUrl(J));const l=A??function(J){const T=J.split("?")[0],b=T.lastIndexOf(".");return b>-1?T.substring(b).toLowerCase():""}(J),W=(0,C.c)(l),p=(J,T)=>{K.dispose(),Y?Y(J,T):J&&t.d.Warn(J)},o=(q,Y)=>{J===E?q&&p(q.status+" "+q.statusText,Y):(t.d.Warn(`Failed to load ${J}, falling back to the ${E}`),this.createCubeTextureBase(E,T,b,!!j,B,p,F,A,a,P,v,K,x,I,u,U))};if(W)W.then((q=>{const t=J=>{x&&x(K,J),q.loadCubeData(J,K,a,B,((J,T)=>{p(J,T)}))};U?t(U):b&&6===b.length?q.supportCascades?this._cascadeLoadFiles(T,(J=>t(J.map((J=>new Uint8Array(J))))),b,p):p("Textures type does not support cascades."):this._loadFile(J,(J=>t(new Uint8Array(J))),void 0,void 0,!0,o)}));else{if(!b||0===b.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(T,K,((J,T)=>{I&&I(J,T)}),b,p)}return this._internalTexturesCache.push(K),K}},2277:(J,T,b)=>{b.r(T),b.d(T,{_DDSTextureLoader:()=>j});var q=b(2279),t=b(2300);class j{constructor(){this.supportCascades=!0}loadCubeData(J,T,b,j){const B=T.getEngine();let Y,C=!1,F=1e3;if(Array.isArray(J))for(let q=0;q<J.length;q++){const b=J[q];Y=t.DDSTools.GetDDSInfo(b),T.width=Y.width,T.height=Y.height,C=(Y.isRGB||Y.isLuminance||Y.mipmapCount>1)&&T.generateMipMaps,B._unpackFlipY(Y.isCompressed),t.DDSTools.UploadDDSLevels(B,T,b,Y,C,6,-1,q),Y.isFourCC||1!==Y.mipmapCount?F=Y.mipmapCount-1:B.generateMipMapsForCubemap(T)}else{const j=J;Y=t.DDSTools.GetDDSInfo(j),T.width=Y.width,T.height=Y.height,b&&(Y.sphericalPolynomial=new q.i),C=(Y.isRGB||Y.isLuminance||Y.mipmapCount>1)&&T.generateMipMaps,B._unpackFlipY(Y.isCompressed),t.DDSTools.UploadDDSLevels(B,T,j,Y,C,6),Y.isFourCC||1!==Y.mipmapCount?F=Y.mipmapCount-1:B.generateMipMapsForCubemap(T,!1)}B._setCubeMapTextureParams(T,C,F),T.isReady=!0,T.onLoadedObservable.notifyObservers(T),T.onLoadedObservable.clear(),j&&j({isDDS:!0,width:T.width,info:Y,data:J,texture:T})}loadData(J,T,b){const q=t.DDSTools.GetDDSInfo(J),j=(q.isRGB||q.isLuminance||q.mipmapCount>1)&&T.generateMipMaps&&Math.max(q.width,q.height)>>q.mipmapCount-1===1;b(q.width,q.height,j,q.isFourCC,(()=>{t.DDSTools.UploadDDSLevels(T.getEngine(),T,J,q,j,1)}))}}},2300:(J,T,b)=>{b.d(T,{DDSTools:()=>G});var q=b(717),t=b(519),j=b(2309),B=b(2317);b(2414);const Y=131072,C=131072;function F(J){return J.charCodeAt(0)+(J.charCodeAt(1)<<8)+(J.charCodeAt(2)<<16)+(J.charCodeAt(3)<<24)}const A=F("DXT1"),a=F("DXT3"),P=F("DXT5"),v=F("DX10");class G{static GetDDSInfo(J){const T=new Int32Array(J.buffer,J.byteOffset,31),b=new Int32Array(J.buffer,J.byteOffset,35);let q=1;T[2]&Y&&(q=Math.max(1,T[7]));const t=T[21],j=t===v?b[32]:0;let B=0;switch(t){case 113:B=2;break;case 116:B=1;break;case v:if(10===j){B=2;break}if(2===j){B=1;break}}return{width:T[4],height:T[3],mipmapCount:q,isFourCC:4===(4&T[20]),isRGB:64===(64&T[20]),isLuminance:(T[20]&C)===C,isCube:512===(512&T[28]),isCompressed:t===A||t===a||t===P,dxgiFormat:j,textureType:B}}static _GetHalfFloatAsFloatRGBAArrayBuffer(J,T,b,q,t,j){const Y=new Float32Array(q),C=new Uint16Array(t,b);let F=0;for(let A=0;A<T;A++)for(let T=0;T<J;T++){const b=4*(T+A*J);Y[F]=(0,B.i)(C[b]),Y[F+1]=(0,B.i)(C[b+1]),Y[F+2]=(0,B.i)(C[b+2]),G.StoreLODInAlphaChannel?Y[F+3]=j:Y[F+3]=(0,B.i)(C[b+3]),F+=4}return Y}static _GetHalfFloatRGBAArrayBuffer(J,T,b,q,t,j){if(G.StoreLODInAlphaChannel){const Y=new Uint16Array(q),C=new Uint16Array(t,b);let F=0;for(let b=0;b<T;b++)for(let T=0;T<J;T++){const q=4*(T+b*J);Y[F]=C[q],Y[F+1]=C[q+1],Y[F+2]=C[q+2],Y[F+3]=(0,B.o)(j),F+=4}return Y}return new Uint16Array(t,b,q)}static _GetFloatRGBAArrayBuffer(J,T,b,q,t,j){if(G.StoreLODInAlphaChannel){const B=new Float32Array(q),Y=new Float32Array(t,b);let C=0;for(let b=0;b<T;b++)for(let T=0;T<J;T++){const q=4*(T+b*J);B[C]=Y[q],B[C+1]=Y[q+1],B[C+2]=Y[q+2],B[C+3]=j,C+=4}return B}return new Float32Array(t,b,q)}static _GetFloatAsHalfFloatRGBAArrayBuffer(J,T,b,q,t,j){const Y=new Uint16Array(q),C=new Float32Array(t,b);let F=0;for(let A=0;A<T;A++)for(let T=0;T<J;T++)Y[F]=(0,B.o)(C[F]),Y[F+1]=(0,B.o)(C[F+1]),Y[F+2]=(0,B.o)(C[F+2]),G.StoreLODInAlphaChannel?Y[F+3]=(0,B.o)(j):Y[F+3]=(0,B.o)(C[F+3]),F+=4;return Y}static _GetFloatAsUIntRGBAArrayBuffer(J,T,b,t,j,B){const Y=new Uint8Array(t),C=new Float32Array(j,b);let F=0;for(let A=0;A<T;A++)for(let T=0;T<J;T++){const b=4*(T+A*J);Y[F]=255*(0,q.b)(C[b]),Y[F+1]=255*(0,q.b)(C[b+1]),Y[F+2]=255*(0,q.b)(C[b+2]),G.StoreLODInAlphaChannel?Y[F+3]=B:Y[F+3]=255*(0,q.b)(C[b+3]),F+=4}return Y}static _GetHalfFloatAsUIntRGBAArrayBuffer(J,T,b,t,j,Y){const C=new Uint8Array(t),F=new Uint16Array(j,b);let A=0;for(let a=0;a<T;a++)for(let T=0;T<J;T++){const b=4*(T+a*J);C[A]=255*(0,q.b)((0,B.i)(F[b])),C[A+1]=255*(0,q.b)((0,B.i)(F[b+1])),C[A+2]=255*(0,q.b)((0,B.i)(F[b+2])),G.StoreLODInAlphaChannel?C[A+3]=Y:C[A+3]=255*(0,q.b)((0,B.i)(F[b+3])),A+=4}return C}static _GetRGBAArrayBuffer(J,T,b,q,t,j,B,Y,C){const F=new Uint8Array(q),A=new Uint8Array(t,b);let a=0;for(let P=0;P<T;P++)for(let T=0;T<J;T++){const b=4*(T+P*J);F[a]=A[b+j],F[a+1]=A[b+B],F[a+2]=A[b+Y],F[a+3]=A[b+C],a+=4}return F}static _ExtractLongWordOrder(J){return 0===J||255===J||-16777216===J?0:1+G._ExtractLongWordOrder(J>>8)}static _GetRGBArrayBuffer(J,T,b,q,t,j,B,Y){const C=new Uint8Array(q),F=new Uint8Array(t,b);let A=0;for(let a=0;a<T;a++)for(let T=0;T<J;T++){const b=3*(T+a*J);C[A]=F[b+j],C[A+1]=F[b+B],C[A+2]=F[b+Y],A+=3}return C}static _GetLuminanceArrayBuffer(J,T,b,q,t){const j=new Uint8Array(q),B=new Uint8Array(t,b);let Y=0;for(let C=0;C<T;C++)for(let T=0;T<J;T++){const b=T+C*J;j[Y]=B[b],Y++}return j}static UploadDDSLevels(J,T,b,q,B,C){let F=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,x=arguments.length>7?arguments[7]:void 0,I=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],u=null;q.sphericalPolynomial&&(u=[]);const U=!!J.getCaps().s3tc;T.generateMipMaps=B;const K=new Int32Array(b.buffer,b.byteOffset,31);let E,l,W,p,o,S,H,s=0,g=0,d=1;if(542327876!==K[0])return void t.d.Error("Invalid magic number in DDS header");if(!q.isFourCC&&!q.isRGB&&!q.isLuminance)return void t.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(q.isCompressed&&!U)return void t.d.Error("Compressed textures are not supported on this platform.");let w=K[22];p=K[1]+4;let Z=!1;if(q.isFourCC)switch(E=K[21],E){case A:d=8,g=33777;break;case a:d=16,g=33778;break;case P:d=16,g=33779;break;case 113:Z=!0,w=64;break;case 116:Z=!0,w=128;break;case v:{p+=20;let J=!1;switch(q.dxgiFormat){case 10:Z=!0,w=64,J=!0;break;case 2:Z=!0,w=128,J=!0;break;case 88:q.isRGB=!0,q.isFourCC=!1,w=32,J=!0}if(J)break}default:return void t.d.Error(["Unsupported FourCC code:",(e=E,String.fromCharCode(255&e,e>>8&255,e>>16&255,e>>24&255))])}var e;const c=G._ExtractLongWordOrder(K[23]),V=G._ExtractLongWordOrder(K[24]),Q=G._ExtractLongWordOrder(K[25]),h=G._ExtractLongWordOrder(K[26]);Z&&(g=J._getRGBABufferInternalSizedFormat(q.textureType)),S=1,K[2]&Y&&!1!==B&&(S=Math.max(1,K[7]));const i=x||0,m=J.getCaps();for(let t=i;t<C;t++){for(l=K[4],W=K[3],H=0;H<S;++H){if(-1===F||F===H){const j=-1===F?H:0;if(!q.isCompressed&&q.isFourCC){T.format=5,s=l*W*4;let q=null;if(J._badOS||J._badDesktopOS||!m.textureHalfFloat&&!m.textureFloat)128===w?(q=G._GetFloatAsUIntRGBAArrayBuffer(l,W,b.byteOffset+p,s,b.buffer,j),u&&0==j&&u.push(G._GetFloatRGBAArrayBuffer(l,W,b.byteOffset+p,s,b.buffer,j))):64===w&&(q=G._GetHalfFloatAsUIntRGBAArrayBuffer(l,W,b.byteOffset+p,s,b.buffer,j),u&&0==j&&u.push(G._GetHalfFloatAsFloatRGBAArrayBuffer(l,W,b.byteOffset+p,s,b.buffer,j))),T.type=0;else{const J=m.textureFloat&&(I&&m.textureFloatLinearFiltering||!I),t=m.textureHalfFloat&&(I&&m.textureHalfFloatLinearFiltering||!I),B=(128===w||64===w&&!t)&&J?1:(64===w||128===w&&!J)&&t?2:0;let Y,C=null;if(128===w)switch(B){case 1:Y=G._GetFloatRGBAArrayBuffer,C=null;break;case 2:Y=G._GetFloatAsHalfFloatRGBAArrayBuffer,C=G._GetFloatRGBAArrayBuffer;break;case 0:Y=G._GetFloatAsUIntRGBAArrayBuffer,C=G._GetFloatRGBAArrayBuffer}else switch(B){case 1:Y=G._GetHalfFloatAsFloatRGBAArrayBuffer,C=null;break;case 2:Y=G._GetHalfFloatRGBAArrayBuffer,C=G._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:Y=G._GetHalfFloatAsUIntRGBAArrayBuffer,C=G._GetHalfFloatAsFloatRGBAArrayBuffer}T.type=B,q=Y(l,W,b.byteOffset+p,s,b.buffer,j),u&&0==j&&u.push(C?C(l,W,b.byteOffset+p,s,b.buffer,j):q)}q&&J._uploadDataToTextureDirectly(T,q,t,j)}else if(q.isRGB)T.type=0,24===w?(T.format=4,s=l*W*3,o=G._GetRGBArrayBuffer(l,W,b.byteOffset+p,s,b.buffer,c,V,Q),J._uploadDataToTextureDirectly(T,o,t,j)):(T.format=5,s=l*W*4,o=G._GetRGBAArrayBuffer(l,W,b.byteOffset+p,s,b.buffer,c,V,Q,h),J._uploadDataToTextureDirectly(T,o,t,j));else if(q.isLuminance){const q=J._getUnpackAlignement(),B=l;s=Math.floor((l+q-1)/q)*q*(W-1)+B,o=G._GetLuminanceArrayBuffer(l,W,b.byteOffset+p,s,b.buffer),T.format=1,T.type=0,J._uploadDataToTextureDirectly(T,o,t,j)}else s=Math.max(4,l)/4*Math.max(4,W)/4*d,o=new Uint8Array(b.buffer,b.byteOffset+p,s),T.type=0,J._uploadCompressedDataToTextureDirectly(T,g,l,W,o,t,j)}p+=w?l*W*(w/8):s,l*=.5,W*=.5,l=Math.max(1,l),W=Math.max(1,W)}if(void 0!==x)break}u&&u.length>0?q.sphericalPolynomial=j.c.ConvertCubeMapToSphericalPolynomial({size:K[4],right:u[0],left:u[1],up:u[2],down:u[3],front:u[4],back:u[5],format:5,type:1,gammaSpace:!1}):q.sphericalPolynomial=void 0}}G.StoreLODInAlphaChannel=!1}}]);