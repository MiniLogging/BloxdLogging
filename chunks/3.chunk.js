"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10330:(R,N,q)=>{q.r(N),q.d(N,{_DDSTextureLoader:()=>M});var w=q(1450),u=q(1484);class M{constructor(){this.supportCascades=!0}loadCubeData(R,N,q,M){const v=N.getEngine();let G,J=!1,y=1e3;if(Array.isArray(R))for(let w=0;w<R.length;w++){const q=R[w];G=u.b.GetDDSInfo(q),N.width=G.width,N.height=G.height,J=(G.isRGB||G.isLuminance||G.mipmapCount>1)&&N.generateMipMaps,v._unpackFlipY(G.isCompressed),u.b.UploadDDSLevels(v,N,q,G,J,6,-1,w),G.isFourCC||1!==G.mipmapCount?y=G.mipmapCount-1:v.generateMipMapsForCubemap(N)}else{const M=R;G=u.b.GetDDSInfo(M),N.width=G.width,N.height=G.height,q&&(G.sphericalPolynomial=new w.h),J=(G.isRGB||G.isLuminance||G.mipmapCount>1)&&N.generateMipMaps,v._unpackFlipY(G.isCompressed),u.b.UploadDDSLevels(v,N,M,G,J,6),G.isFourCC||1!==G.mipmapCount?y=G.mipmapCount-1:v.generateMipMapsForCubemap(N,!1)}v._setCubeMapTextureParams(N,J,y),N.isReady=!0,N.onLoadedObservable.notifyObservers(N),N.onLoadedObservable.clear(),M&&M({isDDS:!0,width:N.width,info:G,data:R,texture:N})}loadData(R,N,q){const w=u.b.GetDDSInfo(R),M=(w.isRGB||w.isLuminance||w.mipmapCount>1)&&N.generateMipMaps&&Math.max(w.width,w.height)>>w.mipmapCount-1===1;q(w.width,w.height,M,w.isFourCC,(()=>{u.b.UploadDDSLevels(N.getEngine(),N,R,w,M,1)}))}}}}]);