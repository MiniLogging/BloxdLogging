"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10419:(U,b,e)=>{e.r(b),e.d(b,{_DDSTextureLoader:()=>m});var K=e(1452),p=e(1477);class m{constructor(){this.supportCascades=!0}loadCubeData(U,b,e,m){const i=b.getEngine();let D,S=!1,u=1e3;if(Array.isArray(U))for(let K=0;K<U.length;K++){const e=U[K];D=p.c.GetDDSInfo(e),b.width=D.width,b.height=D.height,S=(D.isRGB||D.isLuminance||D.mipmapCount>1)&&b.generateMipMaps,i._unpackFlipY(D.isCompressed),p.c.UploadDDSLevels(i,b,e,D,S,6,-1,K),D.isFourCC||1!==D.mipmapCount?u=D.mipmapCount-1:i.generateMipMapsForCubemap(b)}else{const m=U;D=p.c.GetDDSInfo(m),b.width=D.width,b.height=D.height,e&&(D.sphericalPolynomial=new K.f),S=(D.isRGB||D.isLuminance||D.mipmapCount>1)&&b.generateMipMaps,i._unpackFlipY(D.isCompressed),p.c.UploadDDSLevels(i,b,m,D,S,6),D.isFourCC||1!==D.mipmapCount?u=D.mipmapCount-1:i.generateMipMapsForCubemap(b,!1)}i._setCubeMapTextureParams(b,S,u),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),m&&m({isDDS:!0,width:b.width,info:D,data:U,texture:b})}loadData(U,b,e){const K=p.c.GetDDSInfo(U),m=(K.isRGB||K.isLuminance||K.mipmapCount>1)&&b.generateMipMaps&&Math.max(K.width,K.height)>>K.mipmapCount-1===1;e(K.width,K.height,m,K.isFourCC,(()=>{p.c.UploadDDSLevels(b.getEngine(),b,U,K,m,1)}))}}}}]);