"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3,6],{2510:(u,F,z)=>{var p=z(651),b=z(541),R=z(583),c=z(670),I=z(609),G=z(661);I.c.prototype._partialLoadFile=function(u,F,z,p){let b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(u,(u=>{z[F]=u,z._internalCount++,6===z._internalCount&&p(z)}),void 0,void 0,!0,((u,F)=>{b&&u&&b(u.status+" "+u.statusText,F)}))},I.c.prototype._cascadeLoadFiles=function(u,F,z){let p=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const b=[];b._internalCount=0;for(let R=0;R<6;R++)this._partialLoadFile(z[R],R,b,F,p)},I.c.prototype._cascadeLoadImgs=function(u,F,z,p){let b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,R=arguments.length>5?arguments[5]:void 0;const c=[];c._internalCount=0;for(let I=0;I<6;I++)this._partialLoadImg(p[I],I,c,u,F,z,b,R)},I.c.prototype._partialLoadImg=function(u,F,z,p,b,I){let G=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,X=arguments.length>7?arguments[7]:void 0;const j=(0,c.c)();(0,R.p)(u,(u=>{z[F]=u,z._internalCount++,p&&p.removePendingData(j),6===z._internalCount&&I&&I(b,z)}),((u,F)=>{p&&p.removePendingData(j),G&&G(u,F)}),p?p.offlineProvider:null,X),p&&p.addPendingData(j)},I.c.prototype.createCubeTextureBase=function(u,F,z,R){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,X=arguments.length>6?arguments[6]:void 0,j=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,W=arguments.length>8&&void 0!==arguments[8]&&arguments[8],E=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,L=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,k=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,N=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,Y=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,e=arguments.length>14&&void 0!==arguments[14]&&arguments[14],d=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const C=k||new p.d(this,7);C.isCube=!0,C.url=u,C.generateMipMaps=!R,C._lodGenerationScale=E,C._lodGenerationOffset=L,C._useSRGBBuffer=!!e&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!R),C!==k&&(C.label=u.substring(0,60)),this._doNotHandleContextLost||(C._extension=j,C._files=z,C._buffer=d);const r=u;this._transformTextureUrl&&!k&&(u=this._transformTextureUrl(u));const f=j??function(u){const F=u.split("?")[0],z=F.lastIndexOf(".");return z>-1?F.substring(z).toLowerCase():""}(u),n=(0,G.c)(f),T=(u,F)=>{C.dispose(),I?I(u,F):u&&b.b.Warn(u)},H=(p,I)=>{u===r?p&&T(p.status+" "+p.statusText,I):(b.b.Warn(`Failed to load ${u}, falling back to the ${r}`),this.createCubeTextureBase(r,F,z,!!R,c,T,X,j,W,E,L,C,N,Y,e,d))};if(n)n.then((p=>{const b=u=>{N&&N(C,u),p.loadCubeData(u,C,W,c,((u,F)=>{T(u,F)}))};d?b(d):z&&6===z.length?p.supportCascades?this._cascadeLoadFiles(F,(u=>b(u.map((u=>new Uint8Array(u))))),z,T):T("Textures type does not support cascades."):this._loadFile(u,(u=>b(new Uint8Array(u))),void 0,void 0,!0,H)}));else{if(!z||0===z.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(F,C,((u,F)=>{Y&&Y(u,F)}),z,T)}return this._internalTexturesCache.push(C),C}},2350:(u,F,z)=>{z.r(F),z.d(F,{_DDSTextureLoader:()=>R});var p=z(2352),b=z(2387);class R{constructor(){this.supportCascades=!0}loadCubeData(u,F,z,R){const c=F.getEngine();let I,G=!1,X=1e3;if(Array.isArray(u))for(let p=0;p<u.length;p++){const z=u[p];I=b.DDSTools.GetDDSInfo(z),F.width=I.width,F.height=I.height,G=(I.isRGB||I.isLuminance||I.mipmapCount>1)&&F.generateMipMaps,c._unpackFlipY(I.isCompressed),b.DDSTools.UploadDDSLevels(c,F,z,I,G,6,-1,p),I.isFourCC||1!==I.mipmapCount?X=I.mipmapCount-1:c.generateMipMapsForCubemap(F)}else{const R=u;I=b.DDSTools.GetDDSInfo(R),F.width=I.width,F.height=I.height,z&&(I.sphericalPolynomial=new p.h),G=(I.isRGB||I.isLuminance||I.mipmapCount>1)&&F.generateMipMaps,c._unpackFlipY(I.isCompressed),b.DDSTools.UploadDDSLevels(c,F,R,I,G,6),I.isFourCC||1!==I.mipmapCount?X=I.mipmapCount-1:c.generateMipMapsForCubemap(F,!1)}c._setCubeMapTextureParams(F,G,X),F.isReady=!0,F.onLoadedObservable.notifyObservers(F),F.onLoadedObservable.clear(),R&&R({isDDS:!0,width:F.width,info:I,data:u,texture:F})}loadData(u,F,z){const p=b.DDSTools.GetDDSInfo(u),R=(p.isRGB||p.isLuminance||p.mipmapCount>1)&&F.generateMipMaps&&Math.max(p.width,p.height)>>p.mipmapCount-1===1;z(p.width,p.height,R,p.isFourCC,(()=>{b.DDSTools.UploadDDSLevels(F.getEngine(),F,u,p,R,1)}))}}},2387:(u,F,z)=>{z.d(F,{DDSTools:()=>k});var p=z(749),b=z(541),R=z(2393),c=z(2400);z(2510);const I=131072,G=131072;function X(u){return u.charCodeAt(0)+(u.charCodeAt(1)<<8)+(u.charCodeAt(2)<<16)+(u.charCodeAt(3)<<24)}const j=X("DXT1"),W=X("DXT3"),E=X("DXT5"),L=X("DX10");class k{static GetDDSInfo(u){const F=new Int32Array(u.buffer,u.byteOffset,31),z=new Int32Array(u.buffer,u.byteOffset,35);let p=1;F[2]&I&&(p=Math.max(1,F[7]));const b=F[21],R=b===L?z[32]:0;let c=0;switch(b){case 113:c=2;break;case 116:c=1;break;case L:if(10===R){c=2;break}if(2===R){c=1;break}}return{width:F[4],height:F[3],mipmapCount:p,isFourCC:4===(4&F[20]),isRGB:64===(64&F[20]),isLuminance:(F[20]&G)===G,isCube:512===(512&F[28]),isCompressed:b===j||b===W||b===E,dxgiFormat:R,textureType:c}}static _GetHalfFloatAsFloatRGBAArrayBuffer(u,F,z,p,b,R){const I=new Float32Array(p),G=new Uint16Array(b,z);let X=0;for(let j=0;j<F;j++)for(let F=0;F<u;F++){const z=4*(F+j*u);I[X]=(0,c.e)(G[z]),I[X+1]=(0,c.e)(G[z+1]),I[X+2]=(0,c.e)(G[z+2]),k.StoreLODInAlphaChannel?I[X+3]=R:I[X+3]=(0,c.e)(G[z+3]),X+=4}return I}static _GetHalfFloatRGBAArrayBuffer(u,F,z,p,b,R){if(k.StoreLODInAlphaChannel){const I=new Uint16Array(p),G=new Uint16Array(b,z);let X=0;for(let z=0;z<F;z++)for(let F=0;F<u;F++){const p=4*(F+z*u);I[X]=G[p],I[X+1]=G[p+1],I[X+2]=G[p+2],I[X+3]=(0,c.m)(R),X+=4}return I}return new Uint16Array(b,z,p)}static _GetFloatRGBAArrayBuffer(u,F,z,p,b,R){if(k.StoreLODInAlphaChannel){const c=new Float32Array(p),I=new Float32Array(b,z);let G=0;for(let z=0;z<F;z++)for(let F=0;F<u;F++){const p=4*(F+z*u);c[G]=I[p],c[G+1]=I[p+1],c[G+2]=I[p+2],c[G+3]=R,G+=4}return c}return new Float32Array(b,z,p)}static _GetFloatAsHalfFloatRGBAArrayBuffer(u,F,z,p,b,R){const I=new Uint16Array(p),G=new Float32Array(b,z);let X=0;for(let j=0;j<F;j++)for(let F=0;F<u;F++)I[X]=(0,c.m)(G[X]),I[X+1]=(0,c.m)(G[X+1]),I[X+2]=(0,c.m)(G[X+2]),k.StoreLODInAlphaChannel?I[X+3]=(0,c.m)(R):I[X+3]=(0,c.m)(G[X+3]),X+=4;return I}static _GetFloatAsUIntRGBAArrayBuffer(u,F,z,b,R,c){const I=new Uint8Array(b),G=new Float32Array(R,z);let X=0;for(let j=0;j<F;j++)for(let F=0;F<u;F++){const z=4*(F+j*u);I[X]=255*(0,p.e)(G[z]),I[X+1]=255*(0,p.e)(G[z+1]),I[X+2]=255*(0,p.e)(G[z+2]),k.StoreLODInAlphaChannel?I[X+3]=c:I[X+3]=255*(0,p.e)(G[z+3]),X+=4}return I}static _GetHalfFloatAsUIntRGBAArrayBuffer(u,F,z,b,R,I){const G=new Uint8Array(b),X=new Uint16Array(R,z);let j=0;for(let W=0;W<F;W++)for(let F=0;F<u;F++){const z=4*(F+W*u);G[j]=255*(0,p.e)((0,c.e)(X[z])),G[j+1]=255*(0,p.e)((0,c.e)(X[z+1])),G[j+2]=255*(0,p.e)((0,c.e)(X[z+2])),k.StoreLODInAlphaChannel?G[j+3]=I:G[j+3]=255*(0,p.e)((0,c.e)(X[z+3])),j+=4}return G}static _GetRGBAArrayBuffer(u,F,z,p,b,R,c,I,G){const X=new Uint8Array(p),j=new Uint8Array(b,z);let W=0;for(let E=0;E<F;E++)for(let F=0;F<u;F++){const z=4*(F+E*u);X[W]=j[z+R],X[W+1]=j[z+c],X[W+2]=j[z+I],X[W+3]=j[z+G],W+=4}return X}static _ExtractLongWordOrder(u){return 0===u||255===u||-16777216===u?0:1+k._ExtractLongWordOrder(u>>8)}static _GetRGBArrayBuffer(u,F,z,p,b,R,c,I){const G=new Uint8Array(p),X=new Uint8Array(b,z);let j=0;for(let W=0;W<F;W++)for(let F=0;F<u;F++){const z=3*(F+W*u);G[j]=X[z+R],G[j+1]=X[z+c],G[j+2]=X[z+I],j+=3}return G}static _GetLuminanceArrayBuffer(u,F,z,p,b){const R=new Uint8Array(p),c=new Uint8Array(b,z);let I=0;for(let G=0;G<F;G++)for(let F=0;F<u;F++){const z=F+G*u;R[I]=c[z],I++}return R}static UploadDDSLevels(u,F,z,p,c,G){let X=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,N=arguments.length>7?arguments[7]:void 0,Y=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],e=null;p.sphericalPolynomial&&(e=[]);const d=!!u.getCaps().s3tc;F.generateMipMaps=c;const C=new Int32Array(z.buffer,z.byteOffset,31);let r,f,n,T,H,y,U,a=0,J=0,q=1;if(542327876!==C[0])return void b.b.Error("Invalid magic number in DDS header");if(!p.isFourCC&&!p.isRGB&&!p.isLuminance)return void b.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(p.isCompressed&&!d)return void b.b.Error("Compressed textures are not supported on this platform.");let Q=C[22];T=C[1]+4;let l=!1;if(p.isFourCC)switch(r=C[21],r){case j:q=8,J=33777;break;case W:q=16,J=33778;break;case E:q=16,J=33779;break;case 113:l=!0,Q=64;break;case 116:l=!0,Q=128;break;case L:{T+=20;let u=!1;switch(p.dxgiFormat){case 10:l=!0,Q=64,u=!0;break;case 2:l=!0,Q=128,u=!0;break;case 88:p.isRGB=!0,p.isFourCC=!1,Q=32,u=!0}if(u)break}default:return void b.b.Error(["Unsupported FourCC code:",(Z=r,String.fromCharCode(255&Z,Z>>8&255,Z>>16&255,Z>>24&255))])}var Z;const s=k._ExtractLongWordOrder(C[23]),o=k._ExtractLongWordOrder(C[24]),v=k._ExtractLongWordOrder(C[25]),m=k._ExtractLongWordOrder(C[26]);l&&(J=u._getRGBABufferInternalSizedFormat(p.textureType)),y=1,C[2]&I&&!1!==c&&(y=Math.max(1,C[7]));const A=N||0,B=u.getCaps();for(let b=A;b<G;b++){for(f=C[4],n=C[3],U=0;U<y;++U){if(-1===X||X===U){const R=-1===X?U:0;if(!p.isCompressed&&p.isFourCC){F.format=5,a=f*n*4;let p=null;if(u._badOS||u._badDesktopOS||!B.textureHalfFloat&&!B.textureFloat)128===Q?(p=k._GetFloatAsUIntRGBAArrayBuffer(f,n,z.byteOffset+T,a,z.buffer,R),e&&0==R&&e.push(k._GetFloatRGBAArrayBuffer(f,n,z.byteOffset+T,a,z.buffer,R))):64===Q&&(p=k._GetHalfFloatAsUIntRGBAArrayBuffer(f,n,z.byteOffset+T,a,z.buffer,R),e&&0==R&&e.push(k._GetHalfFloatAsFloatRGBAArrayBuffer(f,n,z.byteOffset+T,a,z.buffer,R))),F.type=0;else{const u=B.textureFloat&&(Y&&B.textureFloatLinearFiltering||!Y),b=B.textureHalfFloat&&(Y&&B.textureHalfFloatLinearFiltering||!Y),c=(128===Q||64===Q&&!b)&&u?1:(64===Q||128===Q&&!u)&&b?2:0;let I,G=null;if(128===Q)switch(c){case 1:I=k._GetFloatRGBAArrayBuffer,G=null;break;case 2:I=k._GetFloatAsHalfFloatRGBAArrayBuffer,G=k._GetFloatRGBAArrayBuffer;break;case 0:I=k._GetFloatAsUIntRGBAArrayBuffer,G=k._GetFloatRGBAArrayBuffer}else switch(c){case 1:I=k._GetHalfFloatAsFloatRGBAArrayBuffer,G=null;break;case 2:I=k._GetHalfFloatRGBAArrayBuffer,G=k._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:I=k._GetHalfFloatAsUIntRGBAArrayBuffer,G=k._GetHalfFloatAsFloatRGBAArrayBuffer}F.type=c,p=I(f,n,z.byteOffset+T,a,z.buffer,R),e&&0==R&&e.push(G?G(f,n,z.byteOffset+T,a,z.buffer,R):p)}p&&u._uploadDataToTextureDirectly(F,p,b,R)}else if(p.isRGB)F.type=0,24===Q?(F.format=4,a=f*n*3,H=k._GetRGBArrayBuffer(f,n,z.byteOffset+T,a,z.buffer,s,o,v),u._uploadDataToTextureDirectly(F,H,b,R)):(F.format=5,a=f*n*4,H=k._GetRGBAArrayBuffer(f,n,z.byteOffset+T,a,z.buffer,s,o,v,m),u._uploadDataToTextureDirectly(F,H,b,R));else if(p.isLuminance){const p=u._getUnpackAlignement(),c=f;a=Math.floor((f+p-1)/p)*p*(n-1)+c,H=k._GetLuminanceArrayBuffer(f,n,z.byteOffset+T,a,z.buffer),F.format=1,F.type=0,u._uploadDataToTextureDirectly(F,H,b,R)}else a=Math.max(4,f)/4*Math.max(4,n)/4*q,H=new Uint8Array(z.buffer,z.byteOffset+T,a),F.type=0,u._uploadCompressedDataToTextureDirectly(F,J,f,n,H,b,R)}T+=Q?f*n*(Q/8):a,f*=.5,n*=.5,f=Math.max(1,f),n=Math.max(1,n)}if(void 0!==N)break}e&&e.length>0?p.sphericalPolynomial=R.c.ConvertCubeMapToSphericalPolynomial({size:C[4],right:e[0],left:e[1],up:e[2],down:e[3],front:e[4],back:e[5],format:5,type:1,gammaSpace:!1}):p.sphericalPolynomial=void 0}}k.StoreLODInAlphaChannel=!1}}]);