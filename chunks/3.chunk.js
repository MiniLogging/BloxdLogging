"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3,6],{2164:(c,b,A)=>{var o=A(615),t=A(531),n=A(552),h=A(640),s=A(589),L=A(625);s.c.prototype._partialLoadFile=function(c,b,A,o){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(c,(c=>{A[b]=c,A._internalCount++,6===A._internalCount&&o(A)}),void 0,void 0,!0,((c,b)=>{t&&c&&t(c.status+" "+c.statusText,b)}))},s.c.prototype._cascadeLoadFiles=function(c,b,A){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const t=[];t._internalCount=0;for(let n=0;n<6;n++)this._partialLoadFile(A[n],n,t,b,o)},s.c.prototype._cascadeLoadImgs=function(c,b,A,o){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,n=arguments.length>5?arguments[5]:void 0;const h=[];h._internalCount=0;for(let s=0;s<6;s++)this._partialLoadImg(o[s],s,h,c,b,A,t,n)},s.c.prototype._partialLoadImg=function(c,b,A,o,t,s){let L=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,C=arguments.length>7?arguments[7]:void 0;const J=(0,h.d)();(0,n.r)(c,(c=>{A[b]=c,A._internalCount++,o&&o.removePendingData(J),6===A._internalCount&&s&&s(t,A)}),((c,b)=>{o&&o.removePendingData(J),L&&L(c,b)}),o?o.offlineProvider:null,C),o&&o.addPendingData(J)},s.c.prototype.createCubeTextureBase=function(c,b,A,n){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,C=arguments.length>6?arguments[6]:void 0,J=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,X=arguments.length>8&&void 0!==arguments[8]&&arguments[8],R=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,N=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,k=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,E=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,V=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,y=arguments.length>14&&void 0!==arguments[14]&&arguments[14],j=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const F=k||new o.c(this,7);F.isCube=!0,F.url=c,F.generateMipMaps=!n,F._lodGenerationScale=R,F._lodGenerationOffset=N,F._useSRGBBuffer=!!y&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!n),F!==k&&(F.label=c.substring(0,60)),this._doNotHandleContextLost||(F._extension=J,F._files=A,F._buffer=j);const M=c;this._transformTextureUrl&&!k&&(c=this._transformTextureUrl(c));const W=J??function(c){const b=c.split("?")[0],A=b.lastIndexOf(".");return A>-1?b.substring(A).toLowerCase():""}(c),d=(0,L.d)(W),r=(c,b)=>{F.dispose(),s?s(c,b):c&&t.c.Warn(c)},z=(o,s)=>{c===M?o&&r(o.status+" "+o.statusText,s):(t.c.Warn(`Failed to load ${c}, falling back to the ${M}`),this.createCubeTextureBase(M,b,A,!!n,h,r,C,J,X,R,N,F,E,V,y,j))};if(d)d.then((o=>{const t=c=>{E&&E(F,c),o.loadCubeData(c,F,X,h,((c,b)=>{r(c,b)}))};j?t(j):A&&6===A.length?o.supportCascades?this._cascadeLoadFiles(b,(c=>t(c.map((c=>new Uint8Array(c))))),A,r):r("Textures type does not support cascades."):this._loadFile(c,(c=>t(new Uint8Array(c))),void 0,void 0,!0,z)}));else{if(!A||0===A.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(b,F,((c,b)=>{V&&V(c,b)}),A,r)}return this._internalTexturesCache.push(F),F}},2027:(c,b,A)=>{A.r(b),A.d(b,{_DDSTextureLoader:()=>n});var o=A(2031),t=A(2056);class n{constructor(){this.supportCascades=!0}loadCubeData(c,b,A,n){const h=b.getEngine();let s,L=!1,C=1e3;if(Array.isArray(c))for(let o=0;o<c.length;o++){const A=c[o];s=t.DDSTools.GetDDSInfo(A),b.width=s.width,b.height=s.height,L=(s.isRGB||s.isLuminance||s.mipmapCount>1)&&b.generateMipMaps,h._unpackFlipY(s.isCompressed),t.DDSTools.UploadDDSLevels(h,b,A,s,L,6,-1,o),s.isFourCC||1!==s.mipmapCount?C=s.mipmapCount-1:h.generateMipMapsForCubemap(b)}else{const n=c;s=t.DDSTools.GetDDSInfo(n),b.width=s.width,b.height=s.height,A&&(s.sphericalPolynomial=new o.d),L=(s.isRGB||s.isLuminance||s.mipmapCount>1)&&b.generateMipMaps,h._unpackFlipY(s.isCompressed),t.DDSTools.UploadDDSLevels(h,b,n,s,L,6),s.isFourCC||1!==s.mipmapCount?C=s.mipmapCount-1:h.generateMipMapsForCubemap(b,!1)}h._setCubeMapTextureParams(b,L,C),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),n&&n({isDDS:!0,width:b.width,info:s,data:c,texture:b})}loadData(c,b,A){const o=t.DDSTools.GetDDSInfo(c),n=(o.isRGB||o.isLuminance||o.mipmapCount>1)&&b.generateMipMaps&&Math.max(o.width,o.height)>>o.mipmapCount-1===1;A(o.width,o.height,n,o.isFourCC,(()=>{t.DDSTools.UploadDDSLevels(b.getEngine(),b,c,o,n,1)}))}}},2056:(c,b,A)=>{A.d(b,{DDSTools:()=>k});var o=A(702),t=A(531),n=A(2060),h=A(2064);A(2164);const s=131072,L=131072;function C(c){return c.charCodeAt(0)+(c.charCodeAt(1)<<8)+(c.charCodeAt(2)<<16)+(c.charCodeAt(3)<<24)}const J=C("DXT1"),X=C("DXT3"),R=C("DXT5"),N=C("DX10");class k{static GetDDSInfo(c){const b=new Int32Array(c.buffer,c.byteOffset,31),A=new Int32Array(c.buffer,c.byteOffset,35);let o=1;b[2]&s&&(o=Math.max(1,b[7]));const t=b[21],n=t===N?A[32]:0;let h=0;switch(t){case 113:h=2;break;case 116:h=1;break;case N:if(10===n){h=2;break}if(2===n){h=1;break}}return{width:b[4],height:b[3],mipmapCount:o,isFourCC:4===(4&b[20]),isRGB:64===(64&b[20]),isLuminance:(b[20]&L)===L,isCube:512===(512&b[28]),isCompressed:t===J||t===X||t===R,dxgiFormat:n,textureType:h}}static _GetHalfFloatAsFloatRGBAArrayBuffer(c,b,A,o,t,n){const s=new Float32Array(o),L=new Uint16Array(t,A);let C=0;for(let J=0;J<b;J++)for(let b=0;b<c;b++){const A=4*(b+J*c);s[C]=(0,h.g)(L[A]),s[C+1]=(0,h.g)(L[A+1]),s[C+2]=(0,h.g)(L[A+2]),k.StoreLODInAlphaChannel?s[C+3]=n:s[C+3]=(0,h.g)(L[A+3]),C+=4}return s}static _GetHalfFloatRGBAArrayBuffer(c,b,A,o,t,n){if(k.StoreLODInAlphaChannel){const s=new Uint16Array(o),L=new Uint16Array(t,A);let C=0;for(let A=0;A<b;A++)for(let b=0;b<c;b++){const o=4*(b+A*c);s[C]=L[o],s[C+1]=L[o+1],s[C+2]=L[o+2],s[C+3]=(0,h.l)(n),C+=4}return s}return new Uint16Array(t,A,o)}static _GetFloatRGBAArrayBuffer(c,b,A,o,t,n){if(k.StoreLODInAlphaChannel){const h=new Float32Array(o),s=new Float32Array(t,A);let L=0;for(let A=0;A<b;A++)for(let b=0;b<c;b++){const o=4*(b+A*c);h[L]=s[o],h[L+1]=s[o+1],h[L+2]=s[o+2],h[L+3]=n,L+=4}return h}return new Float32Array(t,A,o)}static _GetFloatAsHalfFloatRGBAArrayBuffer(c,b,A,o,t,n){const s=new Uint16Array(o),L=new Float32Array(t,A);let C=0;for(let J=0;J<b;J++)for(let b=0;b<c;b++)s[C]=(0,h.l)(L[C]),s[C+1]=(0,h.l)(L[C+1]),s[C+2]=(0,h.l)(L[C+2]),k.StoreLODInAlphaChannel?s[C+3]=(0,h.l)(n):s[C+3]=(0,h.l)(L[C+3]),C+=4;return s}static _GetFloatAsUIntRGBAArrayBuffer(c,b,A,t,n,h){const s=new Uint8Array(t),L=new Float32Array(n,A);let C=0;for(let J=0;J<b;J++)for(let b=0;b<c;b++){const A=4*(b+J*c);s[C]=255*(0,o.Clamp)(L[A]),s[C+1]=255*(0,o.Clamp)(L[A+1]),s[C+2]=255*(0,o.Clamp)(L[A+2]),k.StoreLODInAlphaChannel?s[C+3]=h:s[C+3]=255*(0,o.Clamp)(L[A+3]),C+=4}return s}static _GetHalfFloatAsUIntRGBAArrayBuffer(c,b,A,t,n,s){const L=new Uint8Array(t),C=new Uint16Array(n,A);let J=0;for(let X=0;X<b;X++)for(let b=0;b<c;b++){const A=4*(b+X*c);L[J]=255*(0,o.Clamp)((0,h.g)(C[A])),L[J+1]=255*(0,o.Clamp)((0,h.g)(C[A+1])),L[J+2]=255*(0,o.Clamp)((0,h.g)(C[A+2])),k.StoreLODInAlphaChannel?L[J+3]=s:L[J+3]=255*(0,o.Clamp)((0,h.g)(C[A+3])),J+=4}return L}static _GetRGBAArrayBuffer(c,b,A,o,t,n,h,s,L){const C=new Uint8Array(o),J=new Uint8Array(t,A);let X=0;for(let R=0;R<b;R++)for(let b=0;b<c;b++){const A=4*(b+R*c);C[X]=J[A+n],C[X+1]=J[A+h],C[X+2]=J[A+s],C[X+3]=J[A+L],X+=4}return C}static _ExtractLongWordOrder(c){return 0===c||255===c||-16777216===c?0:1+k._ExtractLongWordOrder(c>>8)}static _GetRGBArrayBuffer(c,b,A,o,t,n,h,s){const L=new Uint8Array(o),C=new Uint8Array(t,A);let J=0;for(let X=0;X<b;X++)for(let b=0;b<c;b++){const A=3*(b+X*c);L[J]=C[A+n],L[J+1]=C[A+h],L[J+2]=C[A+s],J+=3}return L}static _GetLuminanceArrayBuffer(c,b,A,o,t){const n=new Uint8Array(o),h=new Uint8Array(t,A);let s=0;for(let L=0;L<b;L++)for(let b=0;b<c;b++){const A=b+L*c;n[s]=h[A],s++}return n}static UploadDDSLevels(c,b,A,o,h,L){let C=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,E=arguments.length>7?arguments[7]:void 0,V=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],y=null;o.sphericalPolynomial&&(y=[]);const j=!!c.getCaps().s3tc;b.generateMipMaps=h;const F=new Int32Array(A.buffer,A.byteOffset,31);let M,W,d,r,z,Y,D,f=0,v=0,G=1;if(542327876!==F[0])return void t.c.Error("Invalid magic number in DDS header");if(!o.isFourCC&&!o.isRGB&&!o.isLuminance)return void t.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(o.isCompressed&&!j)return void t.c.Error("Compressed textures are not supported on this platform.");let P=F[22];r=F[1]+4;let O=!1;if(o.isFourCC)switch(M=F[21],M){case J:G=8,v=33777;break;case X:G=16,v=33778;break;case R:G=16,v=33779;break;case 113:O=!0,P=64;break;case 116:O=!0,P=128;break;case N:{r+=20;let c=!1;switch(o.dxgiFormat){case 10:O=!0,P=64,c=!0;break;case 2:O=!0,P=128,c=!0;break;case 88:o.isRGB=!0,o.isFourCC=!1,P=32,c=!0}if(c)break}default:return void t.c.Error(["Unsupported FourCC code:",(p=M,String.fromCharCode(255&p,p>>8&255,p>>16&255,p>>24&255))])}var p;const q=k._ExtractLongWordOrder(F[23]),I=k._ExtractLongWordOrder(F[24]),K=k._ExtractLongWordOrder(F[25]),Z=k._ExtractLongWordOrder(F[26]);O&&(v=c._getRGBABufferInternalSizedFormat(o.textureType)),Y=1,F[2]&s&&!1!==h&&(Y=Math.max(1,F[7]));const H=E||0,S=c.getCaps();for(let t=H;t<L;t++){for(W=F[4],d=F[3],D=0;D<Y;++D){if(-1===C||C===D){const n=-1===C?D:0;if(!o.isCompressed&&o.isFourCC){b.format=5,f=W*d*4;let o=null;if(c._badOS||c._badDesktopOS||!S.textureHalfFloat&&!S.textureFloat)128===P?(o=k._GetFloatAsUIntRGBAArrayBuffer(W,d,A.byteOffset+r,f,A.buffer,n),y&&0==n&&y.push(k._GetFloatRGBAArrayBuffer(W,d,A.byteOffset+r,f,A.buffer,n))):64===P&&(o=k._GetHalfFloatAsUIntRGBAArrayBuffer(W,d,A.byteOffset+r,f,A.buffer,n),y&&0==n&&y.push(k._GetHalfFloatAsFloatRGBAArrayBuffer(W,d,A.byteOffset+r,f,A.buffer,n))),b.type=0;else{const c=S.textureFloat&&(V&&S.textureFloatLinearFiltering||!V),t=S.textureHalfFloat&&(V&&S.textureHalfFloatLinearFiltering||!V),h=(128===P||64===P&&!t)&&c?1:(64===P||128===P&&!c)&&t?2:0;let s,L=null;if(128===P)switch(h){case 1:s=k._GetFloatRGBAArrayBuffer,L=null;break;case 2:s=k._GetFloatAsHalfFloatRGBAArrayBuffer,L=k._GetFloatRGBAArrayBuffer;break;case 0:s=k._GetFloatAsUIntRGBAArrayBuffer,L=k._GetFloatRGBAArrayBuffer}else switch(h){case 1:s=k._GetHalfFloatAsFloatRGBAArrayBuffer,L=null;break;case 2:s=k._GetHalfFloatRGBAArrayBuffer,L=k._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:s=k._GetHalfFloatAsUIntRGBAArrayBuffer,L=k._GetHalfFloatAsFloatRGBAArrayBuffer}b.type=h,o=s(W,d,A.byteOffset+r,f,A.buffer,n),y&&0==n&&y.push(L?L(W,d,A.byteOffset+r,f,A.buffer,n):o)}o&&c._uploadDataToTextureDirectly(b,o,t,n)}else if(o.isRGB)b.type=0,24===P?(b.format=4,f=W*d*3,z=k._GetRGBArrayBuffer(W,d,A.byteOffset+r,f,A.buffer,q,I,K),c._uploadDataToTextureDirectly(b,z,t,n)):(b.format=5,f=W*d*4,z=k._GetRGBAArrayBuffer(W,d,A.byteOffset+r,f,A.buffer,q,I,K,Z),c._uploadDataToTextureDirectly(b,z,t,n));else if(o.isLuminance){const o=c._getUnpackAlignement(),h=W;f=Math.floor((W+o-1)/o)*o*(d-1)+h,z=k._GetLuminanceArrayBuffer(W,d,A.byteOffset+r,f,A.buffer),b.format=1,b.type=0,c._uploadDataToTextureDirectly(b,z,t,n)}else f=Math.max(4,W)/4*Math.max(4,d)/4*G,z=new Uint8Array(A.buffer,A.byteOffset+r,f),b.type=0,c._uploadCompressedDataToTextureDirectly(b,v,W,d,z,t,n)}r+=P?W*d*(P/8):f,W*=.5,d*=.5,W=Math.max(1,W),d=Math.max(1,d)}if(void 0!==E)break}y&&y.length>0?o.sphericalPolynomial=n.d.ConvertCubeMapToSphericalPolynomial({size:F[4],right:y[0],left:y[1],up:y[2],down:y[3],front:y[4],back:y[5],format:5,type:1,gammaSpace:!1}):o.sphericalPolynomial=void 0}}k.StoreLODInAlphaChannel=!1}}]);