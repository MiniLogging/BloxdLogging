"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10647:(C,M,x)=>{x.r(M),x.d(M,{_DDSTextureLoader:()=>z});var f=x(1434),T=x(1462);class z{constructor(){this.supportCascades=!0}loadCubeData(C,M,x,z){const s=M.getEngine();let S,m=!1,Q=1e3;if(Array.isArray(C))for(let f=0;f<C.length;f++){const x=C[f];S=T.d.GetDDSInfo(x),M.width=S.width,M.height=S.height,m=(S.isRGB||S.isLuminance||S.mipmapCount>1)&&M.generateMipMaps,s._unpackFlipY(S.isCompressed),T.d.UploadDDSLevels(s,M,x,S,m,6,-1,f),S.isFourCC||1!==S.mipmapCount?Q=S.mipmapCount-1:s.generateMipMapsForCubemap(M)}else{const z=C;S=T.d.GetDDSInfo(z),M.width=S.width,M.height=S.height,x&&(S.sphericalPolynomial=new f.e),m=(S.isRGB||S.isLuminance||S.mipmapCount>1)&&M.generateMipMaps,s._unpackFlipY(S.isCompressed),T.d.UploadDDSLevels(s,M,z,S,m,6),S.isFourCC||1!==S.mipmapCount?Q=S.mipmapCount-1:s.generateMipMapsForCubemap(M,!1)}s._setCubeMapTextureParams(M,m,Q),M.isReady=!0,M.onLoadedObservable.notifyObservers(M),M.onLoadedObservable.clear(),z&&z({isDDS:!0,width:M.width,info:S,data:C,texture:M})}loadData(C,M,x){const f=T.d.GetDDSInfo(C),z=(f.isRGB||f.isLuminance||f.mipmapCount>1)&&M.generateMipMaps&&Math.max(f.width,f.height)>>f.mipmapCount-1===1;x(f.width,f.height,z,f.isFourCC,(()=>{T.d.UploadDDSLevels(M.getEngine(),M,C,f,z,1)}))}}}}]);