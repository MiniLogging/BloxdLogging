"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10026:(a,i,K)=>{K.r(i),K.d(i,{_DDSTextureLoader:()=>E});var j=K(1533),N=K(1556);class E{constructor(){this.supportCascades=!0}loadCubeData(a,i,K,E){const v=i.getEngine();let e,Y=!1,H=1e3;if(Array.isArray(a))for(let j=0;j<a.length;j++){const K=a[j];e=N.c.GetDDSInfo(K),i.width=e.width,i.height=e.height,Y=(e.isRGB||e.isLuminance||e.mipmapCount>1)&&i.generateMipMaps,v._unpackFlipY(e.isCompressed),N.c.UploadDDSLevels(v,i,K,e,Y,6,-1,j),e.isFourCC||1!==e.mipmapCount?H=e.mipmapCount-1:v.generateMipMapsForCubemap(i)}else{const E=a;e=N.c.GetDDSInfo(E),i.width=e.width,i.height=e.height,K&&(e.sphericalPolynomial=new j.f),Y=(e.isRGB||e.isLuminance||e.mipmapCount>1)&&i.generateMipMaps,v._unpackFlipY(e.isCompressed),N.c.UploadDDSLevels(v,i,E,e,Y,6),e.isFourCC||1!==e.mipmapCount?H=e.mipmapCount-1:v.generateMipMapsForCubemap(i,!1)}v._setCubeMapTextureParams(i,Y,H),i.isReady=!0,i.onLoadedObservable.notifyObservers(i),i.onLoadedObservable.clear(),E&&E({isDDS:!0,width:i.width,info:e,data:a,texture:i})}loadData(a,i,K){const j=N.c.GetDDSInfo(a),E=(j.isRGB||j.isLuminance||j.mipmapCount>1)&&i.generateMipMaps&&Math.max(j.width,j.height)>>j.mipmapCount-1===1;K(j.width,j.height,E,j.isFourCC,(()=>{N.c.UploadDDSLevels(i.getEngine(),i,a,j,E,1)}))}}}}]);