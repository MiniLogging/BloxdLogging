"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10945:(T,z,X)=>{X.r(z),X.d(z,{_DDSTextureLoader:()=>A});var b=X(1437),F=X(1465);class A{constructor(){this.supportCascades=!0}loadCubeData(T,z,X,A){const u=z.getEngine();let y,E=!1,v=1e3;if(Array.isArray(T))for(let b=0;b<T.length;b++){const X=T[b];y=F.c.GetDDSInfo(X),z.width=y.width,z.height=y.height,E=(y.isRGB||y.isLuminance||y.mipmapCount>1)&&z.generateMipMaps,u._unpackFlipY(y.isCompressed),F.c.UploadDDSLevels(u,z,X,y,E,6,-1,b),y.isFourCC||1!==y.mipmapCount?v=y.mipmapCount-1:u.generateMipMapsForCubemap(z)}else{const A=T;y=F.c.GetDDSInfo(A),z.width=y.width,z.height=y.height,X&&(y.sphericalPolynomial=new b.e),E=(y.isRGB||y.isLuminance||y.mipmapCount>1)&&z.generateMipMaps,u._unpackFlipY(y.isCompressed),F.c.UploadDDSLevels(u,z,A,y,E,6),y.isFourCC||1!==y.mipmapCount?v=y.mipmapCount-1:u.generateMipMapsForCubemap(z,!1)}u._setCubeMapTextureParams(z,E,v),z.isReady=!0,z.onLoadedObservable.notifyObservers(z),z.onLoadedObservable.clear(),A&&A({isDDS:!0,width:z.width,info:y,data:T,texture:z})}loadData(T,z,X){const b=F.c.GetDDSInfo(T),A=(b.isRGB||b.isLuminance||b.mipmapCount>1)&&z.generateMipMaps&&Math.max(b.width,b.height)>>b.mipmapCount-1===1;X(b.width,b.height,A,b.isFourCC,(()=>{F.c.UploadDDSLevels(z.getEngine(),z,T,b,A,1)}))}}}}]);