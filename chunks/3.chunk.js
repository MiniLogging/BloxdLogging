"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10297:(G,D,N)=>{N.r(D),N.d(D,{_DDSTextureLoader:()=>Z});var T=N(1471),o=N(1494);class Z{constructor(){this.supportCascades=!0}loadCubeData(G,D,N,Z){const n=D.getEngine();let C,P=!1,r=1e3;if(Array.isArray(G))for(let T=0;T<G.length;T++){const N=G[T];C=o.c.GetDDSInfo(N),D.width=C.width,D.height=C.height,P=(C.isRGB||C.isLuminance||C.mipmapCount>1)&&D.generateMipMaps,n._unpackFlipY(C.isCompressed),o.c.UploadDDSLevels(n,D,N,C,P,6,-1,T),C.isFourCC||1!==C.mipmapCount?r=C.mipmapCount-1:n.generateMipMapsForCubemap(D)}else{const Z=G;C=o.c.GetDDSInfo(Z),D.width=C.width,D.height=C.height,N&&(C.sphericalPolynomial=new T.g),P=(C.isRGB||C.isLuminance||C.mipmapCount>1)&&D.generateMipMaps,n._unpackFlipY(C.isCompressed),o.c.UploadDDSLevels(n,D,Z,C,P,6),C.isFourCC||1!==C.mipmapCount?r=C.mipmapCount-1:n.generateMipMapsForCubemap(D,!1)}n._setCubeMapTextureParams(D,P,r),D.isReady=!0,D.onLoadedObservable.notifyObservers(D),D.onLoadedObservable.clear(),Z&&Z({isDDS:!0,width:D.width,info:C,data:G,texture:D})}loadData(G,D,N){const T=o.c.GetDDSInfo(G),Z=(T.isRGB||T.isLuminance||T.mipmapCount>1)&&D.generateMipMaps&&Math.max(T.width,T.height)>>T.mipmapCount-1===1;N(T.width,T.height,Z,T.isFourCC,(()=>{o.c.UploadDDSLevels(D.getEngine(),D,G,T,Z,1)}))}}}}]);