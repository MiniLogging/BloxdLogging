"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10296:(r,L,M)=>{M.r(L),M.d(L,{_DDSTextureLoader:()=>C});var S=M(1397),T=M(1420);class C{constructor(){this.supportCascades=!0}loadCubeData(r,L,M,C){const y=L.getEngine();let s,v=!1,u=1e3;if(Array.isArray(r))for(let S=0;S<r.length;S++){const M=r[S];s=T.b.GetDDSInfo(M),L.width=s.width,L.height=s.height,v=(s.isRGB||s.isLuminance||s.mipmapCount>1)&&L.generateMipMaps,y._unpackFlipY(s.isCompressed),T.b.UploadDDSLevels(y,L,M,s,v,6,-1,S),s.isFourCC||1!==s.mipmapCount?u=s.mipmapCount-1:y.generateMipMapsForCubemap(L)}else{const C=r;s=T.b.GetDDSInfo(C),L.width=s.width,L.height=s.height,M&&(s.sphericalPolynomial=new S.f),v=(s.isRGB||s.isLuminance||s.mipmapCount>1)&&L.generateMipMaps,y._unpackFlipY(s.isCompressed),T.b.UploadDDSLevels(y,L,C,s,v,6),s.isFourCC||1!==s.mipmapCount?u=s.mipmapCount-1:y.generateMipMapsForCubemap(L,!1)}y._setCubeMapTextureParams(L,v,u),L.isReady=!0,L.onLoadedObservable.notifyObservers(L),L.onLoadedObservable.clear(),C&&C({isDDS:!0,width:L.width,info:s,data:r,texture:L})}loadData(r,L,M){const S=T.b.GetDDSInfo(r),C=(S.isRGB||S.isLuminance||S.mipmapCount>1)&&L.generateMipMaps&&Math.max(S.width,S.height)>>S.mipmapCount-1===1;M(S.width,S.height,C,S.isFourCC,(()=>{T.b.UploadDDSLevels(L.getEngine(),L,r,S,C,1)}))}}}}]);