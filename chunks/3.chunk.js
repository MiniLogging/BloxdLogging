"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{11231:(x,Z,l)=>{l.r(Z),l.d(Z,{_DDSTextureLoader:()=>z});var t=l(1560),L=l(1586);class z{constructor(){this.supportCascades=!0}loadCubeData(x,Z,l,z){const A=Z.getEngine();let P,C=!1,j=1e3;if(Array.isArray(x))for(let t=0;t<x.length;t++){const l=x[t];P=L.d.GetDDSInfo(l),Z.width=P.width,Z.height=P.height,C=(P.isRGB||P.isLuminance||P.mipmapCount>1)&&Z.generateMipMaps,A._unpackFlipY(P.isCompressed),L.d.UploadDDSLevels(A,Z,l,P,C,6,-1,t),P.isFourCC||1!==P.mipmapCount?j=P.mipmapCount-1:A.generateMipMapsForCubemap(Z)}else{const z=x;P=L.d.GetDDSInfo(z),Z.width=P.width,Z.height=P.height,l&&(P.sphericalPolynomial=new t.g),C=(P.isRGB||P.isLuminance||P.mipmapCount>1)&&Z.generateMipMaps,A._unpackFlipY(P.isCompressed),L.d.UploadDDSLevels(A,Z,z,P,C,6),P.isFourCC||1!==P.mipmapCount?j=P.mipmapCount-1:A.generateMipMapsForCubemap(Z,!1)}A._setCubeMapTextureParams(Z,C,j),Z.isReady=!0,Z.onLoadedObservable.notifyObservers(Z),Z.onLoadedObservable.clear(),z&&z({isDDS:!0,width:Z.width,info:P,data:x,texture:Z})}loadData(x,Z,l){const t=L.d.GetDDSInfo(x),z=(t.isRGB||t.isLuminance||t.mipmapCount>1)&&Z.generateMipMaps&&Math.max(t.width,t.height)>>t.mipmapCount-1===1;l(t.width,t.height,z,t.isFourCC,(()=>{L.d.UploadDDSLevels(Z.getEngine(),Z,x,t,z,1)}))}}}}]);