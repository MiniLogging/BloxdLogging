"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3,6],{2394:(A,X,s)=>{var N=s(592),f=s(470),E=s(508),g=s(624),K=s(547),r=s(605);K.d.prototype._partialLoadFile=function(A,X,s,N){let f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(A,(A=>{s[X]=A,s._internalCount++,6===s._internalCount&&N(s)}),void 0,void 0,!0,((A,X)=>{f&&A&&f(A.status+" "+A.statusText,X)}))},K.d.prototype._cascadeLoadFiles=function(A,X,s){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const f=[];f._internalCount=0;for(let E=0;E<6;E++)this._partialLoadFile(s[E],E,f,X,N)},K.d.prototype._cascadeLoadImgs=function(A,X,s,N){let f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,E=arguments.length>5?arguments[5]:void 0;const g=[];g._internalCount=0;for(let K=0;K<6;K++)this._partialLoadImg(N[K],K,g,A,X,s,f,E)},K.d.prototype._partialLoadImg=function(A,X,s,N,f,K){let r=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,i=arguments.length>7?arguments[7]:void 0;const Y=(0,g.c)();(0,E.o)(A,(A=>{s[X]=A,s._internalCount++,N&&N.removePendingData(Y),6===s._internalCount&&K&&K(f,s)}),((A,X)=>{N&&N.removePendingData(Y),r&&r(A,X)}),N?N.offlineProvider:null,i),N&&N.addPendingData(Y)},K.d.prototype.createCubeTextureBase=function(A,X,s,E){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,K=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,v=arguments.length>8&&void 0!==arguments[8]&&arguments[8],c=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,M=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,d=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,Q=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,w=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,R=arguments.length>14&&void 0!==arguments[14]&&arguments[14],C=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const J=d||new N.b(this,7);J.isCube=!0,J.url=A,J.generateMipMaps=!E,J._lodGenerationScale=c,J._lodGenerationOffset=M,J._useSRGBBuffer=!!R&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!E),J!==d&&(J.label=A.substring(0,60)),this._doNotHandleContextLost||(J._extension=Y,J._files=s,J._buffer=C);const a=A;this._transformTextureUrl&&!d&&(A=this._transformTextureUrl(A));const u=Y??function(A){const X=A.split("?")[0],s=X.lastIndexOf(".");return s>-1?X.substring(s).toLowerCase():""}(A),z=(0,r.e)(u),m=(A,X)=>{J.dispose(),K?K(A,X):A&&f.b.Warn(A)},b=(N,K)=>{A===a?N&&m(N.status+" "+N.statusText,K):(f.b.Warn(`Failed to load ${A}, falling back to the ${a}`),this.createCubeTextureBase(a,X,s,!!E,g,m,i,Y,v,c,M,J,Q,w,R,C))};if(z)z.then((N=>{const f=A=>{Q&&Q(J,A),N.loadCubeData(A,J,v,g,((A,X)=>{m(A,X)}))};C?f(C):s&&6===s.length?N.supportCascades?this._cascadeLoadFiles(X,(A=>f(A.map((A=>new Uint8Array(A))))),s,m):m("Textures type does not support cascades."):this._loadFile(A,(A=>f(new Uint8Array(A))),void 0,void 0,!0,b)}));else{if(!s||0===s.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(X,J,((A,X)=>{w&&w(A,X)}),s,m)}return this._internalTexturesCache.push(J),J}},2232:(A,X,s)=>{s.r(X),s.d(X,{_DDSTextureLoader:()=>E});var N=s(2239),f=s(2262);class E{constructor(){this.supportCascades=!0}loadCubeData(A,X,s,E){const g=X.getEngine();let K,r=!1,i=1e3;if(Array.isArray(A))for(let N=0;N<A.length;N++){const s=A[N];K=f.DDSTools.GetDDSInfo(s),X.width=K.width,X.height=K.height,r=(K.isRGB||K.isLuminance||K.mipmapCount>1)&&X.generateMipMaps,g._unpackFlipY(K.isCompressed),f.DDSTools.UploadDDSLevels(g,X,s,K,r,6,-1,N),K.isFourCC||1!==K.mipmapCount?i=K.mipmapCount-1:g.generateMipMapsForCubemap(X)}else{const E=A;K=f.DDSTools.GetDDSInfo(E),X.width=K.width,X.height=K.height,s&&(K.sphericalPolynomial=new N.d),r=(K.isRGB||K.isLuminance||K.mipmapCount>1)&&X.generateMipMaps,g._unpackFlipY(K.isCompressed),f.DDSTools.UploadDDSLevels(g,X,E,K,r,6),K.isFourCC||1!==K.mipmapCount?i=K.mipmapCount-1:g.generateMipMapsForCubemap(X,!1)}g._setCubeMapTextureParams(X,r,i),X.isReady=!0,X.onLoadedObservable.notifyObservers(X),X.onLoadedObservable.clear(),E&&E({isDDS:!0,width:X.width,info:K,data:A,texture:X})}loadData(A,X,s){const N=f.DDSTools.GetDDSInfo(A),E=(N.isRGB||N.isLuminance||N.mipmapCount>1)&&X.generateMipMaps&&Math.max(N.width,N.height)>>N.mipmapCount-1===1;s(N.width,N.height,E,N.isFourCC,(()=>{f.DDSTools.UploadDDSLevels(X.getEngine(),X,A,N,E,1)}))}}},2262:(A,X,s)=>{s.d(X,{DDSTools:()=>d});var N=s(696),f=s(470),E=s(2267),g=s(2274);s(2394);const K=131072,r=131072;function i(A){return A.charCodeAt(0)+(A.charCodeAt(1)<<8)+(A.charCodeAt(2)<<16)+(A.charCodeAt(3)<<24)}const Y=i("DXT1"),v=i("DXT3"),c=i("DXT5"),M=i("DX10");class d{static GetDDSInfo(A){const X=new Int32Array(A.buffer,A.byteOffset,31),s=new Int32Array(A.buffer,A.byteOffset,35);let N=1;X[2]&K&&(N=Math.max(1,X[7]));const f=X[21],E=f===M?s[32]:0;let g=0;switch(f){case 113:g=2;break;case 116:g=1;break;case M:if(10===E){g=2;break}if(2===E){g=1;break}}return{width:X[4],height:X[3],mipmapCount:N,isFourCC:4===(4&X[20]),isRGB:64===(64&X[20]),isLuminance:(X[20]&r)===r,isCube:512===(512&X[28]),isCompressed:f===Y||f===v||f===c,dxgiFormat:E,textureType:g}}static _GetHalfFloatAsFloatRGBAArrayBuffer(A,X,s,N,f,E){const K=new Float32Array(N),r=new Uint16Array(f,s);let i=0;for(let Y=0;Y<X;Y++)for(let X=0;X<A;X++){const s=4*(X+Y*A);K[i]=(0,g.d)(r[s]),K[i+1]=(0,g.d)(r[s+1]),K[i+2]=(0,g.d)(r[s+2]),d.StoreLODInAlphaChannel?K[i+3]=E:K[i+3]=(0,g.d)(r[s+3]),i+=4}return K}static _GetHalfFloatRGBAArrayBuffer(A,X,s,N,f,E){if(d.StoreLODInAlphaChannel){const K=new Uint16Array(N),r=new Uint16Array(f,s);let i=0;for(let s=0;s<X;s++)for(let X=0;X<A;X++){const N=4*(X+s*A);K[i]=r[N],K[i+1]=r[N+1],K[i+2]=r[N+2],K[i+3]=(0,g.f)(E),i+=4}return K}return new Uint16Array(f,s,N)}static _GetFloatRGBAArrayBuffer(A,X,s,N,f,E){if(d.StoreLODInAlphaChannel){const g=new Float32Array(N),K=new Float32Array(f,s);let r=0;for(let s=0;s<X;s++)for(let X=0;X<A;X++){const N=4*(X+s*A);g[r]=K[N],g[r+1]=K[N+1],g[r+2]=K[N+2],g[r+3]=E,r+=4}return g}return new Float32Array(f,s,N)}static _GetFloatAsHalfFloatRGBAArrayBuffer(A,X,s,N,f,E){const K=new Uint16Array(N),r=new Float32Array(f,s);let i=0;for(let Y=0;Y<X;Y++)for(let X=0;X<A;X++)K[i]=(0,g.f)(r[i]),K[i+1]=(0,g.f)(r[i+1]),K[i+2]=(0,g.f)(r[i+2]),d.StoreLODInAlphaChannel?K[i+3]=(0,g.f)(E):K[i+3]=(0,g.f)(r[i+3]),i+=4;return K}static _GetFloatAsUIntRGBAArrayBuffer(A,X,s,f,E,g){const K=new Uint8Array(f),r=new Float32Array(E,s);let i=0;for(let Y=0;Y<X;Y++)for(let X=0;X<A;X++){const s=4*(X+Y*A);K[i]=255*(0,N.c)(r[s]),K[i+1]=255*(0,N.c)(r[s+1]),K[i+2]=255*(0,N.c)(r[s+2]),d.StoreLODInAlphaChannel?K[i+3]=g:K[i+3]=255*(0,N.c)(r[s+3]),i+=4}return K}static _GetHalfFloatAsUIntRGBAArrayBuffer(A,X,s,f,E,K){const r=new Uint8Array(f),i=new Uint16Array(E,s);let Y=0;for(let v=0;v<X;v++)for(let X=0;X<A;X++){const s=4*(X+v*A);r[Y]=255*(0,N.c)((0,g.d)(i[s])),r[Y+1]=255*(0,N.c)((0,g.d)(i[s+1])),r[Y+2]=255*(0,N.c)((0,g.d)(i[s+2])),d.StoreLODInAlphaChannel?r[Y+3]=K:r[Y+3]=255*(0,N.c)((0,g.d)(i[s+3])),Y+=4}return r}static _GetRGBAArrayBuffer(A,X,s,N,f,E,g,K,r){const i=new Uint8Array(N),Y=new Uint8Array(f,s);let v=0;for(let c=0;c<X;c++)for(let X=0;X<A;X++){const s=4*(X+c*A);i[v]=Y[s+E],i[v+1]=Y[s+g],i[v+2]=Y[s+K],i[v+3]=Y[s+r],v+=4}return i}static _ExtractLongWordOrder(A){return 0===A||255===A||-16777216===A?0:1+d._ExtractLongWordOrder(A>>8)}static _GetRGBArrayBuffer(A,X,s,N,f,E,g,K){const r=new Uint8Array(N),i=new Uint8Array(f,s);let Y=0;for(let v=0;v<X;v++)for(let X=0;X<A;X++){const s=3*(X+v*A);r[Y]=i[s+E],r[Y+1]=i[s+g],r[Y+2]=i[s+K],Y+=3}return r}static _GetLuminanceArrayBuffer(A,X,s,N,f){const E=new Uint8Array(N),g=new Uint8Array(f,s);let K=0;for(let r=0;r<X;r++)for(let X=0;X<A;X++){const s=X+r*A;E[K]=g[s],K++}return E}static UploadDDSLevels(A,X,s,N,g,r){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,Q=arguments.length>7?arguments[7]:void 0,w=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],R=null;N.sphericalPolynomial&&(R=[]);const C=!!A.getCaps().s3tc;X.generateMipMaps=g;const J=new Int32Array(s.buffer,s.byteOffset,31);let a,u,z,m,b,y,j,G=0,V=0,D=1;if(542327876!==J[0])return void f.b.Error("Invalid magic number in DDS header");if(!N.isFourCC&&!N.isRGB&&!N.isLuminance)return void f.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(N.isCompressed&&!C)return void f.b.Error("Compressed textures are not supported on this platform.");let O=J[22];m=J[1]+4;let P=!1;if(N.isFourCC)switch(a=J[21],a){case Y:D=8,V=33777;break;case v:D=16,V=33778;break;case c:D=16,V=33779;break;case 113:P=!0,O=64;break;case 116:P=!0,O=128;break;case M:{m+=20;let A=!1;switch(N.dxgiFormat){case 10:P=!0,O=64,A=!0;break;case 2:P=!0,O=128,A=!0;break;case 88:N.isRGB=!0,N.isFourCC=!1,O=32,A=!0}if(A)break}default:return void f.b.Error(["Unsupported FourCC code:",(l=a,String.fromCharCode(255&l,l>>8&255,l>>16&255,l>>24&255))])}var l;const n=d._ExtractLongWordOrder(J[23]),U=d._ExtractLongWordOrder(J[24]),t=d._ExtractLongWordOrder(J[25]),e=d._ExtractLongWordOrder(J[26]);P&&(V=A._getRGBABufferInternalSizedFormat(N.textureType)),y=1,J[2]&K&&!1!==g&&(y=Math.max(1,J[7]));const T=Q||0,I=A.getCaps();for(let f=T;f<r;f++){for(u=J[4],z=J[3],j=0;j<y;++j){if(-1===i||i===j){const E=-1===i?j:0;if(!N.isCompressed&&N.isFourCC){X.format=5,G=u*z*4;let N=null;if(A._badOS||A._badDesktopOS||!I.textureHalfFloat&&!I.textureFloat)128===O?(N=d._GetFloatAsUIntRGBAArrayBuffer(u,z,s.byteOffset+m,G,s.buffer,E),R&&0==E&&R.push(d._GetFloatRGBAArrayBuffer(u,z,s.byteOffset+m,G,s.buffer,E))):64===O&&(N=d._GetHalfFloatAsUIntRGBAArrayBuffer(u,z,s.byteOffset+m,G,s.buffer,E),R&&0==E&&R.push(d._GetHalfFloatAsFloatRGBAArrayBuffer(u,z,s.byteOffset+m,G,s.buffer,E))),X.type=0;else{const A=I.textureFloat&&(w&&I.textureFloatLinearFiltering||!w),f=I.textureHalfFloat&&(w&&I.textureHalfFloatLinearFiltering||!w),g=(128===O||64===O&&!f)&&A?1:(64===O||128===O&&!A)&&f?2:0;let K,r=null;if(128===O)switch(g){case 1:K=d._GetFloatRGBAArrayBuffer,r=null;break;case 2:K=d._GetFloatAsHalfFloatRGBAArrayBuffer,r=d._GetFloatRGBAArrayBuffer;break;case 0:K=d._GetFloatAsUIntRGBAArrayBuffer,r=d._GetFloatRGBAArrayBuffer}else switch(g){case 1:K=d._GetHalfFloatAsFloatRGBAArrayBuffer,r=null;break;case 2:K=d._GetHalfFloatRGBAArrayBuffer,r=d._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:K=d._GetHalfFloatAsUIntRGBAArrayBuffer,r=d._GetHalfFloatAsFloatRGBAArrayBuffer}X.type=g,N=K(u,z,s.byteOffset+m,G,s.buffer,E),R&&0==E&&R.push(r?r(u,z,s.byteOffset+m,G,s.buffer,E):N)}N&&A._uploadDataToTextureDirectly(X,N,f,E)}else if(N.isRGB)X.type=0,24===O?(X.format=4,G=u*z*3,b=d._GetRGBArrayBuffer(u,z,s.byteOffset+m,G,s.buffer,n,U,t),A._uploadDataToTextureDirectly(X,b,f,E)):(X.format=5,G=u*z*4,b=d._GetRGBAArrayBuffer(u,z,s.byteOffset+m,G,s.buffer,n,U,t,e),A._uploadDataToTextureDirectly(X,b,f,E));else if(N.isLuminance){const N=A._getUnpackAlignement(),g=u;G=Math.floor((u+N-1)/N)*N*(z-1)+g,b=d._GetLuminanceArrayBuffer(u,z,s.byteOffset+m,G,s.buffer),X.format=1,X.type=0,A._uploadDataToTextureDirectly(X,b,f,E)}else G=Math.max(4,u)/4*Math.max(4,z)/4*D,b=new Uint8Array(s.buffer,s.byteOffset+m,G),X.type=0,A._uploadCompressedDataToTextureDirectly(X,V,u,z,b,f,E)}m+=O?u*z*(O/8):G,u*=.5,z*=.5,u=Math.max(1,u),z=Math.max(1,z)}if(void 0!==Q)break}R&&R.length>0?N.sphericalPolynomial=E.c.ConvertCubeMapToSphericalPolynomial({size:J[4],right:R[0],left:R[1],up:R[2],down:R[3],front:R[4],back:R[5],format:5,type:1,gammaSpace:!1}):N.sphericalPolynomial=void 0}}d.StoreLODInAlphaChannel=!1}}]);