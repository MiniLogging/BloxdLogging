"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10601:(p,O,E)=>{E.r(O),E.d(O,{_DDSTextureLoader:()=>F});var e=E(1457),x=E(1485);class F{constructor(){this.supportCascades=!0}loadCubeData(p,O,E,F){const q=O.getEngine();let a,Y=!1,B=1e3;if(Array.isArray(p))for(let e=0;e<p.length;e++){const E=p[e];a=x.b.GetDDSInfo(E),O.width=a.width,O.height=a.height,Y=(a.isRGB||a.isLuminance||a.mipmapCount>1)&&O.generateMipMaps,q._unpackFlipY(a.isCompressed),x.b.UploadDDSLevels(q,O,E,a,Y,6,-1,e),a.isFourCC||1!==a.mipmapCount?B=a.mipmapCount-1:q.generateMipMapsForCubemap(O)}else{const F=p;a=x.b.GetDDSInfo(F),O.width=a.width,O.height=a.height,E&&(a.sphericalPolynomial=new e.i),Y=(a.isRGB||a.isLuminance||a.mipmapCount>1)&&O.generateMipMaps,q._unpackFlipY(a.isCompressed),x.b.UploadDDSLevels(q,O,F,a,Y,6),a.isFourCC||1!==a.mipmapCount?B=a.mipmapCount-1:q.generateMipMapsForCubemap(O,!1)}q._setCubeMapTextureParams(O,Y,B),O.isReady=!0,O.onLoadedObservable.notifyObservers(O),O.onLoadedObservable.clear(),F&&F({isDDS:!0,width:O.width,info:a,data:p,texture:O})}loadData(p,O,E){const e=x.b.GetDDSInfo(p),F=(e.isRGB||e.isLuminance||e.mipmapCount>1)&&O.generateMipMaps&&Math.max(e.width,e.height)>>e.mipmapCount-1===1;E(e.width,e.height,F,e.isFourCC,(()=>{x.b.UploadDDSLevels(O.getEngine(),O,p,e,F,1)}))}}}}]);