"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10941:(I,S,d)=>{d.r(S),d.d(S,{_DDSTextureLoader:()=>g});var N=d(1511),O=d(1539);class g{constructor(){this.supportCascades=!0}loadCubeData(I,S,d,g){const T=S.getEngine();let q,a=!1,f=1e3;if(Array.isArray(I))for(let N=0;N<I.length;N++){const d=I[N];q=O.c.GetDDSInfo(d),S.width=q.width,S.height=q.height,a=(q.isRGB||q.isLuminance||q.mipmapCount>1)&&S.generateMipMaps,T._unpackFlipY(q.isCompressed),O.c.UploadDDSLevels(T,S,d,q,a,6,-1,N),q.isFourCC||1!==q.mipmapCount?f=q.mipmapCount-1:T.generateMipMapsForCubemap(S)}else{const g=I;q=O.c.GetDDSInfo(g),S.width=q.width,S.height=q.height,d&&(q.sphericalPolynomial=new N.e),a=(q.isRGB||q.isLuminance||q.mipmapCount>1)&&S.generateMipMaps,T._unpackFlipY(q.isCompressed),O.c.UploadDDSLevels(T,S,g,q,a,6),q.isFourCC||1!==q.mipmapCount?f=q.mipmapCount-1:T.generateMipMapsForCubemap(S,!1)}T._setCubeMapTextureParams(S,a,f),S.isReady=!0,S.onLoadedObservable.notifyObservers(S),S.onLoadedObservable.clear(),g&&g({isDDS:!0,width:S.width,info:q,data:I,texture:S})}loadData(I,S,d){const N=O.c.GetDDSInfo(I),g=(N.isRGB||N.isLuminance||N.mipmapCount>1)&&S.generateMipMaps&&Math.max(N.width,N.height)>>N.mipmapCount-1===1;d(N.width,N.height,g,N.isFourCC,(()=>{O.c.UploadDDSLevels(S.getEngine(),S,I,N,g,1)}))}}}}]);