"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10481:(M,E,b)=>{b.r(E),b.d(E,{_DDSTextureLoader:()=>a});var x=b(1499),k=b(1524);class a{constructor(){this.supportCascades=!0}loadCubeData(M,E,b,a){const g=E.getEngine();let n,J=!1,u=1e3;if(Array.isArray(M))for(let x=0;x<M.length;x++){const b=M[x];n=k.e.GetDDSInfo(b),E.width=n.width,E.height=n.height,J=(n.isRGB||n.isLuminance||n.mipmapCount>1)&&E.generateMipMaps,g._unpackFlipY(n.isCompressed),k.e.UploadDDSLevels(g,E,b,n,J,6,-1,x),n.isFourCC||1!==n.mipmapCount?u=n.mipmapCount-1:g.generateMipMapsForCubemap(E)}else{const a=M;n=k.e.GetDDSInfo(a),E.width=n.width,E.height=n.height,b&&(n.sphericalPolynomial=new x.d),J=(n.isRGB||n.isLuminance||n.mipmapCount>1)&&E.generateMipMaps,g._unpackFlipY(n.isCompressed),k.e.UploadDDSLevels(g,E,a,n,J,6),n.isFourCC||1!==n.mipmapCount?u=n.mipmapCount-1:g.generateMipMapsForCubemap(E,!1)}g._setCubeMapTextureParams(E,J,u),E.isReady=!0,E.onLoadedObservable.notifyObservers(E),E.onLoadedObservable.clear(),a&&a({isDDS:!0,width:E.width,info:n,data:M,texture:E})}loadData(M,E,b){const x=k.e.GetDDSInfo(M),a=(x.isRGB||x.isLuminance||x.mipmapCount>1)&&E.generateMipMaps&&Math.max(x.width,x.height)>>x.mipmapCount-1===1;b(x.width,x.height,a,x.isFourCC,(()=>{k.e.UploadDDSLevels(E.getEngine(),E,M,x,a,1)}))}}}}]);