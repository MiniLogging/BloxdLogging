"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10693:(O,q,s)=>{s.r(q),s.d(q,{_DDSTextureLoader:()=>B});var Z=s(1466),D=s(1493);class B{constructor(){this.supportCascades=!0}loadCubeData(O,q,s,B){const P=q.getEngine();let y,o=!1,w=1e3;if(Array.isArray(O))for(let Z=0;Z<O.length;Z++){const s=O[Z];y=D.e.GetDDSInfo(s),q.width=y.width,q.height=y.height,o=(y.isRGB||y.isLuminance||y.mipmapCount>1)&&q.generateMipMaps,P._unpackFlipY(y.isCompressed),D.e.UploadDDSLevels(P,q,s,y,o,6,-1,Z),y.isFourCC||1!==y.mipmapCount?w=y.mipmapCount-1:P.generateMipMapsForCubemap(q)}else{const B=O;y=D.e.GetDDSInfo(B),q.width=y.width,q.height=y.height,s&&(y.sphericalPolynomial=new Z.f),o=(y.isRGB||y.isLuminance||y.mipmapCount>1)&&q.generateMipMaps,P._unpackFlipY(y.isCompressed),D.e.UploadDDSLevels(P,q,B,y,o,6),y.isFourCC||1!==y.mipmapCount?w=y.mipmapCount-1:P.generateMipMapsForCubemap(q,!1)}P._setCubeMapTextureParams(q,o,w),q.isReady=!0,q.onLoadedObservable.notifyObservers(q),q.onLoadedObservable.clear(),B&&B({isDDS:!0,width:q.width,info:y,data:O,texture:q})}loadData(O,q,s){const Z=D.e.GetDDSInfo(O),B=(Z.isRGB||Z.isLuminance||Z.mipmapCount>1)&&q.generateMipMaps&&Math.max(Z.width,Z.height)>>Z.mipmapCount-1===1;s(Z.width,Z.height,B,Z.isFourCC,(()=>{D.e.UploadDDSLevels(q.getEngine(),q,O,Z,B,1)}))}}}}]);