"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10391:(A,I,y)=>{y.r(I),y.d(I,{_DDSTextureLoader:()=>M});var X=y(1505),F=y(1535);class M{constructor(){this.supportCascades=!0}loadCubeData(A,I,y,M){const g=I.getEngine();let d,V=!1,k=1e3;if(Array.isArray(A))for(let X=0;X<A.length;X++){const y=A[X];d=F.e.GetDDSInfo(y),I.width=d.width,I.height=d.height,V=(d.isRGB||d.isLuminance||d.mipmapCount>1)&&I.generateMipMaps,g._unpackFlipY(d.isCompressed),F.e.UploadDDSLevels(g,I,y,d,V,6,-1,X),d.isFourCC||1!==d.mipmapCount?k=d.mipmapCount-1:g.generateMipMapsForCubemap(I)}else{const M=A;d=F.e.GetDDSInfo(M),I.width=d.width,I.height=d.height,y&&(d.sphericalPolynomial=new X.e),V=(d.isRGB||d.isLuminance||d.mipmapCount>1)&&I.generateMipMaps,g._unpackFlipY(d.isCompressed),F.e.UploadDDSLevels(g,I,M,d,V,6),d.isFourCC||1!==d.mipmapCount?k=d.mipmapCount-1:g.generateMipMapsForCubemap(I,!1)}g._setCubeMapTextureParams(I,V,k),I.isReady=!0,I.onLoadedObservable.notifyObservers(I),I.onLoadedObservable.clear(),M&&M({isDDS:!0,width:I.width,info:d,data:A,texture:I})}loadData(A,I,y){const X=F.e.GetDDSInfo(A),M=(X.isRGB||X.isLuminance||X.mipmapCount>1)&&I.generateMipMaps&&Math.max(X.width,X.height)>>X.mipmapCount-1===1;y(X.width,X.height,M,X.isFourCC,(()=>{F.e.UploadDDSLevels(I.getEngine(),I,A,X,M,1)}))}}}}]);