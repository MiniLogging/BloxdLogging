"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10226:(B,q,C)=>{C.r(q),C.d(q,{_DDSTextureLoader:()=>O});var v=C(1431),m=C(1456);class O{constructor(){this.supportCascades=!0}loadCubeData(B,q,C,O){const S=q.getEngine();let D,R=!1,T=1e3;if(Array.isArray(B))for(let v=0;v<B.length;v++){const C=B[v];D=m.b.GetDDSInfo(C),q.width=D.width,q.height=D.height,R=(D.isRGB||D.isLuminance||D.mipmapCount>1)&&q.generateMipMaps,S._unpackFlipY(D.isCompressed),m.b.UploadDDSLevels(S,q,C,D,R,6,-1,v),D.isFourCC||1!==D.mipmapCount?T=D.mipmapCount-1:S.generateMipMapsForCubemap(q)}else{const O=B;D=m.b.GetDDSInfo(O),q.width=D.width,q.height=D.height,C&&(D.sphericalPolynomial=new v.h),R=(D.isRGB||D.isLuminance||D.mipmapCount>1)&&q.generateMipMaps,S._unpackFlipY(D.isCompressed),m.b.UploadDDSLevels(S,q,O,D,R,6),D.isFourCC||1!==D.mipmapCount?T=D.mipmapCount-1:S.generateMipMapsForCubemap(q,!1)}S._setCubeMapTextureParams(q,R,T),q.isReady=!0,q.onLoadedObservable.notifyObservers(q),q.onLoadedObservable.clear(),O&&O({isDDS:!0,width:q.width,info:D,data:B,texture:q})}loadData(B,q,C){const v=m.b.GetDDSInfo(B),O=(v.isRGB||v.isLuminance||v.mipmapCount>1)&&q.generateMipMaps&&Math.max(v.width,v.height)>>v.mipmapCount-1===1;C(v.width,v.height,O,v.isFourCC,(()=>{m.b.UploadDDSLevels(q.getEngine(),q,B,v,O,1)}))}}}}]);