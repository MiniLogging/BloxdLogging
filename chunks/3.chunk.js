"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10232:(f,Q,H)=>{H.r(Q),H.d(Q,{_DDSTextureLoader:()=>S});var X=H(1483),i=H(1510);class S{constructor(){this.supportCascades=!0}loadCubeData(f,Q,H,S){const x=Q.getEngine();let K,Z=!1,B=1e3;if(Array.isArray(f))for(let X=0;X<f.length;X++){const H=f[X];K=i.e.GetDDSInfo(H),Q.width=K.width,Q.height=K.height,Z=(K.isRGB||K.isLuminance||K.mipmapCount>1)&&Q.generateMipMaps,x._unpackFlipY(K.isCompressed),i.e.UploadDDSLevels(x,Q,H,K,Z,6,-1,X),K.isFourCC||1!==K.mipmapCount?B=K.mipmapCount-1:x.generateMipMapsForCubemap(Q)}else{const S=f;K=i.e.GetDDSInfo(S),Q.width=K.width,Q.height=K.height,H&&(K.sphericalPolynomial=new X.d),Z=(K.isRGB||K.isLuminance||K.mipmapCount>1)&&Q.generateMipMaps,x._unpackFlipY(K.isCompressed),i.e.UploadDDSLevels(x,Q,S,K,Z,6),K.isFourCC||1!==K.mipmapCount?B=K.mipmapCount-1:x.generateMipMapsForCubemap(Q,!1)}x._setCubeMapTextureParams(Q,Z,B),Q.isReady=!0,Q.onLoadedObservable.notifyObservers(Q),Q.onLoadedObservable.clear(),S&&S({isDDS:!0,width:Q.width,info:K,data:f,texture:Q})}loadData(f,Q,H){const X=i.e.GetDDSInfo(f),S=(X.isRGB||X.isLuminance||X.mipmapCount>1)&&Q.generateMipMaps&&Math.max(X.width,X.height)>>X.mipmapCount-1===1;H(X.width,X.height,S,X.isFourCC,(()=>{i.e.UploadDDSLevels(Q.getEngine(),Q,f,X,S,1)}))}}}}]);