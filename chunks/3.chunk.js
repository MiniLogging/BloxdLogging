"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10990:(b,o,l)=>{l.r(o),l.d(o,{_DDSTextureLoader:()=>v});var g=l(1537),I=l(1569);class v{constructor(){this.supportCascades=!0}loadCubeData(b,o,l,v){const W=o.getEngine();let n,T=!1,t=1e3;if(Array.isArray(b))for(let g=0;g<b.length;g++){const l=b[g];n=I.c.GetDDSInfo(l),o.width=n.width,o.height=n.height,T=(n.isRGB||n.isLuminance||n.mipmapCount>1)&&o.generateMipMaps,W._unpackFlipY(n.isCompressed),I.c.UploadDDSLevels(W,o,l,n,T,6,-1,g),n.isFourCC||1!==n.mipmapCount?t=n.mipmapCount-1:W.generateMipMapsForCubemap(o)}else{const v=b;n=I.c.GetDDSInfo(v),o.width=n.width,o.height=n.height,l&&(n.sphericalPolynomial=new g.f),T=(n.isRGB||n.isLuminance||n.mipmapCount>1)&&o.generateMipMaps,W._unpackFlipY(n.isCompressed),I.c.UploadDDSLevels(W,o,v,n,T,6),n.isFourCC||1!==n.mipmapCount?t=n.mipmapCount-1:W.generateMipMapsForCubemap(o,!1)}W._setCubeMapTextureParams(o,T,t),o.isReady=!0,o.onLoadedObservable.notifyObservers(o),o.onLoadedObservable.clear(),v&&v({isDDS:!0,width:o.width,info:n,data:b,texture:o})}loadData(b,o,l){const g=I.c.GetDDSInfo(b),v=(g.isRGB||g.isLuminance||g.mipmapCount>1)&&o.generateMipMaps&&Math.max(g.width,g.height)>>g.mipmapCount-1===1;l(g.width,g.height,v,g.isFourCC,(()=>{I.c.UploadDDSLevels(o.getEngine(),o,b,g,v,1)}))}}}}]);