"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{11046:(f,H,Q)=>{Q.r(H),Q.d(H,{_DDSTextureLoader:()=>s});var a=Q(1505),d=Q(1539);class s{constructor(){this.supportCascades=!0}loadCubeData(f,H,Q,s){const n=H.getEngine();let e,c=!1,J=1e3;if(Array.isArray(f))for(let a=0;a<f.length;a++){const Q=f[a];e=d.e.GetDDSInfo(Q),H.width=e.width,H.height=e.height,c=(e.isRGB||e.isLuminance||e.mipmapCount>1)&&H.generateMipMaps,n._unpackFlipY(e.isCompressed),d.e.UploadDDSLevels(n,H,Q,e,c,6,-1,a),e.isFourCC||1!==e.mipmapCount?J=e.mipmapCount-1:n.generateMipMapsForCubemap(H)}else{const s=f;e=d.e.GetDDSInfo(s),H.width=e.width,H.height=e.height,Q&&(e.sphericalPolynomial=new a.f),c=(e.isRGB||e.isLuminance||e.mipmapCount>1)&&H.generateMipMaps,n._unpackFlipY(e.isCompressed),d.e.UploadDDSLevels(n,H,s,e,c,6),e.isFourCC||1!==e.mipmapCount?J=e.mipmapCount-1:n.generateMipMapsForCubemap(H,!1)}n._setCubeMapTextureParams(H,c,J),H.isReady=!0,H.onLoadedObservable.notifyObservers(H),H.onLoadedObservable.clear(),s&&s({isDDS:!0,width:H.width,info:e,data:f,texture:H})}loadData(f,H,Q){const a=d.e.GetDDSInfo(f),s=(a.isRGB||a.isLuminance||a.mipmapCount>1)&&H.generateMipMaps&&Math.max(a.width,a.height)>>a.mipmapCount-1===1;Q(a.width,a.height,s,a.isFourCC,(()=>{d.e.UploadDDSLevels(H.getEngine(),H,f,a,s,1)}))}}}}]);