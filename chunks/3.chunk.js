"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10828:(v,T,X)=>{X.r(T),X.d(T,{_DDSTextureLoader:()=>B});var O=X(1483),u=X(1511);class B{constructor(){this.supportCascades=!0}loadCubeData(v,T,X,B){const m=T.getEngine();let A,x=!1,f=1e3;if(Array.isArray(v))for(let O=0;O<v.length;O++){const X=v[O];A=u.b.GetDDSInfo(X),T.width=A.width,T.height=A.height,x=(A.isRGB||A.isLuminance||A.mipmapCount>1)&&T.generateMipMaps,m._unpackFlipY(A.isCompressed),u.b.UploadDDSLevels(m,T,X,A,x,6,-1,O),A.isFourCC||1!==A.mipmapCount?f=A.mipmapCount-1:m.generateMipMapsForCubemap(T)}else{const B=v;A=u.b.GetDDSInfo(B),T.width=A.width,T.height=A.height,X&&(A.sphericalPolynomial=new O.e),x=(A.isRGB||A.isLuminance||A.mipmapCount>1)&&T.generateMipMaps,m._unpackFlipY(A.isCompressed),u.b.UploadDDSLevels(m,T,B,A,x,6),A.isFourCC||1!==A.mipmapCount?f=A.mipmapCount-1:m.generateMipMapsForCubemap(T,!1)}m._setCubeMapTextureParams(T,x,f),T.isReady=!0,T.onLoadedObservable.notifyObservers(T),T.onLoadedObservable.clear(),B&&B({isDDS:!0,width:T.width,info:A,data:v,texture:T})}loadData(v,T,X){const O=u.b.GetDDSInfo(v),B=(O.isRGB||O.isLuminance||O.mipmapCount>1)&&T.generateMipMaps&&Math.max(O.width,O.height)>>O.mipmapCount-1===1;X(O.width,O.height,B,O.isFourCC,(()=>{u.b.UploadDDSLevels(T.getEngine(),T,v,O,B,1)}))}}}}]);