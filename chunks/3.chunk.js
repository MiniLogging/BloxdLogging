"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3,6],{2454:(n,k,T)=>{var c=T(654),K=T(556),Q=T(591),G=T(684),w=T(615),E=T(663);w.b.prototype._partialLoadFile=function(n,k,T,c){let K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(n,(n=>{T[k]=n,T._internalCount++,6===T._internalCount&&c(T)}),void 0,void 0,!0,((n,k)=>{K&&n&&K(n.status+" "+n.statusText,k)}))},w.b.prototype._cascadeLoadFiles=function(n,k,T){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const K=[];K._internalCount=0;for(let Q=0;Q<6;Q++)this._partialLoadFile(T[Q],Q,K,k,c)},w.b.prototype._cascadeLoadImgs=function(n,k,T,c){let K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,Q=arguments.length>5?arguments[5]:void 0;const G=[];G._internalCount=0;for(let w=0;w<6;w++)this._partialLoadImg(c[w],w,G,n,k,T,K,Q)},w.b.prototype._partialLoadImg=function(n,k,T,c,K,w){let E=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,I=arguments.length>7?arguments[7]:void 0;const S=(0,G.d)();(0,Q.m)(n,(n=>{T[k]=n,T._internalCount++,c&&c.removePendingData(S),6===T._internalCount&&w&&w(K,T)}),((n,k)=>{c&&c.removePendingData(S),E&&E(n,k)}),c?c.offlineProvider:null,I),c&&c.addPendingData(S)},w.b.prototype.createCubeTextureBase=function(n,k,T,Q){let G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,w=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,I=arguments.length>6?arguments[6]:void 0,S=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,P=arguments.length>8&&void 0!==arguments[8]&&arguments[8],W=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,J=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,H=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,s=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,b=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,C=arguments.length>14&&void 0!==arguments[14]&&arguments[14],z=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const r=H||new c.d(this,7);r.isCube=!0,r.url=n,r.generateMipMaps=!Q,r._lodGenerationScale=W,r._lodGenerationOffset=J,r._useSRGBBuffer=!!C&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!Q),r!==H&&(r.label=n.substring(0,60)),this._doNotHandleContextLost||(r._extension=S,r._files=T,r._buffer=z);const q=n;this._transformTextureUrl&&!H&&(n=this._transformTextureUrl(n));const O=S??function(n){const k=n.split("?")[0],T=k.lastIndexOf(".");return T>-1?k.substring(T).toLowerCase():""}(n),u=(0,E.c)(O),f=(n,k)=>{r.dispose(),w?w(n,k):n&&K.d.Warn(n)},A=(c,w)=>{n===q?c&&f(c.status+" "+c.statusText,w):(K.d.Warn(`Failed to load ${n}, falling back to the ${q}`),this.createCubeTextureBase(q,k,T,!!Q,G,f,I,S,P,W,J,r,s,b,C,z))};if(u)u.then((c=>{const K=n=>{s&&s(r,n),c.loadCubeData(n,r,P,G,((n,k)=>{f(n,k)}))};z?K(z):T&&6===T.length?c.supportCascades?this._cascadeLoadFiles(k,(n=>K(n.map((n=>new Uint8Array(n))))),T,f):f("Textures type does not support cascades."):this._loadFile(n,(n=>K(new Uint8Array(n))),void 0,void 0,!0,A)}));else{if(!T||0===T.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(k,r,((n,k)=>{b&&b(n,k)}),T,f)}return this._internalTexturesCache.push(r),r}},2288:(n,k,T)=>{T.r(k),T.d(k,{_DDSTextureLoader:()=>Q});var c=T(2294),K=T(2321);class Q{constructor(){this.supportCascades=!0}loadCubeData(n,k,T,Q){const G=k.getEngine();let w,E=!1,I=1e3;if(Array.isArray(n))for(let c=0;c<n.length;c++){const T=n[c];w=K.DDSTools.GetDDSInfo(T),k.width=w.width,k.height=w.height,E=(w.isRGB||w.isLuminance||w.mipmapCount>1)&&k.generateMipMaps,G._unpackFlipY(w.isCompressed),K.DDSTools.UploadDDSLevels(G,k,T,w,E,6,-1,c),w.isFourCC||1!==w.mipmapCount?I=w.mipmapCount-1:G.generateMipMapsForCubemap(k)}else{const Q=n;w=K.DDSTools.GetDDSInfo(Q),k.width=w.width,k.height=w.height,T&&(w.sphericalPolynomial=new c.d),E=(w.isRGB||w.isLuminance||w.mipmapCount>1)&&k.generateMipMaps,G._unpackFlipY(w.isCompressed),K.DDSTools.UploadDDSLevels(G,k,Q,w,E,6),w.isFourCC||1!==w.mipmapCount?I=w.mipmapCount-1:G.generateMipMapsForCubemap(k,!1)}G._setCubeMapTextureParams(k,E,I),k.isReady=!0,k.onLoadedObservable.notifyObservers(k),k.onLoadedObservable.clear(),Q&&Q({isDDS:!0,width:k.width,info:w,data:n,texture:k})}loadData(n,k,T){const c=K.DDSTools.GetDDSInfo(n),Q=(c.isRGB||c.isLuminance||c.mipmapCount>1)&&k.generateMipMaps&&Math.max(c.width,c.height)>>c.mipmapCount-1===1;T(c.width,c.height,Q,c.isFourCC,(()=>{K.DDSTools.UploadDDSLevels(k.getEngine(),k,n,c,Q,1)}))}}},2321:(n,k,T)=>{T.d(k,{DDSTools:()=>H});var c=T(747),K=T(556),Q=T(2325),G=T(2329);T(2454);const w=131072,E=131072;function I(n){return n.charCodeAt(0)+(n.charCodeAt(1)<<8)+(n.charCodeAt(2)<<16)+(n.charCodeAt(3)<<24)}const S=I("DXT1"),P=I("DXT3"),W=I("DXT5"),J=I("DX10");class H{static GetDDSInfo(n){const k=new Int32Array(n.buffer,n.byteOffset,31),T=new Int32Array(n.buffer,n.byteOffset,35);let c=1;k[2]&w&&(c=Math.max(1,k[7]));const K=k[21],Q=K===J?T[32]:0;let G=0;switch(K){case 113:G=2;break;case 116:G=1;break;case J:if(10===Q){G=2;break}if(2===Q){G=1;break}}return{width:k[4],height:k[3],mipmapCount:c,isFourCC:4===(4&k[20]),isRGB:64===(64&k[20]),isLuminance:(k[20]&E)===E,isCube:512===(512&k[28]),isCompressed:K===S||K===P||K===W,dxgiFormat:Q,textureType:G}}static _GetHalfFloatAsFloatRGBAArrayBuffer(n,k,T,c,K,Q){const w=new Float32Array(c),E=new Uint16Array(K,T);let I=0;for(let S=0;S<k;S++)for(let k=0;k<n;k++){const T=4*(k+S*n);w[I]=(0,G.g)(E[T]),w[I+1]=(0,G.g)(E[T+1]),w[I+2]=(0,G.g)(E[T+2]),H.StoreLODInAlphaChannel?w[I+3]=Q:w[I+3]=(0,G.g)(E[T+3]),I+=4}return w}static _GetHalfFloatRGBAArrayBuffer(n,k,T,c,K,Q){if(H.StoreLODInAlphaChannel){const w=new Uint16Array(c),E=new Uint16Array(K,T);let I=0;for(let T=0;T<k;T++)for(let k=0;k<n;k++){const c=4*(k+T*n);w[I]=E[c],w[I+1]=E[c+1],w[I+2]=E[c+2],w[I+3]=(0,G.m)(Q),I+=4}return w}return new Uint16Array(K,T,c)}static _GetFloatRGBAArrayBuffer(n,k,T,c,K,Q){if(H.StoreLODInAlphaChannel){const G=new Float32Array(c),w=new Float32Array(K,T);let E=0;for(let T=0;T<k;T++)for(let k=0;k<n;k++){const c=4*(k+T*n);G[E]=w[c],G[E+1]=w[c+1],G[E+2]=w[c+2],G[E+3]=Q,E+=4}return G}return new Float32Array(K,T,c)}static _GetFloatAsHalfFloatRGBAArrayBuffer(n,k,T,c,K,Q){const w=new Uint16Array(c),E=new Float32Array(K,T);let I=0;for(let S=0;S<k;S++)for(let k=0;k<n;k++)w[I]=(0,G.m)(E[I]),w[I+1]=(0,G.m)(E[I+1]),w[I+2]=(0,G.m)(E[I+2]),H.StoreLODInAlphaChannel?w[I+3]=(0,G.m)(Q):w[I+3]=(0,G.m)(E[I+3]),I+=4;return w}static _GetFloatAsUIntRGBAArrayBuffer(n,k,T,K,Q,G){const w=new Uint8Array(K),E=new Float32Array(Q,T);let I=0;for(let S=0;S<k;S++)for(let k=0;k<n;k++){const T=4*(k+S*n);w[I]=255*(0,c.b)(E[T]),w[I+1]=255*(0,c.b)(E[T+1]),w[I+2]=255*(0,c.b)(E[T+2]),H.StoreLODInAlphaChannel?w[I+3]=G:w[I+3]=255*(0,c.b)(E[T+3]),I+=4}return w}static _GetHalfFloatAsUIntRGBAArrayBuffer(n,k,T,K,Q,w){const E=new Uint8Array(K),I=new Uint16Array(Q,T);let S=0;for(let P=0;P<k;P++)for(let k=0;k<n;k++){const T=4*(k+P*n);E[S]=255*(0,c.b)((0,G.g)(I[T])),E[S+1]=255*(0,c.b)((0,G.g)(I[T+1])),E[S+2]=255*(0,c.b)((0,G.g)(I[T+2])),H.StoreLODInAlphaChannel?E[S+3]=w:E[S+3]=255*(0,c.b)((0,G.g)(I[T+3])),S+=4}return E}static _GetRGBAArrayBuffer(n,k,T,c,K,Q,G,w,E){const I=new Uint8Array(c),S=new Uint8Array(K,T);let P=0;for(let W=0;W<k;W++)for(let k=0;k<n;k++){const T=4*(k+W*n);I[P]=S[T+Q],I[P+1]=S[T+G],I[P+2]=S[T+w],I[P+3]=S[T+E],P+=4}return I}static _ExtractLongWordOrder(n){return 0===n||255===n||-16777216===n?0:1+H._ExtractLongWordOrder(n>>8)}static _GetRGBArrayBuffer(n,k,T,c,K,Q,G,w){const E=new Uint8Array(c),I=new Uint8Array(K,T);let S=0;for(let P=0;P<k;P++)for(let k=0;k<n;k++){const T=3*(k+P*n);E[S]=I[T+Q],E[S+1]=I[T+G],E[S+2]=I[T+w],S+=3}return E}static _GetLuminanceArrayBuffer(n,k,T,c,K){const Q=new Uint8Array(c),G=new Uint8Array(K,T);let w=0;for(let E=0;E<k;E++)for(let k=0;k<n;k++){const T=k+E*n;Q[w]=G[T],w++}return Q}static UploadDDSLevels(n,k,T,c,G,E){let I=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,s=arguments.length>7?arguments[7]:void 0,b=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],C=null;c.sphericalPolynomial&&(C=[]);const z=!!n.getCaps().s3tc;k.generateMipMaps=G;const r=new Int32Array(T.buffer,T.byteOffset,31);let q,O,u,f,A,v,F,m=0,x=0,g=1;if(542327876!==r[0])return void K.d.Error("Invalid magic number in DDS header");if(!c.isFourCC&&!c.isRGB&&!c.isLuminance)return void K.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(c.isCompressed&&!z)return void K.d.Error("Compressed textures are not supported on this platform.");let U=r[22];f=r[1]+4;let V=!1;if(c.isFourCC)switch(q=r[21],q){case S:g=8,x=33777;break;case P:g=16,x=33778;break;case W:g=16,x=33779;break;case 113:V=!0,U=64;break;case 116:V=!0,U=128;break;case J:{f+=20;let n=!1;switch(c.dxgiFormat){case 10:V=!0,U=64,n=!0;break;case 2:V=!0,U=128,n=!0;break;case 88:c.isRGB=!0,c.isFourCC=!1,U=32,n=!0}if(n)break}default:return void K.d.Error(["Unsupported FourCC code:",(Y=q,String.fromCharCode(255&Y,Y>>8&255,Y>>16&255,Y>>24&255))])}var Y;const Z=H._ExtractLongWordOrder(r[23]),e=H._ExtractLongWordOrder(r[24]),d=H._ExtractLongWordOrder(r[25]),l=H._ExtractLongWordOrder(r[26]);V&&(x=n._getRGBABufferInternalSizedFormat(c.textureType)),v=1,r[2]&w&&!1!==G&&(v=Math.max(1,r[7]));const i=s||0,B=n.getCaps();for(let K=i;K<E;K++){for(O=r[4],u=r[3],F=0;F<v;++F){if(-1===I||I===F){const Q=-1===I?F:0;if(!c.isCompressed&&c.isFourCC){k.format=5,m=O*u*4;let c=null;if(n._badOS||n._badDesktopOS||!B.textureHalfFloat&&!B.textureFloat)128===U?(c=H._GetFloatAsUIntRGBAArrayBuffer(O,u,T.byteOffset+f,m,T.buffer,Q),C&&0==Q&&C.push(H._GetFloatRGBAArrayBuffer(O,u,T.byteOffset+f,m,T.buffer,Q))):64===U&&(c=H._GetHalfFloatAsUIntRGBAArrayBuffer(O,u,T.byteOffset+f,m,T.buffer,Q),C&&0==Q&&C.push(H._GetHalfFloatAsFloatRGBAArrayBuffer(O,u,T.byteOffset+f,m,T.buffer,Q))),k.type=0;else{const n=B.textureFloat&&(b&&B.textureFloatLinearFiltering||!b),K=B.textureHalfFloat&&(b&&B.textureHalfFloatLinearFiltering||!b),G=(128===U||64===U&&!K)&&n?1:(64===U||128===U&&!n)&&K?2:0;let w,E=null;if(128===U)switch(G){case 1:w=H._GetFloatRGBAArrayBuffer,E=null;break;case 2:w=H._GetFloatAsHalfFloatRGBAArrayBuffer,E=H._GetFloatRGBAArrayBuffer;break;case 0:w=H._GetFloatAsUIntRGBAArrayBuffer,E=H._GetFloatRGBAArrayBuffer}else switch(G){case 1:w=H._GetHalfFloatAsFloatRGBAArrayBuffer,E=null;break;case 2:w=H._GetHalfFloatRGBAArrayBuffer,E=H._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:w=H._GetHalfFloatAsUIntRGBAArrayBuffer,E=H._GetHalfFloatAsFloatRGBAArrayBuffer}k.type=G,c=w(O,u,T.byteOffset+f,m,T.buffer,Q),C&&0==Q&&C.push(E?E(O,u,T.byteOffset+f,m,T.buffer,Q):c)}c&&n._uploadDataToTextureDirectly(k,c,K,Q)}else if(c.isRGB)k.type=0,24===U?(k.format=4,m=O*u*3,A=H._GetRGBArrayBuffer(O,u,T.byteOffset+f,m,T.buffer,Z,e,d),n._uploadDataToTextureDirectly(k,A,K,Q)):(k.format=5,m=O*u*4,A=H._GetRGBAArrayBuffer(O,u,T.byteOffset+f,m,T.buffer,Z,e,d,l),n._uploadDataToTextureDirectly(k,A,K,Q));else if(c.isLuminance){const c=n._getUnpackAlignement(),G=O;m=Math.floor((O+c-1)/c)*c*(u-1)+G,A=H._GetLuminanceArrayBuffer(O,u,T.byteOffset+f,m,T.buffer),k.format=1,k.type=0,n._uploadDataToTextureDirectly(k,A,K,Q)}else m=Math.max(4,O)/4*Math.max(4,u)/4*g,A=new Uint8Array(T.buffer,T.byteOffset+f,m),k.type=0,n._uploadCompressedDataToTextureDirectly(k,x,O,u,A,K,Q)}f+=U?O*u*(U/8):m,O*=.5,u*=.5,O=Math.max(1,O),u=Math.max(1,u)}if(void 0!==s)break}C&&C.length>0?c.sphericalPolynomial=Q.e.ConvertCubeMapToSphericalPolynomial({size:r[4],right:C[0],left:C[1],up:C[2],down:C[3],front:C[4],back:C[5],format:5,type:1,gammaSpace:!1}):c.sphericalPolynomial=void 0}}H.StoreLODInAlphaChannel=!1}}]);