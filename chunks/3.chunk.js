"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10252:(L,J,o)=>{o.r(J),o.d(J,{_DDSTextureLoader:()=>q});var g=o(1489),V=o(1515);class q{constructor(){this.supportCascades=!0}loadCubeData(L,J,o,q){const I=J.getEngine();let b,D=!1,Z=1e3;if(Array.isArray(L))for(let g=0;g<L.length;g++){const o=L[g];b=V.b.GetDDSInfo(o),J.width=b.width,J.height=b.height,D=(b.isRGB||b.isLuminance||b.mipmapCount>1)&&J.generateMipMaps,I._unpackFlipY(b.isCompressed),V.b.UploadDDSLevels(I,J,o,b,D,6,-1,g),b.isFourCC||1!==b.mipmapCount?Z=b.mipmapCount-1:I.generateMipMapsForCubemap(J)}else{const q=L;b=V.b.GetDDSInfo(q),J.width=b.width,J.height=b.height,o&&(b.sphericalPolynomial=new g.g),D=(b.isRGB||b.isLuminance||b.mipmapCount>1)&&J.generateMipMaps,I._unpackFlipY(b.isCompressed),V.b.UploadDDSLevels(I,J,q,b,D,6),b.isFourCC||1!==b.mipmapCount?Z=b.mipmapCount-1:I.generateMipMapsForCubemap(J,!1)}I._setCubeMapTextureParams(J,D,Z),J.isReady=!0,J.onLoadedObservable.notifyObservers(J),J.onLoadedObservable.clear(),q&&q({isDDS:!0,width:J.width,info:b,data:L,texture:J})}loadData(L,J,o){const g=V.b.GetDDSInfo(L),q=(g.isRGB||g.isLuminance||g.mipmapCount>1)&&J.generateMipMaps&&Math.max(g.width,g.height)>>g.mipmapCount-1===1;o(g.width,g.height,q,g.isFourCC,(()=>{V.b.UploadDDSLevels(J.getEngine(),J,L,g,q,1)}))}}}}]);