"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10659:(j,S,h)=>{h.r(S),h.d(S,{_DDSTextureLoader:()=>d});var m=h(1442),I=h(1460);class d{constructor(){this.supportCascades=!0}loadCubeData(j,S,h,d){const U=S.getEngine();let f,r=!1,a=1e3;if(Array.isArray(j))for(let m=0;m<j.length;m++){const h=j[m];f=I.c.GetDDSInfo(h),S.width=f.width,S.height=f.height,r=(f.isRGB||f.isLuminance||f.mipmapCount>1)&&S.generateMipMaps,U._unpackFlipY(f.isCompressed),I.c.UploadDDSLevels(U,S,h,f,r,6,-1,m),f.isFourCC||1!==f.mipmapCount?a=f.mipmapCount-1:U.generateMipMapsForCubemap(S)}else{const d=j;f=I.c.GetDDSInfo(d),S.width=f.width,S.height=f.height,h&&(f.sphericalPolynomial=new m.h),r=(f.isRGB||f.isLuminance||f.mipmapCount>1)&&S.generateMipMaps,U._unpackFlipY(f.isCompressed),I.c.UploadDDSLevels(U,S,d,f,r,6),f.isFourCC||1!==f.mipmapCount?a=f.mipmapCount-1:U.generateMipMapsForCubemap(S,!1)}U._setCubeMapTextureParams(S,r,a),S.isReady=!0,S.onLoadedObservable.notifyObservers(S),S.onLoadedObservable.clear(),d&&d({isDDS:!0,width:S.width,info:f,data:j,texture:S})}loadData(j,S,h){const m=I.c.GetDDSInfo(j),d=(m.isRGB||m.isLuminance||m.mipmapCount>1)&&S.generateMipMaps&&Math.max(m.width,m.height)>>m.mipmapCount-1===1;h(m.width,m.height,d,m.isFourCC,(()=>{I.c.UploadDDSLevels(S.getEngine(),S,j,m,d,1)}))}}}}]);