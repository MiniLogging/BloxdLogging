"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[3],{10233:(N,Z,d)=>{d.r(Z),d.d(Z,{_DDSTextureLoader:()=>m});var X=d(1378),I=d(1401);class m{constructor(){this.supportCascades=!0}loadCubeData(N,Z,d,m){const z=Z.getEngine();let w,S=!1,e=1e3;if(Array.isArray(N))for(let X=0;X<N.length;X++){const d=N[X];w=I.b.GetDDSInfo(d),Z.width=w.width,Z.height=w.height,S=(w.isRGB||w.isLuminance||w.mipmapCount>1)&&Z.generateMipMaps,z._unpackFlipY(w.isCompressed),I.b.UploadDDSLevels(z,Z,d,w,S,6,-1,X),w.isFourCC||1!==w.mipmapCount?e=w.mipmapCount-1:z.generateMipMapsForCubemap(Z)}else{const m=N;w=I.b.GetDDSInfo(m),Z.width=w.width,Z.height=w.height,d&&(w.sphericalPolynomial=new X.e),S=(w.isRGB||w.isLuminance||w.mipmapCount>1)&&Z.generateMipMaps,z._unpackFlipY(w.isCompressed),I.b.UploadDDSLevels(z,Z,m,w,S,6),w.isFourCC||1!==w.mipmapCount?e=w.mipmapCount-1:z.generateMipMapsForCubemap(Z,!1)}z._setCubeMapTextureParams(Z,S,e),Z.isReady=!0,Z.onLoadedObservable.notifyObservers(Z),Z.onLoadedObservable.clear(),m&&m({isDDS:!0,width:Z.width,info:w,data:N,texture:Z})}loadData(N,Z,d){const X=I.b.GetDDSInfo(N),m=(X.isRGB||X.isLuminance||X.mipmapCount>1)&&Z.generateMipMaps&&Math.max(X.width,X.height)>>X.mipmapCount-1===1;d(X.width,X.height,m,X.isFourCC,(()=>{I.b.UploadDDSLevels(Z.getEngine(),Z,N,X,m,1)}))}}}}]);