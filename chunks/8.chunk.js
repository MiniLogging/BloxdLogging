"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10358:(R,N,q)=>{q.r(N),q.d(N,{_HDRTextureLoader:()=>a});var w=q(966);class u{static ConvertPanoramaToCubemap(R,N,q,w){let u=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!R)throw"ConvertPanoramaToCubemap: input cannot be null";if(R.length!=N*q*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(w,this.FACE_FRONT,R,N,q,u),back:this.CreateCubemapTexture(w,this.FACE_BACK,R,N,q,u),left:this.CreateCubemapTexture(w,this.FACE_LEFT,R,N,q,u),right:this.CreateCubemapTexture(w,this.FACE_RIGHT,R,N,q,u),up:this.CreateCubemapTexture(w,this.FACE_UP,R,N,q,u),down:this.CreateCubemapTexture(w,this.FACE_DOWN,R,N,q,u),size:w,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(R,N,q,w,u){let M=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const v=new ArrayBuffer(R*R*4*3),G=new Float32Array(v),J=M?Math.max(1,Math.round(w/4/R)):1,y=1/J,a=y*y,j=N[1].Vc(N[0]).scale(y/R),F=N[3].Vc(N[2]).scale(y/R),S=1/R;let H=0;for(let W=0;W<R;W++)for(let M=0;M<J;M++){let M=N[0],v=N[2];for(let N=0;N<R;N++)for(let y=0;y<J;y++){const J=v.Vc(M).scale(H).add(M);J.normalize();const y=this.CalcProjectionSpherical(J,q,w,u);G[W*R*3+3*N+0]+=y.r*a,G[W*R*3+3*N+1]+=y.g*a,G[W*R*3+3*N+2]+=y.b*a,M=M.add(j),v=v.add(F)}H+=S*y}return G}static CalcProjectionSpherical(R,N,q,w){let u=Math.atan2(R.z,R.x);const M=Math.acos(R.y);for(;u<-Math.PI;)u+=2*Math.PI;for(;u>Math.PI;)u-=2*Math.PI;let v=u/Math.PI;const G=M/Math.PI;v=.5*v+.5;let J=Math.round(v*q);J<0?J=0:J>=q&&(J=q-1);let y=Math.round(G*w);y<0?y=0:y>=w&&(y=w-1);const a=w-y-1;return{r:N[a*q*3+3*J+0],g:N[a*q*3+3*J+1],b:N[a*q*3+3*J+2]}}}function M(R,N,q,w,u,M){u>0?(u=function(R,N){return N>1023?R*Math.pow(2,1023)*Math.pow(2,N-1023):N<-1074?R*Math.pow(2,-1074)*Math.pow(2,N+1074):R*Math.pow(2,N)}(1,u-136),R[M+0]=N*u,R[M+1]=q*u,R[M+2]=w*u):(R[M+0]=0,R[M+1]=0,R[M+2]=0)}function v(R,N){let q="",w="";for(let u=N;u<R.length-N&&(w=String.fromCharCode(R[u]),"\n"!=w);u++)q+=w;return q}function G(R){let N=0,q=0,w=v(R,0);if("#"!=w[0]||"?"!=w[1])throw"Bad HDR Format.";let u=!1,M=!1,G=0;do{G+=w.length+1,w=v(R,G),"FORMAT=32-bit_rle_rgbe"==w?M=!0:0==w.length&&(u=!0)}while(!u);if(!M)throw"HDR Bad header format, unsupported FORMAT";G+=w.length+1,w=v(R,G);const J=/^-Y (.*) \+X (.*)$/g.exec(w);if(!J||J.length<3)throw"HDR Bad header format, no size";if(q=parseInt(J[2]),N=parseInt(J[1]),q<8||q>32767)throw"HDR Bad header format, unsupported size";return G+=w.length+1,{height:N,width:q,dataPosition:G}}function J(R,N){return function(R,N){let q=N.height;const w=N.width;let u,v,G,J,a,j=N.dataPosition,F=0,S=0,H=0;const W=new ArrayBuffer(4*w),k=new Uint8Array(W),C=new ArrayBuffer(N.width*N.height*4*3),e=new Float32Array(C);for(;q>0;){if(u=R[j++],v=R[j++],G=R[j++],J=R[j++],2!=u||2!=v||128&G||N.width<8||N.width>32767)return y(R,N);if((G<<8|J)!=w)throw"HDR Bad header format, wrong scan line width";for(F=0,H=0;H<4;H++)for(S=(H+1)*w;F<S;)if(u=R[j++],v=R[j++],u>128){if(a=u-128,0==a||a>S-F)throw"HDR Bad Format, bad scanline data (run)";for(;a-- >0;)k[F++]=v}else{if(a=u,0==a||a>S-F)throw"HDR Bad Format, bad scanline data (non-run)";if(k[F++]=v,--a>0)for(let N=0;N<a;N++)k[F++]=R[j++]}for(H=0;H<w;H++)u=k[H],v=k[H+w],G=k[H+2*w],J=k[H+3*w],M(e,u,v,G,J,(N.height-q)*w*3+3*H);q--}return e}(R,N)}function y(R,N){let q=N.height;const w=N.width;let u,v,G,J,y,a=N.dataPosition;const j=new ArrayBuffer(N.width*N.height*4*3),F=new Float32Array(j);for(;q>0;){for(y=0;y<N.width;y++)u=R[a++],v=R[a++],G=R[a++],J=R[a++],M(F,u,v,G,J,(N.height-q)*w*3+3*y);q--}return F}u.FACE_LEFT=[new w.m(-1,-1,-1),new w.m(1,-1,-1),new w.m(-1,1,-1),new w.m(1,1,-1)],u.FACE_RIGHT=[new w.m(1,-1,1),new w.m(-1,-1,1),new w.m(1,1,1),new w.m(-1,1,1)],u.FACE_FRONT=[new w.m(1,-1,-1),new w.m(1,-1,1),new w.m(1,1,-1),new w.m(1,1,1)],u.FACE_BACK=[new w.m(-1,-1,1),new w.m(-1,-1,-1),new w.m(-1,1,1),new w.m(-1,1,-1)],u.FACE_DOWN=[new w.m(1,1,-1),new w.m(1,1,1),new w.m(-1,1,-1),new w.m(-1,1,1)],u.FACE_UP=[new w.m(-1,-1,-1),new w.m(-1,-1,1),new w.m(1,-1,-1),new w.m(1,-1,1)];class a{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(R,N,q){const w=new Uint8Array(R.buffer,R.byteOffset,R.byteLength),u=G(w),M=J(w,u),v=u.width*u.height,y=new Float32Array(4*v);for(let G=0;G<v;G+=1)y[4*G]=M[3*G],y[4*G+1]=M[3*G+1],y[4*G+2]=M[3*G+2],y[4*G+3]=1;q(u.width,u.height,N.generateMipMaps,!1,(()=>{const R=N.getEngine();N.type=1,N.format=5,N._gammaSpace=!1,R._uploadDataToTextureDirectly(N,y)}))}}}}]);