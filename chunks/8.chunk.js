"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10125:(V,H,t)=>{t.r(H),t.d(H,{_HDRTextureLoader:()=>d});var I=t(943);class Z{static ConvertPanoramaToCubemap(V,H,t,I){let Z=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!V)throw"ConvertPanoramaToCubemap: input cannot be null";if(V.length!=H*t*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(I,this.FACE_FRONT,V,H,t,Z),back:this.CreateCubemapTexture(I,this.FACE_BACK,V,H,t,Z),left:this.CreateCubemapTexture(I,this.FACE_LEFT,V,H,t,Z),right:this.CreateCubemapTexture(I,this.FACE_RIGHT,V,H,t,Z),up:this.CreateCubemapTexture(I,this.FACE_UP,V,H,t,Z),down:this.CreateCubemapTexture(I,this.FACE_DOWN,V,H,t,Z),size:I,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(V,H,t,I,Z){let h=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const f=new ArrayBuffer(V*V*4*3),m=new Float32Array(f),K=h?Math.max(1,Math.round(I/4/V)):1,E=1/K,d=E*E,a=H[1].Ec(H[0]).scale(E/V),J=H[3].Ec(H[2]).scale(E/V),O=1/V;let C=0;for(let S=0;S<V;S++)for(let h=0;h<K;h++){let h=H[0],f=H[2];for(let H=0;H<V;H++)for(let E=0;E<K;E++){const K=f.Ec(h).scale(C).add(h);K.normalize();const E=this.CalcProjectionSpherical(K,t,I,Z);m[S*V*3+3*H+0]+=E.r*d,m[S*V*3+3*H+1]+=E.g*d,m[S*V*3+3*H+2]+=E.b*d,h=h.add(a),f=f.add(J)}C+=O*E}return m}static CalcProjectionSpherical(V,H,t,I){let Z=Math.atan2(V.z,V.x);const h=Math.acos(V.y);for(;Z<-Math.PI;)Z+=2*Math.PI;for(;Z>Math.PI;)Z-=2*Math.PI;let f=Z/Math.PI;const m=h/Math.PI;f=.5*f+.5;let K=Math.round(f*t);K<0?K=0:K>=t&&(K=t-1);let E=Math.round(m*I);E<0?E=0:E>=I&&(E=I-1);const d=I-E-1;return{r:H[d*t*3+3*K+0],g:H[d*t*3+3*K+1],b:H[d*t*3+3*K+2]}}}function h(V,H,t,I,Z,h){Z>0?(Z=function(V,H){return H>1023?V*Math.pow(2,1023)*Math.pow(2,H-1023):H<-1074?V*Math.pow(2,-1074)*Math.pow(2,H+1074):V*Math.pow(2,H)}(1,Z-136),V[h+0]=H*Z,V[h+1]=t*Z,V[h+2]=I*Z):(V[h+0]=0,V[h+1]=0,V[h+2]=0)}function f(V,H){let t="",I="";for(let Z=H;Z<V.length-H&&(I=String.fromCharCode(V[Z]),"\n"!=I);Z++)t+=I;return t}function m(V){let H=0,t=0,I=f(V,0);if("#"!=I[0]||"?"!=I[1])throw"Bad HDR Format.";let Z=!1,h=!1,m=0;do{m+=I.length+1,I=f(V,m),"FORMAT=32-bit_rle_rgbe"==I?h=!0:0==I.length&&(Z=!0)}while(!Z);if(!h)throw"HDR Bad header format, unsupported FORMAT";m+=I.length+1,I=f(V,m);const K=/^-Y (.*) \+X (.*)$/g.exec(I);if(!K||K.length<3)throw"HDR Bad header format, no size";if(t=parseInt(K[2]),H=parseInt(K[1]),t<8||t>32767)throw"HDR Bad header format, unsupported size";return m+=I.length+1,{height:H,width:t,dataPosition:m}}function K(V,H){return function(V,H){let t=H.height;const I=H.width;let Z,f,m,K,d,a=H.dataPosition,J=0,O=0,C=0;const S=new ArrayBuffer(4*I),v=new Uint8Array(S),Q=new ArrayBuffer(H.width*H.height*4*3),e=new Float32Array(Q);for(;t>0;){if(Z=V[a++],f=V[a++],m=V[a++],K=V[a++],2!=Z||2!=f||128&m||H.width<8||H.width>32767)return E(V,H);if((m<<8|K)!=I)throw"HDR Bad header format, wrong scan line width";for(J=0,C=0;C<4;C++)for(O=(C+1)*I;J<O;)if(Z=V[a++],f=V[a++],Z>128){if(d=Z-128,0==d||d>O-J)throw"HDR Bad Format, bad scanline data (run)";for(;d-- >0;)v[J++]=f}else{if(d=Z,0==d||d>O-J)throw"HDR Bad Format, bad scanline data (non-run)";if(v[J++]=f,--d>0)for(let H=0;H<d;H++)v[J++]=V[a++]}for(C=0;C<I;C++)Z=v[C],f=v[C+I],m=v[C+2*I],K=v[C+3*I],h(e,Z,f,m,K,(H.height-t)*I*3+3*C);t--}return e}(V,H)}function E(V,H){let t=H.height;const I=H.width;let Z,f,m,K,E,d=H.dataPosition;const a=new ArrayBuffer(H.width*H.height*4*3),J=new Float32Array(a);for(;t>0;){for(E=0;E<H.width;E++)Z=V[d++],f=V[d++],m=V[d++],K=V[d++],h(J,Z,f,m,K,(H.height-t)*I*3+3*E);t--}return J}Z.FACE_LEFT=[new I.o(-1,-1,-1),new I.o(1,-1,-1),new I.o(-1,1,-1),new I.o(1,1,-1)],Z.FACE_RIGHT=[new I.o(1,-1,1),new I.o(-1,-1,1),new I.o(1,1,1),new I.o(-1,1,1)],Z.FACE_FRONT=[new I.o(1,-1,-1),new I.o(1,-1,1),new I.o(1,1,-1),new I.o(1,1,1)],Z.FACE_BACK=[new I.o(-1,-1,1),new I.o(-1,-1,-1),new I.o(-1,1,1),new I.o(-1,1,-1)],Z.FACE_DOWN=[new I.o(1,1,-1),new I.o(1,1,1),new I.o(-1,1,-1),new I.o(-1,1,1)],Z.FACE_UP=[new I.o(-1,-1,-1),new I.o(-1,-1,1),new I.o(1,-1,-1),new I.o(1,-1,1)];class d{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(V,H,t){const I=new Uint8Array(V.buffer,V.byteOffset,V.byteLength),Z=m(I),h=K(I,Z),f=Z.width*Z.height,E=new Float32Array(4*f);for(let m=0;m<f;m+=1)E[4*m]=h[3*m],E[4*m+1]=h[3*m+1],E[4*m+2]=h[3*m+2],E[4*m+3]=1;t(Z.width,Z.height,H.generateMipMaps,!1,(()=>{const V=H.getEngine();H.type=1,H.format=5,H._gammaSpace=!1,V._uploadDataToTextureDirectly(H,E)}))}}}}]);