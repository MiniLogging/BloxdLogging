"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10272:(N,Z,d)=>{d.r(Z),d.d(Z,{_HDRTextureLoader:()=>j});var X=d(960);class I{static ConvertPanoramaToCubemap(N,Z,d,X){let I=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!N)throw"ConvertPanoramaToCubemap: input cannot be null";if(N.length!=Z*d*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(X,this.FACE_FRONT,N,Z,d,I),back:this.CreateCubemapTexture(X,this.FACE_BACK,N,Z,d,I),left:this.CreateCubemapTexture(X,this.FACE_LEFT,N,Z,d,I),right:this.CreateCubemapTexture(X,this.FACE_RIGHT,N,Z,d,I),up:this.CreateCubemapTexture(X,this.FACE_UP,N,Z,d,I),down:this.CreateCubemapTexture(X,this.FACE_DOWN,N,Z,d,I),size:X,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(N,Z,d,X,I){let m=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const z=new ArrayBuffer(N*N*4*3),w=new Float32Array(z),S=m?Math.max(1,Math.round(X/4/N)):1,e=1/S,j=e*e,B=Z[1].rc(Z[0]).scale(e/N),D=Z[3].rc(Z[2]).scale(e/N),v=1/N;let T=0;for(let k=0;k<N;k++)for(let m=0;m<S;m++){let m=Z[0],z=Z[2];for(let Z=0;Z<N;Z++)for(let e=0;e<S;e++){const S=z.rc(m).scale(T).add(m);S.normalize();const e=this.CalcProjectionSpherical(S,d,X,I);w[k*N*3+3*Z+0]+=e.r*j,w[k*N*3+3*Z+1]+=e.g*j,w[k*N*3+3*Z+2]+=e.b*j,m=m.add(B),z=z.add(D)}T+=v*e}return w}static CalcProjectionSpherical(N,Z,d,X){let I=Math.atan2(N.z,N.x);const m=Math.acos(N.y);for(;I<-Math.PI;)I+=2*Math.PI;for(;I>Math.PI;)I-=2*Math.PI;let z=I/Math.PI;const w=m/Math.PI;z=.5*z+.5;let S=Math.round(z*d);S<0?S=0:S>=d&&(S=d-1);let e=Math.round(w*X);e<0?e=0:e>=X&&(e=X-1);const j=X-e-1;return{r:Z[j*d*3+3*S+0],g:Z[j*d*3+3*S+1],b:Z[j*d*3+3*S+2]}}}function m(N,Z,d,X,I,m){I>0?(I=function(N,Z){return Z>1023?N*Math.pow(2,1023)*Math.pow(2,Z-1023):Z<-1074?N*Math.pow(2,-1074)*Math.pow(2,Z+1074):N*Math.pow(2,Z)}(1,I-136),N[m+0]=Z*I,N[m+1]=d*I,N[m+2]=X*I):(N[m+0]=0,N[m+1]=0,N[m+2]=0)}function z(N,Z){let d="",X="";for(let I=Z;I<N.length-Z&&(X=String.fromCharCode(N[I]),"\n"!=X);I++)d+=X;return d}function w(N){let Z=0,d=0,X=z(N,0);if("#"!=X[0]||"?"!=X[1])throw"Bad HDR Format.";let I=!1,m=!1,w=0;do{w+=X.length+1,X=z(N,w),"FORMAT=32-bit_rle_rgbe"==X?m=!0:0==X.length&&(I=!0)}while(!I);if(!m)throw"HDR Bad header format, unsupported FORMAT";w+=X.length+1,X=z(N,w);const S=/^-Y (.*) \+X (.*)$/g.exec(X);if(!S||S.length<3)throw"HDR Bad header format, no size";if(d=parseInt(S[2]),Z=parseInt(S[1]),d<8||d>32767)throw"HDR Bad header format, unsupported size";return w+=X.length+1,{height:Z,width:d,dataPosition:w}}function S(N,Z){return function(N,Z){let d=Z.height;const X=Z.width;let I,z,w,S,j,B=Z.dataPosition,D=0,v=0,T=0;const k=new ArrayBuffer(4*X),h=new Uint8Array(k),U=new ArrayBuffer(Z.width*Z.height*4*3),C=new Float32Array(U);for(;d>0;){if(I=N[B++],z=N[B++],w=N[B++],S=N[B++],2!=I||2!=z||128&w||Z.width<8||Z.width>32767)return e(N,Z);if((w<<8|S)!=X)throw"HDR Bad header format, wrong scan line width";for(D=0,T=0;T<4;T++)for(v=(T+1)*X;D<v;)if(I=N[B++],z=N[B++],I>128){if(j=I-128,0==j||j>v-D)throw"HDR Bad Format, bad scanline data (run)";for(;j-- >0;)h[D++]=z}else{if(j=I,0==j||j>v-D)throw"HDR Bad Format, bad scanline data (non-run)";if(h[D++]=z,--j>0)for(let Z=0;Z<j;Z++)h[D++]=N[B++]}for(T=0;T<X;T++)I=h[T],z=h[T+X],w=h[T+2*X],S=h[T+3*X],m(C,I,z,w,S,(Z.height-d)*X*3+3*T);d--}return C}(N,Z)}function e(N,Z){let d=Z.height;const X=Z.width;let I,z,w,S,e,j=Z.dataPosition;const B=new ArrayBuffer(Z.width*Z.height*4*3),D=new Float32Array(B);for(;d>0;){for(e=0;e<Z.width;e++)I=N[j++],z=N[j++],w=N[j++],S=N[j++],m(D,I,z,w,S,(Z.height-d)*X*3+3*e);d--}return D}I.FACE_LEFT=[new X.n(-1,-1,-1),new X.n(1,-1,-1),new X.n(-1,1,-1),new X.n(1,1,-1)],I.FACE_RIGHT=[new X.n(1,-1,1),new X.n(-1,-1,1),new X.n(1,1,1),new X.n(-1,1,1)],I.FACE_FRONT=[new X.n(1,-1,-1),new X.n(1,-1,1),new X.n(1,1,-1),new X.n(1,1,1)],I.FACE_BACK=[new X.n(-1,-1,1),new X.n(-1,-1,-1),new X.n(-1,1,1),new X.n(-1,1,-1)],I.FACE_DOWN=[new X.n(1,1,-1),new X.n(1,1,1),new X.n(-1,1,-1),new X.n(-1,1,1)],I.FACE_UP=[new X.n(-1,-1,-1),new X.n(-1,-1,1),new X.n(1,-1,-1),new X.n(1,-1,1)];class j{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(N,Z,d){const X=new Uint8Array(N.buffer,N.byteOffset,N.byteLength),I=w(X),m=S(X,I),z=I.width*I.height,e=new Float32Array(4*z);for(let w=0;w<z;w+=1)e[4*w]=m[3*w],e[4*w+1]=m[3*w+1],e[4*w+2]=m[3*w+2],e[4*w+3]=1;d(I.width,I.height,Z.generateMipMaps,!1,(()=>{const N=Z.getEngine();Z.type=1,Z.format=5,Z._gammaSpace=!1,N._uploadDataToTextureDirectly(Z,e)}))}}}}]);