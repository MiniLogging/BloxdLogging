"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10326:(r,L,M)=>{M.r(L),M.d(L,{_HDRTextureLoader:()=>J});var S=M(945);class T{static ConvertPanoramaToCubemap(r,L,M,S){let T=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!r)throw"ConvertPanoramaToCubemap: input cannot be null";if(r.length!=L*M*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(S,this.FACE_FRONT,r,L,M,T),back:this.CreateCubemapTexture(S,this.FACE_BACK,r,L,M,T),left:this.CreateCubemapTexture(S,this.FACE_LEFT,r,L,M,T),right:this.CreateCubemapTexture(S,this.FACE_RIGHT,r,L,M,T),up:this.CreateCubemapTexture(S,this.FACE_UP,r,L,M,T),down:this.CreateCubemapTexture(S,this.FACE_DOWN,r,L,M,T),size:S,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(r,L,M,S,T){let C=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const y=new ArrayBuffer(r*r*4*3),s=new Float32Array(y),v=C?Math.max(1,Math.round(S/4/r)):1,u=1/v,J=u*u,f=L[1].hc(L[0]).scale(u/r),t=L[3].hc(L[2]).scale(u/r),o=1/r;let h=0;for(let U=0;U<r;U++)for(let C=0;C<v;C++){let C=L[0],y=L[2];for(let L=0;L<r;L++)for(let u=0;u<v;u++){const v=y.hc(C).scale(h).add(C);v.normalize();const u=this.CalcProjectionSpherical(v,M,S,T);s[U*r*3+3*L+0]+=u.r*J,s[U*r*3+3*L+1]+=u.g*J,s[U*r*3+3*L+2]+=u.b*J,C=C.add(f),y=y.add(t)}h+=o*u}return s}static CalcProjectionSpherical(r,L,M,S){let T=Math.atan2(r.z,r.x);const C=Math.acos(r.y);for(;T<-Math.PI;)T+=2*Math.PI;for(;T>Math.PI;)T-=2*Math.PI;let y=T/Math.PI;const s=C/Math.PI;y=.5*y+.5;let v=Math.round(y*M);v<0?v=0:v>=M&&(v=M-1);let u=Math.round(s*S);u<0?u=0:u>=S&&(u=S-1);const J=S-u-1;return{r:L[J*M*3+3*v+0],g:L[J*M*3+3*v+1],b:L[J*M*3+3*v+2]}}}function C(r,L,M,S,T,C){T>0?(T=function(r,L){return L>1023?r*Math.pow(2,1023)*Math.pow(2,L-1023):L<-1074?r*Math.pow(2,-1074)*Math.pow(2,L+1074):r*Math.pow(2,L)}(1,T-136),r[C+0]=L*T,r[C+1]=M*T,r[C+2]=S*T):(r[C+0]=0,r[C+1]=0,r[C+2]=0)}function y(r,L){let M="",S="";for(let T=L;T<r.length-L&&(S=String.fromCharCode(r[T]),"\n"!=S);T++)M+=S;return M}function s(r){let L=0,M=0,S=y(r,0);if("#"!=S[0]||"?"!=S[1])throw"Bad HDR Format.";let T=!1,C=!1,s=0;do{s+=S.length+1,S=y(r,s),"FORMAT=32-bit_rle_rgbe"==S?C=!0:0==S.length&&(T=!0)}while(!T);if(!C)throw"HDR Bad header format, unsupported FORMAT";s+=S.length+1,S=y(r,s);const v=/^-Y (.*) \+X (.*)$/g.exec(S);if(!v||v.length<3)throw"HDR Bad header format, no size";if(M=parseInt(v[2]),L=parseInt(v[1]),M<8||M>32767)throw"HDR Bad header format, unsupported size";return s+=S.length+1,{height:L,width:M,dataPosition:s}}function v(r,L){return function(r,L){let M=L.height;const S=L.width;let T,y,s,v,J,f=L.dataPosition,t=0,o=0,h=0;const U=new ArrayBuffer(4*S),G=new Uint8Array(U),W=new ArrayBuffer(L.width*L.height*4*3),l=new Float32Array(W);for(;M>0;){if(T=r[f++],y=r[f++],s=r[f++],v=r[f++],2!=T||2!=y||128&s||L.width<8||L.width>32767)return u(r,L);if((s<<8|v)!=S)throw"HDR Bad header format, wrong scan line width";for(t=0,h=0;h<4;h++)for(o=(h+1)*S;t<o;)if(T=r[f++],y=r[f++],T>128){if(J=T-128,0==J||J>o-t)throw"HDR Bad Format, bad scanline data (run)";for(;J-- >0;)G[t++]=y}else{if(J=T,0==J||J>o-t)throw"HDR Bad Format, bad scanline data (non-run)";if(G[t++]=y,--J>0)for(let L=0;L<J;L++)G[t++]=r[f++]}for(h=0;h<S;h++)T=G[h],y=G[h+S],s=G[h+2*S],v=G[h+3*S],C(l,T,y,s,v,(L.height-M)*S*3+3*h);M--}return l}(r,L)}function u(r,L){let M=L.height;const S=L.width;let T,y,s,v,u,J=L.dataPosition;const f=new ArrayBuffer(L.width*L.height*4*3),t=new Float32Array(f);for(;M>0;){for(u=0;u<L.width;u++)T=r[J++],y=r[J++],s=r[J++],v=r[J++],C(t,T,y,s,v,(L.height-M)*S*3+3*u);M--}return t}T.FACE_LEFT=[new S.m(-1,-1,-1),new S.m(1,-1,-1),new S.m(-1,1,-1),new S.m(1,1,-1)],T.FACE_RIGHT=[new S.m(1,-1,1),new S.m(-1,-1,1),new S.m(1,1,1),new S.m(-1,1,1)],T.FACE_FRONT=[new S.m(1,-1,-1),new S.m(1,-1,1),new S.m(1,1,-1),new S.m(1,1,1)],T.FACE_BACK=[new S.m(-1,-1,1),new S.m(-1,-1,-1),new S.m(-1,1,1),new S.m(-1,1,-1)],T.FACE_DOWN=[new S.m(1,1,-1),new S.m(1,1,1),new S.m(-1,1,-1),new S.m(-1,1,1)],T.FACE_UP=[new S.m(-1,-1,-1),new S.m(-1,-1,1),new S.m(1,-1,-1),new S.m(1,-1,1)];class J{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(r,L,M){const S=new Uint8Array(r.buffer,r.byteOffset,r.byteLength),T=s(S),C=v(S,T),y=T.width*T.height,u=new Float32Array(4*y);for(let s=0;s<y;s+=1)u[4*s]=C[3*s],u[4*s+1]=C[3*s+1],u[4*s+2]=C[3*s+2],u[4*s+3]=1;M(T.width,T.height,L.generateMipMaps,!1,(()=>{const r=L.getEngine();L.type=1,L.format=5,L._gammaSpace=!1,r._uploadDataToTextureDirectly(L,u)}))}}}}]);