"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{11266:(x,Z,l)=>{l.r(Z),l.d(Z,{_HDRTextureLoader:()=>V});var t=l(1043);class L{static ConvertPanoramaToCubemap(x,Z,l,t){let L=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!x)throw"ConvertPanoramaToCubemap: input cannot be null";if(x.length!=Z*l*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(t,this.FACE_FRONT,x,Z,l,L),back:this.CreateCubemapTexture(t,this.FACE_BACK,x,Z,l,L),left:this.CreateCubemapTexture(t,this.FACE_LEFT,x,Z,l,L),right:this.CreateCubemapTexture(t,this.FACE_RIGHT,x,Z,l,L),up:this.CreateCubemapTexture(t,this.FACE_UP,x,Z,l,L),down:this.CreateCubemapTexture(t,this.FACE_DOWN,x,Z,l,L),size:t,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(x,Z,l,t,L){let z=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const A=new ArrayBuffer(x*x*4*3),P=new Float32Array(A),C=z?Math.max(1,Math.round(t/4/x)):1,j=1/C,V=j*j,Q=Z[1].qd(Z[0]).scale(j/x),c=Z[3].qd(Z[2]).scale(j/x),a=1/x;let I=0;for(let u=0;u<x;u++)for(let z=0;z<C;z++){let z=Z[0],A=Z[2];for(let Z=0;Z<x;Z++)for(let j=0;j<C;j++){const C=A.qd(z).scale(I).add(z);C.normalize();const j=this.CalcProjectionSpherical(C,l,t,L);P[u*x*3+3*Z+0]+=j.r*V,P[u*x*3+3*Z+1]+=j.g*V,P[u*x*3+3*Z+2]+=j.b*V,z=z.add(Q),A=A.add(c)}I+=a*j}return P}static CalcProjectionSpherical(x,Z,l,t){let L=Math.atan2(x.z,x.x);const z=Math.acos(x.y);for(;L<-Math.PI;)L+=2*Math.PI;for(;L>Math.PI;)L-=2*Math.PI;let A=L/Math.PI;const P=z/Math.PI;A=.5*A+.5;let C=Math.round(A*l);C<0?C=0:C>=l&&(C=l-1);let j=Math.round(P*t);j<0?j=0:j>=t&&(j=t-1);const V=t-j-1;return{r:Z[V*l*3+3*C+0],g:Z[V*l*3+3*C+1],b:Z[V*l*3+3*C+2]}}}function z(x,Z,l,t,L,z){L>0?(L=function(x,Z){return Z>1023?x*Math.pow(2,1023)*Math.pow(2,Z-1023):Z<-1074?x*Math.pow(2,-1074)*Math.pow(2,Z+1074):x*Math.pow(2,Z)}(1,L-136),x[z+0]=Z*L,x[z+1]=l*L,x[z+2]=t*L):(x[z+0]=0,x[z+1]=0,x[z+2]=0)}function A(x,Z){let l="",t="";for(let L=Z;L<x.length-Z&&(t=String.fromCharCode(x[L]),"\n"!=t);L++)l+=t;return l}function P(x){let Z=0,l=0,t=A(x,0);if("#"!=t[0]||"?"!=t[1])throw"Bad HDR Format.";let L=!1,z=!1,P=0;do{P+=t.length+1,t=A(x,P),"FORMAT=32-bit_rle_rgbe"==t?z=!0:0==t.length&&(L=!0)}while(!L);if(!z)throw"HDR Bad header format, unsupported FORMAT";P+=t.length+1,t=A(x,P);const C=/^-Y (.*) \+X (.*)$/g.exec(t);if(!C||C.length<3)throw"HDR Bad header format, no size";if(l=parseInt(C[2]),Z=parseInt(C[1]),l<8||l>32767)throw"HDR Bad header format, unsupported size";return P+=t.length+1,{height:Z,width:l,dataPosition:P}}function C(x,Z){return function(x,Z){let l=Z.height;const t=Z.width;let L,A,P,C,V,Q=Z.dataPosition,c=0,a=0,I=0;const u=new ArrayBuffer(4*t),n=new Uint8Array(u),v=new ArrayBuffer(Z.width*Z.height*4*3),X=new Float32Array(v);for(;l>0;){if(L=x[Q++],A=x[Q++],P=x[Q++],C=x[Q++],2!=L||2!=A||128&P||Z.width<8||Z.width>32767)return j(x,Z);if((P<<8|C)!=t)throw"HDR Bad header format, wrong scan line width";for(c=0,I=0;I<4;I++)for(a=(I+1)*t;c<a;)if(L=x[Q++],A=x[Q++],L>128){if(V=L-128,0==V||V>a-c)throw"HDR Bad Format, bad scanline data (run)";for(;V-- >0;)n[c++]=A}else{if(V=L,0==V||V>a-c)throw"HDR Bad Format, bad scanline data (non-run)";if(n[c++]=A,--V>0)for(let Z=0;Z<V;Z++)n[c++]=x[Q++]}for(I=0;I<t;I++)L=n[I],A=n[I+t],P=n[I+2*t],C=n[I+3*t],z(X,L,A,P,C,(Z.height-l)*t*3+3*I);l--}return X}(x,Z)}function j(x,Z){let l=Z.height;const t=Z.width;let L,A,P,C,j,V=Z.dataPosition;const Q=new ArrayBuffer(Z.width*Z.height*4*3),c=new Float32Array(Q);for(;l>0;){for(j=0;j<Z.width;j++)L=x[V++],A=x[V++],P=x[V++],C=x[V++],z(c,L,A,P,C,(Z.height-l)*t*3+3*j);l--}return c}L.FACE_LEFT=[new t.k(-1,-1,-1),new t.k(1,-1,-1),new t.k(-1,1,-1),new t.k(1,1,-1)],L.FACE_RIGHT=[new t.k(1,-1,1),new t.k(-1,-1,1),new t.k(1,1,1),new t.k(-1,1,1)],L.FACE_FRONT=[new t.k(1,-1,-1),new t.k(1,-1,1),new t.k(1,1,-1),new t.k(1,1,1)],L.FACE_BACK=[new t.k(-1,-1,1),new t.k(-1,-1,-1),new t.k(-1,1,1),new t.k(-1,1,-1)],L.FACE_DOWN=[new t.k(1,1,-1),new t.k(1,1,1),new t.k(-1,1,-1),new t.k(-1,1,1)],L.FACE_UP=[new t.k(-1,-1,-1),new t.k(-1,-1,1),new t.k(1,-1,-1),new t.k(1,-1,1)];class V{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(x,Z,l){const t=new Uint8Array(x.buffer,x.byteOffset,x.byteLength),L=P(t),z=C(t,L),A=L.width*L.height,j=new Float32Array(4*A);for(let P=0;P<A;P+=1)j[4*P]=z[3*P],j[4*P+1]=z[3*P+1],j[4*P+2]=z[3*P+2],j[4*P+3]=1;l(L.width,L.height,Z.generateMipMaps,!1,(()=>{const x=Z.getEngine();Z.type=1,Z.format=5,Z._gammaSpace=!1,x._uploadDataToTextureDirectly(Z,j)}))}}}}]);