"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{2405:(Z,U,n)=>{n.r(U),n.d(U,{_BasisTextureLoader:()=>z});var i,B=n(498),l=n(2303),H=n(615);function V(){const Z=0,U=1,n=2,i=3,B=6,l=8,H=9,V=10,G=14;let R=null;function d(Z,U,n,i,B){const l=Z.getImageTranscodedSizeInBytes(U,n,i);let H=new Uint8Array(l);if(!Z.transcodeImage(H,U,n,i,1,0))return null;if(B){H=function(Z,U,n,i){const B=new Uint16Array(4),l=new Uint16Array(n*i),H=n/4,V=i/4;for(let G=0;G<V;G++)for(let i=0;i<H;i++){const V=U+8*(G*H+i);B[0]=Z[V]|Z[V+1]<<8,B[1]=Z[V+2]|Z[V+3]<<8,B[2]=(2*(31&B[0])+1*(31&B[1]))/3|(2*(2016&B[0])+1*(2016&B[1]))/3&2016|(2*(63488&B[0])+1*(63488&B[1]))/3&63488,B[3]=(2*(31&B[1])+1*(31&B[0]))/3|(2*(2016&B[1])+1*(2016&B[0]))/3&2016|(2*(63488&B[1])+1*(63488&B[0]))/3&63488;for(let U=0;U<4;U++){const H=Z[V+4+U];let R=(4*G+U)*n+4*i;l[R++]=B[3&H],l[R++]=B[H>>2&3],l[R++]=B[H>>4&3],l[R++]=B[H>>6&3]}}return l}(H,0,Z.getImageWidth(U,n)+3&-4,Z.getImageHeight(U,n)+3&-4)}return H}onmessage=F=>{if("init"===F.data.action){if(F.data.url)try{importScripts(F.data.url)}catch(y){postMessage({action:"error",error:y})}R||(R=BASIS({wasmBinary:F.data.wasmBinary})),null!==R&&R.then((Z=>{BASIS=Z,Z.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===F.data.action){const R=F.data.config,y=F.data.imageData,S=new BASIS.BasisFile(y),q=function(Z){const U=Z.getHasAlpha(),n=Z.getNumImages(),i=[];for(let B=0;B<n;B++){const U={levels:[]},n=Z.getNumLevels(B);for(let i=0;i<n;i++){const n={width:Z.getImageWidth(B,i),height:Z.getImageHeight(B,i)};U.levels.push(n)}i.push(U)}return{Jj:U,images:i}}(S);let c=F.data.ignoreSupportedFormats?null:function(R,d){let F=null;R.supportedCompressionFormats&&(F=R.supportedCompressionFormats.astc?V:R.supportedCompressionFormats.bc7?B:R.supportedCompressionFormats.s3tc?d.Jj?i:n:R.supportedCompressionFormats.pvrtc?d.Jj?H:l:R.supportedCompressionFormats.etc2?U:R.supportedCompressionFormats.etc1?Z:G);return F}(F.data.config,q),s=!1;null===c&&(s=!0,c=q.Jj?i:n);let z=!0;S.startTranscoding()||(z=!1);const O=[];for(let Z=0;Z<q.images.length&&z;Z++){const U=q.images[Z];if(void 0===R.loadSingleImage||R.loadSingleImage===Z){let n=U.levels.length;!1===R.loadMipmapLevels&&(n=1);for(let i=0;i<n;i++){const n=U.levels[i],B=d(S,Z,i,c,s);if(!B){z=!1;break}n.transcodedPixels=B,O.push(n.transcodedPixels.buffer)}}}S.close(),S.delete(),s&&(c=-1),z?postMessage({action:"transcode",success:z,id:F.data.id,fileInfo:q,format:c},O):postMessage({action:"transcode",success:z,id:F.data.id})}}}!function(Z){Z[Z.cTFETC1=0]="cTFETC1",Z[Z.cTFETC2=1]="cTFETC2",Z[Z.cTFBC1=2]="cTFBC1",Z[Z.cTFBC3=3]="cTFBC3",Z[Z.cTFBC4=4]="cTFBC4",Z[Z.cTFBC5=5]="cTFBC5",Z[Z.cTFBC7=6]="cTFBC7",Z[Z.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",Z[Z.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",Z[Z.cTFASTC_4x4=10]="cTFASTC_4x4",Z[Z.cTFATC_RGB=11]="cTFATC_RGB",Z[Z.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",Z[Z.cTFRGBA32=13]="cTFRGBA32",Z[Z.cTFRGB565=14]="cTFRGB565",Z[Z.cTFBGR565=15]="cTFBGR565",Z[Z.cTFRGBA4444=16]="cTFRGBA4444",Z[Z.cTFFXT1_RGB=17]="cTFFXT1_RGB",Z[Z.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",Z[Z.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",Z[Z.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",Z[Z.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(i||(i={}));const G={JSModuleURL:`${B.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${B.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let R=null,d=null,F=0;const y=async()=>(R||(R=new Promise(((Z,U)=>{d?Z(d):B.e.LoadFileAsync(B.e.GetBabylonScriptURL(G.WasmModuleURL)).then((n=>{if("function"!==typeof URL)return U("Basis transcoder requires an environment with a URL constructor");const i=URL.createObjectURL(new Blob([`(${V})()`],{type:"application/javascript"}));d=new Worker(i),async function(Z,U,n){return await new Promise(((i,l)=>{const H=U=>{"init"===U.data.action?(Z.removeEventListener("message",H),i(Z)):"error"===U.data.action&&l(U.data.error||"error initializing worker")};Z.addEventListener("message",H),Z.postMessage({action:"init",url:n?B.e.GetBabylonScriptURL(n):void 0,wasmBinary:U},[U])}))}(d,n,G.JSModuleURL).then(Z,U)})).catch(U)}))),await R),S=async(Z,U)=>{const n=Z instanceof ArrayBuffer?new Uint8Array(Z):Z;return await new Promise(((Z,i)=>{y().then((()=>{const B=F++,l=U=>{"transcode"===U.data.action&&U.data.id===B&&(d.removeEventListener("message",l),U.data.success?Z(U.data):i("Transcode is not supported on this device"))};d.addEventListener("message",l);const H=new Uint8Array(n.byteLength);H.set(new Uint8Array(n.buffer,n.byteOffset,n.byteLength)),d.postMessage({action:"transcode",id:B,imageData:H,config:U,ignoreSupportedFormats:false},[H.buffer])}),(Z=>{i(Z)}))}))},q=(Z,U)=>{var n;let i=null===(n=U._gl)||void 0===n?void 0:n.TEXTURE_2D;var B;Z.isCube&&(i=null===(B=U._gl)||void 0===B?void 0:B.TEXTURE_CUBE_MAP);U._bindTextureDirectly(i,Z,!0)},c=(Z,U)=>{const n=Z.getEngine();for(let V=0;V<U.fileInfo.images.length;V++){const G=U.fileInfo.images[V].levels[0];if(Z._invertVScale=Z.invertY,-1===U.format||U.format===i.cTFRGB565)if(Z.type=10,Z.format=4,!n._features.basisNeedsPOT||Math.log2(G.width)%1===0&&Math.log2(G.height)%1===0)Z._invertVScale=!Z.invertY,Z.width=G.width+3&-4,Z.height=G.height+3&-4,Z.samplingMode=2,q(Z,n),n._uploadDataToTextureDirectly(Z,new Uint16Array(G.transcodedPixels.buffer),V,0,4,!0);else{const U=new H.b(n,2);Z._invertVScale=Z.invertY,U.type=10,U.format=4,U.width=G.width+3&-4,U.height=G.height+3&-4,q(U,n),n._uploadDataToTextureDirectly(U,new Uint16Array(G.transcodedPixels.buffer),V,0,4,!0),n._rescaleTexture(U,Z,n.scenes[0],n._getInternalFormat(4),(()=>{n._releaseTexture(U),q(Z,n)}))}else{Z.width=G.width,Z.height=G.height,Z.generateMipMaps=U.fileInfo.images[V].levels.length>1;const i=s.GetInternalFormatFromBasisFormat(U.format,n);Z.format=i,q(Z,n);const H=U.fileInfo.images[V].levels;for(let U=0;U<H.length;U++){const B=H[U];n._uploadCompressedDataToTextureDirectly(Z,i,B.width,B.height,B.transcodedPixels,V,U)}!n._features.basisNeedsPOT||Math.log2(Z.width)%1===0&&Math.log2(Z.height)%1===0||(B.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),Z._cachedWrapU=l.c.CLAMP_ADDRESSMODE,Z._cachedWrapV=l.c.CLAMP_ADDRESSMODE)}}},s={JSModuleURL:G.JSModuleURL,WasmModuleURL:G.WasmModuleURL,GetInternalFormatFromBasisFormat:(Z,U)=>{let n;switch(Z){case i.cTFETC1:n=36196;break;case i.cTFBC1:n=33776;break;case i.cTFBC4:n=33779;break;case i.cTFASTC_4x4:n=37808;break;case i.cTFETC2:n=37496;break;case i.cTFBC7:n=36492}if(void 0===n)throw"The chosen Basis transcoder format is not currently supported";return n},TranscodeAsync:S,LoadTextureFromTranscodeResult:c};Object.defineProperty(s,"JSModuleURL",{get:function(){return G.JSModuleURL},set:function(Z){G.JSModuleURL=Z}}),Object.defineProperty(s,"WasmModuleURL",{get:function(){return G.WasmModuleURL},set:function(Z){G.WasmModuleURL=Z}});class z{constructor(){this.supportCascades=!1}loadCubeData(Z,U,n,i,l){if(Array.isArray(Z))return;const H=U.getEngine().getCaps(),V={supportedCompressionFormats:{etc1:!!H.etc1,s3tc:!!H.s3tc,pvrtc:!!H.pvrtc,etc2:!!H.etc2,astc:!!H.astc,bc7:!!H.bptc}};S(Z,V).then((Z=>{const n=Z.fileInfo.images[0].levels.length>1&&U.generateMipMaps;c(U,Z),U.getEngine()._setCubeMapTextureParams(U,n),U.isReady=!0,U.onLoadedObservable.notifyObservers(U),U.onLoadedObservable.clear(),i&&i()})).catch((Z=>{B.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),U.isReady=!0,l&&l(Z)}))}loadData(Z,U,n){const i=U.getEngine().getCaps(),l={supportedCompressionFormats:{etc1:!!i.etc1,s3tc:!!i.s3tc,pvrtc:!!i.pvrtc,etc2:!!i.etc2,astc:!!i.astc,bc7:!!i.bptc}};S(Z,l).then((Z=>{const i=Z.fileInfo.images[0].levels[0],B=Z.fileInfo.images[0].levels.length>1&&U.generateMipMaps;n(i.width,i.height,B,-1!==Z.format,(()=>{c(U,Z)}))})).catch((Z=>{B.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),B.e.Warn(`Failed to transcode Basis file: ${Z}`),n(0,0,!1,!1,(()=>{}),!0)}))}}}}]);