"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10896:(s,Z,o)=>{o.r(Z),o.d(Z,{EXT_materials_diffuse_roughness:()=>hZ,EXT_mesh_gpu_instancing:()=>Es,GLTF2Export:()=>Ks,GLTFData:()=>G,KHR_draco_mesh_compression:()=>oZ,KHR_lights_punctual:()=>vZ,KHR_materials_anisotropy:()=>QZ,KHR_materials_clearcoat:()=>zZ,KHR_materials_diffuse_transmission:()=>fZ,KHR_materials_dispersion:()=>dZ,KHR_materials_emissive_strength:()=>uZ,KHR_materials_ior:()=>FZ,KHR_materials_iridescence:()=>NZ,KHR_materials_sheen:()=>VZ,KHR_materials_specular:()=>lZ,KHR_materials_transmission:()=>eZ,KHR_materials_unlit:()=>wZ,KHR_materials_volume:()=>WZ,KHR_texture_transform:()=>xZ,OBJExport:()=>a,STLExport:()=>kZ,USDZExportAsync:()=>Zo,_ConvertToGLTFPBRMetallicRoughness:()=>c,_SolveMetallic:()=>e,__IGLTFExporterExtension:()=>O});var t=o(10900),j=o(10938),S=o(11081);class a{static OBJ(s,Z,o,a){const O=[];let v=1,G=1;Z&&(o||(o="mat"),O.push("mtllib "+o+".mtl"));for(let B=0;B<s.length;B++){const o=s[B],Q=o.name||`mesh${B}}`;O.push(`o ${Q}`);let D=null;if(a){const s=o.Ea(!0);D=new t.b,s.invertToRef(D),o.bakeTransformIntoVertices(s)}if(Z){const s=o.material;s&&O.push("usemtl "+s.id)}const z=o.Pa;if(!z){j.g.Warn("No geometry is present on the mesh");continue}const Y=z.getVerticesData("position"),b=z.getVerticesData("gt"),f=z.getVerticesData("uv"),A=z.ra();let d=0,U=0;if(!Y||!A){j.g.Warn("There are no position vertices or indices on the mesh!");continue}const u=s[0].Ls().useRightHandedSystem?1:-1;for(let s=0;s<Y.length;s+=3)O.push("v "+Y[s]*u+" "+Y[s+1]+" "+Y[s+2]),d++;if(null!=b)for(let s=0;s<b.length;s+=3)O.push("vn "+b[s]*u+" "+b[s+1]+" "+b[s+2]);if(null!=f)for(let s=0;s<f.length;s+=2)O.push("vt "+f[s]+" "+f[s+1]),U++;const H=["","",""],F=(o.material||o.Ls().defaultMaterial)._getEffectiveOrientation(o),[i,N]=F===S.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let s=0;s<A.length;s+=3){const Z=[String(A[s]+v),String(A[s+i]+v),String(A[s+N]+v)],o=[String(A[s]+G),String(A[s+i]+G),String(A[s+N]+G)],t=Z,j=null!=f?o:H,S=null!=b?Z:H;O.push("f "+t[0]+"/"+j[0]+"/"+S[0]+" "+t[1]+"/"+j[1]+"/"+S[1]+" "+t[2]+"/"+j[2]+"/"+S[2])}a&&D&&o.bakeTransformIntoVertices(D),v+=d,G+=U}return O.join("\n")}static MTL(s){const Z=[],o=s.material;Z.push("newmtl mat1"),Z.push("  Ns "+o.specularPower.toFixed(4)),Z.push("  Ni 1.5000"),Z.push("  d "+o.alpha.toFixed(4)),Z.push("  Tr 0.0000"),Z.push("  Tf 1.0000 1.0000 1.0000"),Z.push("  illum 2"),Z.push("  Ka "+o.ambientColor.r.toFixed(4)+" "+o.ambientColor.g.toFixed(4)+" "+o.ambientColor.b.toFixed(4)),Z.push("  Kd "+o.diffuseColor.r.toFixed(4)+" "+o.diffuseColor.g.toFixed(4)+" "+o.diffuseColor.b.toFixed(4)),Z.push("  Ks "+o.specularColor.r.toFixed(4)+" "+o.specularColor.g.toFixed(4)+" "+o.specularColor.b.toFixed(4)),Z.push("  Ke "+o.emissiveColor.r.toFixed(4)+" "+o.emissiveColor.g.toFixed(4)+" "+o.emissiveColor.b.toFixed(4));o.ambientTexture&&Z.push("  map_Ka "+o.ambientTexture.name),o.diffuseTexture&&Z.push("  map_Kd "+o.diffuseTexture.name),o.specularTexture&&Z.push("  map_Ks "+o.specularTexture.name),o.bumpTexture&&Z.push("  map_bump -imfchan z "+o.bumpTexture.name),o.opacityTexture&&Z.push("  map_d "+o.opacityTexture.name);return Z.join("\n")}}var O=0,v=o(10982);class G{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const s in this.files){const Z=this.files[s],o=new Blob([Z],{type:(0,v.l)(s)});j.g.Download(o,s)}}}var B=o(11113),Q=o(11197),D=o(11206),z=o(11236),Y=o(11304),b=o(10927),f=o(11174),A=o(10935);const d=A.HighestCommonFactor,U={...A,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:d};var u=o(11405),H=o(11410),F=o(11451),i=o(11457),N=o(11460);const L=1e-6,V=new f.d(.04,.04,.04),g=1024,l=f.d.White(),R=f.d.Black();function e(s,Z,o){if(Z<V.r)return 0;const t=V.r,j=s*o/(1-V.r)+Z-2*V.r,S=j*j-4*t*(V.r-Z);return U.Clamp((-j+Math.sqrt(S))/(2*t),0,1)}function c(s){const Z=s.diffuseColor.toLinearSpace(s.Ls().getEngine().useExactSrgbConversions).scale(.5),o=s.alpha,j=function(s){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new t.j(0,1),o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new t.j(0,.1),j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new t.j(0,.1),S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new t.j(1300,.1);return function(s,Z,o,t,j){return(1-s)*(1-s)*(1-s)*Z+3*(1-s)*(1-s)*s*o+3*(1-s)*s*s*t+s*s*s*j}(Math.pow(s/S.x,.333333),Z.y,o.y,j.y,S.y)}(U.Clamp(s.specularPower,0,g));return{baseColorFactor:[Z.r,Z.g,Z.b,o],metallicFactor:0,roughnessFactor:j}}function w(s,Z){Z.needAlphaBlending()?s.alphaMode="BLEND":Z.needAlphaTesting()&&(s.alphaMode="MASK",s.alphaCutoff=Z.alphaCutOff)}function X(s,Z,o){const t=new Uint8Array(s*Z*4);for(let j=0;j<t.length;j+=4)t[j]=t[j+1]=t[j+2]=t[j+3]=255;return F.b.CreateRGBATexture(t,s,Z,o)}function W(s){if(s instanceof Uint8Array){const Z=s.length,o=new Float32Array(s.length);for(let t=0;t<Z;++t)o[t]=s[t]/255;return o}if(s instanceof Float32Array)return s;throw new Error("Unsupported pixel format!")}class q{constructor(s){this._exporter=s,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(s){return s?this._textureMap.get(s)??null:null}async exportStandardMaterialAsync(s,Z,o){const t=c(s),S={name:s.name};if(null==s.Ta||s.Ta||(s.twoSidedLighting||j.g.Warn(s.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),S.doubleSided=!0),o){const o=[],j=s.diffuseTexture;j&&o.push(this.exportTextureAsync(j,Z).then((s=>{s&&(t.baseColorTexture=s)})));const a=s.bumpTexture;a&&o.push(this.exportTextureAsync(a,Z).then((s=>{s&&(S.normalTexture=s,1!==a.level&&(S.normalTexture.scale=a.level))})));const O=s.emissiveTexture;O&&(S.emissiveFactor=[1,1,1],o.push(this.exportTextureAsync(O,Z).then((s=>{s&&(S.emissiveTexture=s)}))));const v=s.ambientTexture;v&&o.push(this.exportTextureAsync(v,Z).then((s=>{if(s){const Z={index:s.index};S.occlusionTexture=Z}}))),o.length>0&&(this._exporter._materialNeedsUVsSet.add(s),await Promise.all(o))}(s.alpha<1||s.opacityTexture)&&(s.alphaMode===i.b.ALPHA_COMBINE?S.alphaMode="BLEND":j.g.Warn(s.name+": glTF 2.0 does not support alpha mode: "+s.alphaMode.toString())),s.emissiveColor&&!s.emissiveColor.equalsWithEpsilon(R,L)&&(S.emissiveFactor=s.emissiveColor.ma()),S.pbrMetallicRoughness=t,w(S,s),await this._finishMaterialAsync(S,s,Z);const a=this._exporter._materials;return a.push(S),a.length-1}async _finishMaterialAsync(s,Z,o){const t=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",s,Z),j=[];for(const S of t)j.push(this.exportTextureAsync(S,o));await Promise.all(j),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",s,Z)}async _getImageDataAsync(s,Z,t,j){const S=i.b.TEXTURETYPE_UNSIGNED_BYTE,a=this._exporter._babylonScene,O=a.getEngine(),v=O.createRawTexture(s,Z,t,i.b.TEXTUREFORMAT_RGBA,!1,!0,H.c.NEAREST_SAMPLINGMODE,null,S);O.isWebGPU?await o.e(36).then(o.bind(o,13543)):await o.e(37).then(o.bind(o,13550)),await u.h.ApplyPostProcess("pass",v,a,S,i.b.TEXTURE_NEAREST_SAMPLINGMODE,i.b.TEXTUREFORMAT_RGBA);const G=await O._readTexturePixels(v,Z,t);return await N.DumpTools.DumpDataAsync(Z,t,G,j,void 0,!0,!0)}_resizeTexturesToSameDimensions(s,Z,o){const t=s?s.getSize():{width:0,height:0},j=Z?Z.getSize():{width:0,height:0};let S,a;return t.width<j.width?(S=s&&s instanceof H.c?u.h.CreateResizedCopy(s,j.width,j.height,!0):X(j.width,j.height,o),a=Z):t.width>j.width?(a=Z&&Z instanceof H.c?u.h.CreateResizedCopy(Z,t.width,t.height,!0):X(t.width,t.height,o),S=s):(S=s,a=Z),{texture1:S,texture2:a}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(s,Z,o,t){const j=new Array;if(!s&&!Z)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const S=s?s.Ls():Z?Z.Ls():null;if(S){var a;const O=this._resizeTexturesToSameDimensions(s,Z,S),v=null===(a=O.texture1)||void 0===a?void 0:a.getSize();let G,B;const Q=v.width,D=v.height,z=await O.texture1.readPixels(),Y=await O.texture2.readPixels();if(!z)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(G=W(z),!Y)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");B=W(Y);const b=B.byteLength,A=new Uint8Array(b),d=new Uint8Array(b),U=4,u=R;let H=0,F=0;for(let s=0;s<D;++s)for(let Z=0;Z<Q;++Z){const t=(Q*s+Z)*U,j={diffuseColor:new f.d(G[t],G[t+1],G[t+2]).toLinearSpace(S.getEngine().useExactSrgbConversions).multiply(o.diffuseColor),specularColor:new f.d(B[t],B[t+1],B[t+2]).toLinearSpace(S.getEngine().useExactSrgbConversions).multiply(o.specularColor),glossiness:B[t+3]*o.glossiness},a=this._convertSpecularGlossinessToMetallicRoughness(j);u.r=Math.max(u.r,a.baseColor.r),u.g=Math.max(u.g,a.baseColor.g),u.b=Math.max(u.b,a.baseColor.b),H=Math.max(H,a.metallic),F=Math.max(F,a.roughness),d[t]=255*a.baseColor.r,d[t+1]=255*a.baseColor.g,d[t+2]=255*a.baseColor.b,d[t+3]=O.texture1.na?255*G[t+3]:255,A[t]=0,A[t+1]=255*a.roughness,A[t+2]=255*a.metallic,A[t+3]=255}const i={baseColor:u,metallic:H,roughness:F};let N=!1,V=!1;for(let s=0;s<D;++s)for(let Z=0;Z<Q;++Z){const o=(Q*s+Z)*U;d[o]/=i.baseColor.r>L?i.baseColor.r:1,d[o+1]/=i.baseColor.g>L?i.baseColor.g:1,d[o+2]/=i.baseColor.b>L?i.baseColor.b:1;const t=f.d.FromInts(d[o],d[o+1],d[o+2]).toGammaSpace(S.getEngine().useExactSrgbConversions);d[o]=255*t.r,d[o+1]=255*t.g,d[o+2]=255*t.b,t.equalsWithEpsilon(l,L)||(V=!0),A[o+1]/=i.roughness>L?i.roughness:1,A[o+2]/=i.metallic>L?i.metallic:1;f.d.FromInts(255,A[o+1],A[o+2]).equalsWithEpsilon(l,L)||(N=!0)}return N&&j.push(this._getImageDataAsync(A,Q,D,t).then((s=>{i.metallicRoughnessTextureData=s}))),V&&j.push(this._getImageDataAsync(d,Q,D,t).then((s=>{i.baseColorTextureData=s}))),await Promise.all(j).then((()=>i))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(s){const Z=this._getPerceivedBrightness(s.diffuseColor),o=this._getPerceivedBrightness(s.specularColor),t=1-this._getMaxComponent(s.specularColor),j=e(Z,o,t),S=s.diffuseColor.scale(t/(1-V.r)/Math.max(1-j)),a=s.specularColor.Go(V.scale(1-j)).scale(1/Math.max(j));let O=f.d.Lerp(S,a,j*j);O=O.clampToRef(0,1,O);return{baseColor:O,metallic:j,roughness:1-s.glossiness}}_getPerceivedBrightness(s){return s?Math.sqrt(.299*s.r*s.r+.587*s.g*s.g+.114*s.b*s.b):0}_getMaxComponent(s){return s?Math.max(s.r,Math.max(s.g,s.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(s,Z,o,t){const j=[],S={baseColor:s._albedoColor,metallic:s._metallic,roughness:s._roughness};if(t){s._albedoTexture&&j.push(this.exportTextureAsync(s._albedoTexture,Z).then((s=>{s&&(o.baseColorTexture=s)})));const t=s._metallicTexture;t&&j.push(this.exportTextureAsync(t,Z).then((s=>{s&&(o.metallicRoughnessTexture=s)})))}return j.length>0&&(this._exporter._materialNeedsUVsSet.add(s),await Promise.all(j)),S}_getTextureSampler(s){const Z={};if(!s||!(s instanceof H.c))return Z;const o=this._getGLTFTextureWrapMode(s.wrapU);10497!==o&&(Z.wrapS=o);const t=this._getGLTFTextureWrapMode(s.wrapV);switch(10497!==t&&(Z.wrapT=t),s.samplingMode){case H.c.LINEAR_LINEAR:Z.magFilter=9729,Z.minFilter=9729;break;case H.c.LINEAR_NEAREST:Z.magFilter=9729,Z.minFilter=9728;break;case H.c.NEAREST_LINEAR:Z.magFilter=9728,Z.minFilter=9729;break;case H.c.NEAREST_LINEAR_MIPLINEAR:Z.magFilter=9728,Z.minFilter=9987;break;case H.c.NEAREST_NEAREST:Z.magFilter=9728,Z.minFilter=9728;break;case H.c.NEAREST_LINEAR_MIPNEAREST:Z.magFilter=9728,Z.minFilter=9985;break;case H.c.LINEAR_NEAREST_MIPNEAREST:Z.magFilter=9729,Z.minFilter=9984;break;case H.c.LINEAR_NEAREST_MIPLINEAR:Z.magFilter=9729,Z.minFilter=9986;break;case H.c.NEAREST_NEAREST_MIPLINEAR:Z.magFilter=9728,Z.minFilter=9986;break;case H.c.LINEAR_LINEAR_MIPLINEAR:Z.magFilter=9729,Z.minFilter=9987;break;case H.c.LINEAR_LINEAR_MIPNEAREST:Z.magFilter=9729,Z.minFilter=9985;break;case H.c.NEAREST_NEAREST_MIPNEAREST:Z.magFilter=9728,Z.minFilter=9984}return Z}_getGLTFTextureWrapMode(s){switch(s){case H.c.WRAP_ADDRESSMODE:return 10497;case H.c.CLAMP_ADDRESSMODE:return 33071;case H.c.MIRROR_ADDRESSMODE:return 33648;default:return j.g.Error(`Unsupported Texture Wrap Mode ${s}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(s,Z,o,t){const j={diffuseColor:s._albedoColor,specularColor:s._reflectivityColor,glossiness:s._microSurface},S=s._albedoTexture,a=s._reflectivityTexture,O=s._useMicroSurfaceFromReflectivityMapAlpha;if(a&&!O)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((S||a)&&t){this._exporter._materialNeedsUVsSet.add(s);const t=this._exportTextureSampler(S||a),O=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(S,a,j,Z),v=this._exporter._textures;if(O.baseColorTextureData){const s=this._exportImage(`baseColor${v.length}`,Z,O.baseColorTextureData);o.baseColorTexture=this._exportTextureInfo(s,t,null===S||void 0===S?void 0:S.coordinatesIndex)}if(O.metallicRoughnessTextureData){const s=this._exportImage(`metallicRoughness${v.length}`,Z,O.metallicRoughnessTextureData);o.metallicRoughnessTexture=this._exportTextureInfo(s,t,null===a||void 0===a?void 0:a.coordinatesIndex)}return O}return this._convertSpecularGlossinessToMetallicRoughness(j)}async exportPBRMaterialAsync(s,Z,o){const t={},j={name:s.name},S=s.isMetallicWorkflow();if(S){const Z=s._albedoColor,o=s.alpha;Z&&(t.baseColorFactor=[Z.r,Z.g,Z.b,o])}const a=S?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(s,Z,t,o):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(s,Z,t,o);await this._setMetallicRoughnessPbrMaterialAsync(a,s,j,t,Z,o),await this._finishMaterialAsync(j,s,Z);const O=this._exporter._materials;return O.push(j),O.length-1}async _setMetallicRoughnessPbrMaterialAsync(s,Z,o,t,S,a){if(w(o,Z),s.baseColor.equalsWithEpsilon(l,L)&&U.WithinEpsilon(Z.alpha,1,L)||(t.baseColorFactor=[s.baseColor.r,s.baseColor.g,s.baseColor.b,Z.alpha]),null!=s.metallic&&1!==s.metallic&&(t.metallicFactor=s.metallic),null!=s.roughness&&1!==s.roughness&&(t.roughnessFactor=s.roughness),null==Z.Ta||Z.Ta||(Z._twoSidedLighting||j.g.Warn(Z.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),o.doubleSided=!0),a){const s=[],t=Z._bumpTexture;t&&s.push(this.exportTextureAsync(t,S).then((s=>{s&&(o.normalTexture=s,1!==t.level&&(o.normalTexture.scale=t.level))})));const j=Z._ambientTexture;j&&s.push(this.exportTextureAsync(j,S).then((s=>{if(s){const t={index:s.index,texCoord:s.texCoord,extensions:s.extensions};o.occlusionTexture=t;const j=Z._ambientTextureStrength;j&&(t.strength=j)}})));const a=Z._emissiveTexture;a&&s.push(this.exportTextureAsync(a,S).then((s=>{s&&(o.emissiveTexture=s)}))),s.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(s))}const O=Z._emissiveColor;O.equalsWithEpsilon(R,L)||(o.emissiveFactor=O.ma()),o.pbrMetallicRoughness=t}_getPixelsFromTextureAsync(s){return function(s){switch(s){case i.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case i.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case i.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case i.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case i.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case i.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case i.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case i.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case i.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case i.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case i.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case i.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case i.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case i.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case i.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case i.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case i.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case i.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case i.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case i.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case i.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(s.textureFormat)?(0,u.g)(s,s._texture.width,s._texture.height):(s.textureType,i.b.TEXTURETYPE_UNSIGNED_BYTE,s.readPixels())}async exportTextureAsync(s,Z){const o=this._exporter._extensionsPreExportTextureAsync("exporter",s,Z);return o?await o.then((async o=>o?await this._exportTextureInfoAsync(o,Z):await this._exportTextureInfoAsync(s,Z))):await this._exportTextureInfoAsync(s,Z)}async _exportTextureInfoAsync(s,Z){let o=this._textureMap.get(s);if(!o){const t=await this._getPixelsFromTextureAsync(s);if(!t)return null;const S=this._exportTextureSampler(s),a=s.mimeType;if(a)switch(a){case"image/jpeg":case"image/png":case"image/webp":Z=a;break;default:j.g.Warn(`Unsupported media type: ${a}. Exporting texture as PNG.`)}const O=this._internalTextureToImage,v=s.getInternalTexture().uniqueId;O[v]||(O[v]={});let G=O[v][Z];if(void 0===G){const o=s.getSize();G=(async()=>{const j=await this._getImageDataAsync(t,o.width,o.height,Z);return this._exportImage(s.name,Z,j)})(),O[v][Z]=G}o=this._exportTextureInfo(await G,S,s.coordinatesIndex),this._textureMap.set(s,o),this._exporter._extensionsPostExportTextures("exporter",o,s)}return o}_exportImage(s,Z,o){const t=this._exporter._images;let S;if(this._exporter._shouldUseGlb){S={name:s,mimeType:Z,bufferView:void 0};const t=this._exporter._bufferManager.createBufferView(new Uint8Array(o));this._exporter._bufferManager.setBufferView(S,t)}else{const a=s.replace(/\.\/|\/|\.\\|\\/g,"_"),O=function(s){switch(s){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(Z);let v=a+O;t.some((s=>s.uri===v))&&(v=`${a}_${j.g.RandomId()}${O}`),S={name:s,uri:v},this._exporter._imageData[v]={data:o,mimeType:Z}}return t.push(S),t.length-1}_exportTextureInfo(s,Z,o){const t=this._exporter._textures;let j=t.findIndex((o=>o.sampler==Z&&o.source===s));-1===j&&(j=t.length,t.push({source:s,sampler:Z}));const S={index:j};return o&&(S.texCoord=o),S}_exportTextureSampler(s){const Z=this._getTextureSampler(s),o=this._exporter._samplers,t=o.findIndex((s=>s.minFilter===Z.minFilter&&s.magFilter===Z.magFilter&&s.wrapS===Z.wrapS&&s.wrapT===Z.wrapT));return-1!==t?t:(o.push(Z),o.length-1)}}var h=o(11122),M=o(10955),x=o(11468),k=o(10904);const y=t.n.Zero(),I=t.e.Identity(),C=t.n.One(),K=new t.n(-1,1,1);function p(s,Z){const{byteOffset:o,byteStride:t,type:j,normalized:S}=s,a=s.getSize(),O=Z.reduce(((s,Z)=>Z.getTotalVertices()>s?Z.getTotalVertices():s),-Number.MAX_VALUE);return{byteOffset:o,byteStride:t,componentCount:a,type:j,count:O*a,normalized:S,totalVertices:O,kind:s.getKind()}}function E(s){switch(s){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function P(s){switch(s){case B.e.PositionKind:case B.e.NormalKind:case B.e.TangentKind:case B.e.ColorKind:case B.e.MatricesIndicesKind:case B.e.MatricesIndicesExtraKind:case B.e.MatricesWeightsKind:case B.e.MatricesWeightsExtraKind:case B.e.UVKind:case B.e.UV2Kind:case B.e.UV3Kind:case B.e.UV4Kind:case B.e.UV5Kind:case B.e.UV6Kind:return!0}return!1}function r(s){switch(s){case S.c.TriangleFillMode:return 4;case S.c.TriangleStripDrawMode:return 5;case S.c.TriangleFanDrawMode:return 6;case S.c.PointListDrawMode:case S.c.PointFillMode:return 0;case S.c.LineLoopDrawMode:return 2;case S.c.LineListDrawMode:return 1;case S.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${s}`)}function T(s){const Z=Math.sqrt(s.x*s.x+s.y*s.y+s.z*s.z);Z>0&&(s.x/=Z,s.y/=Z,s.z/=Z)}function m(s){return s.x*=-1,s}function n(s){if(s.x*s.x+s.y*s.y>.5){const Z=Math.abs(s.x),o=Math.abs(s.y);if(Z>o){const o=Math.sign(s.x);s.x=Z,s.y*=-o,s.z*=-o,s.w*=o}else{const Z=Math.sign(s.y);s.x*=-Z,s.y=o,s.z*=Z,s.w*=-Z}}else{const Z=Math.abs(s.z),o=Math.abs(s.w);if(Z>o){const o=Math.sign(s.z);s.x*=-o,s.y*=o,s.z=Z,s.w*=-o}else{const Z=Math.sign(s.w);s.x*=Z,s.y*=-Z,s.z*=-Z,s.w=o}}return s}function J(s){s.Ja(-s.z,s.w,s.x,-s.y)}function ss(s,Z){const o=t.n.FromArrayToRef(Z.translation||[0,0,0],0,t.g.sO[0]),j=t.e.FromArrayToRef(Z.rotation||[0,0,0,1],0,t.g.Quaternion[0]),S=t.b.ComposeToRef(C,j,o,t.g.Matrix[0]),a=t.n.FromArrayToRef(s.translation||[0,0,0],0,t.g.sO[2]),O=t.e.FromArrayToRef(s.rotation||[0,0,0,1],0,t.g.Quaternion[1]),v=t.b.ComposeToRef(C,O,a,t.g.Matrix[1]);S.multiplyToRef(v,v),v.decompose(void 0,j,o),o.equalsWithEpsilon(y,k.b)?delete Z.translation:Z.translation=o.ma(),j.equalsWithEpsilon(I,k.b)?delete Z.rotation:Z.rotation=j.ma(),Z.scale&&delete Z.scale}function Zs(s,Z){if(!(Z instanceof Q.c))return!1;if(!(1===Z.getChildren().length&&0===s.getChildren().length&&s.parent===Z))return!1;const o=s.Ls(),t=s instanceof x.b&&!o.useRightHandedSystem?K:C;return!!Z.ZO.equalsWithEpsilon(t,k.b)||(M.b.Warn(`Cannot collapse node ${s.name} into parent node ${Z.name} with modified scaling.`),!1)}function os(s){if(s instanceof Array){const Z=new Float32Array(s);return new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength)}return ArrayBuffer.isView(s)?new Uint8Array(s.buffer,s.byteOffset,s.byteLength):new Uint8Array(s)}function ts(s,Z){for(const[o,t]of Object.entries(s)){const j=Z[o];(Array.isArray(t)&&Array.isArray(j)&&js(t,j)||t===j)&&delete s[o]}return s}function js(s,Z){return s.length===Z.length&&s.every(((s,o)=>s===Z[o]))}const Ss=t.b.Compose(new t.n(-1,1,1),t.e.Identity(),t.n.Zero());function as(s,Z){if(!(s instanceof Q.c))return!1;if(Z){if(!s.getWorldMatrix().equalsWithEpsilon(t.b.IdentityReadOnly,k.b))return!1}else{if(!s.getWorldMatrix().multiplyToRef(Ss,t.g.Matrix[0]).equalsWithEpsilon(t.b.IdentityReadOnly,k.b))return!1}return!(s instanceof D.b&&s.Pa)}const Os=new Map([[Int8Array,(s,Z,o)=>s.setInt8(Z,o)],[Uint8Array,(s,Z,o)=>s.setUint8(Z,o)],[Uint8ClampedArray,(s,Z,o)=>s.setUint8(Z,o)],[Int16Array,(s,Z,o)=>s.setInt16(Z,o,!0)],[Uint16Array,(s,Z,o)=>s.setUint16(Z,o,!0)],[Int32Array,(s,Z,o)=>s.setInt32(Z,o,!0)],[Uint32Array,(s,Z,o)=>s.setUint32(Z,o,!0)],[Float32Array,(s,Z,o)=>s.setFloat32(Z,o,!0)],[Float64Array,(s,Z,o)=>s.setFloat64(Z,o,!0)]]);class vs{writeTypedArray(s){this._checkGrowBuffer(s.byteLength);const Z=Os.get(s.constructor);for(let o=0;o<s.length;o++)Z(this._dataView,this._byteOffset,s[o]),this._byteOffset+=s.BYTES_PER_ELEMENT}constructor(s){this._data=new Uint8Array(s),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(s){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,s),this._byteOffset++}writeInt8(s){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,s),this._byteOffset++}writeInt16(s){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,s,!0),this._byteOffset+=2}writeUInt16(s){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,s,!0),this._byteOffset+=2}writeInt32(s){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,s,!0),this._byteOffset+=4}writeUInt32(s){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,s,!0),this._byteOffset+=4}writeFloat32(s){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,s,!0),this._byteOffset+=4}writeFloat64(s){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,s,!0),this._byteOffset+=8}_checkGrowBuffer(s){const Z=this.byteOffset+s;if(Z>this._data.byteLength){const s=new Uint8Array(2*Z);s.set(this._data),this._data=s,this._dataView=new DataView(this._data.buffer)}}}function Gs(s){return s%4===0?4:s%2===0?2:1}class Bs{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(s){let Z=0;this._bufferViewToData.forEach((s=>{Z+=s.byteLength}));const o=new vs(Z),t=Array.from(this._bufferViewToData.keys()).sort(((s,Z)=>Gs(Z.byteLength)-Gs(s.byteLength)));for(const j of t){j.byteOffset=o.byteOffset,s.push(j);const Z=s.length-1,t=this.getPropertiesWithBufferView(j);for(const s of t)s.bufferView=Z;o.writeTypedArray(this._bufferViewToData.get(j)),this._bufferViewToData.delete(j)}return o.getOutputData()}createBufferView(s,Z){const o={buffer:0,byteOffset:void 0,byteLength:s.byteLength,byteStride:Z};return this._bufferViewToData.set(o,s),o}createAccessor(s,Z,o,t,j,S,a){this._verifyBufferView(s);const O={bufferView:void 0,componentType:o,count:t,type:Z,min:null===S||void 0===S?void 0:S.min,max:null===S||void 0===S?void 0:S.max,normalized:a,byteOffset:j};return this.setBufferView(O,s),this._accessorToBufferView.set(O,s),O}setBufferView(s,Z){this._verifyBufferView(Z);this.getPropertiesWithBufferView(Z).push(s)}removeBufferView(s){const Z=this.getPropertiesWithBufferView(s);for(const o of Z)void 0!==o.bufferView&&delete o.bufferView;this._bufferViewToData.delete(s),this._bufferViewToProperties.delete(s),this._accessorToBufferView.forEach(((Z,o)=>{Z===s&&(void 0!==o.byteOffset&&delete o.byteOffset,this._accessorToBufferView.delete(o))}))}getBufferView(s){const Z=this._accessorToBufferView.get(s);return this._verifyBufferView(Z),Z}getPropertiesWithBufferView(s){return this._verifyBufferView(s),this._bufferViewToProperties.set(s,this._bufferViewToProperties.get(s)??[]),this._bufferViewToProperties.get(s)}getData(s){return this._verifyBufferView(s),this._bufferViewToData.get(s)}_verifyBufferView(s){if(void 0===s||!this._bufferViewToData.has(s))throw new Error(`BufferView ${s} not found in BufferManager.`)}}var Qs,Ds=o(11246),zs=o(11295),Ys=o(11475),bs=o(11608),fs=o(11611),As=o(11619),ds=o(11240),Us=o(11626);!function(s){s[s.INTANGENT=0]="INTANGENT",s[s.OUTTANGENT=1]="OUTTANGENT"}(Qs||(Qs={}));class us{static _IsTransformable(s){return s&&(s instanceof Q.c||s instanceof Ds.e||s instanceof Us.b)}static _CreateNodeAnimation(s,Z,o,t,S){if(this._IsTransformable(s)){const a=[],O=[],v=Z.getKeys(),G=us._CalculateMinMaxKeyFrames(v),B=us._DeduceInterpolation(v,o,t),Q=B.interpolationType,D=B.shouldBakeAnimation;if(D?us._CreateBakedAnimation(s,Z,o,G.min,G.max,Z.framePerSecond,S,a,O,G,t):"LINEAR"===Q||"STEP"===Q?us._CreateLinearOrStepAnimation(s,Z,o,a,O,t):"CUBICSPLINE"===Q?us._CreateCubicSplineAnimation(s,Z,o,a,O,t):us._CreateBakedAnimation(s,Z,o,G.min,G.max,Z.framePerSecond,S,a,O,G,t),a.length&&O.length){return{inputs:a,outputs:O,samplerInterpolation:Q,inputsMin:D?G.min:j.g.FloatRound(G.min/Z.framePerSecond),inputsMax:D?G.max:j.g.FloatRound(G.max/Z.framePerSecond)}}}return null}static _DeduceAnimationInfo(s){let Z=null,o="VEC3",t=!1;const S=s.targetProperty.split(".");switch(S[0]){case"ZO":Z="scale";break;case"position":Z="translation";break;case"rotation":o="VEC4",Z="rotation";break;case"rotationQuaternion":o="VEC4",t=!0,Z="rotation";break;case"influence":o="SCALAR",Z="weights";break;default:j.g.Error(`Unsupported animatable property ${S[0]}`)}return Z?{animationChannelTargetPath:Z,dataAccessorType:o,useQuaternion:t}:(j.g.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(s,Z,o,t,j,S,a,O,v,G,B){let Q;if(us._IsTransformable(s)&&s.animations)for(const D of s.animations){if(B&&!B(D))continue;const j=us._DeduceAnimationInfo(D);j&&(Q={name:D.name,samplers:[],channels:[]},us._AddAnimation(`${D.name}`,D.hasRunningRuntimeAnimations?Z:Q,s,D,j.dataAccessorType,j.animationChannelTargetPath,t,S,a,O,j.useQuaternion,v,G),Q.samplers.length&&Q.channels.length&&o.push(Q))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(s,Z,o,t,j,S,a,O,v,G,B){let Q;if(s instanceof ds.d){const j=s.morphTargetManager;if(j)for(let D=0;D<j.numTargets;++D){const z=j.getTarget(D);for(const Y of z.animations){if(B&&!B(Y))continue;const z=new fs.e(`${Y.name}`,"influence",Y.framePerSecond,Y.dataType,Y.loopMode,Y.enableBlending),b=[],f=Y.getKeys();for(let s=0;s<f.length;++s){const Z=f[s];for(let s=0;s<j.numTargets;++s)s==D?b.push(Z):b.push({frame:Z.frame,value:0})}z.setKeys(b);const A=us._DeduceAnimationInfo(z);A&&(Q={name:z.name,samplers:[],channels:[]},us._AddAnimation(Y.name,Y.hasRunningRuntimeAnimations?Z:Q,s,z,A.dataAccessorType,A.animationChannelTargetPath,t,S,a,O,A.useQuaternion,v,G,j.numTargets),Q.samplers.length&&Q.channels.length&&o.push(Q))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(s,Z,o,t,j,S,a,O,v){let G;if(s.animationGroups){const Q=s.animationGroups;for(const D of Q){const Q=new Map,z=new Map,Y=new Set,b=D.to-D.from;G={name:D.name,channels:[],samplers:[]};for(let Z=0;Z<D.targetedAnimations.length;++Z){const b=D.targetedAnimations[Z],f=b.target,A=b.animation;if(v&&!v(A))continue;const d=O.has(f);if(this._IsTransformable(f)||1===f.length&&this._IsTransformable(f[0])){const s=us._DeduceAnimationInfo(b.animation);if(s){const Z=this._IsTransformable(f)?f:this._IsTransformable(f[0])?f[0]:null;Z&&us._AddAnimation(`${A.name}`,G,Z,A,s.dataAccessorType,s.animationChannelTargetPath,o,t,j,S,s.useQuaternion,a,d)}}else if(f instanceof As.e||1===f.length&&f[0]instanceof As.e){if(us._DeduceAnimationInfo(b.animation)){const Z=f instanceof As.e?f:f[0];if(Z){const o=s.morphTargetManagers.find((s=>{for(let o=0;o<s.numTargets;++o)if(s.getTarget(o)===Z)return!0;return!1}));if(o){const t=s.meshes.find((s=>s.morphTargetManager===o));var B;if(t)Q.has(t)||Q.set(t,new Map),null===(B=Q.get(t))||void 0===B||B.set(Z,A),Y.add(t),z.set(t,A)}}}}}Y.forEach((s=>{const Z=s.morphTargetManager;let O=null;const v=[],B=z.get(s).getKeys(),Y=B.length;for(let o=0;o<Y;++o)for(let t=0;t<Z.numTargets;++t){const j=Z.getTarget(t),S=Q.get(s);if(S){const Z=S.get(j);Z?(O||(O=new fs.e(`${D.name}_${s.name}_MorphWeightAnimation`,"influence",Z.framePerSecond,fs.e.ANIMATIONTYPE_FLOAT,Z.loopMode,Z.enableBlending)),v.push(Z.getKeys()[o])):v.push({frame:D.from+b/Y*o,value:j.influence,inTangent:B[0].inTangent?0:void 0,outTangent:B[0].outTangent?0:void 0})}}O.setKeys(v);const f=us._DeduceAnimationInfo(O);f&&us._AddAnimation(`${D.name}_${s.name}_MorphWeightAnimation`,G,s,O,f.dataAccessorType,f.animationChannelTargetPath,o,t,j,S,f.useQuaternion,a,!1,null===Z||void 0===Z?void 0:Z.numTargets)})),G.channels.length&&G.samplers.length&&Z.push(G)}}}static _AddAnimation(s,Z,o,j,S,a,O,v,G,B,Q,D,z,Y){const b=us._CreateNodeAnimation(o,j,a,Q,D);let f,A,d,U,u,H;if(b){if(Y){let s=0,Z=0;const o=[];for(;b.inputs.length>0;)Z=b.inputs.shift(),s%Y==0&&o.push(Z),s++;b.inputs=o}const s=O.get(o),j=new Float32Array(b.inputs);f=v.createBufferView(j),A=v.createAccessor(f,"SCALAR",5126,b.inputs.length,void 0,{min:[b.inputsMin],max:[b.inputsMax]}),B.push(A),d=B.length-1;const G=new t.e,Q=new t.n,D=new t.n,F=o instanceof Ds.e,i=E(S),N=new Float32Array(b.outputs.length*i);b.outputs.forEach((function(s,Z){let o=s;switch(a){case"translation":z&&(t.n.FromArrayToRef(s,0,D),m(D),D.toArray(o));break;case"rotation":4===s.length?t.e.FromArrayToRef(s,0,G):(o=new Array(4),t.n.FromArrayToRef(s,0,Q),t.e.FromEulerVectorToRef(Q,G)),z&&(n(G),F&&J(G)),G.toArray(o)}N.set(o,Z*i)})),f=v.createBufferView(N),A=v.createAccessor(f,S,5126,b.outputs.length),B.push(A),U=B.length-1,u={interpolation:b.samplerInterpolation,input:d,output:U},Z.samplers.push(u),H={sampler:Z.samplers.length-1,target:{node:s,path:a}},Z.channels.push(H)}}static _CreateBakedAnimation(s,Z,o,S,a,O,v,G,B,Q,D){let z;const Y=t.e.Identity();let b,f=null,A=null,d=null,U=null,u=null,H=null;Q.min=j.g.FloatRound(S/O);const F=Z.getKeys();for(let t=0,i=F.length;t<i;++t){if(H=null,d=F[t],t+1<i)if(U=F[t+1],d.value.equals&&d.value.equals(U.value)||d.value===U.value){if(0!==t)continue;H=d.frame}else H=U.frame;else{if(u=F[t-1],d.value.equals&&d.value.equals(u.value)||d.value===u.value)continue;H=a}if(H)for(let t=d.frame;t<=H;t+=v){if(b=j.g.FloatRound(t/O),b===f)continue;f=b,A=b;const S={key:0,repeatCount:0,loopMode:Z.loopMode};z=Z._interpolate(t,S),us._SetInterpolatedValue(s,z,b,Z,o,Y,G,B,D)}}A&&(Q.max=A)}static _ConvertFactorToVector3OrQuaternion(s,Z,o,S,a){const O=us._GetBasePositionRotationOrScale(Z,S,a),v=o.targetProperty.split("."),G=v?v[1]:"",B=a?t.e.oO(O).normalize():t.n.oO(O);switch(G){case"x":case"y":case"z":B[G]=s;break;case"w":B.w=s;break;default:j.g.Error(`glTFAnimation: Unsupported component name "${G}"!`)}return B}static _SetInterpolatedValue(s,Z,o,j,S,a,O,v,G){let B;O.push(o),"weights"!==S?(j.dataType===fs.e.ANIMATIONTYPE_FLOAT&&(Z=this._ConvertFactorToVector3OrQuaternion(Z,s,j,S,G)),"rotation"===S?(G?a=Z:(B=Z,t.e.RotationYawPitchRollToRef(B.y,B.x,B.z,a)),v.push(a.ma())):(B=Z,v.push(B.ma()))):v.push([Z])}static _CreateLinearOrStepAnimation(s,Z,o,t,j,S){for(const a of Z.getKeys())t.push(a.frame/Z.framePerSecond),us._AddKeyframeValue(a,Z,j,o,s,S)}static _CreateCubicSplineAnimation(s,Z,o,t,j,S){Z.getKeys().forEach((function(a){t.push(a.frame/Z.framePerSecond),us._AddSplineTangent(Qs.INTANGENT,j,o,"CUBICSPLINE",a,S),us._AddKeyframeValue(a,Z,j,o,s,S),us._AddSplineTangent(Qs.OUTTANGENT,j,o,"CUBICSPLINE",a,S)}))}static _GetBasePositionRotationOrScale(s,Z,o){let j;if("rotation"===Z)if(o){j=(s.rotationQuaternion??t.e.Identity()).ma()}else{j=(s.rotation??t.n.Zero()).ma()}else if("translation"===Z){j=(s.position??t.n.Zero()).ma()}else{j=(s.ZO??t.n.One()).ma()}return j}static _AddKeyframeValue(s,Z,o,S,a,O){let v;const G=Z.dataType;if(G===fs.e.ANIMATIONTYPE_VECTOR3){let Z=s.value.ma();if("rotation"===S){const s=t.n.oO(Z);Z=t.e.RotationYawPitchRoll(s.y,s.x,s.z).ma()}o.push(Z)}else if(G===fs.e.ANIMATIONTYPE_FLOAT){if("weights"===S)o.push([s.value]);else if(v=this._ConvertFactorToVector3OrQuaternion(s.value,a,Z,S,O),v){if("rotation"===S){const s=O?v:t.e.RotationYawPitchRoll(v.y,v.x,v.z).normalize();o.push(s.ma())}o.push(v.ma())}}else G===fs.e.ANIMATIONTYPE_QUATERNION?o.push(s.value.normalize().ma()):j.g.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(s,Z,o){let t,j,S=!1;if("rotation"===Z&&!o)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let a=0,O=s.length;a<O;++a)if(j=s[a],j.inTangent||j.outTangent)if(t){if("CUBICSPLINE"!==t){t="LINEAR",S=!0;break}}else t="CUBICSPLINE";else if(t){if("CUBICSPLINE"===t||j.interpolation&&1===j.interpolation&&"STEP"!==t){t="LINEAR",S=!0;break}}else t=j.interpolation&&1===j.interpolation?"STEP":"LINEAR";return t||(t="LINEAR"),{interpolationType:t,shouldBakeAnimation:S}}static _AddSplineTangent(s,Z,o,j,S,a){let O;const v=s===Qs.INTANGENT?S.inTangent:S.outTangent;if("CUBICSPLINE"===j){if("rotation"===o)if(v)if(a)O=v.ma();else{const s=v;O=t.e.RotationYawPitchRoll(s.y,s.x,s.z).ma()}else O=[0,0,0,0];else O="weights"===o?v?[v]:[0]:v?v.ma():[0,0,0];Z.push(O)}}static _CalculateMinMaxKeyFrames(s){let Z=1/0,o=-1/0;return s.forEach((function(s){Z=Math.min(Z,s.frame),o=Math.max(o,s.frame)})),{min:Z,max:o}}}function Hs(s,Z,o,S,a,O){const v={attributes:{},influence:s.influence,name:s.name},G=Z.Pa;if(!G)return j.g.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),v;const Q=O?-1:1,D=t.n.Zero();let z=0,Y=0;if(s.hasPositions){const S=s.getPositions(),O=G.getVerticesData(B.e.PositionKind);if(O){const s=new Float32Array(O.length),Z=[1/0,1/0,1/0],j=[-1/0,-1/0,-1/0];Y=O.length/3,z=0;for(let o=z;o<Y;++o){const a=t.n.oO(O,3*o);t.n.oO(S,3*o).subtractToRef(a,D),D.x*=Q,Z[0]=Math.min(Z[0],D.x),j[0]=Math.max(j[0],D.x),Z[1]=Math.min(Z[1],D.y),j[1]=Math.max(j[1],D.y),Z[2]=Math.min(Z[2],D.z),j[2]=Math.max(j[2],D.z),s[3*o]=D.x,s[3*o+1]=D.y,s[3*o+2]=D.z}const G=o.createBufferView(s,12),B=o.createAccessor(G,"VEC3",5126,S.length/3,0,{min:Z,max:j});a.push(B),v.attributes.POSITION=a.length-1}else j.g.Warn(`Morph target positions for mesh ${Z.name} were not exported. Mesh does not have position vertex data`)}if(s.hasNormals){const S=s.getNormals(),O=G.getVerticesData(B.e.NormalKind);if(O){const s=new Float32Array(O.length);Y=O.length/3,z=0;for(let o=z;o<Y;++o){const Z=t.n.oO(O,3*o).normalize();t.n.oO(S,3*o).normalize().subtractToRef(Z,D),s[3*o]=D.x*Q,s[3*o+1]=D.y,s[3*o+2]=D.z}const Z=o.createBufferView(s,12),j=o.createAccessor(Z,"VEC3",5126,S.length/3,0);a.push(j),v.attributes.NORMAL=a.length-1}else j.g.Warn(`Morph target normals for mesh ${Z.name} were not exported. Mesh does not have normals vertex data`)}if(s.hasTangents){const S=s.getTangents(),O=G.getVerticesData(B.e.TangentKind);if(O){Y=O.length/4;const s=new Float32Array(3*Y);z=0;for(let o=z;o<Y;++o){const Z=t.n.oO(O,4*o);T(Z);const j=t.n.oO(S,3*o);T(j),j.subtractToRef(Z,D),s[3*o]=D.x*Q,s[3*o+1]=D.y,s[3*o+2]=D.z}const Z=o.createBufferView(s,12),j=o.createAccessor(Z,"VEC3",5126,Y,0);a.push(j),v.attributes.TANGENT=a.length-1}else j.g.Warn(`Morph target tangents for mesh ${Z.name} were not exported. Mesh does not have tangents vertex data`)}if(s.hasColors){const S=s.getColors(),O=G.getVerticesData(B.e.ColorKind),Q=G.getVertexBuffer(B.e.ColorKind);if(O&&Q){const s=Q.getSize();Y=O.length/s;const Z=new Float32Array(Y*s);z=0;for(let o=z;o<Y;++o)if(3===s){const j=t.n.oO(O,o*s);t.n.oO(S,o*s).subtractToRef(j,D),Z[3*o]=D.x,Z[3*o+1]=D.y,Z[3*o+2]=D.z}else if(4===s){const j=new t.p,a=t.p.oO(O,o*s);t.p.oO(S,o*s).subtractToRef(a,j),Z[4*o]=j.x,Z[4*o+1]=j.y,Z[4*o+2]=j.z,Z[4*o+3]=j.w}else j.g.Warn(`Unsupported number of components for color attribute: ${s}`);const G=o.createBufferView(Z,4*s),B=o.createAccessor(G,3===s?"VEC3":"VEC4",5126,Y,0);a.push(B),v.attributes.COLOR_0=a.length-1}else j.g.Warn(`Morph target colors for mesh ${Z.name} were not exported. Mesh does not have colors vertex data`)}return v}var Fs=o(11635),is=o(11556),Ns=o(11548),Ls=o(10916);class Vs{}Vs.DEFAULT_COLOR=f.d.White(),Vs.DEFAULT_WIDTH_ATTENUATED=1,Vs.DEFAULT_WIDTH=.1;var gs=o(11383),ls=o(11649);class Rs{static ConvertPoints(s,Z){if(s.length&&Array.isArray(s)&&"number"===typeof s[0])return[s];if(s.length&&Array.isArray(s[0])&&"number"===typeof s[0][0])return s;if(s.length&&!Array.isArray(s[0])&&s[0]instanceof t.n){const Z=[];for(let o=0;o<s.length;o++){const t=s[o];Z.push(t.x,t.y,t.z)}return[Z]}if(s.length>0&&Array.isArray(s[0])&&s[0].length>0&&s[0][0]instanceof t.n){const Z=[],o=s;for(const s of o)Z.push(s.flatMap((s=>[s.x,s.y,s.z])));return Z}if(s instanceof Float32Array){if(null!==Z&&void 0!==Z&&Z.floatArrayStride){const o=[],t=3*Z.floatArrayStride;for(let Z=0;Z<s.length;Z+=t){const j=new Array(t);for(let o=0;o<t;o++)j[o]=s[Z+o];o.push(j)}return o}return[Array.from(s)]}if(s.length&&s[0]instanceof Float32Array){const Z=[];for(const o of s)Z.push(Array.from(o));return Z}return[]}static OmitZeroLengthPredicate(s,Z,o){const t=[];return Z.Go(s).lengthSquared()>0&&t.push([s,Z]),o.Go(Z).lengthSquared()>0&&t.push([Z,o]),s.Go(o).lengthSquared()>0&&t.push([o,s]),0===t.length?null:t}static OmitDuplicatesPredicate(s,Z,o,t){const j=[];return Rs._SearchInPoints(s,Z,t)||j.push([s,Z]),Rs._SearchInPoints(Z,o,t)||j.push([Z,o]),Rs._SearchInPoints(o,s,t)||j.push([o,s]),0===j.length?null:j}static _SearchInPoints(s,Z,o){for(const a of o)for(let o=0;o<a.length;o++){var t,j,S;if(null!==(t=a[o])&&void 0!==t&&t.equals(s))if(null!==(j=a[o+1])&&void 0!==j&&j.equals(Z)||null!==(S=a[o-1])&&void 0!==S&&S.equals(Z))return!0}return!1}static MeshesToLines(s,Z){const o=[];for(let j=0;j<s.length;j++){const S=s[j],a=S.getVerticesData(B.e.PositionKind),O=S.ra();if(a&&O)for(let s=0,v=0;s<O.length;s++){const G=3*O[v++],B=3*O[v++],Q=3*O[v++],D=new t.n(a[G],a[G+1],a[G+2]),z=new t.n(a[B],a[B+1],a[B+2]),Y=new t.n(a[Q],a[Q+1],a[Q+2]);if(Z){const t=Z(D,z,Y,o,s,G,S,j,a,O);if(t)for(const s of t)o.push(s)}else o.push([D,z],[z,Y],[Y,D])}}return o}static ToVector3Array(s){if(Array.isArray(s[0])){const Z=[],o=s;for(const s of o){const o=[];for(let Z=0;Z<s.length;Z+=3)o.push(new t.n(s[Z],s[Z+1],s[Z+2]));Z.push(o)}return Z}const Z=s,o=[];for(let j=0;j<Z.length;j+=3)o.push(new t.n(Z[j],Z[j+1],Z[j+2]));return o}static ToNumberArray(s){return s.flatMap((s=>[s.x,s.y,s.z]))}static GetPointsCountInfo(s){const Z=new Array(s.length);let o=0;for(let t=s.length;t--;)Z[t]=s[t].length/3,o+=Z[t];return{total:o,counts:Z}}static GetLineLength(s){if(0===s.length)return 0;let Z;Z="number"===typeof s[0]?Rs.ToVector3Array(s):s;const o=t.g.sO[0];let j=0;for(let t=0;t<Z.length-1;t++){const s=Z[t];j+=Z[t+1].subtractToRef(s,o).length()}return j}static GetLineLengthArray(s){const Z=new Float32Array(s.length/3);let o=0;for(let t=0,j=s.length/3-1;t<j;t++){let j=s[3*t+0],S=s[3*t+1],a=s[3*t+2];j-=s[3*t+3],S-=s[3*t+4],a-=s[3*t+5];o+=Math.sqrt(j*j+S*S+a*a),Z[t+1]=o}return Z}static SegmentizeSegmentByCount(s,Z,o){const j=[],S=Z.Go(s),a=t.g.sO[0];a.tO(o);const O=t.g.sO[1];S.divideToRef(a,O);let v=s.clone();j.push(v);for(let t=0;t<o;t++)v=v.clone(),j.push(v.addInPlace(O));return j}static SegmentizeLineBySegmentLength(s,Z){const o=s[0]instanceof t.n?Rs.GetLineSegments(s):"number"===typeof s[0]?Rs.GetLineSegments(Rs.ToVector3Array(s)):s,j=[];for(const t of o)if(t.length>Z){const s=Rs.SegmentizeSegmentByCount(t.point1,t.point2,Math.ceil(t.length/Z));for(const Z of s)j.push(Z)}else j.push(t.point1),j.push(t.point2);return j}static SegmentizeLineBySegmentCount(s,Z){const o="number"===typeof s[0]?Rs.ToVector3Array(s):s,t=Rs.GetLineLength(o)/Z;return Rs.SegmentizeLineBySegmentLength(o,t)}static GetLineSegments(s){const Z=[];for(let o=0;o<s.length-1;o++){const t=s[o],j=s[o+1],S=j.Go(t).length();Z.push({point1:t,point2:j,length:S})}return Z}static GetMinMaxSegmentLength(s){const Z=Rs.GetLineSegments(s).sort((s=>s.length));return{min:Z[0].length,max:Z[Z.length-1].length}}static GetPositionOnLineByVisibility(s,Z,o){let j=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const S=Z*o;let a=0,O=0;const v=s.length;for(let t=0;t<v;t++){if(S<=a+s[t].length){O=t;break}a+=s[t].length}const G=(S-a)/s[O].length;return s[O].point2.subtractToRef(s[O].point1,t.g.sO[0]),t.g.sO[1]=t.g.sO[0].multiplyByFloats(G,G,G),j||t.g.sO[1].addInPlace(s[O].point1),t.g.sO[1].clone()}static GetCircleLinePoints(s,Z){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:s,S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/Z;const a=[];for(let O=0;O<=Z;O++)a.push(new t.n(Math.cos(O*S)*s,Math.sin(O*S)*j,o));return a}static GetBezierLinePoints(s,Z,o,t){return gs.h.CreateQuadraticBezier(s,Z,o,t).getPoints().flatMap((s=>[s.x,s.y,s.z]))}static GetArrowCap(s,Z,o,t,j){let S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[s.clone(),s.add(Z.multiplyByFloats(o,o,o))],widths:[t,j,S,a]}}static GetPointsFromText(s,Z,o,t){let j=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,S=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const a=[],O=(0,ls.c)(s,Z,o,t);for(const v of O){for(const s of v.paths){const Z=[],o=s.getPoints();for(const s of o)Z.push(s.x,s.y,j);a.push(Z)}if(S)for(const s of v.holes){const Z=[],o=s.getPoints();for(const s of o)Z.push(s.x,s.y,j);a.push(Z)}}return a}static Color3toRGBAUint8(s){const Z=new Uint8Array(4*s.length);for(let o=0,t=0;o<s.length;o++)Z[t++]=255*s[o].r,Z[t++]=255*s[o].g,Z[t++]=255*s[o].b,Z[t++]=255;return Z}static CreateColorsTexture(s,Z,o,t){const j=t.getEngine().getCaps().maxTextureSize??1,S=Z.length>j?j:Z.length,a=Math.ceil(Z.length/j);a>1&&(Z=[...Z,...Array(S*a-Z.length).fill(Z[0])]);const O=Rs.Color3toRGBAUint8(Z),v=new F.b(O,S,a,Y.d.TEXTUREFORMAT_RGBA,t,!1,!0,o);return v.name=s,v}static PrepareEmptyColorsTexture(s){if(!Vs.EmptyColorsTexture){const Z=new Uint8Array(4);Vs.EmptyColorsTexture=new F.b(Z,1,1,Y.d.TEXTUREFORMAT_RGBA,s,!1,!1,F.b.NEAREST_NEAREST),Vs.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Vs.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var s;null===(s=Vs.EmptyColorsTexture)||void 0===s||s.dispose(),Vs.EmptyColorsTexture=null}static BooleanToNumber(s){return s?1:0}}class es extends Ns.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class cs extends is.c{isCompatible(s){return!0}constructor(s,Z,o){var j;o=o||{color:Vs.DEFAULT_COLOR};const S=new es;S.GREASED_LINE_HAS_COLOR=!!o.color&&!o.useColors,S.GREASED_LINE_SIZE_ATTENUATION=o.sizeAttenuation??!1,S.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===o.colorDistributionType,S.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(Z??s.Ls()).useRightHandedSystem,S.GREASED_LINE_CAMERA_FACING=o.cameraFacing??!0,super(s,cs.GREASED_LINE_MATERIAL_NAME,200,S,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(j=o)||void 0===j?void 0:j.forceGLSL)||cs.ForceGLSL,this._scene=Z??s.Ls(),this._engine=this._scene.getEngine(),this._cameraFacing=o.cameraFacing??!0,this.visibility=o.visibility??1,this.useDash=o.useDash??!1,this.dashRatio=o.dashRatio??.5,this.dashOffset=o.dashOffset??0,this.width=o.width?o.width:o.sizeAttenuation?Vs.DEFAULT_WIDTH_ATTENUATED:Vs.DEFAULT_WIDTH,this._sizeAttenuation=o.sizeAttenuation??!1,this.colorMode=o.colorMode??0,this._color=o.color??null,this.useColors=o.useColors??!1,this._colorsDistributionType=o.colorDistributionType??0,this.colorsSampling=o.colorsSampling??F.b.NEAREST_NEAREST,this._colors=o.Rs??null,this.dashCount=o.dashCount??1,this.resolution=o.resolution??new t.j(this._engine.getRenderWidth(),this._engine.getRenderHeight()),o.colorsTexture?this.colorsTexture=o.colorsTexture:this._colors?this.colorsTexture=Rs.CreateColorsTexture(`${s.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Vs.DEFAULT_COLOR,Rs.PrepareEmptyColorsTexture(this._scene)),this._engine.jO.add((()=>{Rs.DisposeEmptyColorsTexture()}))}getAttributes(s){s.push("grl_offsets"),s.push("grl_widths"),s.push("grl_colorPointers"),s.push("grl_counters"),this._cameraFacing?(s.push("grl_previousAndSide"),s.push("grl_nextAndCounters")):s.push("grl_slopes")}getSamplers(s){s.push("grl_colors")}getActiveTextures(s){this.colorsTexture&&s.push(this.colorsTexture)}getUniforms(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const Z=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&Z.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===s&&Z.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:Z,vertex:this._cameraFacing&&this._isGLSL(s)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(s)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(s){if(this._cameraFacing){s.SO("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||s.SO("viewProjection",this._scene.getTransformMatrix());const Z=t.g.Vector4[0];Z.x=this._aspect,Z.y=this._resolution.x,Z.z=this._resolution.y,Z.w=this.width,s.updateVector4("grl_aspect_resolution_lineWidth",Z)}const Z=t.g.Vector4[0];Z.x=Rs.BooleanToNumber(this.useDash),Z.y=this._dashArray,Z.z=this.dashOffset,Z.w=this.dashRatio,s.updateVector4("grl_dashOptions",Z);const o=t.g.Vector4[1];o.x=this.colorMode,o.y=this.visibility,o.z=this.colorsTexture?this.colorsTexture.getSize().width:0,o.w=Rs.BooleanToNumber(this.useColors),s.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",o),this._color&&s.updateColor3("grl_singleColor",this._color);const j=this.colorsTexture??Vs.EmptyColorsTexture;s.setTexture("grl_colors",j),s.updateFloat2("grl_textureSize",(null===j||void 0===j?void 0:j.getSize().width)??1,(null===j||void 0===j?void 0:j.getSize().height)??1)}prepareDefines(s,Z,o){s.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,s.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,s.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,s.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=Z.useRightHandedSystem,s.GREASED_LINE_CAMERA_FACING=this._cameraFacing,s.GREASED_LINE_USE_OFFSETS=!!o.offsets}getClassName(){return cs.GREASED_LINE_MATERIAL_NAME}getCustomCode(s){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(Z)?function(s,Z){if("vertex"===s){const s={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return Z&&(s["!gl_Position\\=viewProjection\\*worldPos;"]="//"),s}return"fragment"===s?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(s,this._cameraFacing):function(s,Z){if("vertex"===s){const s={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return Z&&(s["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),s}return"fragment"===s?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(s,this._cameraFacing)}dispose(){var s;null===(s=this.colorsTexture)||void 0===s||s.dispose(),super.dispose()}get Rs(){return this._colors}set Rs(s){this.setColors(s)}setColors(s){var Z;let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const j=(null===(Z=this._colors)||void 0===Z?void 0:Z.length)??0;var S;if(this._colors=s,null!==s&&0!==s.length){if(!o||t)if(this.colorsTexture&&j===s.length&&!t){const Z=Rs.Color3toRGBAUint8(s);this.colorsTexture.update(Z)}else{var a;null===(a=this.colorsTexture)||void 0===a||a.dispose(),this.colorsTexture=Rs.CreateColorsTexture(`${this._material.name}-colors-texture`,s,this.colorsSampling,this._scene)}}else null===(S=this.colorsTexture)||void 0===S||S.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(s){this._dashCount=s,this._dashArray=1/s}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(s){this._sizeAttenuation=s,this.markAllDefinesAsDirty()}get color(){return this._color}set color(s){this.setColor(s)}setColor(s){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==s||null!==this._color&&null===s?(this._color=s,Z||this.markAllDefinesAsDirty()):this._color=s}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(s){this._colorsDistributionType=s,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(s){this._aspect=s.x/s.y,this._resolution=s}serialize(){const s=super.serialize(),Z={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(Z.Rs=this._colors),this._color&&(Z.color=this._color),s.greasedLineMaterialOptions=Z,s}parse(s,Z,o){var t;super.parse(s,Z,o);const j=s.greasedLineMaterialOptions;null===(t=this.colorsTexture)||void 0===t||t.dispose(),j.color&&this.setColor(j.color,!0),j.colorDistributionType&&(this.colorsDistributionType=j.colorDistributionType),j.Rs&&(this.Rs=j.Rs),j.colorsSampling&&(this.colorsSampling=j.colorsSampling),j.colorMode&&(this.colorMode=j.colorMode),j.useColors&&(this.useColors=j.useColors),j.visibility&&(this.visibility=j.visibility),j.useDash&&(this.useDash=j.useDash),j.dashCount&&(this.dashCount=j.dashCount),j.dashRatio&&(this.dashRatio=j.dashRatio),j.dashOffset&&(this.dashOffset=j.dashOffset),j.width&&(this.width=j.width),j.sizeAttenuation&&(this.sizeAttenuation=j.sizeAttenuation),j.resolution&&(this.resolution=j.resolution),this.Rs?this.colorsTexture=Rs.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Rs,this.colorsSampling,Z):Rs.PrepareEmptyColorsTexture(Z),this.markAllDefinesAsDirty()}copyTo(s){var Z;const o=s;null===(Z=o.colorsTexture)||void 0===Z||Z.dispose(),this._colors&&(o.colorsTexture=Rs.CreateColorsTexture(`${o._material.name}-colors-texture`,this._colors,o.colorsSampling,this._scene)),o.setColor(this.color,!0),o.colorsDistributionType=this.colorsDistributionType,o.colorsSampling=this.colorsSampling,o.colorMode=this.colorMode,o.useColors=this.useColors,o.visibility=this.visibility,o.useDash=this.useDash,o.dashCount=this.dashCount,o.dashRatio=this.dashRatio,o.dashOffset=this.dashOffset,o.width=this.width,o.sizeAttenuation=this.sizeAttenuation,o.resolution=this.resolution,o.markAllDefinesAsDirty()}_isGLSL(s){return 0===s||this._forceGLSL}}cs.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",cs.ForceGLSL=!1,(0,Ls.f)(`BABYLON.${cs.GREASED_LINE_MATERIAL_NAME}`,cs);var ws=o(11214),Xs=o(10964),Ws=o(11642),qs=o(11052);class hs extends Ws.e{constructor(s,Z,j){const S=Z.getEngine(),a=S.isWebGPU&&!(j.forceGLSL||hs.ForceGLSL),O=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];Z.useRightHandedSystem&&O.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const v=["position","grl_widths","grl_offsets","grl_colorPointers"];j.cameraFacing?(O.push("GREASED_LINE_CAMERA_FACING"),v.push("grl_previousAndSide","grl_nextAndCounters")):(v.push("grl_slopes"),v.push("grl_counters"));const G=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(a||G.push("world","viewProjection","view","projection"),super(s,Z,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:a?["Scene","Mesh"]:void 0,attributes:v,uniforms:G,samplers:a?[]:["grlColors"],defines:O,extraInitializationsAsync:async()=>{a?await Promise.all([o.e(47).then(o.bind(o,14181)),o.e(55).then(o.bind(o,14190))]):await Promise.all([o.e(50).then(o.bind(o,14197)),o.e(56).then(o.bind(o,14203))])},shaderLanguage:a?1:0}),this._color=f.d.White(),this._colorsDistributionType=0,this._colorsTexture=null,j=j||{color:Vs.DEFAULT_COLOR},this.visibility=j.visibility??1,this.useDash=j.useDash??!1,this.dashRatio=j.dashRatio??.5,this.dashOffset=j.dashOffset??0,this.dashCount=j.dashCount??1,this.width=j.width?j.width:j.sizeAttenuation&&j.cameraFacing?Vs.DEFAULT_WIDTH_ATTENUATED:Vs.DEFAULT_WIDTH,this.sizeAttenuation=j.sizeAttenuation??!1,this.color=j.color??f.d.White(),this.useColors=j.useColors??!1,this.colorsDistributionType=j.colorDistributionType??0,this.colorsSampling=j.colorsSampling??F.b.NEAREST_NEAREST,this.colorMode=j.colorMode??0,this._colors=j.Rs??null,this._cameraFacing=j.cameraFacing??!0,this.resolution=j.resolution??new t.j(S.getRenderWidth(),S.getRenderHeight()),j.colorsTexture?this.colorsTexture=j.colorsTexture:this._colors?this.colorsTexture=Rs.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,Z):(this._color=this._color??Vs.DEFAULT_COLOR,this.colorsTexture=Rs.PrepareEmptyColorsTexture(Z)),a){const s=new qs.e;s.setParameters(),s.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",s)}S.jO.add((()=>{Rs.DisposeEmptyColorsTexture()}))}dispose(){var s;null===(s=this._colorsTexture)||void 0===s||s.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new t.j(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Rs(){return this._colors}set Rs(s){this.setColors(s)}setColors(s){var Z;let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const j=(null===(Z=this._colors)||void 0===Z?void 0:Z.length)??0;var S;if(this._colors=s,null!==s&&0!==s.length){if(!o||t)if(this._colorsTexture&&j===s.length&&!t){const Z=Rs.Color3toRGBAUint8(s);this._colorsTexture.update(Z)}else{var a;null===(a=this._colorsTexture)||void 0===a||a.dispose(),this.colorsTexture=Rs.CreateColorsTexture(`${this.name}-colors-texture`,s,this.colorsSampling,this.Ls())}}else null===(S=this._colorsTexture)||void 0===S||S.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(s){this._colorsTexture=s,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(s){this._width=s,this.setFloat("grlWidth",s)}get useColors(){return this._useColors}set useColors(s){this._useColors=s,this.setFloat("grlUseColors",Rs.BooleanToNumber(s))}get colorsSampling(){return this._colorsSampling}set colorsSampling(s){this._colorsSampling=s}get visibility(){return this._visibility}set visibility(s){this._visibility=s,this.setFloat("grlVisibility",s)}get useDash(){return this._useDash}set useDash(s){this._useDash=s,this.setFloat("grlUseDash",Rs.BooleanToNumber(s))}get dashOffset(){return this._dashOffset}set dashOffset(s){this._dashOffset=s,this.setFloat("grlDashOffset",s)}get dashRatio(){return this._dashRatio}set dashRatio(s){this._dashRatio=s,this.setFloat("grlDashRatio",s)}get dashCount(){return this._dashCount}set dashCount(s){this._dashCount=s,this._dashArray=1/s,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(s){this._sizeAttenuation=s,this.setFloat("grlSizeAttenuation",Rs.BooleanToNumber(s))}get color(){return this._color}set color(s){this.setColor(s)}setColor(s){s=s??Vs.DEFAULT_COLOR,this._color=s,this.setColor3("grlColor",s)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(s){this._colorsDistributionType=s,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(s){this._colorMode=s,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(s){this._resolution=s,this.setVector2("grlResolution",s),this.setFloat("grlAspect",s.x/s.y)}serialize(){const s=super.serialize(),Z={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(Z.Rs=this._colors),s.greasedLineMaterialOptions=Z,s}parse(s,Z,o){var t;const j=s.greasedLineMaterialOptions;null===(t=this._colorsTexture)||void 0===t||t.dispose(),j.color&&(this.color=j.color),j.colorDistributionType&&(this.colorsDistributionType=j.colorDistributionType),j.colorsSampling&&(this.colorsSampling=j.colorsSampling),j.colorMode&&(this.colorMode=j.colorMode),j.useColors&&(this.useColors=j.useColors),j.visibility&&(this.visibility=j.visibility),j.useDash&&(this.useDash=j.useDash),j.dashCount&&(this.dashCount=j.dashCount),j.dashRatio&&(this.dashRatio=j.dashRatio),j.dashOffset&&(this.dashOffset=j.dashOffset),j.width&&(this.width=j.width),j.sizeAttenuation&&(this.sizeAttenuation=j.sizeAttenuation),j.resolution&&(this.resolution=j.resolution),j.Rs?this.colorsTexture=Rs.CreateColorsTexture(`${this.name}-colors-texture`,j.Rs,this.colorsSampling,this.Ls()):this.colorsTexture=Rs.PrepareEmptyColorsTexture(Z),this._cameraFacing=j.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Ms,xs,ks;hs.ForceGLSL=!1,function(s){s[s.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",s[s.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Ms||(Ms={})),function(s){s[s.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",s[s.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",s[s.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(xs||(xs={})),function(s){s[s.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",s[s.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",s[s.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",s[s.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",s[s.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(ks||(ks={}));class ys extends ds.d{constructor(s,Z,o){super(s,Z,null,null,!1,!1),this.name=s,this._options=o,this._lazy=!1,this._updatable=!1,this._engine=Z.getEngine(),this._lazy=o.lazy??!1,this._updatable=o.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=o.colorPointers??[],this._widths=o.widths??new Array(o.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(s){let Z=0;for(const t of this._points)Z+=t.length;const o=Z/3*2-this._widths.length;for(let t=0;t<o;t++)this._widths.push(s)}updateLazy(){var s,Z;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(s=this._options.ribbonOptions)||void 0===s?void 0:s.smoothShading),!this.Xs&&this.refreshBoundingInfo(),null===(Z=this.greasedLineMaterial)||void 0===Z||Z.updateLazy()}addPoints(s,Z){for(const o of s)this._points.push(o);this._lazy||this.setPoints(this._points,Z)}dispose(s){let Z=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(s,Z)}isLazy(){return this._lazy}get es(){return this._uvs}set es(s){this._uvs=s instanceof Float32Array?s:new Float32Array(s),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(s){this.material instanceof hs&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===s||void 0===s?void 0:s.length)>0),this._offsets=s,this._offsetsBuffer?this._offsetsBuffer.update(s):this._createOffsetsBuffer(s)}get widths(){return this._widths}set widths(s){this._widths=s,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(s)}get colorPointers(){return this._colorPointers}set colorPointers(s){this._colorPointers=s,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(s)}get greasedLineMaterial(){var s,Z;if(this.material&&this.material instanceof hs)return this.material;const o=null===(s=this.material)||void 0===s||null===(Z=s.pluginManager)||void 0===Z?void 0:Z.getPlugin(cs.GREASED_LINE_MATERIAL_NAME);return o||void 0}get points(){const s=[];return Xs.c.DeepCopy(this._points,s),s}setPoints(s,Z){this._points=Rs.ConvertPoints(s,(null===Z||void 0===Z?void 0:Z.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==Z&&void 0!==Z&&Z.colorPointers||this._updateColorPointers(),this._setPoints(this._points,Z)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,es:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(s){super.serialize(s),s.type=this.getClassName(),s.lineOptions=this._createLineOptions()}_createVertexBuffers(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Z=new ws.d;return Z.gs=this._vertexPositions,Z.indices=this._indices,Z.es=this._uvs,s&&(Z.ls=[],ws.d.ComputeNormals(this._vertexPositions,this._indices,Z.ls)),Z.ws(this,this._options.updatable),Z}_createOffsetsBuffer(s){const Z=this._scene.getEngine(),o=new B.c(Z,s,this._updatable,3);this.setVerticesBuffer(o.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=o}}class Is{constructor(s,Z){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=s,this.wasAddedByNoopNode=Z}getIndicesAccessor(s,Z,o,t,j){var S,a,O,v;return null===(S=this._indicesAccessorMap.get(s))||void 0===S||null===(a=S.get(Z))||void 0===a||null===(O=a.get(o))||void 0===O||null===(v=O.get(t))||void 0===v?void 0:v.get(j)}setIndicesAccessor(s,Z,o,t,j,S){let a=this._indicesAccessorMap.get(s);a||(a=new Map,this._indicesAccessorMap.set(s,a));let O=a.get(Z);O||(O=new Map,a.set(Z,O));let v=O.get(o);v||(v=new Map,O.set(o,v));let G=v.get(t);G||(G=new Map,v.set(t,G)),G.set(j,S)}pushExportedNode(s){this._exportedNodes.has(s)||this._exportedNodes.add(s)}getNodesSet(){return this._exportedNodes}getVertexBufferView(s){return this._vertexBufferViewMap.get(s)}setVertexBufferView(s,Z){this._vertexBufferViewMap.set(s,Z)}setRemappedBufferView(s,Z,o){this._remappedBufferView.set(s,new Map),this._remappedBufferView.get(s).set(Z,o)}getRemappedBufferView(s,Z){var o;return null===(o=this._remappedBufferView.get(s))||void 0===o?void 0:o.get(Z)}getVertexAccessor(s,Z,o){var t,j;return null===(t=this._vertexAccessorMap.get(s))||void 0===t||null===(j=t.get(Z))||void 0===j?void 0:j.get(o)}setVertexAccessor(s,Z,o,t){let j=this._vertexAccessorMap.get(s);j||(j=new Map,this._vertexAccessorMap.set(s,j));let S=j.get(Z);S||(S=new Map,j.set(Z,S)),S.set(o,t)}hasVertexColorAlpha(s){return this._vertexMapColorAlpha.get(s)||!1}setHasVertexColorAlpha(s,Z){return this._vertexMapColorAlpha.set(s,Z)}getMesh(s){return this._meshMap.get(s)}setMesh(s,Z){this._meshMap.set(s,Z)}bindMorphDataToMesh(s,Z){const o=this._meshMorphTargetMap.get(s)||[];this._meshMorphTargetMap.set(s,o),-1===o.indexOf(Z)&&o.push(Z)}getMorphTargetsFromMesh(s){return this._meshMorphTargetMap.get(s)}}class Cs{_ApplyExtension(s,Z,o,t){if(o>=Z.length)return Promise.resolve(s);const j=t(Z[o],s);return j?j.then((async s=>s?await this._ApplyExtension(s,Z,o+1,t):null)):this._ApplyExtension(s,Z,o+1,t)}_ApplyExtensions(s,Z){const o=[];for(const t of Cs._ExtensionNames)o.push(this._extensions[t]);return this._ApplyExtension(s,o,0,Z)}_extensionsPreExportTextureAsync(s,Z,o){return this._ApplyExtensions(Z,((Z,t)=>Z.preExportTextureAsync&&Z.preExportTextureAsync(s,t,o)))}_extensionsPostExportNodeAsync(s,Z,o,t,j){return this._ApplyExtensions(Z,((Z,S)=>Z.postExportNodeAsync&&Z.postExportNodeAsync(s,S,o,t,j,this._bufferManager)))}_extensionsPostExportMaterialAsync(s,Z,o){return this._ApplyExtensions(Z,((Z,t)=>Z.postExportMaterialAsync&&Z.postExportMaterialAsync(s,t,o)))}_extensionsPostExportMaterialAdditionalTextures(s,Z,o){const t=[];for(const j of Cs._ExtensionNames){const S=this._extensions[j];S.postExportMaterialAdditionalTextures&&t.push(...S.postExportMaterialAdditionalTextures(s,Z,o))}return t}_extensionsPostExportTextures(s,Z,o){for(const t of Cs._ExtensionNames){const j=this._extensions[t];j.postExportTexture&&j.postExportTexture(s,Z,o)}}_extensionsPostExportMeshPrimitive(s){for(const Z of Cs._ExtensionNames){const o=this._extensions[Z];o.postExportMeshPrimitive&&o.postExportMeshPrimitive(s,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const s of Cs._ExtensionNames){const Z=this._extensions[s];Z.preGenerateBinaryAsync&&await Z.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(s){for(const Z of Cs._ExtensionNames){const o=this._extensions[Z];o.enabled&&s(o)}}_extensionsOnExporting(){this._forEachExtensions((s=>{var Z,o,t;s.wasUsed&&((Z=this._glTF).extensionsUsed||(Z.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(s.name)&&this._glTF.extensionsUsed.push(s.name),s.required&&((o=this._glTF).extensionsRequired||(o.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(s.name)&&this._glTF.extensionsRequired.push(s.name)),(t=this._glTF).extensions||(t.extensions={}),s.onExporting&&s.onExporting())}))}_loadExtensions(){for(const s of Cs._ExtensionNames){const Z=Cs._ExtensionFactories[s](this);this._extensions[s]=Z}}constructor(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:b.c.LastCreatedScene,Z=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${Y.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new q(this),this._extensions={},this._bufferManager=new Bs,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!s)throw new Error("No scene available to export");this._babylonScene=s,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:s=>{var Z;return null===s||void 0===s||null===(Z=s.aO)||void 0===Z?void 0:Z.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...Z},this._loadExtensions()}dispose(){for(const s in this._extensions){this._extensions[s].dispose()}}get options(){return this._options}static RegisterExtension(s,Z){Cs.UnregisterExtension(s)&&j.g.Warn(`Extension with the name ${s} already exists`),Cs._ExtensionFactories[s]=Z,Cs._ExtensionNames.push(s)}static UnregisterExtension(s){if(!Cs._ExtensionFactories[s])return!1;delete Cs._ExtensionFactories[s];const Z=Cs._ExtensionNames.indexOf(s);return-1!==Z&&Cs._ExtensionNames.splice(Z,1),!0}_generateJSON(s,Z,o){const t={byteLength:s};return t.byteLength&&(this._glTF.buffers=[t]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.fZ=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(t.uri=Z+".bin"),o?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(s){const Z=await this._generateBinaryAsync();this._extensionsOnExporting();const o=this._generateJSON(Z.byteLength,s,!0),t=new Blob([Z],{type:"application/octet-stream"}),j=s+".gltf",S=s+".bin",a=new G;if(a.files[j]=o,a.files[S]=t,this._imageData)for(const O in this._imageData)a.files[O]=new Blob([this._imageData[O].data],{type:this._imageData[O].mimeType});return a}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(s){const Z=s%4;return 0===Z?Z:4-Z}async generateGLBAsync(s){this._shouldUseGlb=!0;const Z=await this._generateBinaryAsync();this._extensionsOnExporting();const o=this._generateJSON(Z.byteLength),t=s+".glb";let j,S=o.length;if("undefined"!==typeof TextEncoder){j=(new TextEncoder).encode(o),S=j.length}const a=this._getPadding(S),O=this._getPadding(Z.byteLength),v=28+S+a+Z.byteLength+O,B=new vs(v);if(B.writeUInt32(1179937895),B.writeUInt32(2),B.writeUInt32(v),B.writeUInt32(S+a),B.writeUInt32(1313821514),j)B.writeTypedArray(j);else{const s="_".charCodeAt(0);for(let Z=0;Z<S;++Z){const t=o.charCodeAt(Z);t!=o.codePointAt(Z)?B.writeUInt8(s):B.writeUInt8(t)}}for(let G=0;G<a;++G)B.writeUInt8(32);B.writeUInt32(Z.byteLength+O),B.writeUInt32(5130562),B.writeTypedArray(Z);for(let G=0;G<O;++G)B.writeUInt8(0);const Q=new G;return Q.files[t]=new Blob([B.getOutputData()],{type:"application/octet-stream"}),Q}_setNodeTransformation(s,Z,o){if(Z.getPivotPoint().equalsWithEpsilon(y,k.b)||j.g.Warn("Pivot points are not supported in the glTF serializer"),!Z.position.equalsWithEpsilon(y,k.b)){const j=t.g.sO[0].O(Z.position);o&&m(j),s.translation=j.ma()}Z.ZO.equalsWithEpsilon(C,k.b)||(s.scale=Z.ZO.ma());const S=Z.rotationQuaternion||t.e.FromEulerAngles(Z.rotation.x,Z.rotation.y,Z.rotation.z);S.equalsWithEpsilon(I,k.b)||(o&&n(S),s.rotation=S.normalize().ma())}_setCameraTransformation(s,Z,o){if(!Z.position.equalsWithEpsilon(y,k.b)){const j=t.g.sO[0].O(Z.position);o&&m(j),s.translation=j.ma()}const j=Z.rotationQuaternion||t.e.FromEulerAngles(Z.rotation.x,Z.rotation.y,Z.rotation.z);o&&n(j),this._babylonScene.useRightHandedSystem||J(j),j.equalsWithEpsilon(I,k.b)||(s.rotation=j.ma())}_listAvailableCameras(){for(const s of this._babylonScene.cameras){const Z={type:s.mode===Ds.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(s.name&&(Z.name=s.name),"perspective"===Z.type)Z.perspective={aspectRatio:s.getEngine().getAspectRatio(s),yfov:s.fovMode===Ds.e.FOVMODE_VERTICAL_FIXED?s.fov:s.fov*s.getEngine().getAspectRatio(s),znear:s.OO,zfar:s.maxZ};else if("orthographic"===Z.type){const o=s.orthoLeft&&s.orthoRight?.5*(s.orthoRight-s.orthoLeft):.5*s.getEngine().getRenderWidth(),t=s.orthoBottom&&s.orthoTop?.5*(s.orthoTop-s.orthoBottom):.5*s.getEngine().getRenderHeight();Z.orthographic={xmag:o,ymag:t,znear:s.OO,zfar:s.maxZ}}this._camerasMap.set(s,Z)}}_exportAndAssignCameras(){const s=Array.from(this._camerasMap.values());for(const Z of s){const s=this._nodesCameraMap.get(Z);if(void 0!==s){this._cameras.push(Z);for(const Z of s)Z.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const s of this._babylonScene.skeletons){if(s.bones.length<=0)continue;const Z={joints:[]};this._skinMap.set(s,Z)}}_exportAndAssignSkeletons(){for(const s of this._babylonScene.skeletons){if(s.bones.length<=0)continue;const Z=this._skinMap.get(s);if(void 0==Z)continue;const o={},t=[];let S=-1;for(let j=0;j<s.bones.length;++j){const Z=s.bones[j],t=Z.getIndex()??j;-1!==t&&(o[t]=Z,t>S&&(S=t))}for(let s=0;s<=S;++s){const S=o[s];t.push(S.getAbsoluteInverseBindMatrix());const a=S.getTransformNode();if(null!==a){const s=this._nodeMap.get(a);a&&null!==s&&void 0!==s?Z.joints.push(s):j.g.Warn("Exporting a bone without a linked transform node is currently unsupported")}else j.g.Warn("Exporting a bone without a linked transform node is currently unsupported")}const a=this._nodesSkinMap.get(Z);if(Z.joints.length>0&&void 0!==a){const s=64*t.length,o=new Float32Array(s/4);t.forEach(((s,Z)=>{o.set(s.m,16*Z)}));const j=this._bufferManager.createBufferView(o);this._accessors.push(this._bufferManager.createAccessor(j,"MAT4",5126,t.length)),Z.inverseBindMatrices=this._accessors.length-1,this._skins.push(Z);for(const Z of a)Z.skin=this._skins.length-1}}}async _exportSceneAsync(){const s={nodes:[]};if(this._babylonScene.metadata){const Z=this._options.metadataSelector(this._babylonScene.metadata);Z&&(s.extras=Z)}const Z=new Array,o=new Array,t=new Array;for(const O of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&as(O,this._babylonScene.useRightHandedSystem)?t.push(...O.getChildren()):this._babylonScene.useRightHandedSystem?Z.push(O):o.push(O);this._listAvailableCameras(),this._listAvailableSkeletons();const j=new Is(!0,!1);s.nodes.push(...await this._exportNodesAsync(o,j));const S=new Is(!1,!1);s.nodes.push(...await this._exportNodesAsync(Z,S));const a=new Is(!1,!0);s.nodes.push(...await this._exportNodesAsync(t,a)),s.nodes.length&&this._scenes.push(s),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&us._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,j.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(s){let Z=this._shouldExportNodeMap.get(s);return void 0===Z&&(Z=this._options.shouldExportNode(s),this._shouldExportNodeMap.set(s,Z)),Z}async _exportNodesAsync(s,Z){const o=new Array;this._exportBuffers(s,Z);for(const t of s)await this._exportNodeAsync(t,o,Z);return o}_collectBuffers(s,Z,o,t,j){if(this._shouldExportNode(s)&&s instanceof D.b&&s.Pa){const S=s.Pa.getVertexBuffers();if(S)for(const t in S){if(!P(t))continue;const a=S[t];j.setHasVertexColorAlpha(a,s.hasVertexAlpha);const O=a._buffer,v=Z.get(O)||[];Z.set(O,v),-1===v.indexOf(a)&&v.push(a);const G=o.get(a)||[];o.set(a,G),-1===G.indexOf(s)&&G.push(s)}const a=s.morphTargetManager;if(a)for(let Z=0;Z<a.numTargets;Z++){const o=a.getTarget(Z),j=t.get(o)||[];t.set(o,j),-1===j.indexOf(s)&&j.push(s)}}for(const S of s.getChildren())this._collectBuffers(S,Z,o,t,j)}_exportBuffers(s,Z){const o=new Map,t=new Map,j=new Map;for(const O of s)this._collectBuffers(O,o,t,j,Z);const S=Array.from(o.keys());for(const O of S){const s=O.getData();if(!s)throw new Error("Buffer data is not available");const j=o.get(O);if(!j)continue;const S=j[0].byteStride;if(j.some((s=>s.byteStride!==S)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const a=os(s).slice();for(const Z of j){const s=t.get(Z),{byteOffset:o,byteStride:j,componentCount:S,type:O,count:v,normalized:G,kind:Q}=p(Z,s);switch(Q){case B.e.NormalKind:case B.e.TangentKind:(0,h.j)(a,o,j,S,O,v,G,(s=>{const Z=Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);if(Z>0){const o=1/Z;s[0]*=o,s[1]*=o,s[2]*=o}}));break;case B.e.ColorKind:{const Z=s.filter((s=>s.material instanceof bs.e||null==s.material)).length;if(0==Z)break;if(Z!=s.length){M.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}O==B.e.UNSIGNED_BYTE&&M.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const t=new f.d,Q=new f.h,D=this._babylonScene.getEngine().useExactSrgbConversions;(0,h.j)(a,o,j,S,O,v,G,(s=>{3===s.length?(t.Bo(s,0),t.toLinearSpaceToRef(t,D),t.toArray(s,0)):(Q.Bo(s,0),Q.toLinearSpaceToRef(Q,D),Q.toArray(s,0))}))}}}if(Z.convertToRightHanded){for(const s of j){const Z=t.get(s),{byteOffset:o,byteStride:j,componentCount:S,type:O,count:v,normalized:G,kind:Q}=p(s,Z);switch(Q){case B.e.PositionKind:case B.e.NormalKind:case B.e.TangentKind:(0,h.j)(a,o,j,S,O,v,G,(s=>{s[0]=-s[0]}))}}Z.convertedToRightHandedBuffers.set(O,a)}const v=this._bufferManager.createBufferView(a,S);Z.setVertexBufferView(O,v);const G=new Map;for(const Z of j){const s=t.get(Z),{kind:o,totalVertices:j}=p(Z,s);switch(o){case B.e.MatricesIndicesKind:case B.e.MatricesIndicesExtraKind:if(Z.type==B.e.FLOAT){const s=Z.getFloatData(j);null!==s&&G.set(Z,s)}}}0!==G.size&&M.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const Q=Array.from(G.keys());for(const o of Q){const s=G.get(o);if(!s)continue;const t=s.some((s=>s>=256)),j=new(t?Uint16Array:Uint8Array)(s.length);for(let Z=0;Z<s.length;Z++)j[Z]=s[Z];const S=this._bufferManager.createBufferView(j,4*(t?2:1));Z.setRemappedBufferView(O,o,S)}}const a=Array.from(j.keys());for(const O of a){const s=j.get(O);if(!s)continue;const o=Hs(O,s[0],this._bufferManager,this._bufferViews,this._accessors,Z.convertToRightHanded);for(const t of s)Z.bindMorphDataToMesh(t,o)}}async _exportNodeAsync(s,Z,o){let t=this._nodeMap.get(s);if(void 0!==t)return void(Z.includes(t)||Z.push(t));const j=await this._createNodeAsync(s,o);if(j){t=this._nodes.length,this._nodes.push(j),this._nodeMap.set(s,t),o.pushExportedNode(s),Z.push(t);const S={name:"runtime animations",channels:[],samplers:[]},a=[];this._babylonScene.animationGroups.length||(us._CreateMorphTargetAnimationFromMorphTargetAnimations(s,S,a,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,o.convertToRightHanded,this._options.shouldExportAnimation),s.animations.length&&us._CreateNodeAnimationFromNodeAnimations(s,S,a,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,o.convertToRightHanded,this._options.shouldExportAnimation)),S.channels.length&&S.samplers.length&&this._animations.push(S),a.forEach((s=>{s.channels.length&&s.samplers.length&&this._animations.push(s)}))}const S=j?[]:Z;for(const a of s.getChildren())await this._exportNodeAsync(a,S,o);j&&S.length&&(j.children=S)}async _createNodeAsync(s,Z){if(!this._shouldExportNode(s))return null;const o={};if(s.name&&(o.name=s.name),s.metadata){const Z=this._options.metadataSelector(s.metadata);Z&&(o.extras=Z)}if(s instanceof Q.c&&(this._setNodeTransformation(o,s,Z.convertToRightHanded),s instanceof D.b)){const j=s instanceof z.e?s.sourceMesh:s;if(j.vO&&j.vO.length>0&&(o.mesh=await this._exportMeshAsync(j,Z)),s.skeleton){const Z=this._skinMap.get(s.skeleton);var t;if(void 0!==Z)void 0===this._nodesSkinMap.get(Z)&&this._nodesSkinMap.set(Z,[]),null===(t=this._nodesSkinMap.get(Z))||void 0===t||t.push(o)}}if(s instanceof x.b){const t=this._camerasMap.get(s);if(t){var j;void 0===this._nodesCameraMap.get(t)&&this._nodesCameraMap.set(t,[]),this._setCameraTransformation(o,s,Z.convertToRightHanded);const a=s.parent;if(null!==a&&Zs(s,a)){const s=this._nodeMap.get(a);if(void 0!==s){var S;const Z=this._nodes[s];return ss(o,Z),null===(S=this._nodesCameraMap.get(t))||void 0===S||S.push(Z),null}}null===(j=this._nodesCameraMap.get(t))||void 0===j||j.push(o)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",o,s,this._nodeMap,Z.convertToRightHanded)?o:(M.b.Warn(`Not exporting node ${s.name}`),null)}_exportIndices(s,Z,o,t,j,a,O,v,G){let B=s;G.mode=r(a);const Q=O!==S.c.CounterClockWiseSideOrientation,D=!v.wasAddedByNoopNode&&Q,z=function(s){switch(s){case S.c.TriangleFillMode:case S.c.TriangleStripDrawMode:case S.c.TriangleFanDrawMode:return!0}return!1}(a)&&D;if(z){if(a===S.c.TriangleStripDrawMode||a===S.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");G.mode=r(a);const O=Z?new Uint32Array(t):new Uint16Array(t);if(s)for(let Z=0;Z+2<t;Z+=3)O[Z]=s[o+Z]+j,O[Z+1]=s[o+Z+2]+j,O[Z+2]=s[o+Z+1]+j;else for(let s=0;s+2<t;s+=3)O[s]=s,O[s+1]=s+2,O[s+2]=s+1;B=O}else if(s&&0!==j){const S=Z?new Uint32Array(t):new Uint16Array(t);for(let Z=0;Z<t;Z++)S[Z]=s[o+Z]+j;B=S}if(B){let S=v.getIndicesAccessor(s,o,t,j,z);if(void 0===S){const a=function(s,Z,o,t){if(s instanceof Uint16Array||s instanceof Uint32Array)return s;if(s instanceof Int32Array)return new Uint32Array(s.buffer,s.byteOffset,s.length);const j=s.slice(Z,Z+o);return t?new Uint32Array(j):new Uint16Array(j)}(B,0,t,Z),O=this._bufferManager.createBufferView(a),G=Z?5125:5123;this._accessors.push(this._bufferManager.createAccessor(O,"SCALAR",G,t,0)),S=this._accessors.length-1,v.setIndicesAccessor(s,o,t,j,z,S)}G.indices=S}}_exportVertexBuffer(s,Z,o,t,j,S){const a=s.getKind();if(!P(a))return;if(a.startsWith("uv")&&!this._options.exportUnusedUVs&&(!Z||!this._materialNeedsUVsSet.has(Z)))return;let O=j.getVertexAccessor(s,o,t);if(void 0===O){const Z=j.convertedToRightHandedBuffers.get(s._buffer)||s._buffer.getData(),S=a===B.e.PositionKind?function(s,Z,o,t){const{byteOffset:j,byteStride:S,type:a,normalized:O}=Z,v=Z.getSize(),G=new Array(v).fill(1/0),B=new Array(v).fill(-1/0);return(0,h.j)(s,j+o*S,S,v,a,t*v,O,(s=>{for(let Z=0;Z<v;Z++)G[Z]=Math.min(G[Z],s[Z]),B[Z]=Math.max(B[Z],s[Z])})),{min:G,max:B}}(Z,s,o,t):void 0,v=(a===B.e.MatricesIndicesKind||a===B.e.MatricesIndicesExtraKind)&&s.type===B.e.FLOAT,G=v?B.e.UNSIGNED_BYTE:s.type,Q=v?void 0:s.normalized,D=v?j.getRemappedBufferView(s._buffer,s):j.getVertexBufferView(s._buffer),z=s.byteOffset+o*s.byteStride;this._accessors.push(this._bufferManager.createAccessor(D,function(s,Z){if(s==B.e.ColorKind)return Z?"VEC4":"VEC3";switch(s){case B.e.PositionKind:case B.e.NormalKind:return"VEC3";case B.e.TangentKind:case B.e.MatricesIndicesKind:case B.e.MatricesIndicesExtraKind:case B.e.MatricesWeightsKind:case B.e.MatricesWeightsExtraKind:return"VEC4";case B.e.UVKind:case B.e.UV2Kind:case B.e.UV3Kind:case B.e.UV4Kind:case B.e.UV5Kind:case B.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${s}`)}(a,j.hasVertexColorAlpha(s)),G,t,z,S,Q)),O=this._accessors.length-1,j.setVertexAccessor(s,o,t,O)}S.attributes[function(s){switch(s){case B.e.PositionKind:return"POSITION";case B.e.NormalKind:return"NORMAL";case B.e.TangentKind:return"TANGENT";case B.e.ColorKind:return"COLOR_0";case B.e.UVKind:return"TEXCOORD_0";case B.e.UV2Kind:return"TEXCOORD_1";case B.e.UV3Kind:return"TEXCOORD_2";case B.e.UV4Kind:return"TEXCOORD_3";case B.e.UV5Kind:return"TEXCOORD_4";case B.e.UV6Kind:return"TEXCOORD_5";case B.e.MatricesIndicesKind:return"JOINTS_0";case B.e.MatricesIndicesExtraKind:return"JOINTS_1";case B.e.MatricesWeightsKind:return"WEIGHTS_0";case B.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${s}`)}(a)]=O}async _exportMaterialAsync(s,Z,o,t){let j=this._materialMap.get(s);if(void 0===j){const t=Z&&Object.keys(Z).some((s=>s.startsWith("uv")));if((s=s instanceof zs.d?s.GO[o.materialIndex]:s)instanceof Ys.d)j=await this._materialExporter.exportPBRMaterialAsync(s,"image/png",t);else{if(!(s instanceof bs.e))return void M.b.Warn(`Unsupported material '${s.name}' with type ${s.getClassName()}`);j=await this._materialExporter.exportStandardMaterialAsync(s,"image/png",t)}this._materialMap.set(s,j)}t.material=j}async _exportMeshAsync(s,Z){var o;let t=Z.getMesh(s);if(void 0!==t)return t;const j={primitives:[]};t=this._meshes.length,this._meshes.push(j),Z.setMesh(s,t);const a=s.isUnIndexed?null:s.ra(),O=null===(o=s.Pa)||void 0===o?void 0:o.getVertexBuffers(),v=Z.getMorphTargetsFromMesh(s),G=s instanceof Fs.d,B=s instanceof ys,Q=s.vO;if(O&&Q&&Q.length>0)for(const Y of Q){const o={attributes:{}},t=Y.Ms()||this._babylonScene.defaultMaterial;if(B){var D,z;const Z={name:t.name},j=s,S=f.d.White(),a=(null===(D=j.material)||void 0===D?void 0:D.alpha)??1,O=(null===(z=j.greasedLineMaterial)||void 0===z?void 0:z.color)??S;(!O.equalsWithEpsilon(S,k.b)||a<1)&&(Z.pbrMetallicRoughness={baseColorFactor:[...O.ma(),a]}),this._materials.push(Z),o.material=this._materials.length-1}else if(G){const Z={name:t.name},j=s;(!j.color.equalsWithEpsilon(f.d.White(),k.b)||j.alpha<1)&&(Z.pbrMetallicRoughness={baseColorFactor:[...j.color.ma(),j.alpha]}),this._materials.push(Z),o.material=this._materials.length-1}else await this._exportMaterialAsync(t,O,Y,o);const Q=G||B?S.c.LineListDrawMode:s.overrideRenderingFillMode??t.fillMode,b=t._getEffectiveOrientation(s);this._exportIndices(a,a?(0,h.e)(a,Y.indexCount,Y.indexStart,Y.verticesStart):Y.verticesCount>65535,a?Y.indexStart:Y.verticesStart,a?Y.indexCount:Y.verticesCount,-Y.verticesStart,Q,b,Z,o);for(const s of Object.values(O))this._exportVertexBuffer(s,t,Y.verticesStart,Y.verticesCount,Z,o);if(v){o.targets=[];for(const s of v)o.targets.push(s.attributes)}j.primitives.push(o),this._extensionsPostExportMeshPrimitive(o)}if(v){j.weights=[],j.extras||(j.extras={}),j.extras.targetNames=[];for(const s of v)j.weights.push(s.influence),j.extras.targetNames.push(s.name)}return t}}Cs._ExtensionNames=new Array,Cs._ExtensionFactories={};class Ks{static async GLTFAsync(s,Z,o){o&&o.exportWithoutWaitingForScene||await s.whenReadyAsync();const t=new Cs(s,o),j=await t.generateGLTFAsync(Z.replace(/\.[^/.]+$/,""));return t.dispose(),j}static async GLBAsync(s,Z,o){o&&o.exportWithoutWaitingForScene||await s.whenReadyAsync();const t=new Cs(s,o),j=await t.generateGLBAsync(Z.replace(/\.[^/.]+$/,""));return t.dispose(),j}}o(11656);const ps="EXT_mesh_gpu_instancing";class Es{constructor(s){this.name=ps,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(s,Z,o,j,S,a){return await new Promise((s=>{if(Z&&o instanceof ds.d&&o.hasThinInstances&&this._exporter){this._wasUsed=!0;const s=t.n.Zero(),j=t.e.Identity(),O=t.n.One(),v=o.thinInstanceGetWorldMatrices(),G=t.g.sO[2],B=t.g.Quaternion[1],Q=t.g.sO[3];let D=!1,z=!1,Y=!1;const b=new Float32Array(3*o.BO),f=new Float32Array(4*o.BO),A=new Float32Array(3*o.BO);let d=0;for(const Z of v)Z.decompose(Q,B,G),S&&(m(G),n(B)),b.set(G.ma(),3*d),f.set(B.normalize().ma(),4*d),A.set(Q.ma(),3*d),D=D||!G.equalsWithEpsilon(s),z=z||!B.equalsWithEpsilon(j),Y=Y||!Q.equalsWithEpsilon(O),d++;const U={attributes:{}};D&&(U.attributes.TRANSLATION=this._buildAccessor(b,"VEC3",o.BO,a)),z&&(U.attributes.ROTATION=this._buildAccessor(f,"VEC4",o.BO,a)),Y&&(U.attributes.SCALE=this._buildAccessor(A,"VEC3",o.BO,a)),Z.extensions=Z.extensions||{},Z.extensions[ps]=U}s(Z)}))}_buildAccessor(s,Z,o,t){const j=t.createBufferView(s),S=t.createAccessor(j,Z,5126,o);return this._exporter._accessors.push(S),this._exporter._accessors.length-1}}Cs.RegisterExtension(ps,(s=>new Es(s)));var Ps=o(11661),rs=o(11669),Ts=o(11675),ms=o(11683);function ns(s){return s===Ts.e.PositionKind?"POSITION":s===Ts.e.NormalKind?"NORMAL":s===Ts.e.ColorKind?"COLOR":s.startsWith(Ts.e.UVKind)?"TEX_COORD":"GENERIC"}const Js={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class sZ extends Ps.e{static get DefaultAvailable(){return(0,Ps.i)(sZ.DefaultConfiguration)}static get Default(){return sZ._Default??(sZ._Default=new sZ),sZ._Default}static ResetDefault(s){sZ._Default&&(s||sZ._Default.dispose(),sZ._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(s,Z){return{module:await(Z||DracoEncoderModule)({wasmBinary:s})}}_getWorkerContent(){return`${rs.i}(${rs.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:sZ.DefaultConfiguration)}async _encodeAsync(s,Z,o){const t=o?(0,ms.e)(Js,o):Js;if(this._workerPoolPromise){const o=await this._workerPoolPromise;return await new Promise(((j,S)=>{o.push(((o,a)=>{const O=s=>{o.removeEventListener("error",O),o.removeEventListener("message",v),S(s),a()},v=s=>{"encodeMeshDone"===s.data.id&&(o.removeEventListener("error",O),o.removeEventListener("message",v),j(s.data.encodedMeshData),a())};o.addEventListener("error",O),o.addEventListener("message",v);const G=[];for(const Z of s)G.push(Z.data.buffer);Z&&G.push(Z.buffer),o.postMessage({id:"encodeMesh",attributes:s,indices:Z,options:t},G)}))}))}if(this._modulePromise){const o=await this._modulePromise;return(0,rs.i)(o.module,s,Z,t)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(s,Z){if(0==s.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");s instanceof ds.d&&s.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===Z||void 0===Z?void 0:Z.method)&&(M.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),Z.method="MESH_SEQUENTIAL_ENCODING");const o=function(s){let Z=s.ra(void 0,!0);return!Z||Z instanceof Uint32Array||Z instanceof Uint16Array||(Z=((0,h.e)(Z,Z.length)?Uint32Array:Uint16Array).from(Z)),Z}(s),t=function(s,Z){const o=[];for(const t of s.getVerticesDataKinds()){if(null!==Z&&void 0!==Z&&Z.includes(t)){if(t===Ts.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const j=s.getVertexBuffer(t),S=j.getSize(),a=(0,h.u)(j.getData(),S,j.type,j.byteOffset,j.byteStride,j.normalized,s.getTotalVertices(),!0);o.push({kind:t,dracoName:ns(t),size:S,data:a})}return o}(s,null===Z||void 0===Z?void 0:Z.excludedAttributes);return await this._encodeAsync(t,o,Z)}}sZ.DefaultConfiguration={wasmUrl:`${j.g._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${j.g._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${j.g._DefaultCdnUrl}/draco_encoder.js`},sZ._Default=null;const ZZ="KHR_draco_mesh_compression";class oZ{get wasUsed(){return this._wasUsed}constructor(s){this.name=ZZ,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===s.options.meshCompressionMethod&&sZ.DefaultAvailable}dispose(){}postExportMeshPrimitive(s,Z,o){if(!this.enabled)return;if(4!==s.mode&&5!==s.mode)return void M.b.Warn("Cannot compress primitive with mode "+s.mode+".");const t=[],j=[];let S=null;if(void 0!==s.indices){const a=o[s.indices],O=Z.getBufferView(a);S=Z.getData(O).slice(),t.push(O),j.push(a)}const a=[];for(const[B,Q]of Object.entries(s.attributes)){const s=o[Q],S=Z.getBufferView(s),v=E(s.type),G=(0,h.u)(Z.getData(S),v,s.componentType,s.byteOffset||0,S.byteStride||(0,h.o)(s.componentType)*v,s.normalized||!1,s.count,!0);a.push({kind:B,dracoName:(O=B,"POSITION"===O?"POSITION":"NORMAL"===O?"NORMAL":O.startsWith("COLOR")?"COLOR":O.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:E(s.type),data:G}),t.push(S),j.push(s)}var O;const v={method:s.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},G=sZ.Default._encodeAsync(a,S,v).then((o=>{if(!o)return void M.b.Error("Draco encoding failed for primitive.");const S={bufferView:-1,attributes:o.attributeIds},a=Z.createBufferView(o.data);Z.setBufferView(S,a);for(const s of t)this._bufferViewsUsed.add(s);for(const s of j)this._accessorsUsed.add(s);s.extensions||(s.extensions={}),s.extensions[ZZ]=S})).catch((s=>{M.b.Error("Draco encoding failed for primitive: "+s)}));this._encodePromises.push(G),this._wasUsed=!0}async preGenerateBinaryAsync(s){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((Z=>{s.getPropertiesWithBufferView(Z).every((s=>this._accessorsUsed.has(s)))&&s.removeBufferView(Z)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Cs.RegisterExtension(ZZ,(s=>new oZ(s)));var tZ=o(11689);const jZ="KHR_lights_punctual",SZ={name:"",color:[1,1,1],QO:1,range:Number.MAX_VALUE},aZ={innerConeAngle:0,outerConeAngle:Math.PI/4},OZ=t.n.Backward();class vZ{constructor(s){this.name=jZ,this.enabled=!0,this.required=!1,this._exporter=s}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[jZ]=this._lights}async postExportNodeAsync(s,Z,o,j,S){return await new Promise((a=>{if(!(o instanceof Us.b))return void a(Z);const O=o.getTypeID()==Us.b.LIGHTTYPEID_POINTLIGHT?"point":o.getTypeID()==Us.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":o.getTypeID()==Us.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!O||!(o instanceof tZ.d))return M.b.Warn(`${s}: Light ${o.name} is not supported in ${jZ}`),void a(Z);if(o.falloffType!==Us.b.FALLOFF_GLTF&&M.b.Warn(`${s}: Light falloff for ${o.name} does not match the ${jZ} specification!`),!o.position.equalsToFloats(0,0,0)){const s=t.g.sO[0].O(o.position);S&&m(s),Z.translation=s.ma()}if("point"!==O){const s=o.direction.normalizeToRef(t.g.sO[0]);S&&m(s);const j=t.e.FromUnitVectorsToRef(OZ,s,t.g.Quaternion[0]);t.e.IsIdentity(j)||(Z.rotation=j.ma())}const v={type:O,name:o.name,color:o.DO.ma(),QO:o.QO,range:o.range};if(ts(v,SZ),"spot"===O){const s=o;v.spot={innerConeAngle:s.innerAngle/2,outerConeAngle:s.angle/2},ts(v.spot,aZ)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(v);const G={pa:this._lights.lights.length-1},B=o.parent;if(B&&Zs(o,B)){const s=j.get(B);if(s){const o=this._exporter._nodes[s];return ss(Z,o),o.extensions||(o.extensions={}),o.extensions[jZ]=G,void a(null)}}Z.extensions||(Z.extensions={}),Z.extensions[jZ]=G,a(Z)}))}}Cs.RegisterExtension(jZ,(s=>new vZ(s)));var GZ=o(11486);const BZ="KHR_materials_anisotropy";class QZ{constructor(s){this.name=BZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,Z,o){const t=[];return o instanceof GZ.d&&o.anisotropy.isEnabled&&!o.anisotropy.legacy?(o.anisotropy.texture&&t.push(o.anisotropy.texture),t):[]}postExportMaterialAsync(s,Z,o){return new Promise((s=>{if(o instanceof GZ.d){if(!o.anisotropy.isEnabled||o.anisotropy.legacy)return void s(Z);this._wasUsed=!0,Z.extensions=Z.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(o.anisotropy.texture),j={anisotropyStrength:o.anisotropy.QO,anisotropyRotation:o.anisotropy.angle,anisotropyTexture:t??void 0};null!==j.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(o),Z.extensions[BZ]=j}s(Z)}))}}Cs.RegisterExtension(BZ,(s=>new QZ(s)));const DZ="KHR_materials_clearcoat";class zZ{constructor(s){this.name=DZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,Z,o){const t=[];return o instanceof GZ.d&&o.clearCoat.isEnabled?(o.clearCoat.texture&&t.push(o.clearCoat.texture),!o.clearCoat.useRoughnessFromMainTexture&&o.clearCoat.textureRoughness&&t.push(o.clearCoat.textureRoughness),o.clearCoat.bumpTexture&&t.push(o.clearCoat.bumpTexture),t):[]}postExportMaterialAsync(s,Z,o){return new Promise((s=>{if(o instanceof GZ.d){if(!o.clearCoat.isEnabled)return void s(Z);this._wasUsed=!0,Z.extensions=Z.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(o.clearCoat.texture);let S;S=o.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(o.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(o.clearCoat.textureRoughness),o.clearCoat.isTintEnabled&&j.g.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${o.name}`),o.clearCoat.remapF0OnInterfaceChange&&j.g.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${o.name}`);const a=this._exporter._materialExporter.getTextureInfo(o.clearCoat.bumpTexture),O={clearcoatFactor:o.clearCoat.QO,clearcoatTexture:t??void 0,clearcoatRoughnessFactor:o.clearCoat.roughness,clearcoatRoughnessTexture:S??void 0,clearcoatNormalTexture:a??void 0};null===O.clearcoatTexture&&null===O.clearcoatRoughnessTexture&&null===O.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(o),Z.extensions[DZ]=O}s(Z)}))}}Cs.RegisterExtension(DZ,(s=>new zZ(s)));const YZ="KHR_materials_diffuse_transmission";function bZ(s,Z){const o=Z.subSurface;let t=null;return o.translucencyIntensityTexture?t=o.translucencyIntensityTexture:o.thicknessTexture&&o.useMaskFromThicknessTexture&&(t=o.thicknessTexture),t&&!o.useGltfStyleTextures?(M.b.Warn(`${s}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${Z.name}`,1),null):t}class fZ{constructor(s){this.name=YZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,Z,o){const t=[];if(o instanceof Ys.d&&this._isExtensionEnabled(o)){const Z=bZ(s,o);return Z&&t.push(Z),o.subSurface.translucencyColorTexture&&t.push(o.subSurface.translucencyColorTexture),t}return t}_isExtensionEnabled(s){if(s.unlit)return!1;const Z=s.subSurface;return!!Z.isTranslucencyEnabled&&(!s.unlit&&!Z.useAlbedoToTintTranslucency&&Z.useGltfStyleTextures&&1===Z.volumeIndexOfRefraction&&0===Z.minimumThickness&&0===Z.maximumThickness)}postExportMaterialAsync(s,Z,o){return new Promise((t=>{if(o instanceof Ys.d&&this._isExtensionEnabled(o)){this._wasUsed=!0;const t=o.subSurface,j=bZ(s,o),S=0==t.translucencyIntensity?void 0:t.translucencyIntensity,a=this._exporter._materialExporter.getTextureInfo(j)??void 0,O=!t.translucencyColor||t.translucencyColor.equalsFloats(1,1,1)?void 0:t.translucencyColor.ma(),v=this._exporter._materialExporter.getTextureInfo(t.translucencyColorTexture)??void 0,G={diffuseTransmissionFactor:S,diffuseTransmissionTexture:a,diffuseTransmissionColorFactor:O,diffuseTransmissionColorTexture:v};(a||v)&&this._exporter._materialNeedsUVsSet.add(o),Z.extensions=Z.extensions||{},Z.extensions[YZ]=G}t(Z)}))}}Cs.RegisterExtension(YZ,(s=>new fZ(s)));const AZ="KHR_materials_dispersion";class dZ{constructor(){this.name=AZ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(s){if(s.unlit)return!1;const Z=s.subSurface;return!(!Z.isRefractionEnabled&&!Z.isDispersionEnabled)}postExportMaterialAsync(s,Z,o){return new Promise((s=>{if(o instanceof Ys.d&&this._isExtensionEnabled(o)){this._wasUsed=!0;const s={dispersion:o.subSurface.dispersion};Z.extensions=Z.extensions||{},Z.extensions[AZ]=s}s(Z)}))}}Cs.RegisterExtension(AZ,(()=>new dZ));const UZ="KHR_materials_emissive_strength";class uZ{constructor(){this.name=UZ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(s,Z,o){return await new Promise((s=>{if(!(o instanceof Ys.d))return s(Z);const t=o.emissiveColor.ma(),j=Math.max(...t);if(j>1){this._wasUsed=!0,Z.extensions||(Z.extensions={});const s={emissiveStrength:j},t=o.emissiveColor.scale(1/s.emissiveStrength);Z.emissiveFactor=t.ma(),Z.extensions[UZ]=s}return s(Z)}))}}Cs.RegisterExtension(UZ,(s=>new uZ));const HZ="KHR_materials_ior";class FZ{constructor(){this.name=HZ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(s){return!s.unlit&&(void 0!=s.indexOfRefraction&&1.5!=s.indexOfRefraction)}postExportMaterialAsync(s,Z,o){return new Promise((s=>{if(o instanceof Ys.d&&this._isExtensionEnabled(o)){this._wasUsed=!0;const s={ior:o.indexOfRefraction};Z.extensions=Z.extensions||{},Z.extensions[HZ]=s}s(Z)}))}}Cs.RegisterExtension(HZ,(s=>new FZ));const iZ="KHR_materials_iridescence";class NZ{constructor(s){this.name=iZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,Z,o){const t=[];return o instanceof GZ.d&&o.iridescence.isEnabled?(o.iridescence.texture&&t.push(o.iridescence.texture),o.iridescence.thicknessTexture&&o.iridescence.thicknessTexture!==o.iridescence.texture&&t.push(o.iridescence.thicknessTexture),t):[]}postExportMaterialAsync(s,Z,o){return new Promise((s=>{if(o instanceof GZ.d){if(!o.iridescence.isEnabled)return void s(Z);this._wasUsed=!0,Z.extensions=Z.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(o.iridescence.texture),j=this._exporter._materialExporter.getTextureInfo(o.iridescence.thicknessTexture),S={iridescenceFactor:o.iridescence.QO,iridescenceIor:o.iridescence.indexOfRefraction,iridescenceThicknessMinimum:o.iridescence.minimumThickness,iridescenceThicknessMaximum:o.iridescence.maximumThickness,iridescenceTexture:t??void 0,iridescenceThicknessTexture:j??void 0};null===S.iridescenceTexture&&null===S.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(o),Z.extensions[iZ]=S}s(Z)}))}}Cs.RegisterExtension(iZ,(s=>new NZ(s)));const LZ="KHR_materials_sheen";class VZ{constructor(s){this.name=LZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,Z,o){return o instanceof Ys.d&&o.sheen.isEnabled&&o.sheen.texture?[o.sheen.texture]:[]}async postExportMaterialAsync(s,Z,o){return await new Promise((s=>{if(o instanceof Ys.d){if(!o.sheen.isEnabled)return void s(Z);this._wasUsed=!0,null==Z.extensions&&(Z.extensions={});const t={sheenColorFactor:o.sheen.color.ma(),sheenRoughnessFactor:o.sheen.roughness??0};null===t.sheenColorTexture&&null===t.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(o),o.sheen.texture&&(t.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.texture)??void 0),o.sheen.textureRoughness&&!o.sheen.useRoughnessFromMainTexture?t.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.textureRoughness)??void 0:o.sheen.texture&&o.sheen.useRoughnessFromMainTexture&&(t.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.texture)??void 0),Z.extensions[LZ]=t}s(Z)}))}}Cs.RegisterExtension(LZ,(s=>new VZ(s)));const gZ="KHR_materials_specular";class lZ{constructor(s){this.name=gZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,Z,o){const t=[];return o instanceof Ys.d&&this._isExtensionEnabled(o)?(o.metallicReflectanceTexture&&t.push(o.metallicReflectanceTexture),o.reflectanceTexture&&t.push(o.reflectanceTexture),t):t}_isExtensionEnabled(s){return!s.unlit&&(void 0!=s.metallicF0Factor&&1!=s.metallicF0Factor||void 0!=s.metallicReflectanceColor&&!s.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(s))}_hasTexturesExtension(s){return null!=s.metallicReflectanceTexture||null!=s.reflectanceTexture}postExportMaterialAsync(s,Z,o){return new Promise((s=>{if(o instanceof Ys.d&&this._isExtensionEnabled(o)){this._wasUsed=!0,Z.extensions=Z.extensions||{};const s=this._exporter._materialExporter.getTextureInfo(o.metallicReflectanceTexture)??void 0,t=this._exporter._materialExporter.getTextureInfo(o.reflectanceTexture)??void 0,j={specularFactor:1==o.metallicF0Factor?void 0:o.metallicF0Factor,specularTexture:s,specularColorFactor:o.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:o.metallicReflectanceColor.ma(),specularColorTexture:t};this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),Z.extensions[gZ]=j}s(Z)}))}}Cs.RegisterExtension(gZ,(s=>new lZ(s)));const RZ="KHR_materials_transmission";class eZ{constructor(s){this.name=RZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,Z,o){const t=[];return o instanceof Ys.d&&this._isExtensionEnabled(o)?(o.subSurface.thicknessTexture&&t.push(o.subSurface.thicknessTexture),t):t}_isExtensionEnabled(s){if(s.unlit)return!1;const Z=s.subSurface;return Z.isRefractionEnabled&&void 0!=Z.refractionIntensity&&0!=Z.refractionIntensity||this._hasTexturesExtension(s)}_hasTexturesExtension(s){return null!=s.subSurface.refractionIntensityTexture}async postExportMaterialAsync(s,Z,o){if(o instanceof Ys.d&&this._isExtensionEnabled(o)){this._wasUsed=!0;const t=o.subSurface,j={transmissionFactor:0===t.refractionIntensity?void 0:t.refractionIntensity};if(this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),t.refractionIntensityTexture)if(t.useGltfStyleTextures){const s=await this._exporter._materialExporter.exportTextureAsync(t.refractionIntensityTexture,"image/png");s&&(j.transmissionTexture=s)}else M.b.Warn(`${s}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);Z.extensions||(Z.extensions={}),Z.extensions[RZ]=j}return Z}}Cs.RegisterExtension(RZ,(s=>new eZ(s)));const cZ="KHR_materials_unlit";class wZ{constructor(){this.name=cZ,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(s,Z,o){return new Promise((s=>{let t=!1;o instanceof Ys.d?t=o.unlit:o instanceof bs.e&&(t=o.disableLighting),t&&(this._wasUsed=!0,null==Z.extensions&&(Z.extensions={}),Z.extensions[cZ]={}),s(Z)}))}}Cs.RegisterExtension(cZ,(()=>new wZ));const XZ="KHR_materials_volume";class WZ{constructor(s){this.name=XZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,Z,o){const t=[];return o instanceof Ys.d&&this._isExtensionEnabled(o)?(o.subSurface.thicknessTexture&&t.push(o.subSurface.thicknessTexture),t):t}_isExtensionEnabled(s){if(s.unlit)return!1;const Z=s.subSurface;return!(!Z.isRefractionEnabled&&!Z.isTranslucencyEnabled)&&(void 0!=Z.maximumThickness&&0!=Z.maximumThickness||void 0!=Z.tintColorAtDistance&&Z.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=Z.tintColor&&Z.tintColor!=f.d.White()||this._hasTexturesExtension(s))}_hasTexturesExtension(s){return null!=s.subSurface.thicknessTexture}postExportMaterialAsync(s,Z,o){return new Promise((s=>{if(o instanceof Ys.d&&this._isExtensionEnabled(o)){this._wasUsed=!0;const s=o.subSurface,t={thicknessFactor:0==s.maximumThickness?void 0:s.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(s.thicknessTexture)??void 0,attenuationDistance:s.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:s.tintColorAtDistance,attenuationColor:s.tintColor.equalsFloats(1,1,1)?void 0:s.tintColor.ma()};this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),Z.extensions=Z.extensions||{},Z.extensions[XZ]=t}s(Z)}))}}Cs.RegisterExtension(XZ,(s=>new WZ(s)));const qZ="EXT_materials_diffuse_roughness";class hZ{constructor(s){this.name=qZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,Z,o){const t=[];return o instanceof GZ.d&&o._baseDiffuseRoughness?(o._baseDiffuseRoughnessTexture&&t.push(o._baseDiffuseRoughnessTexture),t):[]}postExportMaterialAsync(s,Z,o){return new Promise((s=>{if(o instanceof GZ.d){if(!o._baseDiffuseRoughness)return void s(Z);this._wasUsed=!0,Z.extensions=Z.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(o._baseDiffuseRoughnessTexture),j={diffuseRoughnessFactor:o._baseDiffuseRoughness,diffuseRoughnessTexture:t??void 0};null!==j.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(o),Z.extensions[qZ]=j}s(Z)}))}}Cs.RegisterExtension(qZ,(s=>new hZ(s)));const MZ="KHR_texture_transform";class xZ{constructor(){this.name=MZ,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(s,Z,o){if(o.Ls()||j.g.Warn(`${s}: /*@__KEY__*/"scene" is not defined for Babylon texture ${o.name}!`),(0!==o.uAng||0!==o.vAng)&&(j.g.Warn(`${s}: Texture ${o.name} with rotation in the u or v axis is not supported in glTF.`),0!==o.uRotationCenter||0!==o.vRotationCenter))return;const t={};let S=!1;if(0===o.uOffset&&0===o.vOffset||(t.offset=[o.uOffset,o.vOffset],S=!0),1===o.uScale&&1===o.vScale||(t.scale=[o.uScale,o.vScale],S=!0),0!==o.wAng){if(0!==o.uRotationCenter||0!==o.vRotationCenter){if(o.homogeneousRotationInUVTransform&&o.uScale!==o.vScale)return void j.g.Warn(`${s}: Texture ${o.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${MZ}.`);j.g.Warn(`${s}: Texture ${o.name} with non-origin rotation center will be exported using an adjusted offset with ${MZ}.`),t.offset=function(s){const{uOffset:Z,vOffset:o,uRotationCenter:t,vRotationCenter:j,uScale:S,vScale:a,wAng:O}=s,v=Math.cos(O),G=Math.sin(O),B=t*S,Q=j*a;return[Z+(B*(1-v)+Q*G),o+(Q*(1-v)-B*G)]}(o)}t.rotation=-o.wAng,S=!0}0!==o.coordinatesIndex&&(t.texCoord=o.coordinatesIndex,S=!0),S&&(this._wasUsed=!0,Z.extensions||(Z.extensions={}),Z.extensions[MZ]=t)}}Cs.RegisterExtension(MZ,(()=>new xZ));class kZ{static CreateSTL(s){let Z=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",j=arguments.length>3&&void 0!==arguments[3]&&arguments[3],S=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],O=arguments.length>6&&void 0!==arguments[6]&&arguments[6],v=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const G=function(s,Z,o){const j=[3*s[o],3*s[o+1],3*s[o+2]],S=[new t.n(Z[j[0]],Z[j[0]+2],Z[j[0]+1]),new t.n(Z[j[1]],Z[j[1]+2],Z[j[1]+1]),new t.n(Z[j[2]],Z[j[2]+2],Z[j[2]+1])],a=S[0].Go(S[1]),O=S[2].Go(S[1]);return{v:S,n:t.n.Cross(O,a).normalize()}},Q=function(s,Z,o,t){return Z=D(s,Z,o.x,t),Z=D(s,Z,o.y,t),D(s,Z,o.z,t)},D=function(s,Z,o,t){return s.setFloat32(Z,o,t),Z+4},Y=function(s){if(O){let Z=s;s instanceof z.e&&(Z=s.sourceMesh);const o=Z.getVerticesData(B.e.PositionKind,!0,!0);if(!o)return[];const j=t.n.Zero();let S;for(S=0;S<o.length;S+=3)t.n.TransformCoordinatesFromFloatsToRef(o[S],o[S+1],o[S+2],s.Ea(!0),j).toArray(o,S);return o}return s.getVerticesData(B.e.PositionKind)||[]};O&&(a=!0);let b="",f=0,A=0;if(j){for(let o=0;o<s.length;o++){const Z=s[o].ra();f+=Z?Z.length/3:0}const Z=new ArrayBuffer(84+50*f);b=new DataView(Z),A+=80,b.setUint32(A,f,S),A+=4}else v||(b="solid stlmesh\r\n");for(let t=0;t<s.length;t++){const Z=s[t];!j&&v&&(b+="solid "+Z.name+"\r\n"),!a&&Z instanceof ds.d&&Z.bakeCurrentTransformIntoVertices();const o=Y(Z),O=Z.ra()||[];for(let s=0;s<O.length;s+=3){const Z=G(O,o,s);j?(A=Q(b,A,Z.n,S),A=Q(b,A,Z.v[0],S),A=Q(b,A,Z.v[1],S),A=Q(b,A,Z.v[2],S),A+=2):(b+="\tfacet normal "+Z.n.x+" "+Z.n.y+" "+Z.n.z+"\r\n",b+="\t\touter loop\r\n",b+="\t\t\tvertex "+Z.v[0].x+" "+Z.v[0].y+" "+Z.v[0].z+"\r\n",b+="\t\t\tvertex "+Z.v[1].x+" "+Z.v[1].y+" "+Z.v[1].z+"\r\n",b+="\t\t\tvertex "+Z.v[2].x+" "+Z.v[2].y+" "+Z.v[2].z+"\r\n",b+="\t\tendloop\r\n",b+="\tendfacet\r\n")}!j&&v&&(b+="endsolid "+name+"\r\n")}if(j||v||(b+="endsolid stlmesh"),Z){const s=document.createElement("a"),Z=new Blob([b],{type:"application/octet-stream"});s.href=window.URL.createObjectURL(Z),s.download=o+".stl",s.click()}return b}}function yZ(s,Z){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const t=[];for(let j=0;j<s.length/o;j++){const S=s[j*o],a=s[j*o+1],O=s[j*o+2];t.push(`(${S.toPrecision(Z.precision)}, ${a.toPrecision(Z.precision)}, ${O.toPrecision(Z.precision)})`)}return t.join(", ")}function IZ(s,Z){const o=[];for(let t=0;t<s.length/2;t++){const j=s[2*t],S=s[2*t+1];o.push(`(${j.toPrecision(Z.precision)}, ${(1-S).toPrecision(Z.precision)})`)}return o.join(", ")}function CZ(s,Z){const o=s.getVerticesData(B.e.PositionKind),t=s.getVerticesData(B.e.NormalKind);if(o&&t)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(s){var Z;const o=null!==(Z=s.ra())&&void 0!==Z&&Z.length?s.getTotalIndices():s.getTotalVertices();return Array(o/3).fill(3).join(", ")}(s)}]\n\t\tint[] faceVertexIndices = [${function(s){const Z=s.ra(),o=[];if(null!==Z)for(let t=0;t<Z.length;t++)o.push(Z[t]);else{const Z=s.getTotalVertices();for(let s=0;s<Z;s++)o.push(s)}return o.join(", ")}(s)}]\n\t\tnormal3f[] normals = [${yZ(t,Z)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${yZ(o,Z)}]\n        ${function(s,Z){let o="";for(let j=0;j<4;j++){const t=j>0?j:"",S=s.getVerticesData(B.e.UVKind+(t?t+1:""));S&&(o+=`\n\t\ttexCoord2f[] primvars:st${t} = [${IZ(S,Z)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const t=s.getVerticesData(B.e.ColorKind);return t&&(o+=`\n\tcolor3f[] primvars:displayColor = [${yZ(t,Z,t.length/s.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),o}(s,Z)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function KZ(s,Z){return`\n        def "Geometry"\n        {\n        ${CZ(s,Z)}\n        }\n        `}function pZ(s){let Z='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return Z+=s,fflate.strToU8(Z)}function EZ(s){const Z=s.m;return`( ${PZ(Z,0)}, ${PZ(Z,4)}, ${PZ(Z,8)}, ${PZ(Z,12)} )`}function PZ(s,Z){return`(${s[Z+0]}, ${s[Z+1]}, ${s[Z+2]}, ${s[Z+3]})`}function rZ(s){const Z="Object_"+s.uniqueId,o=function(s){const Z=s.getWorldMatrix().clone(),o=s.Ls().useRightHandedSystem;if(!o){let t=s.parent;for(;t;){if(as(t,o)){Z.multiplyToRef(t.getWorldMatrix().invert(),Z);break}t=t.parent}}return Z.determinant()<0&&j.g.Warn(`Exporting mesh ${s.name} with negative scale. Result may look incorrect in destination engine.`),Z}(s),t=EZ(o);return`def Xform "${Z}" (\n\tprepend references = @./geometries/Geometry_${s.Pa.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${t}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${s.material.uniqueId}>\n}\n\n`}function TZ(s){switch(s){case i.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case i.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case i.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function mZ(s){return`(${s.x}, ${s.y})`}function nZ(s){return`(${s.r}, ${s.g}, ${s.b})`}function JZ(s,Z,o,j,S,a){const O=s.getInternalTexture().uniqueId+"_"+s.invertY;S[O]=s;const v=s.coordinatesIndex>0?"st"+s.coordinatesIndex:"st",G=new t.j(s.uScale,s.vScale),B=new t.j(s.uOffset,s.vOffset),Q=s.wAng,D=Math.sin(Q),z=Math.cos(Q);return B.y=1-B.y-G.y,B.x+=D*G.x,B.y+=(1-z)*G.y,`\n    def Shader "PrimvarReader_${o}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${v}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${o}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${Z.uniqueId}/PrimvarReader_${o}.outputs:result>\n        float inputs:rotation = ${(Q*(180/Math.PI)).toFixed(a.precision)}\n        float2 inputs:scale = ${mZ(G)}\n        float2 inputs:translation = ${mZ(B)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${s.uniqueId}_${o}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${O}.png@\n        float2 inputs:st.connect = </Materials/Material_${Z.uniqueId}/Transform2d_${o}.outputs:result>\n        ${j?"float4 inputs:scale = "+function(s){return`(${s.r}, ${s.g}, ${s.b}, 1.0)`}(j):""}\n        token inputs:sourceColorSpace = "${s.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${TZ(s.wrapU)}"\n        token inputs:wrapT = "${TZ(s.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${Z.needAlphaBlending()?"float outputs:a":""}\n    }`}function so(s,Z,o){const t="\t\t\t",j=[],S=[],{diffuseMap:a,DO:O,alphaCutOff:v,emissiveMap:G,emissive:B,normalMap:Q,roughnessMap:D,roughnessChannel:z,roughness:Y,metalnessMap:b,metalnessChannel:A,metalness:d,aoMap:U,aoMapChannel:u,aoMapIntensity:H,alphaMap:F,ior:i,clearCoatEnabled:N,clearCoat:L,clearCoatMap:V,clearCoatRoughness:g,clearCoatRoughnessMap:l}=function(s){const Z={diffuseMap:null,DO:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return s instanceof bs.e?{...Z,diffuseMap:s.diffuseTexture,DO:s.diffuseColor,alphaCutOff:s.alphaCutOff,emissiveMap:s.emissiveTexture,emissive:s.emissiveColor,roughness:1,alphaMap:s.opacityTexture}:s instanceof GZ.d?{...Z,diffuseMap:s._albedoTexture,DO:s._albedoColor,alphaCutOff:s._alphaCutOff,emissiveMap:s._emissiveTexture,emissive:s._emissiveColor,normalMap:s._bumpTexture,roughnessMap:s._metallicTexture,roughnessChannel:s._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:s._roughness??1,metalnessMap:s._metallicTexture,metalnessChannel:s._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:s._metallic??0,aoMap:s._ambientTexture,aoMapChannel:s._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:s._ambientTextureStrength,alphaMap:s._opacityTexture,ior:s.subSurface.indexOfRefraction,clearCoatEnabled:s.clearCoat.isEnabled,clearCoat:s.clearCoat.QO,clearCoatMap:s.clearCoat.texture,clearCoatRoughness:s.clearCoat.roughness,clearCoatRoughnessMap:s.clearCoat.useRoughnessFromMainTexture?s.clearCoat.texture:s.clearCoat.textureRoughness}:Z}(s);return null!==a?(j.push(`${t}color3f inputs:diffuseColor.connect = </Materials/Material_${s.uniqueId}/Texture_${a.uniqueId}_diffuse.outputs:rgb>`),s.needAlphaBlending()?j.push(`${t}float inputs:opacity.connect = </Materials/Material_${s.uniqueId}/Texture_${a.uniqueId}_diffuse.outputs:a>`):s.needAlphaTesting()&&(j.push(`${t}float inputs:opacity.connect = </Materials/Material_${s.uniqueId}/Texture_${a.uniqueId}_diffuse.outputs:a>`),j.push(`${t}float inputs:opacityThreshold = ${v}`)),S.push(JZ(a,s,"diffuse",O,Z,o))):j.push(`${t}color3f inputs:diffuseColor = ${nZ(O||f.d.White())}`),null!==G?(j.push(`${t}color3f inputs:emissiveColor.connect = </Materials/Material_${s.uniqueId}/Texture_${G.uniqueId}_emissive.outputs:rgb>`),S.push(JZ(G,s,"emissive",B,Z,o))):B&&B.toLuminance()>0&&j.push(`${t}color3f inputs:emissiveColor = ${nZ(B)}`),null!==Q&&(j.push(`${t}normal3f inputs:normal.connect = </Materials/Material_${s.uniqueId}/Texture_${Q.uniqueId}_normal.outputs:rgb>`),S.push(JZ(Q,s,"gt",null,Z,o))),null!==U&&(j.push(`${t}float inputs:occlusion.connect = </Materials/Material_${s.uniqueId}/Texture_${U.uniqueId}_occlusion.outputs:${u}>`),S.push(JZ(U,s,"occlusion",new f.d(H,H,H),Z,o))),null!==D?(j.push(`${t}float inputs:roughness.connect = </Materials/Material_${s.uniqueId}/Texture_${D.uniqueId}_roughness.outputs:${z}>`),S.push(JZ(D,s,"roughness",new f.d(Y,Y,Y),Z,o))):j.push(`${t}float inputs:roughness = ${Y}`),null!==b?(j.push(`${t}float inputs:metallic.connect = </Materials/Material_${s.uniqueId}/Texture_${b.uniqueId}_metallic.outputs:${A}>`),S.push(JZ(b,s,"metallic",new f.d(d,d,d),Z,o))):j.push(`${t}float inputs:metallic = ${d}`),null!==F?(j.push(`${t}float inputs:opacity.connect = </Materials/Material_${s.uniqueId}/Texture_${F.uniqueId}_opacity.outputs:r>`),j.push(`${t}float inputs:opacityThreshold = 0.0001`),S.push(JZ(F,s,"opacity",null,Z,o))):j.push(`${t}float inputs:opacity = ${s.alpha}`),N&&(null!==V?(j.push(`${t}float inputs:clearcoat.connect = </Materials/Material_${s.uniqueId}/Texture_${V.uniqueId}_clearcoat.outputs:r>`),S.push(JZ(V,s,"clearcoat",new f.d(L,L,L),Z,o))):j.push(`${t}float inputs:clearcoat = ${L}`),null!==l?(j.push(`${t}float inputs:clearcoatRoughness.connect = </Materials/Material_${s.uniqueId}/Texture_${l.uniqueId}_clearcoatRoughness.outputs:g>`),S.push(JZ(l,s,"clearcoatRoughness",new f.d(g,g,g),Z,o))):j.push(`${t}float inputs:clearcoatRoughness = ${g}`)),j.push(`${t}float inputs:ior = ${i}`),`\n\tdef Material "Material_${s.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${j.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${s.uniqueId}/PreviewSurface.outputs:surface>\n\n${S.join("\n")}\n\n\t}\n`}async function Zo(s,Z,o){const S={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...Z};"undefined"===typeof fflate&&await j.g.LoadScriptAsync(S.fflateUrl);const a={};a[S.modelFileName]=null;let O='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';O+=function(s){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===s.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${s.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${s.planeAnchoringAlignment}"`:""}\n            `}(S);const v={};for(const t of s.meshes){if(0===t.getTotalVertices())continue;const s=t,Z=s.Pa,G=s.material;if(!G||!Z||o&&!o(s))continue;if(-1!==["zO","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(G.getClassName())){const o="geometries/Geometry_"+Z.uniqueId+".usda";if(!(o in a)){const s=KZ(Z,S);a[o]=pZ(s)}G.uniqueId in v||(v[G.uniqueId]=G),O+=rZ(s)}else j.g.Warn("USDZExportAsync does not support this material type: "+G.getClassName())}s.activeCamera&&S.exportCamera&&(O+=function(s,Z){const o="Camera_"+s.uniqueId,j=EZ(t.b.RotationY(Math.PI).multiply(s.getWorldMatrix()));if(s.mode===i.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${o}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${j}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${s.OO.toPrecision(Z.precision)}, ${s.maxZ.toPrecision(Z.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(s.orthoLeft||1)+Math.abs(s.orthoRight||1))).toPrecision(Z.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(s.orthoTop||1)+Math.abs(s.orthoBottom||1))).toPrecision(Z.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const t=s.getEngine().getAspectRatio(s),S=Z.cameraSensorWidth||35;return`def Camera "${o}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${j}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${s.OO.toPrecision(Z.precision)}, ${s.maxZ.toPrecision(Z.precision)})\n\t\t\tfloat focalLength = ${(S/(2*Math.tan(.5*s.fov))).toPrecision(Z.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(S*t).toPrecision(Z.precision)}\n\t\t\tfloat verticalAperture = ${(S/t).toPrecision(Z.precision)}            \n\t\t}\n\t\n\t`}}(s.activeCamera,S)),O+="\n            }\n        }\n    }";const G={};O+=function(s,Z,o){const t=[];for(const j in s){const S=s[j];t.push(so(S,Z,o))}return`\n    def "Materials"\n{\n${t.join("")}\n}\n\n`}(v,G,S),a[S.modelFileName]=fflate.strToU8(O);for(const t in G){const s=G[t],Z=s.getSize(),o=await s.readPixels();if(!o)throw new Error("Texture data is not available");const j=await N.DumpTools.DumpDataAsync(Z.width,Z.height,o,"image/png",void 0,!1,!0);a[`textures/Texture_${t}.png`]=new Uint8Array(j).slice()}let B=0;for(const t in a){const s=a[t];if(!s)continue;B+=34+t.length;const Z=63&B;if(4!==Z){const o=new Uint8Array(64-Z);a[t]=[s,{extra:{12345:o}}]}B=s.length}return fflate.zipSync(a,{level:0})}}}]);