"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{2426:(R,x,H)=>{H.r(x),H.d(x,{_BasisTextureLoader:()=>L});var k,c=H(485),t=H(2311),A=H(590);function D(){const R=0,x=1,H=2,k=3,c=6,t=8,A=9,D=10,U=14;let J=null;function V(R,x,H,k,c){const t=R.getImageTranscodedSizeInBytes(x,H,k);let A=new Uint8Array(t);if(!R.transcodeImage(A,x,H,k,1,0))return null;if(c){A=function(R,x,H,k){const c=new Uint16Array(4),t=new Uint16Array(H*k),A=H/4,D=k/4;for(let U=0;U<D;U++)for(let k=0;k<A;k++){const D=x+8*(U*A+k);c[0]=R[D]|R[D+1]<<8,c[1]=R[D+2]|R[D+3]<<8,c[2]=(2*(31&c[0])+1*(31&c[1]))/3|(2*(2016&c[0])+1*(2016&c[1]))/3&2016|(2*(63488&c[0])+1*(63488&c[1]))/3&63488,c[3]=(2*(31&c[1])+1*(31&c[0]))/3|(2*(2016&c[1])+1*(2016&c[0]))/3&2016|(2*(63488&c[1])+1*(63488&c[0]))/3&63488;for(let x=0;x<4;x++){const A=R[D+4+x];let J=(4*U+x)*H+4*k;t[J++]=c[3&A],t[J++]=c[A>>2&3],t[J++]=c[A>>4&3],t[J++]=c[A>>6&3]}}return t}(A,0,R.getImageWidth(x,H)+3&-4,R.getImageHeight(x,H)+3&-4)}return A}onmessage=n=>{if("init"===n.data.action){if(n.data.url)try{importScripts(n.data.url)}catch(g){postMessage({action:"error",error:g})}J||(J=BASIS({wasmBinary:n.data.wasmBinary})),null!==J&&J.then((R=>{BASIS=R,R.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===n.data.action){const J=n.data.config,g=n.data.imageData,I=new BASIS.BasisFile(g),i=function(R){const x=R.getHasAlpha(),H=R.getNumImages(),k=[];for(let c=0;c<H;c++){const x={levels:[]},H=R.getNumLevels(c);for(let k=0;k<H;k++){const H={width:R.getImageWidth(c,k),height:R.getImageHeight(c,k)};x.levels.push(H)}k.push(x)}return{Qj:x,images:k}}(I);let q=n.data.ignoreSupportedFormats?null:function(J,V){let n=null;J.supportedCompressionFormats&&(n=J.supportedCompressionFormats.astc?D:J.supportedCompressionFormats.bc7?c:J.supportedCompressionFormats.s3tc?V.Qj?k:H:J.supportedCompressionFormats.pvrtc?V.Qj?A:t:J.supportedCompressionFormats.etc2?x:J.supportedCompressionFormats.etc1?R:U);return n}(n.data.config,i),S=!1;null===q&&(S=!0,q=i.Qj?k:H);let L=!0;I.startTranscoding()||(L=!1);const b=[];for(let R=0;R<i.images.length&&L;R++){const x=i.images[R];if(void 0===J.loadSingleImage||J.loadSingleImage===R){let H=x.levels.length;!1===J.loadMipmapLevels&&(H=1);for(let k=0;k<H;k++){const H=x.levels[k],c=V(I,R,k,q,S);if(!c){L=!1;break}H.transcodedPixels=c,b.push(H.transcodedPixels.buffer)}}}I.close(),I.delete(),S&&(q=-1),L?postMessage({action:"transcode",success:L,id:n.data.id,fileInfo:i,format:q},b):postMessage({action:"transcode",success:L,id:n.data.id})}}}!function(R){R[R.cTFETC1=0]="cTFETC1",R[R.cTFETC2=1]="cTFETC2",R[R.cTFBC1=2]="cTFBC1",R[R.cTFBC3=3]="cTFBC3",R[R.cTFBC4=4]="cTFBC4",R[R.cTFBC5=5]="cTFBC5",R[R.cTFBC7=6]="cTFBC7",R[R.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",R[R.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",R[R.cTFASTC_4x4=10]="cTFASTC_4x4",R[R.cTFATC_RGB=11]="cTFATC_RGB",R[R.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",R[R.cTFRGBA32=13]="cTFRGBA32",R[R.cTFRGB565=14]="cTFRGB565",R[R.cTFBGR565=15]="cTFBGR565",R[R.cTFRGBA4444=16]="cTFRGBA4444",R[R.cTFFXT1_RGB=17]="cTFFXT1_RGB",R[R.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",R[R.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",R[R.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",R[R.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(k||(k={}));const U={JSModuleURL:`${c.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${c.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let J=null,V=null,n=0;const g=async()=>(J||(J=new Promise(((R,x)=>{V?R(V):c.e.LoadFileAsync(c.e.GetBabylonScriptURL(U.WasmModuleURL)).then((H=>{if("function"!==typeof URL)return x("Basis transcoder requires an environment with a URL constructor");const k=URL.createObjectURL(new Blob([`(${D})()`],{type:"application/javascript"}));V=new Worker(k),async function(R,x,H){return await new Promise(((k,t)=>{const A=x=>{"init"===x.data.action?(R.removeEventListener("message",A),k(R)):"error"===x.data.action&&t(x.data.error||"error initializing worker")};R.addEventListener("message",A),R.postMessage({action:"init",url:H?c.e.GetBabylonScriptURL(H):void 0,wasmBinary:x},[x])}))}(V,H,U.JSModuleURL).then(R,x)})).catch(x)}))),await J),I=async(R,x)=>{const H=R instanceof ArrayBuffer?new Uint8Array(R):R;return await new Promise(((R,k)=>{g().then((()=>{const c=n++,t=x=>{"transcode"===x.data.action&&x.data.id===c&&(V.removeEventListener("message",t),x.data.success?R(x.data):k("Transcode is not supported on this device"))};V.addEventListener("message",t);const A=new Uint8Array(H.byteLength);A.set(new Uint8Array(H.buffer,H.byteOffset,H.byteLength)),V.postMessage({action:"transcode",id:c,imageData:A,config:x,ignoreSupportedFormats:false},[A.buffer])}),(R=>{k(R)}))}))},i=(R,x)=>{var H;let k=null===(H=x._gl)||void 0===H?void 0:H.TEXTURE_2D;var c;R.isCube&&(k=null===(c=x._gl)||void 0===c?void 0:c.TEXTURE_CUBE_MAP);x._bindTextureDirectly(k,R,!0)},q=(R,x)=>{const H=R.getEngine();for(let D=0;D<x.fileInfo.images.length;D++){const U=x.fileInfo.images[D].levels[0];if(R._invertVScale=R.invertY,-1===x.format||x.format===k.cTFRGB565)if(R.type=10,R.format=4,!H._features.basisNeedsPOT||Math.log2(U.width)%1===0&&Math.log2(U.height)%1===0)R._invertVScale=!R.invertY,R.width=U.width+3&-4,R.height=U.height+3&-4,R.samplingMode=2,i(R,H),H._uploadDataToTextureDirectly(R,new Uint16Array(U.transcodedPixels.buffer),D,0,4,!0);else{const x=new A.b(H,2);R._invertVScale=R.invertY,x.type=10,x.format=4,x.width=U.width+3&-4,x.height=U.height+3&-4,i(x,H),H._uploadDataToTextureDirectly(x,new Uint16Array(U.transcodedPixels.buffer),D,0,4,!0),H._rescaleTexture(x,R,H.scenes[0],H._getInternalFormat(4),(()=>{H._releaseTexture(x),i(R,H)}))}else{R.width=U.width,R.height=U.height,R.generateMipMaps=x.fileInfo.images[D].levels.length>1;const k=S.GetInternalFormatFromBasisFormat(x.format,H);R.format=k,i(R,H);const A=x.fileInfo.images[D].levels;for(let x=0;x<A.length;x++){const c=A[x];H._uploadCompressedDataToTextureDirectly(R,k,c.width,c.height,c.transcodedPixels,D,x)}!H._features.basisNeedsPOT||Math.log2(R.width)%1===0&&Math.log2(R.height)%1===0||(c.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),R._cachedWrapU=t.d.CLAMP_ADDRESSMODE,R._cachedWrapV=t.d.CLAMP_ADDRESSMODE)}}},S={JSModuleURL:U.JSModuleURL,WasmModuleURL:U.WasmModuleURL,GetInternalFormatFromBasisFormat:(R,x)=>{let H;switch(R){case k.cTFETC1:H=36196;break;case k.cTFBC1:H=33776;break;case k.cTFBC4:H=33779;break;case k.cTFASTC_4x4:H=37808;break;case k.cTFETC2:H=37496;break;case k.cTFBC7:H=36492}if(void 0===H)throw"The chosen Basis transcoder format is not currently supported";return H},TranscodeAsync:I,LoadTextureFromTranscodeResult:q};Object.defineProperty(S,"JSModuleURL",{get:function(){return U.JSModuleURL},set:function(R){U.JSModuleURL=R}}),Object.defineProperty(S,"WasmModuleURL",{get:function(){return U.WasmModuleURL},set:function(R){U.WasmModuleURL=R}});class L{constructor(){this.supportCascades=!1}loadCubeData(R,x,H,k,t){if(Array.isArray(R))return;const A=x.getEngine().getCaps(),D={supportedCompressionFormats:{etc1:!!A.etc1,s3tc:!!A.s3tc,pvrtc:!!A.pvrtc,etc2:!!A.etc2,astc:!!A.astc,bc7:!!A.bptc}};I(R,D).then((R=>{const H=R.fileInfo.images[0].levels.length>1&&x.generateMipMaps;q(x,R),x.getEngine()._setCubeMapTextureParams(x,H),x.isReady=!0,x.onLoadedObservable.notifyObservers(x),x.onLoadedObservable.clear(),k&&k()})).catch((R=>{c.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),x.isReady=!0,t&&t(R)}))}loadData(R,x,H){const k=x.getEngine().getCaps(),t={supportedCompressionFormats:{etc1:!!k.etc1,s3tc:!!k.s3tc,pvrtc:!!k.pvrtc,etc2:!!k.etc2,astc:!!k.astc,bc7:!!k.bptc}};I(R,t).then((R=>{const k=R.fileInfo.images[0].levels[0],c=R.fileInfo.images[0].levels.length>1&&x.generateMipMaps;H(k.width,k.height,c,-1!==R.format,(()=>{q(x,R)}))})).catch((R=>{c.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),c.e.Warn(`Failed to transcode Basis file: ${R}`),H(0,0,!1,!1,(()=>{}),!0)}))}}}}]);