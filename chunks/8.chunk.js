"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10920:(F,e,a)=>{a.r(e),a.d(e,{_HDRTextureLoader:()=>y});var k=a(1007);class h{static ConvertPanoramaToCubemap(F,e,a,k){let h=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!F)throw"ConvertPanoramaToCubemap: input cannot be null";if(F.length!=e*a*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(k,this.FACE_FRONT,F,e,a,h),back:this.CreateCubemapTexture(k,this.FACE_BACK,F,e,a,h),left:this.CreateCubemapTexture(k,this.FACE_LEFT,F,e,a,h),right:this.CreateCubemapTexture(k,this.FACE_RIGHT,F,e,a,h),up:this.CreateCubemapTexture(k,this.FACE_UP,F,e,a,h),down:this.CreateCubemapTexture(k,this.FACE_DOWN,F,e,a,h),size:k,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(F,e,a,k,h){let z=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const x=new ArrayBuffer(F*F*4*3),t=new Float32Array(x),H=z?Math.max(1,Math.round(k/4/F)):1,p=1/H,y=p*p,L=e[1].qc(e[0]).scale(p/F),s=e[3].qc(e[2]).scale(p/F),Z=1/F;let A=0;for(let w=0;w<F;w++)for(let z=0;z<H;z++){let z=e[0],x=e[2];for(let e=0;e<F;e++)for(let p=0;p<H;p++){const H=x.qc(z).scale(A).add(z);H.normalize();const p=this.CalcProjectionSpherical(H,a,k,h);t[w*F*3+3*e+0]+=p.r*y,t[w*F*3+3*e+1]+=p.g*y,t[w*F*3+3*e+2]+=p.b*y,z=z.add(L),x=x.add(s)}A+=Z*p}return t}static CalcProjectionSpherical(F,e,a,k){let h=Math.atan2(F.z,F.x);const z=Math.acos(F.y);for(;h<-Math.PI;)h+=2*Math.PI;for(;h>Math.PI;)h-=2*Math.PI;let x=h/Math.PI;const t=z/Math.PI;x=.5*x+.5;let H=Math.round(x*a);H<0?H=0:H>=a&&(H=a-1);let p=Math.round(t*k);p<0?p=0:p>=k&&(p=k-1);const y=k-p-1;return{r:e[y*a*3+3*H+0],g:e[y*a*3+3*H+1],b:e[y*a*3+3*H+2]}}}function z(F,e,a,k,h,z){h>0?(h=function(F,e){return e>1023?F*Math.pow(2,1023)*Math.pow(2,e-1023):e<-1074?F*Math.pow(2,-1074)*Math.pow(2,e+1074):F*Math.pow(2,e)}(1,h-136),F[z+0]=e*h,F[z+1]=a*h,F[z+2]=k*h):(F[z+0]=0,F[z+1]=0,F[z+2]=0)}function x(F,e){let a="",k="";for(let h=e;h<F.length-e&&(k=String.fromCharCode(F[h]),"\n"!=k);h++)a+=k;return a}function t(F){let e=0,a=0,k=x(F,0);if("#"!=k[0]||"?"!=k[1])throw"Bad HDR Format.";let h=!1,z=!1,t=0;do{t+=k.length+1,k=x(F,t),"FORMAT=32-bit_rle_rgbe"==k?z=!0:0==k.length&&(h=!0)}while(!h);if(!z)throw"HDR Bad header format, unsupported FORMAT";t+=k.length+1,k=x(F,t);const H=/^-Y (.*) \+X (.*)$/g.exec(k);if(!H||H.length<3)throw"HDR Bad header format, no size";if(a=parseInt(H[2]),e=parseInt(H[1]),a<8||a>32767)throw"HDR Bad header format, unsupported size";return t+=k.length+1,{height:e,width:a,dataPosition:t}}function H(F,e){return function(F,e){let a=e.height;const k=e.width;let h,x,t,H,y,L=e.dataPosition,s=0,Z=0,A=0;const w=new ArrayBuffer(4*k),I=new Uint8Array(w),b=new ArrayBuffer(e.width*e.height*4*3),u=new Float32Array(b);for(;a>0;){if(h=F[L++],x=F[L++],t=F[L++],H=F[L++],2!=h||2!=x||128&t||e.width<8||e.width>32767)return p(F,e);if((t<<8|H)!=k)throw"HDR Bad header format, wrong scan line width";for(s=0,A=0;A<4;A++)for(Z=(A+1)*k;s<Z;)if(h=F[L++],x=F[L++],h>128){if(y=h-128,0==y||y>Z-s)throw"HDR Bad Format, bad scanline data (run)";for(;y-- >0;)I[s++]=x}else{if(y=h,0==y||y>Z-s)throw"HDR Bad Format, bad scanline data (non-run)";if(I[s++]=x,--y>0)for(let e=0;e<y;e++)I[s++]=F[L++]}for(A=0;A<k;A++)h=I[A],x=I[A+k],t=I[A+2*k],H=I[A+3*k],z(u,h,x,t,H,(e.height-a)*k*3+3*A);a--}return u}(F,e)}function p(F,e){let a=e.height;const k=e.width;let h,x,t,H,p,y=e.dataPosition;const L=new ArrayBuffer(e.width*e.height*4*3),s=new Float32Array(L);for(;a>0;){for(p=0;p<e.width;p++)h=F[y++],x=F[y++],t=F[y++],H=F[y++],z(s,h,x,t,H,(e.height-a)*k*3+3*p);a--}return s}h.FACE_LEFT=[new k.l(-1,-1,-1),new k.l(1,-1,-1),new k.l(-1,1,-1),new k.l(1,1,-1)],h.FACE_RIGHT=[new k.l(1,-1,1),new k.l(-1,-1,1),new k.l(1,1,1),new k.l(-1,1,1)],h.FACE_FRONT=[new k.l(1,-1,-1),new k.l(1,-1,1),new k.l(1,1,-1),new k.l(1,1,1)],h.FACE_BACK=[new k.l(-1,-1,1),new k.l(-1,-1,-1),new k.l(-1,1,1),new k.l(-1,1,-1)],h.FACE_DOWN=[new k.l(1,1,-1),new k.l(1,1,1),new k.l(-1,1,-1),new k.l(-1,1,1)],h.FACE_UP=[new k.l(-1,-1,-1),new k.l(-1,-1,1),new k.l(1,-1,-1),new k.l(1,-1,1)];class y{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(F,e,a){const k=new Uint8Array(F.buffer,F.byteOffset,F.byteLength),h=t(k),z=H(k,h),x=h.width*h.height,p=new Float32Array(4*x);for(let t=0;t<x;t+=1)p[4*t]=z[3*t],p[4*t+1]=z[3*t+1],p[4*t+2]=z[3*t+2],p[4*t+3]=1;a(h.width,h.height,e.generateMipMaps,!1,(()=>{const F=e.getEngine();e.type=1,e.format=5,e._gammaSpace=!1,F._uploadDataToTextureDirectly(e,p)}))}}}}]);