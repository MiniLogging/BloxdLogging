"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10390:(d,m,g)=>{g.r(m),g.d(m,{_HDRTextureLoader:()=>X});var V=g(1012);class u{static ConvertPanoramaToCubemap(d,m,g,V){let u=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!d)throw"ConvertPanoramaToCubemap: input cannot be null";if(d.length!=m*g*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(V,this.FACE_FRONT,d,m,g,u),back:this.CreateCubemapTexture(V,this.FACE_BACK,d,m,g,u),left:this.CreateCubemapTexture(V,this.FACE_LEFT,d,m,g,u),right:this.CreateCubemapTexture(V,this.FACE_RIGHT,d,m,g,u),up:this.CreateCubemapTexture(V,this.FACE_UP,d,m,g,u),down:this.CreateCubemapTexture(V,this.FACE_DOWN,d,m,g,u),size:V,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(d,m,g,V,u){let D=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const j=new ArrayBuffer(d*d*4*3),z=new Float32Array(j),s=D?Math.max(1,Math.round(V/4/d)):1,U=1/s,X=U*U,Y=m[1].Vc(m[0]).scale(U/d),Q=m[3].Vc(m[2]).scale(U/d),B=1/d;let i=0;for(let C=0;C<d;C++)for(let D=0;D<s;D++){let D=m[0],j=m[2];for(let m=0;m<d;m++)for(let U=0;U<s;U++){const s=j.Vc(D).scale(i).add(D);s.normalize();const U=this.CalcProjectionSpherical(s,g,V,u);z[C*d*3+3*m+0]+=U.r*X,z[C*d*3+3*m+1]+=U.g*X,z[C*d*3+3*m+2]+=U.b*X,D=D.add(Y),j=j.add(Q)}i+=B*U}return z}static CalcProjectionSpherical(d,m,g,V){let u=Math.atan2(d.z,d.x);const D=Math.acos(d.y);for(;u<-Math.PI;)u+=2*Math.PI;for(;u>Math.PI;)u-=2*Math.PI;let j=u/Math.PI;const z=D/Math.PI;j=.5*j+.5;let s=Math.round(j*g);s<0?s=0:s>=g&&(s=g-1);let U=Math.round(z*V);U<0?U=0:U>=V&&(U=V-1);const X=V-U-1;return{r:m[X*g*3+3*s+0],g:m[X*g*3+3*s+1],b:m[X*g*3+3*s+2]}}}function D(d,m,g,V,u,D){u>0?(u=function(d,m){return m>1023?d*Math.pow(2,1023)*Math.pow(2,m-1023):m<-1074?d*Math.pow(2,-1074)*Math.pow(2,m+1074):d*Math.pow(2,m)}(1,u-136),d[D+0]=m*u,d[D+1]=g*u,d[D+2]=V*u):(d[D+0]=0,d[D+1]=0,d[D+2]=0)}function j(d,m){let g="",V="";for(let u=m;u<d.length-m&&(V=String.fromCharCode(d[u]),"\n"!=V);u++)g+=V;return g}function z(d){let m=0,g=0,V=j(d,0);if("#"!=V[0]||"?"!=V[1])throw"Bad HDR Format.";let u=!1,D=!1,z=0;do{z+=V.length+1,V=j(d,z),"FORMAT=32-bit_rle_rgbe"==V?D=!0:0==V.length&&(u=!0)}while(!u);if(!D)throw"HDR Bad header format, unsupported FORMAT";z+=V.length+1,V=j(d,z);const s=/^-Y (.*) \+X (.*)$/g.exec(V);if(!s||s.length<3)throw"HDR Bad header format, no size";if(g=parseInt(s[2]),m=parseInt(s[1]),g<8||g>32767)throw"HDR Bad header format, unsupported size";return z+=V.length+1,{height:m,width:g,dataPosition:z}}function s(d,m){return function(d,m){let g=m.height;const V=m.width;let u,j,z,s,X,Y=m.dataPosition,Q=0,B=0,i=0;const C=new ArrayBuffer(4*V),L=new Uint8Array(C),O=new ArrayBuffer(m.width*m.height*4*3),R=new Float32Array(O);for(;g>0;){if(u=d[Y++],j=d[Y++],z=d[Y++],s=d[Y++],2!=u||2!=j||128&z||m.width<8||m.width>32767)return U(d,m);if((z<<8|s)!=V)throw"HDR Bad header format, wrong scan line width";for(Q=0,i=0;i<4;i++)for(B=(i+1)*V;Q<B;)if(u=d[Y++],j=d[Y++],u>128){if(X=u-128,0==X||X>B-Q)throw"HDR Bad Format, bad scanline data (run)";for(;X-- >0;)L[Q++]=j}else{if(X=u,0==X||X>B-Q)throw"HDR Bad Format, bad scanline data (non-run)";if(L[Q++]=j,--X>0)for(let m=0;m<X;m++)L[Q++]=d[Y++]}for(i=0;i<V;i++)u=L[i],j=L[i+V],z=L[i+2*V],s=L[i+3*V],D(R,u,j,z,s,(m.height-g)*V*3+3*i);g--}return R}(d,m)}function U(d,m){let g=m.height;const V=m.width;let u,j,z,s,U,X=m.dataPosition;const Y=new ArrayBuffer(m.width*m.height*4*3),Q=new Float32Array(Y);for(;g>0;){for(U=0;U<m.width;U++)u=d[X++],j=d[X++],z=d[X++],s=d[X++],D(Q,u,j,z,s,(m.height-g)*V*3+3*U);g--}return Q}u.FACE_LEFT=[new V.m(-1,-1,-1),new V.m(1,-1,-1),new V.m(-1,1,-1),new V.m(1,1,-1)],u.FACE_RIGHT=[new V.m(1,-1,1),new V.m(-1,-1,1),new V.m(1,1,1),new V.m(-1,1,1)],u.FACE_FRONT=[new V.m(1,-1,-1),new V.m(1,-1,1),new V.m(1,1,-1),new V.m(1,1,1)],u.FACE_BACK=[new V.m(-1,-1,1),new V.m(-1,-1,-1),new V.m(-1,1,1),new V.m(-1,1,-1)],u.FACE_DOWN=[new V.m(1,1,-1),new V.m(1,1,1),new V.m(-1,1,-1),new V.m(-1,1,1)],u.FACE_UP=[new V.m(-1,-1,-1),new V.m(-1,-1,1),new V.m(1,-1,-1),new V.m(1,-1,1)];class X{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(d,m,g){const V=new Uint8Array(d.buffer,d.byteOffset,d.byteLength),u=z(V),D=s(V,u),j=u.width*u.height,U=new Float32Array(4*j);for(let z=0;z<j;z+=1)U[4*z]=D[3*z],U[4*z+1]=D[3*z+1],U[4*z+2]=D[3*z+2],U[4*z+3]=1;g(u.width,u.height,m.generateMipMaps,!1,(()=>{const d=m.getEngine();m.type=1,m.format=5,m._gammaSpace=!1,d._uploadDataToTextureDirectly(m,U)}))}}}}]);