"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{11136:(L,i,P)=>{P.r(i),P.d(i,{_HDRTextureLoader:()=>C});var D=P(995);class V{static ConvertPanoramaToCubemap(L,i,P,D){let V=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!L)throw"ConvertPanoramaToCubemap: input cannot be null";if(L.length!=i*P*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(D,this.FACE_FRONT,L,i,P,V),back:this.CreateCubemapTexture(D,this.FACE_BACK,L,i,P,V),left:this.CreateCubemapTexture(D,this.FACE_LEFT,L,i,P,V),right:this.CreateCubemapTexture(D,this.FACE_RIGHT,L,i,P,V),up:this.CreateCubemapTexture(D,this.FACE_UP,L,i,P,V),down:this.CreateCubemapTexture(D,this.FACE_DOWN,L,i,P,V),size:D,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(L,i,P,D,V){let M=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const a=new ArrayBuffer(L*L*4*3),w=new Float32Array(a),O=M?Math.max(1,Math.round(D/4/L)):1,U=1/O,C=U*U,T=i[1].md(i[0]).scale(U/L),c=i[3].md(i[2]).scale(U/L),r=1/L;let F=0;for(let S=0;S<L;S++)for(let M=0;M<O;M++){let M=i[0],a=i[2];for(let i=0;i<L;i++)for(let U=0;U<O;U++){const O=a.md(M).scale(F).add(M);O.normalize();const U=this.CalcProjectionSpherical(O,P,D,V);w[S*L*3+3*i+0]+=U.r*C,w[S*L*3+3*i+1]+=U.g*C,w[S*L*3+3*i+2]+=U.b*C,M=M.add(T),a=a.add(c)}F+=r*U}return w}static CalcProjectionSpherical(L,i,P,D){let V=Math.atan2(L.z,L.x);const M=Math.acos(L.y);for(;V<-Math.PI;)V+=2*Math.PI;for(;V>Math.PI;)V-=2*Math.PI;let a=V/Math.PI;const w=M/Math.PI;a=.5*a+.5;let O=Math.round(a*P);O<0?O=0:O>=P&&(O=P-1);let U=Math.round(w*D);U<0?U=0:U>=D&&(U=D-1);const C=D-U-1;return{r:i[C*P*3+3*O+0],g:i[C*P*3+3*O+1],b:i[C*P*3+3*O+2]}}}function M(L,i,P,D,V,M){V>0?(V=function(L,i){return i>1023?L*Math.pow(2,1023)*Math.pow(2,i-1023):i<-1074?L*Math.pow(2,-1074)*Math.pow(2,i+1074):L*Math.pow(2,i)}(1,V-136),L[M+0]=i*V,L[M+1]=P*V,L[M+2]=D*V):(L[M+0]=0,L[M+1]=0,L[M+2]=0)}function a(L,i){let P="",D="";for(let V=i;V<L.length-i&&(D=String.fromCharCode(L[V]),"\n"!=D);V++)P+=D;return P}function w(L){let i=0,P=0,D=a(L,0);if("#"!=D[0]||"?"!=D[1])throw"Bad HDR Format.";let V=!1,M=!1,w=0;do{w+=D.length+1,D=a(L,w),"FORMAT=32-bit_rle_rgbe"==D?M=!0:0==D.length&&(V=!0)}while(!V);if(!M)throw"HDR Bad header format, unsupported FORMAT";w+=D.length+1,D=a(L,w);const O=/^-Y (.*) \+X (.*)$/g.exec(D);if(!O||O.length<3)throw"HDR Bad header format, no size";if(P=parseInt(O[2]),i=parseInt(O[1]),P<8||P>32767)throw"HDR Bad header format, unsupported size";return w+=D.length+1,{height:i,width:P,dataPosition:w}}function O(L,i){return function(L,i){let P=i.height;const D=i.width;let V,a,w,O,C,T=i.dataPosition,c=0,r=0,F=0;const S=new ArrayBuffer(4*D),q=new Uint8Array(S),H=new ArrayBuffer(i.width*i.height*4*3),j=new Float32Array(H);for(;P>0;){if(V=L[T++],a=L[T++],w=L[T++],O=L[T++],2!=V||2!=a||128&w||i.width<8||i.width>32767)return U(L,i);if((w<<8|O)!=D)throw"HDR Bad header format, wrong scan line width";for(c=0,F=0;F<4;F++)for(r=(F+1)*D;c<r;)if(V=L[T++],a=L[T++],V>128){if(C=V-128,0==C||C>r-c)throw"HDR Bad Format, bad scanline data (run)";for(;C-- >0;)q[c++]=a}else{if(C=V,0==C||C>r-c)throw"HDR Bad Format, bad scanline data (non-run)";if(q[c++]=a,--C>0)for(let i=0;i<C;i++)q[c++]=L[T++]}for(F=0;F<D;F++)V=q[F],a=q[F+D],w=q[F+2*D],O=q[F+3*D],M(j,V,a,w,O,(i.height-P)*D*3+3*F);P--}return j}(L,i)}function U(L,i){let P=i.height;const D=i.width;let V,a,w,O,U,C=i.dataPosition;const T=new ArrayBuffer(i.width*i.height*4*3),c=new Float32Array(T);for(;P>0;){for(U=0;U<i.width;U++)V=L[C++],a=L[C++],w=L[C++],O=L[C++],M(c,V,a,w,O,(i.height-P)*D*3+3*U);P--}return c}V.FACE_LEFT=[new D.p(-1,-1,-1),new D.p(1,-1,-1),new D.p(-1,1,-1),new D.p(1,1,-1)],V.FACE_RIGHT=[new D.p(1,-1,1),new D.p(-1,-1,1),new D.p(1,1,1),new D.p(-1,1,1)],V.FACE_FRONT=[new D.p(1,-1,-1),new D.p(1,-1,1),new D.p(1,1,-1),new D.p(1,1,1)],V.FACE_BACK=[new D.p(-1,-1,1),new D.p(-1,-1,-1),new D.p(-1,1,1),new D.p(-1,1,-1)],V.FACE_DOWN=[new D.p(1,1,-1),new D.p(1,1,1),new D.p(-1,1,-1),new D.p(-1,1,1)],V.FACE_UP=[new D.p(-1,-1,-1),new D.p(-1,-1,1),new D.p(1,-1,-1),new D.p(1,-1,1)];class C{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(L,i,P){const D=new Uint8Array(L.buffer,L.byteOffset,L.byteLength),V=w(D),M=O(D,V),a=V.width*V.height,U=new Float32Array(4*a);for(let w=0;w<a;w+=1)U[4*w]=M[3*w],U[4*w+1]=M[3*w+1],U[4*w+2]=M[3*w+2],U[4*w+3]=1;P(V.width,V.height,i.generateMipMaps,!1,(()=>{const L=i.getEngine();i.type=1,i.format=5,i._gammaSpace=!1,L._uploadDataToTextureDirectly(i,U)}))}}}}]);