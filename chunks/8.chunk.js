"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{11052:(h,d,m)=>{m.r(d),m.d(d,{EXT_materials_diffuse_roughness:()=>Yd,EXT_mesh_gpu_instancing:()=>ph,GLTF2Export:()=>Oh,GLTFData:()=>S,KHR_draco_mesh_compression:()=>md,KHR_lights_punctual:()=>Dd,KHR_materials_anisotropy:()=>qd,KHR_materials_clearcoat:()=>Id,KHR_materials_diffuse_transmission:()=>Ld,KHR_materials_dispersion:()=>Vd,KHR_materials_emissive_strength:()=>Cd,KHR_materials_ior:()=>od,KHR_materials_iridescence:()=>id,KHR_materials_sheen:()=>Fd,KHR_materials_specular:()=>Hd,KHR_materials_transmission:()=>kd,KHR_materials_unlit:()=>Kd,KHR_materials_volume:()=>Wd,KHR_texture_transform:()=>Qd,OBJExport:()=>w,STLExport:()=>td,USDZExportAsync:()=>dm,_ConvertToGLTFPBRMetallicRoughness:()=>l,_SolveMetallic:()=>k,__IGLTFExporterExtension:()=>a});var j=m(11058),A=m(11107),b=m(11251);class w{static OBJ(h,d,m,w){const a=[];let D=1,S=1;d&&(m||(m="mat"),a.push("mtllib "+m+".mtl"));for(let M=0;M<h.length;M++){const m=h[M],q=m.name||`mesh${M}}`;a.push(`o ${q}`);let E=null;if(w){const h=m.Zd(!0);E=new j.b,h.invertToRef(E),m.bakeTransformIntoVertices(h)}if(d){const h=m.material;h&&a.push("usemtl "+h.id)}const I=m.Ld;if(!I){A.e.Warn("No geometry is present on the mesh");continue}const R=I.getVerticesData("position"),Z=I.getVerticesData("Dd"),L=I.getVerticesData("uv"),B=I.Vd();let V=0,v=0;if(!R||!B){A.e.Warn("There are no position vertices or indices on the mesh!");continue}const C=h[0].ih().useRightHandedSystem?1:-1;for(let h=0;h<R.length;h+=3)a.push("v "+R[h]*C+" "+R[h+1]+" "+R[h+2]),V++;if(null!=Z)for(let h=0;h<Z.length;h+=3)a.push("vn "+Z[h]*C+" "+Z[h+1]+" "+Z[h+2]);if(null!=L)for(let h=0;h<L.length;h+=2)a.push("vt "+L[h]+" "+L[h+1]),v++;const T=["","",""],o=(m.material||m.ih().defaultMaterial)._getEffectiveOrientation(m),[y,i]=o===b.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let h=0;h<B.length;h+=3){const d=[String(B[h]+D),String(B[h+y]+D),String(B[h+i]+D)],m=[String(B[h]+S),String(B[h+y]+S),String(B[h+i]+S)],j=d,A=null!=L?m:T,b=null!=Z?d:T;a.push("f "+j[0]+"/"+A[0]+"/"+b[0]+" "+j[1]+"/"+A[1]+"/"+b[1]+" "+j[2]+"/"+A[2]+"/"+b[2])}w&&E&&m.bakeTransformIntoVertices(E),D+=V,S+=v}return a.join("\n")}static MTL(h){const d=[],m=h.material;d.push("newmtl mat1"),d.push("  Ns "+m.specularPower.toFixed(4)),d.push("  Ni 1.5000"),d.push("  d "+m.alpha.toFixed(4)),d.push("  Tr 0.0000"),d.push("  Tf 1.0000 1.0000 1.0000"),d.push("  illum 2"),d.push("  Ka "+m.ambientColor.r.toFixed(4)+" "+m.ambientColor.g.toFixed(4)+" "+m.ambientColor.b.toFixed(4)),d.push("  Kd "+m.diffuseColor.r.toFixed(4)+" "+m.diffuseColor.g.toFixed(4)+" "+m.diffuseColor.b.toFixed(4)),d.push("  Ks "+m.specularColor.r.toFixed(4)+" "+m.specularColor.g.toFixed(4)+" "+m.specularColor.b.toFixed(4)),d.push("  Ke "+m.emissiveColor.r.toFixed(4)+" "+m.emissiveColor.g.toFixed(4)+" "+m.emissiveColor.b.toFixed(4));m.ambientTexture&&d.push("  map_Ka "+m.ambientTexture.name),m.diffuseTexture&&d.push("  map_Kd "+m.diffuseTexture.name),m.specularTexture&&d.push("  map_Ks "+m.specularTexture.name),m.bumpTexture&&d.push("  map_bump -imfchan z "+m.bumpTexture.name),m.opacityTexture&&d.push("  map_d "+m.opacityTexture.name);return d.join("\n")}}var a=0,D=m(11150);class S{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const h in this.files){const d=this.files[h],m=new Blob([d],{type:(0,D.m)(h)});A.e.Download(m,h)}}}var M=m(11281),q=m(11366),E=m(11380),I=m(11412),R=m(11463),Z=m(11094),L=m(11353),B=m(11099);const V=B.HighestCommonFactor,v={...B,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:V};var C=m(11538),T=m(11543),o=m(11573),y=m(11578),i=m(11582);const g=1e-6,F=new L.d(.04,.04,.04),f=1024,H=L.d.White(),c=L.d.Black();function k(h,d,m){if(d<F.r)return 0;const j=F.r,A=h*m/(1-F.r)+d-2*F.r,b=A*A-4*j*(F.r-d);return v.Clamp((-A+Math.sqrt(b))/(2*j),0,1)}function l(h){const d=h.diffuseColor.toLinearSpace(h.ih().getEngine().useExactSrgbConversions).scale(.5),m=h.alpha,A=function(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new j.h(0,1),m=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new j.h(0,.1),A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new j.h(0,.1),b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new j.h(1300,.1);return function(h,d,m,j,A){return(1-h)*(1-h)*(1-h)*d+3*(1-h)*(1-h)*h*m+3*(1-h)*h*h*j+h*h*h*A}(Math.pow(h/b.x,.333333),d.y,m.y,A.y,b.y)}(v.Clamp(h.specularPower,0,f));return{baseColorFactor:[d.r,d.g,d.b,m],metallicFactor:0,roughnessFactor:A}}function K(h,d){d.needAlphaBlending()?h.alphaMode="BLEND":d.needAlphaTesting()&&(h.alphaMode="MASK",h.alphaCutoff=d.alphaCutOff)}function N(h,d,m){const j=new Uint8Array(h*d*4);for(let A=0;A<j.length;A+=4)j[A]=j[A+1]=j[A+2]=j[A+3]=255;return o.b.CreateRGBATexture(j,h,d,m)}function W(h){if(h instanceof Uint8Array){const d=h.length,m=new Float32Array(h.length);for(let j=0;j<d;++j)m[j]=h[j]/255;return m}if(h instanceof Float32Array)return h;throw new Error("Unsupported pixel format!")}class r{constructor(h){this._exporter=h,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(h){return h?this._textureMap.get(h)??null:null}async exportStandardMaterialAsync(h,d,m){const j=l(h),b={name:h.name};if(null==h.yd||h.yd||(h.twoSidedLighting||A.e.Warn(h.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),b.doubleSided=!0),m){const m=[],A=h.diffuseTexture;A&&m.push(this.exportTextureAsync(A,d).then((h=>{h&&(j.baseColorTexture=h)})));const w=h.bumpTexture;w&&m.push(this.exportTextureAsync(w,d).then((h=>{h&&(b.normalTexture=h,1!==w.level&&(b.normalTexture.scale=w.level))})));const a=h.emissiveTexture;a&&(b.emissiveFactor=[1,1,1],m.push(this.exportTextureAsync(a,d).then((h=>{h&&(b.emissiveTexture=h)}))));const D=h.ambientTexture;D&&m.push(this.exportTextureAsync(D,d).then((h=>{if(h){const d={index:h.index};b.occlusionTexture=d}}))),m.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(m))}(h.alpha<1||h.opacityTexture)&&(h.alphaMode===y.c.ALPHA_COMBINE?b.alphaMode="BLEND":A.e.Warn(h.name+": glTF 2.0 does not support alpha mode: "+h.alphaMode.toString())),h.emissiveColor&&!h.emissiveColor.equalsWithEpsilon(c,g)&&(b.emissiveFactor=h.emissiveColor.fd()),b.pbrMetallicRoughness=j,K(b,h),await this._finishMaterialAsync(b,h,d);const w=this._exporter._materials;return w.push(b),w.length-1}async _finishMaterialAsync(h,d,m){const j=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",h,d),A=[];for(const b of j)A.push(this.exportTextureAsync(b,m));await Promise.all(A),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",h,d)}async _getImageDataAsync(h,d,j,A){const b=y.c.TEXTURETYPE_UNSIGNED_BYTE,w=this._exporter._babylonScene,a=w.getEngine(),D=a.createRawTexture(h,d,j,y.c.TEXTUREFORMAT_RGBA,!1,!0,T.e.NEAREST_SAMPLINGMODE,null,b);a.isWebGPU?await m.e(36).then(m.bind(m,13380)):await m.e(37).then(m.bind(m,13384)),await C.j.ApplyPostProcess("pass",D,w,b,y.c.TEXTURE_NEAREST_SAMPLINGMODE,y.c.TEXTUREFORMAT_RGBA);const S=await a._readTexturePixels(D,d,j);return await i.DumpTools.DumpDataAsync(d,j,S,A,void 0,!0,!0)}_resizeTexturesToSameDimensions(h,d,m){const j=h?h.getSize():{width:0,height:0},A=d?d.getSize():{width:0,height:0};let b,w;return j.width<A.width?(b=h&&h instanceof T.e?C.j.CreateResizedCopy(h,A.width,A.height,!0):N(A.width,A.height,m),w=d):j.width>A.width?(w=d&&d instanceof T.e?C.j.CreateResizedCopy(d,j.width,j.height,!0):N(j.width,j.height,m),b=h):(b=h,w=d),{texture1:b,texture2:w}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(h,d,m,j){const A=new Array;if(!h&&!d)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const b=h?h.ih():d?d.ih():null;if(b){var w;const a=this._resizeTexturesToSameDimensions(h,d,b),D=null===(w=a.texture1)||void 0===w?void 0:w.getSize();let S,M;const q=D.width,E=D.height,I=await a.texture1.readPixels(),R=await a.texture2.readPixels();if(!I)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(S=W(I),!R)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");M=W(R);const Z=M.byteLength,B=new Uint8Array(Z),V=new Uint8Array(Z),v=4,C=c;let T=0,o=0;for(let h=0;h<E;++h)for(let d=0;d<q;++d){const j=(q*h+d)*v,A={diffuseColor:new L.d(S[j],S[j+1],S[j+2]).toLinearSpace(b.getEngine().useExactSrgbConversions).multiply(m.diffuseColor),specularColor:new L.d(M[j],M[j+1],M[j+2]).toLinearSpace(b.getEngine().useExactSrgbConversions).multiply(m.specularColor),glossiness:M[j+3]*m.glossiness},w=this._convertSpecularGlossinessToMetallicRoughness(A);C.r=Math.max(C.r,w.baseColor.r),C.g=Math.max(C.g,w.baseColor.g),C.b=Math.max(C.b,w.baseColor.b),T=Math.max(T,w.metallic),o=Math.max(o,w.roughness),V[j]=255*w.baseColor.r,V[j+1]=255*w.baseColor.g,V[j+2]=255*w.baseColor.b,V[j+3]=a.texture1.Nd?255*S[j+3]:255,B[j]=0,B[j+1]=255*w.roughness,B[j+2]=255*w.metallic,B[j+3]=255}const y={baseColor:C,metallic:T,roughness:o};let i=!1,F=!1;for(let h=0;h<E;++h)for(let d=0;d<q;++d){const m=(q*h+d)*v;V[m]/=y.baseColor.r>g?y.baseColor.r:1,V[m+1]/=y.baseColor.g>g?y.baseColor.g:1,V[m+2]/=y.baseColor.b>g?y.baseColor.b:1;const j=L.d.FromInts(V[m],V[m+1],V[m+2]).toGammaSpace(b.getEngine().useExactSrgbConversions);V[m]=255*j.r,V[m+1]=255*j.g,V[m+2]=255*j.b,j.equalsWithEpsilon(H,g)||(F=!0),B[m+1]/=y.roughness>g?y.roughness:1,B[m+2]/=y.metallic>g?y.metallic:1;L.d.FromInts(255,B[m+1],B[m+2]).equalsWithEpsilon(H,g)||(i=!0)}return i&&A.push(this._getImageDataAsync(B,q,E,j).then((h=>{y.metallicRoughnessTextureData=h}))),F&&A.push(this._getImageDataAsync(V,q,E,j).then((h=>{y.baseColorTextureData=h}))),await Promise.all(A).then((()=>y))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(h){const d=this._getPerceivedBrightness(h.diffuseColor),m=this._getPerceivedBrightness(h.specularColor),j=1-this._getMaxComponent(h.specularColor),A=k(d,m,j),b=h.diffuseColor.scale(j/(1-F.r)/Math.max(1-A)),w=h.specularColor.fm(F.scale(1-A)).scale(1/Math.max(A));let a=L.d.Lerp(b,w,A*A);a=a.clampToRef(0,1,a);return{baseColor:a,metallic:A,roughness:1-h.glossiness}}_getPerceivedBrightness(h){return h?Math.sqrt(.299*h.r*h.r+.587*h.g*h.g+.114*h.b*h.b):0}_getMaxComponent(h){return h?Math.max(h.r,Math.max(h.g,h.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(h,d,m,j){const A=[],b={baseColor:h._albedoColor,metallic:h._metallic,roughness:h._roughness};if(j){h._albedoTexture&&A.push(this.exportTextureAsync(h._albedoTexture,d).then((h=>{h&&(m.baseColorTexture=h)})));const j=h._metallicTexture;j&&A.push(this.exportTextureAsync(j,d).then((h=>{h&&(m.metallicRoughnessTexture=h)})))}return A.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(A)),b}_getTextureSampler(h){const d={};if(!h||!(h instanceof T.e))return d;const m=this._getGLTFTextureWrapMode(h.wrapU);10497!==m&&(d.wrapS=m);const j=this._getGLTFTextureWrapMode(h.wrapV);switch(10497!==j&&(d.wrapT=j),h.samplingMode){case T.e.LINEAR_LINEAR:d.magFilter=9729,d.minFilter=9729;break;case T.e.LINEAR_NEAREST:d.magFilter=9729,d.minFilter=9728;break;case T.e.NEAREST_LINEAR:d.magFilter=9728,d.minFilter=9729;break;case T.e.NEAREST_LINEAR_MIPLINEAR:d.magFilter=9728,d.minFilter=9987;break;case T.e.NEAREST_NEAREST:d.magFilter=9728,d.minFilter=9728;break;case T.e.NEAREST_LINEAR_MIPNEAREST:d.magFilter=9728,d.minFilter=9985;break;case T.e.LINEAR_NEAREST_MIPNEAREST:d.magFilter=9729,d.minFilter=9984;break;case T.e.LINEAR_NEAREST_MIPLINEAR:d.magFilter=9729,d.minFilter=9986;break;case T.e.NEAREST_NEAREST_MIPLINEAR:d.magFilter=9728,d.minFilter=9986;break;case T.e.LINEAR_LINEAR_MIPLINEAR:d.magFilter=9729,d.minFilter=9987;break;case T.e.LINEAR_LINEAR_MIPNEAREST:d.magFilter=9729,d.minFilter=9985;break;case T.e.NEAREST_NEAREST_MIPNEAREST:d.magFilter=9728,d.minFilter=9984}return d}_getGLTFTextureWrapMode(h){switch(h){case T.e.WRAP_ADDRESSMODE:return 10497;case T.e.CLAMP_ADDRESSMODE:return 33071;case T.e.MIRROR_ADDRESSMODE:return 33648;default:return A.e.Error(`Unsupported Texture Wrap Mode ${h}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(h,d,m,j){const A={diffuseColor:h._albedoColor,specularColor:h._reflectivityColor,glossiness:h._microSurface},b=h._albedoTexture,w=h._reflectivityTexture,a=h._useMicroSurfaceFromReflectivityMapAlpha;if(w&&!a)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((b||w)&&j){this._exporter._materialNeedsUVsSet.add(h);const j=this._exportTextureSampler(b||w),a=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(b,w,A,d),D=this._exporter._textures;if(a.baseColorTextureData){const h=this._exportImage(`baseColor${D.length}`,d,a.baseColorTextureData);m.baseColorTexture=this._exportTextureInfo(h,j,null===b||void 0===b?void 0:b.coordinatesIndex)}if(a.metallicRoughnessTextureData){const h=this._exportImage(`metallicRoughness${D.length}`,d,a.metallicRoughnessTextureData);m.metallicRoughnessTexture=this._exportTextureInfo(h,j,null===w||void 0===w?void 0:w.coordinatesIndex)}return a}return this._convertSpecularGlossinessToMetallicRoughness(A)}async exportPBRMaterialAsync(h,d,m){const j={},A={name:h.name},b=h.isMetallicWorkflow();if(b){const d=h._albedoColor,m=h.alpha;d&&(j.baseColorFactor=[d.r,d.g,d.b,m])}const w=b?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(h,d,j,m):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(h,d,j,m);await this._setMetallicRoughnessPbrMaterialAsync(w,h,A,j,d,m),await this._finishMaterialAsync(A,h,d);const a=this._exporter._materials;return a.push(A),a.length-1}async _setMetallicRoughnessPbrMaterialAsync(h,d,m,j,b,w){if(K(m,d),h.baseColor.equalsWithEpsilon(H,g)&&v.WithinEpsilon(d.alpha,1,g)||(j.baseColorFactor=[h.baseColor.r,h.baseColor.g,h.baseColor.b,d.alpha]),null!=h.metallic&&1!==h.metallic&&(j.metallicFactor=h.metallic),null!=h.roughness&&1!==h.roughness&&(j.roughnessFactor=h.roughness),null==d.yd||d.yd||(d._twoSidedLighting||A.e.Warn(d.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),m.doubleSided=!0),w){const h=[],j=d._bumpTexture;j&&h.push(this.exportTextureAsync(j,b).then((h=>{h&&(m.normalTexture=h,1!==j.level&&(m.normalTexture.scale=j.level))})));const A=d._ambientTexture;A&&h.push(this.exportTextureAsync(A,b).then((h=>{if(h){const j={index:h.index,texCoord:h.texCoord,extensions:h.extensions};m.occlusionTexture=j;const A=d._ambientTextureStrength;A&&(j.strength=A)}})));const w=d._emissiveTexture;w&&h.push(this.exportTextureAsync(w,b).then((h=>{h&&(m.emissiveTexture=h)}))),h.length>0&&(this._exporter._materialNeedsUVsSet.add(d),await Promise.all(h))}const a=d._emissiveColor;a.equalsWithEpsilon(c,g)||(m.emissiveFactor=a.fd()),m.pbrMetallicRoughness=j}_getPixelsFromTextureAsync(h){return function(h){switch(h){case y.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case y.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case y.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case y.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case y.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case y.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case y.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case y.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case y.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case y.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case y.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case y.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case y.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case y.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case y.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case y.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case y.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case y.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case y.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case y.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case y.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(h.textureFormat)?(0,C.g)(h,h._texture.width,h._texture.height):(h.textureType,y.c.TEXTURETYPE_UNSIGNED_BYTE,h.readPixels())}async exportTextureAsync(h,d){const m=this._exporter._extensionsPreExportTextureAsync("exporter",h,d);return m?await m.then((async m=>m?await this._exportTextureInfoAsync(m,d):await this._exportTextureInfoAsync(h,d))):await this._exportTextureInfoAsync(h,d)}async _exportTextureInfoAsync(h,d){let m=this._textureMap.get(h);if(!m){const j=await this._getPixelsFromTextureAsync(h);if(!j)return null;const b=this._exportTextureSampler(h),w=h.mimeType;if(w)switch(w){case"image/jpeg":case"image/png":case"image/webp":d=w;break;default:A.e.Warn(`Unsupported media type: ${w}. Exporting texture as PNG.`)}const a=this._internalTextureToImage,D=h.getInternalTexture().uniqueId;a[D]||(a[D]={});let S=a[D][d];if(void 0===S){const m=h.getSize();S=(async()=>{const A=await this._getImageDataAsync(j,m.width,m.height,d);return this._exportImage(h.name,d,A)})(),a[D][d]=S}m=this._exportTextureInfo(await S,b,h.coordinatesIndex),this._textureMap.set(h,m),this._exporter._extensionsPostExportTextures("exporter",m,h)}return m}_exportImage(h,d,m){const j=this._exporter._images;let b;if(this._exporter._shouldUseGlb){b={name:h,mimeType:d,bufferView:void 0};const j=this._exporter._bufferManager.createBufferView(new Uint8Array(m));this._exporter._bufferManager.setBufferView(b,j)}else{const w=h.replace(/\.\/|\/|\.\\|\\/g,"_"),a=function(h){switch(h){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(d);let D=w+a;j.some((h=>h.uri===D))&&(D=`${w}_${A.e.RandomId()}${a}`),b={name:h,uri:D},this._exporter._imageData[D]={data:m,mimeType:d}}return j.push(b),j.length-1}_exportTextureInfo(h,d,m){const j=this._exporter._textures;let A=j.findIndex((m=>m.sampler==d&&m.source===h));-1===A&&(A=j.length,j.push({source:h,sampler:d}));const b={index:A};return m&&(b.texCoord=m),b}_exportTextureSampler(h){const d=this._getTextureSampler(h),m=this._exporter._samplers,j=m.findIndex((h=>h.minFilter===d.minFilter&&h.magFilter===d.magFilter&&h.wrapS===d.wrapS&&h.wrapT===d.wrapT));return-1!==j?j:(m.push(d),m.length-1)}}var Y=m(11290),x=m(11121),Q=m(11587),t=m(11065);const U=j.i.Zero(),s=j.c.Identity(),J=j.i.One(),O=new j.i(-1,1,1);function n(h,d){const{byteOffset:m,byteStride:j,type:A,normalized:b}=h,w=h.getSize(),a=d.reduce(((h,d)=>d.getTotalVertices()>h?d.getTotalVertices():h),-Number.MAX_VALUE);return{byteOffset:m,byteStride:j,componentCount:w,type:A,count:a*w,normalized:b,totalVertices:a,kind:h.getKind()}}function p(h){switch(h){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function e(h){switch(h){case M.d.PositionKind:case M.d.NormalKind:case M.d.TangentKind:case M.d.ColorKind:case M.d.MatricesIndicesKind:case M.d.MatricesIndicesExtraKind:case M.d.MatricesWeightsKind:case M.d.MatricesWeightsExtraKind:case M.d.UVKind:case M.d.UV2Kind:case M.d.UV3Kind:case M.d.UV4Kind:case M.d.UV5Kind:case M.d.UV6Kind:return!0}return!1}function X(h){switch(h){case b.d.TriangleFillMode:return 4;case b.d.TriangleStripDrawMode:return 5;case b.d.TriangleFanDrawMode:return 6;case b.d.PointListDrawMode:case b.d.PointFillMode:return 0;case b.d.LineLoopDrawMode:return 2;case b.d.LineListDrawMode:return 1;case b.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${h}`)}function z(h){const d=Math.sqrt(h.x*h.x+h.y*h.y+h.z*h.z);d>0&&(h.x/=d,h.y/=d,h.z/=d)}function u(h){return h.x*=-1,h}function P(h){if(h.x*h.x+h.y*h.y>.5){const d=Math.abs(h.x),m=Math.abs(h.y);if(d>m){const m=Math.sign(h.x);h.x=d,h.y*=-m,h.z*=-m,h.w*=m}else{const d=Math.sign(h.y);h.x*=-d,h.y=m,h.z*=d,h.w*=-d}}else{const d=Math.abs(h.z),m=Math.abs(h.w);if(d>m){const m=Math.sign(h.z);h.x*=-m,h.y*=m,h.z=d,h.w*=-m}else{const d=Math.sign(h.w);h.x*=d,h.y*=-d,h.z*=-d,h.w=m}}return h}function G(h){h.xd(-h.z,h.w,h.x,-h.y)}function hh(h,d){const m=j.i.FromArrayToRef(d.translation||[0,0,0],0,j.d.Qd[0]),A=j.c.FromArrayToRef(d.rotation||[0,0,0,1],0,j.d.Quaternion[0]),b=j.b.ComposeToRef(J,A,m,j.d.Matrix[0]),w=j.i.FromArrayToRef(h.translation||[0,0,0],0,j.d.Qd[2]),a=j.c.FromArrayToRef(h.rotation||[0,0,0,1],0,j.d.Quaternion[1]),D=j.b.ComposeToRef(J,a,w,j.d.Matrix[1]);b.multiplyToRef(D,D),D.decompose(void 0,A,m),m.equalsWithEpsilon(U,t.c)?delete d.translation:d.translation=m.fd(),A.equalsWithEpsilon(s,t.c)?delete d.rotation:d.rotation=A.fd(),d.scale&&delete d.scale}function dh(h,d){if(!(d instanceof q.c))return!1;if(!(1===d.getChildren().length&&0===h.getChildren().length&&h.parent===d))return!1;const m=h.ih(),j=h instanceof Q.e&&!m.useRightHandedSystem?O:J;return!!d.td.equalsWithEpsilon(j,t.c)||(x.c.Warn(`Cannot collapse node ${h.name} into parent node ${d.name} with modified scaling.`),!1)}function mh(h){if(h instanceof Array){const d=new Float32Array(h);return new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}return ArrayBuffer.isView(h)?new Uint8Array(h.buffer,h.byteOffset,h.byteLength):new Uint8Array(h)}function jh(h,d){for(const[m,j]of Object.entries(h)){const A=d[m];(Array.isArray(j)&&Array.isArray(A)&&Ah(j,A)||j===A)&&delete h[m]}return h}function Ah(h,d){return h.length===d.length&&h.every(((h,m)=>h===d[m]))}const bh=j.b.Compose(new j.i(-1,1,1),j.c.Identity(),j.i.Zero());function wh(h,d){if(!(h instanceof q.c))return!1;if(d){if(!h.getWorldMatrix().equalsWithEpsilon(j.b.IdentityReadOnly,t.c))return!1}else{if(!h.getWorldMatrix().multiplyToRef(bh,j.d.Matrix[0]).equalsWithEpsilon(j.b.IdentityReadOnly,t.c))return!1}return!(h instanceof E.b&&h.Ld)}const ah=new Map([[Int8Array,(h,d,m)=>h.setInt8(d,m)],[Uint8Array,(h,d,m)=>h.setUint8(d,m)],[Uint8ClampedArray,(h,d,m)=>h.setUint8(d,m)],[Int16Array,(h,d,m)=>h.setInt16(d,m,!0)],[Uint16Array,(h,d,m)=>h.setUint16(d,m,!0)],[Int32Array,(h,d,m)=>h.setInt32(d,m,!0)],[Uint32Array,(h,d,m)=>h.setUint32(d,m,!0)],[Float32Array,(h,d,m)=>h.setFloat32(d,m,!0)],[Float64Array,(h,d,m)=>h.setFloat64(d,m,!0)]]);class Dh{writeTypedArray(h){this._checkGrowBuffer(h.byteLength);const d=ah.get(h.constructor);for(let m=0;m<h.length;m++)d(this._dataView,this._byteOffset,h[m]),this._byteOffset+=h.BYTES_PER_ELEMENT}constructor(h){this._data=new Uint8Array(h),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(h){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,h),this._byteOffset++}writeInt8(h){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,h),this._byteOffset++}writeInt16(h){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,h,!0),this._byteOffset+=2}writeUInt16(h){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,h,!0),this._byteOffset+=2}writeInt32(h){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,h,!0),this._byteOffset+=4}writeUInt32(h){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,h,!0),this._byteOffset+=4}writeFloat32(h){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,h,!0),this._byteOffset+=4}writeFloat64(h){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,h,!0),this._byteOffset+=8}_checkGrowBuffer(h){const d=this.byteOffset+h;if(d>this._data.byteLength){const h=new Uint8Array(2*d);h.set(this._data),this._data=h,this._dataView=new DataView(this._data.buffer)}}}function Sh(h){return h%4===0?4:h%2===0?2:1}class Mh{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(h){let d=0;this._bufferViewToData.forEach((h=>{d+=h.byteLength}));const m=new Dh(d),j=Array.from(this._bufferViewToData.keys()).sort(((h,d)=>Sh(d.byteLength)-Sh(h.byteLength)));for(const A of j){A.byteOffset=m.byteOffset,h.push(A);const d=h.length-1,j=this.getPropertiesWithBufferView(A);for(const h of j)h.bufferView=d;m.writeTypedArray(this._bufferViewToData.get(A)),this._bufferViewToData.delete(A)}return m.getOutputData()}createBufferView(h,d){const m={buffer:0,byteOffset:void 0,byteLength:h.byteLength,byteStride:d};return this._bufferViewToData.set(m,h),m}createAccessor(h,d,m,j,A,b,w){this._verifyBufferView(h);const a={bufferView:void 0,componentType:m,count:j,type:d,min:null===b||void 0===b?void 0:b.min,max:null===b||void 0===b?void 0:b.max,normalized:w,byteOffset:A};return this.setBufferView(a,h),this._accessorToBufferView.set(a,h),a}setBufferView(h,d){this._verifyBufferView(d);this.getPropertiesWithBufferView(d).push(h)}removeBufferView(h){const d=this.getPropertiesWithBufferView(h);for(const m of d)void 0!==m.bufferView&&delete m.bufferView;this._bufferViewToData.delete(h),this._bufferViewToProperties.delete(h),this._accessorToBufferView.forEach(((d,m)=>{d===h&&(void 0!==m.byteOffset&&delete m.byteOffset,this._accessorToBufferView.delete(m))}))}getBufferView(h){const d=this._accessorToBufferView.get(h);return this._verifyBufferView(d),d}getPropertiesWithBufferView(h){return this._verifyBufferView(h),this._bufferViewToProperties.set(h,this._bufferViewToProperties.get(h)??[]),this._bufferViewToProperties.get(h)}getData(h){return this._verifyBufferView(h),this._bufferViewToData.get(h)}_verifyBufferView(h){if(void 0===h||!this._bufferViewToData.has(h))throw new Error(`BufferView ${h} not found in BufferManager.`)}}var qh,Eh=m(11427),Ih=m(11457),Rh=m(11590),Zh=m(11711),Lh=m(11714),Bh=m(11728),Vh=m(11419),vh=m(11736);!function(h){h[h.INTANGENT=0]="INTANGENT",h[h.OUTTANGENT=1]="OUTTANGENT"}(qh||(qh={}));class Ch{static _IsTransformable(h){return h&&(h instanceof q.c||h instanceof Eh.e||h instanceof vh.d)}static _CreateNodeAnimation(h,d,m,j,b){if(this._IsTransformable(h)){const w=[],a=[],D=d.getKeys(),S=Ch._CalculateMinMaxKeyFrames(D),M=Ch._DeduceInterpolation(D,m,j),q=M.interpolationType,E=M.shouldBakeAnimation;if(E?Ch._CreateBakedAnimation(h,d,m,S.min,S.max,d.framePerSecond,b,w,a,S,j):"LINEAR"===q||"STEP"===q?Ch._CreateLinearOrStepAnimation(h,d,m,w,a,j):"CUBICSPLINE"===q?Ch._CreateCubicSplineAnimation(h,d,m,w,a,j):Ch._CreateBakedAnimation(h,d,m,S.min,S.max,d.framePerSecond,b,w,a,S,j),w.length&&a.length){return{inputs:w,outputs:a,samplerInterpolation:q,inputsMin:E?S.min:A.e.FloatRound(S.min/d.framePerSecond),inputsMax:E?S.max:A.e.FloatRound(S.max/d.framePerSecond)}}}return null}static _DeduceAnimationInfo(h){let d=null,m="VEC3",j=!1;const b=h.targetProperty.split(".");switch(b[0]){case"td":d="scale";break;case"position":d="translation";break;case"rotation":m="VEC4",d="rotation";break;case"rotationQuaternion":m="VEC4",j=!0,d="rotation";break;case"influence":m="SCALAR",d="weights";break;default:A.e.Error(`Unsupported animatable property ${b[0]}`)}return d?{animationChannelTargetPath:d,dataAccessorType:m,useQuaternion:j}:(A.e.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(h,d,m,j,A,b,w,a,D,S,M){let q;if(Ch._IsTransformable(h)&&h.animations)for(const E of h.animations){if(M&&!M(E))continue;const A=Ch._DeduceAnimationInfo(E);A&&(q={name:E.name,samplers:[],channels:[]},Ch._AddAnimation(`${E.name}`,E.hasRunningRuntimeAnimations?d:q,h,E,A.dataAccessorType,A.animationChannelTargetPath,j,b,w,a,A.useQuaternion,D,S),q.samplers.length&&q.channels.length&&m.push(q))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(h,d,m,j,A,b,w,a,D,S,M){let q;if(h instanceof Vh.d){const A=h.morphTargetManager;if(A)for(let E=0;E<A.numTargets;++E){const I=A.getTarget(E);for(const R of I.animations){if(M&&!M(R))continue;const I=new Lh.b(`${R.name}`,"influence",R.framePerSecond,R.dataType,R.loopMode,R.enableBlending),Z=[],L=R.getKeys();for(let h=0;h<L.length;++h){const d=L[h];for(let h=0;h<A.numTargets;++h)h==E?Z.push(d):Z.push({frame:d.frame,value:0})}I.setKeys(Z);const B=Ch._DeduceAnimationInfo(I);B&&(q={name:I.name,samplers:[],channels:[]},Ch._AddAnimation(R.name,R.hasRunningRuntimeAnimations?d:q,h,I,B.dataAccessorType,B.animationChannelTargetPath,j,b,w,a,B.useQuaternion,D,S,A.numTargets),q.samplers.length&&q.channels.length&&m.push(q))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(h,d,m,j,A,b,w,a,D){let S;if(h.animationGroups){const q=h.animationGroups;for(const E of q){const q=new Map,I=new Map,R=new Set,Z=E.to-E.from;S={name:E.name,channels:[],samplers:[]};for(let d=0;d<E.targetedAnimations.length;++d){const Z=E.targetedAnimations[d],L=Z.target,B=Z.animation;if(D&&!D(B))continue;const V=a.has(L);if(this._IsTransformable(L)||1===L.length&&this._IsTransformable(L[0])){const h=Ch._DeduceAnimationInfo(Z.animation);if(h){const d=this._IsTransformable(L)?L:this._IsTransformable(L[0])?L[0]:null;d&&Ch._AddAnimation(`${B.name}`,S,d,B,h.dataAccessorType,h.animationChannelTargetPath,m,j,A,b,h.useQuaternion,w,V)}}else if(L instanceof Bh.e||1===L.length&&L[0]instanceof Bh.e){if(Ch._DeduceAnimationInfo(Z.animation)){const d=L instanceof Bh.e?L:L[0];if(d){const m=h.morphTargetManagers.find((h=>{for(let m=0;m<h.numTargets;++m)if(h.getTarget(m)===d)return!0;return!1}));if(m){const j=h.meshes.find((h=>h.morphTargetManager===m));var M;if(j)q.has(j)||q.set(j,new Map),null===(M=q.get(j))||void 0===M||M.set(d,B),R.add(j),I.set(j,B)}}}}}R.forEach((h=>{const d=h.morphTargetManager;let a=null;const D=[],M=I.get(h).getKeys(),R=M.length;for(let m=0;m<R;++m)for(let j=0;j<d.numTargets;++j){const A=d.getTarget(j),b=q.get(h);if(b){const d=b.get(A);d?(a||(a=new Lh.b(`${E.name}_${h.name}_MorphWeightAnimation`,"influence",d.framePerSecond,Lh.b.ANIMATIONTYPE_FLOAT,d.loopMode,d.enableBlending)),D.push(d.getKeys()[m])):D.push({frame:E.from+Z/R*m,value:A.influence,inTangent:M[0].inTangent?0:void 0,outTangent:M[0].outTangent?0:void 0})}}a.setKeys(D);const L=Ch._DeduceAnimationInfo(a);L&&Ch._AddAnimation(`${E.name}_${h.name}_MorphWeightAnimation`,S,h,a,L.dataAccessorType,L.animationChannelTargetPath,m,j,A,b,L.useQuaternion,w,!1,null===d||void 0===d?void 0:d.numTargets)})),S.channels.length&&S.samplers.length&&d.push(S)}}}static _AddAnimation(h,d,m,A,b,w,a,D,S,M,q,E,I,R){const Z=Ch._CreateNodeAnimation(m,A,w,q,E);let L,B,V,v,C,T;if(Z){if(R){let h=0,d=0;const m=[];for(;Z.inputs.length>0;)d=Z.inputs.shift(),h%R==0&&m.push(d),h++;Z.inputs=m}const h=a.get(m),A=new Float32Array(Z.inputs);L=D.createBufferView(A),B=D.createAccessor(L,"SCALAR",5126,Z.inputs.length,void 0,{min:[Z.inputsMin],max:[Z.inputsMax]}),M.push(B),V=M.length-1;const S=new j.c,q=new j.i,E=new j.i,o=m instanceof Eh.e,y=p(b),i=new Float32Array(Z.outputs.length*y);Z.outputs.forEach((function(h,d){let m=h;switch(w){case"translation":I&&(j.i.FromArrayToRef(h,0,E),u(E),E.toArray(m));break;case"rotation":4===h.length?j.c.FromArrayToRef(h,0,S):(m=new Array(4),j.i.FromArrayToRef(h,0,q),j.c.FromEulerVectorToRef(q,S)),I&&(P(S),o&&G(S)),S.toArray(m)}i.set(m,d*y)})),L=D.createBufferView(i),B=D.createAccessor(L,b,5126,Z.outputs.length),M.push(B),v=M.length-1,C={interpolation:Z.samplerInterpolation,input:V,output:v},d.samplers.push(C),T={sampler:d.samplers.length-1,target:{node:h,path:w}},d.channels.push(T)}}static _CreateBakedAnimation(h,d,m,b,w,a,D,S,M,q,E){let I;const R=j.c.Identity();let Z,L=null,B=null,V=null,v=null,C=null,T=null;q.min=A.e.FloatRound(b/a);const o=d.getKeys();for(let j=0,y=o.length;j<y;++j){if(T=null,V=o[j],j+1<y)if(v=o[j+1],V.value.equals&&V.value.equals(v.value)||V.value===v.value){if(0!==j)continue;T=V.frame}else T=v.frame;else{if(C=o[j-1],V.value.equals&&V.value.equals(C.value)||V.value===C.value)continue;T=w}if(T)for(let j=V.frame;j<=T;j+=D){if(Z=A.e.FloatRound(j/a),Z===L)continue;L=Z,B=Z;const b={key:0,repeatCount:0,loopMode:d.loopMode};I=d._interpolate(j,b),Ch._SetInterpolatedValue(h,I,Z,d,m,R,S,M,E)}}B&&(q.max=B)}static _ConvertFactorToVector3OrQuaternion(h,d,m,b,w){const a=Ch._GetBasePositionRotationOrScale(d,b,w),D=m.targetProperty.split("."),S=D?D[1]:"",M=w?j.c.Ud(a).normalize():j.i.Ud(a);switch(S){case"x":case"y":case"z":M[S]=h;break;case"w":M.w=h;break;default:A.e.Error(`glTFAnimation: Unsupported component name "${S}"!`)}return M}static _SetInterpolatedValue(h,d,m,A,b,w,a,D,S){let M;a.push(m),"weights"!==b?(A.dataType===Lh.b.ANIMATIONTYPE_FLOAT&&(d=this._ConvertFactorToVector3OrQuaternion(d,h,A,b,S)),"rotation"===b?(S?w=d:(M=d,j.c.RotationYawPitchRollToRef(M.y,M.x,M.z,w)),D.push(w.fd())):(M=d,D.push(M.fd()))):D.push([d])}static _CreateLinearOrStepAnimation(h,d,m,j,A,b){for(const w of d.getKeys())j.push(w.frame/d.framePerSecond),Ch._AddKeyframeValue(w,d,A,m,h,b)}static _CreateCubicSplineAnimation(h,d,m,j,A,b){d.getKeys().forEach((function(w){j.push(w.frame/d.framePerSecond),Ch._AddSplineTangent(qh.INTANGENT,A,m,"CUBICSPLINE",w,b),Ch._AddKeyframeValue(w,d,A,m,h,b),Ch._AddSplineTangent(qh.OUTTANGENT,A,m,"CUBICSPLINE",w,b)}))}static _GetBasePositionRotationOrScale(h,d,m){let A;if("rotation"===d)if(m){A=(h.rotationQuaternion??j.c.Identity()).fd()}else{A=(h.rotation??j.i.Zero()).fd()}else if("translation"===d){A=(h.position??j.i.Zero()).fd()}else{A=(h.td??j.i.One()).fd()}return A}static _AddKeyframeValue(h,d,m,b,w,a){let D;const S=d.dataType;if(S===Lh.b.ANIMATIONTYPE_VECTOR3){let d=h.value.fd();if("rotation"===b){const h=j.i.Ud(d);d=j.c.RotationYawPitchRoll(h.y,h.x,h.z).fd()}m.push(d)}else if(S===Lh.b.ANIMATIONTYPE_FLOAT){if("weights"===b)m.push([h.value]);else if(D=this._ConvertFactorToVector3OrQuaternion(h.value,w,d,b,a),D){if("rotation"===b){const h=a?D:j.c.RotationYawPitchRoll(D.y,D.x,D.z).normalize();m.push(h.fd())}m.push(D.fd())}}else S===Lh.b.ANIMATIONTYPE_QUATERNION?m.push(h.value.normalize().fd()):A.e.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(h,d,m){let j,A,b=!1;if("rotation"===d&&!m)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let w=0,a=h.length;w<a;++w)if(A=h[w],A.inTangent||A.outTangent)if(j){if("CUBICSPLINE"!==j){j="LINEAR",b=!0;break}}else j="CUBICSPLINE";else if(j){if("CUBICSPLINE"===j||A.interpolation&&1===A.interpolation&&"STEP"!==j){j="LINEAR",b=!0;break}}else j=A.interpolation&&1===A.interpolation?"STEP":"LINEAR";return j||(j="LINEAR"),{interpolationType:j,shouldBakeAnimation:b}}static _AddSplineTangent(h,d,m,A,b,w){let a;const D=h===qh.INTANGENT?b.inTangent:b.outTangent;if("CUBICSPLINE"===A){if("rotation"===m)if(D)if(w)a=D.fd();else{const h=D;a=j.c.RotationYawPitchRoll(h.y,h.x,h.z).fd()}else a=[0,0,0,0];else a="weights"===m?D?[D]:[0]:D?D.fd():[0,0,0];d.push(a)}}static _CalculateMinMaxKeyFrames(h){let d=1/0,m=-1/0;return h.forEach((function(h){d=Math.min(d,h.frame),m=Math.max(m,h.frame)})),{min:d,max:m}}}function Th(h,d,m,b,w,a){const D={attributes:{},influence:h.influence,name:h.name},S=d.Ld;if(!S)return A.e.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),D;const q=a?-1:1,E=j.i.Zero();let I=0,R=0;if(h.hasPositions){const b=h.getPositions(),a=S.getVerticesData(M.d.PositionKind);if(a){const h=new Float32Array(a.length),d=[1/0,1/0,1/0],A=[-1/0,-1/0,-1/0];R=a.length/3,I=0;for(let m=I;m<R;++m){const w=j.i.Ud(a,3*m);j.i.Ud(b,3*m).subtractToRef(w,E),E.x*=q,d[0]=Math.min(d[0],E.x),A[0]=Math.max(A[0],E.x),d[1]=Math.min(d[1],E.y),A[1]=Math.max(A[1],E.y),d[2]=Math.min(d[2],E.z),A[2]=Math.max(A[2],E.z),h[3*m]=E.x,h[3*m+1]=E.y,h[3*m+2]=E.z}const S=m.createBufferView(h,12),M=m.createAccessor(S,"VEC3",5126,b.length/3,0,{min:d,max:A});w.push(M),D.attributes.POSITION=w.length-1}else A.e.Warn(`Morph target positions for mesh ${d.name} were not exported. Mesh does not have position vertex data`)}if(h.hasNormals){const b=h.getNormals(),a=S.getVerticesData(M.d.NormalKind);if(a){const h=new Float32Array(a.length);R=a.length/3,I=0;for(let m=I;m<R;++m){const d=j.i.Ud(a,3*m).normalize();j.i.Ud(b,3*m).normalize().subtractToRef(d,E),h[3*m]=E.x*q,h[3*m+1]=E.y,h[3*m+2]=E.z}const d=m.createBufferView(h,12),A=m.createAccessor(d,"VEC3",5126,b.length/3,0);w.push(A),D.attributes.NORMAL=w.length-1}else A.e.Warn(`Morph target normals for mesh ${d.name} were not exported. Mesh does not have normals vertex data`)}if(h.hasTangents){const b=h.getTangents(),a=S.getVerticesData(M.d.TangentKind);if(a){R=a.length/4;const h=new Float32Array(3*R);I=0;for(let m=I;m<R;++m){const d=j.i.Ud(a,4*m);z(d);const A=j.i.Ud(b,3*m);z(A),A.subtractToRef(d,E),h[3*m]=E.x*q,h[3*m+1]=E.y,h[3*m+2]=E.z}const d=m.createBufferView(h,12),A=m.createAccessor(d,"VEC3",5126,R,0);w.push(A),D.attributes.TANGENT=w.length-1}else A.e.Warn(`Morph target tangents for mesh ${d.name} were not exported. Mesh does not have tangents vertex data`)}if(h.hasColors){const b=h.getColors(),a=S.getVerticesData(M.d.ColorKind),q=S.getVertexBuffer(M.d.ColorKind);if(a&&q){const h=q.getSize();R=a.length/h;const d=new Float32Array(R*h);I=0;for(let m=I;m<R;++m)if(3===h){const A=j.i.Ud(a,m*h);j.i.Ud(b,m*h).subtractToRef(A,E),d[3*m]=E.x,d[3*m+1]=E.y,d[3*m+2]=E.z}else if(4===h){const A=new j.m,w=j.m.Ud(a,m*h);j.m.Ud(b,m*h).subtractToRef(w,A),d[4*m]=A.x,d[4*m+1]=A.y,d[4*m+2]=A.z,d[4*m+3]=A.w}else A.e.Warn(`Unsupported number of components for color attribute: ${h}`);const S=m.createBufferView(d,4*h),M=m.createAccessor(S,3===h?"VEC3":"VEC4",5126,R,0);w.push(M),D.attributes.COLOR_0=w.length-1}else A.e.Warn(`Morph target colors for mesh ${d.name} were not exported. Mesh does not have colors vertex data`)}return D}var oh=m(11740),yh=m(11651),ih=m(11647),gh=m(11080);class Fh{}Fh.DEFAULT_COLOR=L.d.White(),Fh.DEFAULT_WIDTH_ATTENUATED=1,Fh.DEFAULT_WIDTH=.1;var fh=m(11526),Hh=m(11752);class ch{static ConvertPoints(h,d){if(h.length&&Array.isArray(h)&&"number"===typeof h[0])return[h];if(h.length&&Array.isArray(h[0])&&"number"===typeof h[0][0])return h;if(h.length&&!Array.isArray(h[0])&&h[0]instanceof j.i){const d=[];for(let m=0;m<h.length;m++){const j=h[m];d.push(j.x,j.y,j.z)}return[d]}if(h.length>0&&Array.isArray(h[0])&&h[0].length>0&&h[0][0]instanceof j.i){const d=[],m=h;for(const h of m)d.push(h.flatMap((h=>[h.x,h.y,h.z])));return d}if(h instanceof Float32Array){if(null!==d&&void 0!==d&&d.floatArrayStride){const m=[],j=3*d.floatArrayStride;for(let d=0;d<h.length;d+=j){const A=new Array(j);for(let m=0;m<j;m++)A[m]=h[d+m];m.push(A)}return m}return[Array.from(h)]}if(h.length&&h[0]instanceof Float32Array){const d=[];for(const m of h)d.push(Array.from(m));return d}return[]}static OmitZeroLengthPredicate(h,d,m){const j=[];return d.fm(h).lengthSquared()>0&&j.push([h,d]),m.fm(d).lengthSquared()>0&&j.push([d,m]),h.fm(m).lengthSquared()>0&&j.push([m,h]),0===j.length?null:j}static OmitDuplicatesPredicate(h,d,m,j){const A=[];return ch._SearchInPoints(h,d,j)||A.push([h,d]),ch._SearchInPoints(d,m,j)||A.push([d,m]),ch._SearchInPoints(m,h,j)||A.push([m,h]),0===A.length?null:A}static _SearchInPoints(h,d,m){for(const w of m)for(let m=0;m<w.length;m++){var j,A,b;if(null!==(j=w[m])&&void 0!==j&&j.equals(h))if(null!==(A=w[m+1])&&void 0!==A&&A.equals(d)||null!==(b=w[m-1])&&void 0!==b&&b.equals(d))return!0}return!1}static MeshesToLines(h,d){const m=[];for(let A=0;A<h.length;A++){const b=h[A],w=b.getVerticesData(M.d.PositionKind),a=b.Vd();if(w&&a)for(let h=0,D=0;h<a.length;h++){const S=3*a[D++],M=3*a[D++],q=3*a[D++],E=new j.i(w[S],w[S+1],w[S+2]),I=new j.i(w[M],w[M+1],w[M+2]),R=new j.i(w[q],w[q+1],w[q+2]);if(d){const j=d(E,I,R,m,h,S,b,A,w,a);if(j)for(const h of j)m.push(h)}else m.push([E,I],[I,R],[R,E])}}return m}static ToVector3Array(h){if(Array.isArray(h[0])){const d=[],m=h;for(const h of m){const m=[];for(let d=0;d<h.length;d+=3)m.push(new j.i(h[d],h[d+1],h[d+2]));d.push(m)}return d}const d=h,m=[];for(let A=0;A<d.length;A+=3)m.push(new j.i(d[A],d[A+1],d[A+2]));return m}static ToNumberArray(h){return h.flatMap((h=>[h.x,h.y,h.z]))}static GetPointsCountInfo(h){const d=new Array(h.length);let m=0;for(let j=h.length;j--;)d[j]=h[j].length/3,m+=d[j];return{total:m,counts:d}}static GetLineLength(h){if(0===h.length)return 0;let d;d="number"===typeof h[0]?ch.ToVector3Array(h):h;const m=j.d.Qd[0];let A=0;for(let j=0;j<d.length-1;j++){const h=d[j];A+=d[j+1].subtractToRef(h,m).length()}return A}static GetLineLengthArray(h){const d=new Float32Array(h.length/3);let m=0;for(let j=0,A=h.length/3-1;j<A;j++){let A=h[3*j+0],b=h[3*j+1],w=h[3*j+2];A-=h[3*j+3],b-=h[3*j+4],w-=h[3*j+5];m+=Math.sqrt(A*A+b*b+w*w),d[j+1]=m}return d}static SegmentizeSegmentByCount(h,d,m){const A=[],b=d.fm(h),w=j.d.Qd[0];w.sd(m);const a=j.d.Qd[1];b.divideToRef(w,a);let D=h.clone();A.push(D);for(let j=0;j<m;j++)D=D.clone(),A.push(D.addInPlace(a));return A}static SegmentizeLineBySegmentLength(h,d){const m=h[0]instanceof j.i?ch.GetLineSegments(h):"number"===typeof h[0]?ch.GetLineSegments(ch.ToVector3Array(h)):h,A=[];for(const j of m)if(j.length>d){const h=ch.SegmentizeSegmentByCount(j.point1,j.point2,Math.ceil(j.length/d));for(const d of h)A.push(d)}else A.push(j.point1),A.push(j.point2);return A}static SegmentizeLineBySegmentCount(h,d){const m="number"===typeof h[0]?ch.ToVector3Array(h):h,j=ch.GetLineLength(m)/d;return ch.SegmentizeLineBySegmentLength(m,j)}static GetLineSegments(h){const d=[];for(let m=0;m<h.length-1;m++){const j=h[m],A=h[m+1],b=A.fm(j).length();d.push({point1:j,point2:A,length:b})}return d}static GetMinMaxSegmentLength(h){const d=ch.GetLineSegments(h).sort((h=>h.length));return{min:d[0].length,max:d[d.length-1].length}}static GetPositionOnLineByVisibility(h,d,m){let A=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const b=d*m;let w=0,a=0;const D=h.length;for(let j=0;j<D;j++){if(b<=w+h[j].length){a=j;break}w+=h[j].length}const S=(b-w)/h[a].length;return h[a].point2.subtractToRef(h[a].point1,j.d.Qd[0]),j.d.Qd[1]=j.d.Qd[0].multiplyByFloats(S,S,S),A||j.d.Qd[1].addInPlace(h[a].point1),j.d.Qd[1].clone()}static GetCircleLinePoints(h,d){let m=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:h,b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/d;const w=[];for(let a=0;a<=d;a++)w.push(new j.i(Math.cos(a*b)*h,Math.sin(a*b)*A,m));return w}static GetBezierLinePoints(h,d,m,j){return fh.d.CreateQuadraticBezier(h,d,m,j).getPoints().flatMap((h=>[h.x,h.y,h.z]))}static GetArrowCap(h,d,m,j,A){let b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,w=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[h.clone(),h.add(d.multiplyByFloats(m,m,m))],widths:[j,A,b,w]}}static GetPointsFromText(h,d,m,j){let A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,b=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const w=[],a=(0,Hh.c)(h,d,m,j);for(const D of a){for(const h of D.paths){const d=[],m=h.getPoints();for(const h of m)d.push(h.x,h.y,A);w.push(d)}if(b)for(const h of D.holes){const d=[],m=h.getPoints();for(const h of m)d.push(h.x,h.y,A);w.push(d)}}return w}static Color3toRGBAUint8(h){const d=new Uint8Array(4*h.length);for(let m=0,j=0;m<h.length;m++)d[j++]=255*h[m].r,d[j++]=255*h[m].g,d[j++]=255*h[m].b,d[j++]=255;return d}static CreateColorsTexture(h,d,m,j){const A=j.getEngine().getCaps().maxTextureSize??1,b=d.length>A?A:d.length,w=Math.ceil(d.length/A);w>1&&(d=[...d,...Array(b*w-d.length).fill(d[0])]);const a=ch.Color3toRGBAUint8(d),D=new o.b(a,b,w,R.b.TEXTUREFORMAT_RGBA,j,!1,!0,m);return D.name=h,D}static PrepareEmptyColorsTexture(h){if(!Fh.EmptyColorsTexture){const d=new Uint8Array(4);Fh.EmptyColorsTexture=new o.b(d,1,1,R.b.TEXTUREFORMAT_RGBA,h,!1,!1,o.b.NEAREST_NEAREST),Fh.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Fh.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var h;null===(h=Fh.EmptyColorsTexture)||void 0===h||h.dispose(),Fh.EmptyColorsTexture=null}static BooleanToNumber(h){return h?1:0}}class kh extends ih.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class lh extends yh.c{isCompatible(h){return!0}constructor(h,d,m){var A;m=m||{color:Fh.DEFAULT_COLOR};const b=new kh;b.GREASED_LINE_HAS_COLOR=!!m.color&&!m.useColors,b.GREASED_LINE_SIZE_ATTENUATION=m.sizeAttenuation??!1,b.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===m.colorDistributionType,b.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(d??h.ih()).useRightHandedSystem,b.GREASED_LINE_CAMERA_FACING=m.cameraFacing??!0,super(h,lh.GREASED_LINE_MATERIAL_NAME,200,b,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(A=m)||void 0===A?void 0:A.forceGLSL)||lh.ForceGLSL,this._scene=d??h.ih(),this._engine=this._scene.getEngine(),this._cameraFacing=m.cameraFacing??!0,this.visibility=m.visibility??1,this.useDash=m.useDash??!1,this.dashRatio=m.dashRatio??.5,this.dashOffset=m.dashOffset??0,this.width=m.width?m.width:m.sizeAttenuation?Fh.DEFAULT_WIDTH_ATTENUATED:Fh.DEFAULT_WIDTH,this._sizeAttenuation=m.sizeAttenuation??!1,this.colorMode=m.colorMode??0,this._color=m.color??null,this.useColors=m.useColors??!1,this._colorsDistributionType=m.colorDistributionType??0,this.colorsSampling=m.colorsSampling??o.b.NEAREST_NEAREST,this._colors=m.Hh??null,this.dashCount=m.dashCount??1,this.resolution=m.resolution??new j.h(this._engine.getRenderWidth(),this._engine.getRenderHeight()),m.colorsTexture?this.colorsTexture=m.colorsTexture:this._colors?this.colorsTexture=ch.CreateColorsTexture(`${h.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Fh.DEFAULT_COLOR,ch.PrepareEmptyColorsTexture(this._scene)),this._engine.pd.add((()=>{ch.DisposeEmptyColorsTexture()}))}getAttributes(h){h.push("grl_offsets"),h.push("grl_widths"),h.push("grl_colorPointers"),h.push("grl_counters"),this._cameraFacing?(h.push("grl_previousAndSide"),h.push("grl_nextAndCounters")):h.push("grl_slopes")}getSamplers(h){h.push("grl_colors")}getActiveTextures(h){this.colorsTexture&&h.push(this.colorsTexture)}getUniforms(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const d=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&d.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===h&&d.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:d,vertex:this._cameraFacing&&this._isGLSL(h)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(h)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(h){if(this._cameraFacing){h.hb("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||h.hb("viewProjection",this._scene.getTransformMatrix());const d=j.d.Vector4[0];d.x=this._aspect,d.y=this._resolution.x,d.z=this._resolution.y,d.w=this.width,h.updateVector4("grl_aspect_resolution_lineWidth",d)}const d=j.d.Vector4[0];d.x=ch.BooleanToNumber(this.useDash),d.y=this._dashArray,d.z=this.dashOffset,d.w=this.dashRatio,h.updateVector4("grl_dashOptions",d);const m=j.d.Vector4[1];m.x=this.colorMode,m.y=this.visibility,m.z=this.colorsTexture?this.colorsTexture.getSize().width:0,m.w=ch.BooleanToNumber(this.useColors),h.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",m),this._color&&h.updateColor3("grl_singleColor",this._color);const A=this.colorsTexture??Fh.EmptyColorsTexture;h.setTexture("grl_colors",A),h.updateFloat2("grl_textureSize",(null===A||void 0===A?void 0:A.getSize().width)??1,(null===A||void 0===A?void 0:A.getSize().height)??1)}prepareDefines(h,d,m){h.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,h.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,h.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,h.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=d.useRightHandedSystem,h.GREASED_LINE_CAMERA_FACING=this._cameraFacing,h.GREASED_LINE_USE_OFFSETS=!!m.offsets}getClassName(){return lh.GREASED_LINE_MATERIAL_NAME}getCustomCode(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(d)?function(h,d){if("vertex"===h){const h={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return d&&(h["!gl_Position\\=viewProjection\\*worldPos;"]="//"),h}return"fragment"===h?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(h,this._cameraFacing):function(h,d){if("vertex"===h){const h={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return d&&(h["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),h}return"fragment"===h?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(h,this._cameraFacing)}dispose(){var h;null===(h=this.colorsTexture)||void 0===h||h.dispose(),super.dispose()}get Hh(){return this._colors}set Hh(h){this.setColors(h)}setColors(h){var d;let m=arguments.length>1&&void 0!==arguments[1]&&arguments[1],j=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const A=(null===(d=this._colors)||void 0===d?void 0:d.length)??0;var b;if(this._colors=h,null!==h&&0!==h.length){if(!m||j)if(this.colorsTexture&&A===h.length&&!j){const d=ch.Color3toRGBAUint8(h);this.colorsTexture.update(d)}else{var w;null===(w=this.colorsTexture)||void 0===w||w.dispose(),this.colorsTexture=ch.CreateColorsTexture(`${this._material.name}-colors-texture`,h,this.colorsSampling,this._scene)}}else null===(b=this.colorsTexture)||void 0===b||b.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(h){this._dashCount=h,this._dashArray=1/h}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(h){this._sizeAttenuation=h,this.markAllDefinesAsDirty()}get color(){return this._color}set color(h){this.setColor(h)}setColor(h){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==h||null!==this._color&&null===h?(this._color=h,d||this.markAllDefinesAsDirty()):this._color=h}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(h){this._colorsDistributionType=h,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(h){this._aspect=h.x/h.y,this._resolution=h}serialize(){const h=super.serialize(),d={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(d.Hh=this._colors),this._color&&(d.color=this._color),h.greasedLineMaterialOptions=d,h}parse(h,d,m){var j;super.parse(h,d,m);const A=h.greasedLineMaterialOptions;null===(j=this.colorsTexture)||void 0===j||j.dispose(),A.color&&this.setColor(A.color,!0),A.colorDistributionType&&(this.colorsDistributionType=A.colorDistributionType),A.Hh&&(this.Hh=A.Hh),A.colorsSampling&&(this.colorsSampling=A.colorsSampling),A.colorMode&&(this.colorMode=A.colorMode),A.useColors&&(this.useColors=A.useColors),A.visibility&&(this.visibility=A.visibility),A.useDash&&(this.useDash=A.useDash),A.dashCount&&(this.dashCount=A.dashCount),A.dashRatio&&(this.dashRatio=A.dashRatio),A.dashOffset&&(this.dashOffset=A.dashOffset),A.width&&(this.width=A.width),A.sizeAttenuation&&(this.sizeAttenuation=A.sizeAttenuation),A.resolution&&(this.resolution=A.resolution),this.Hh?this.colorsTexture=ch.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Hh,this.colorsSampling,d):ch.PrepareEmptyColorsTexture(d),this.markAllDefinesAsDirty()}copyTo(h){var d;const m=h;null===(d=m.colorsTexture)||void 0===d||d.dispose(),this._colors&&(m.colorsTexture=ch.CreateColorsTexture(`${m._material.name}-colors-texture`,this._colors,m.colorsSampling,this._scene)),m.setColor(this.color,!0),m.colorsDistributionType=this.colorsDistributionType,m.colorsSampling=this.colorsSampling,m.colorMode=this.colorMode,m.useColors=this.useColors,m.visibility=this.visibility,m.useDash=this.useDash,m.dashCount=this.dashCount,m.dashRatio=this.dashRatio,m.dashOffset=this.dashOffset,m.width=this.width,m.sizeAttenuation=this.sizeAttenuation,m.resolution=this.resolution,m.markAllDefinesAsDirty()}_isGLSL(h){return 0===h||this._forceGLSL}}lh.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",lh.ForceGLSL=!1,(0,gh.i)(`BABYLON.${lh.GREASED_LINE_MATERIAL_NAME}`,lh);var Kh=m(11388),Nh=m(11126),Wh=m(11747),rh=m(11223);class Yh extends Wh.b{constructor(h,d,A){const b=d.getEngine(),w=b.isWebGPU&&!(A.forceGLSL||Yh.ForceGLSL),a=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];d.useRightHandedSystem&&a.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const D=["position","grl_widths","grl_offsets","grl_colorPointers"];A.cameraFacing?(a.push("GREASED_LINE_CAMERA_FACING"),D.push("grl_previousAndSide","grl_nextAndCounters")):(D.push("grl_slopes"),D.push("grl_counters"));const S=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(w||S.push("world","viewProjection","view","projection"),super(h,d,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:w?["Scene","Mesh"]:void 0,attributes:D,uniforms:S,samplers:w?[]:["grlColors"],defines:a,extraInitializationsAsync:async()=>{w?await Promise.all([m.e(47).then(m.bind(m,14006)),m.e(55).then(m.bind(m,14013))]):await Promise.all([m.e(50).then(m.bind(m,14021)),m.e(56).then(m.bind(m,14029))])},shaderLanguage:w?1:0}),this._color=L.d.White(),this._colorsDistributionType=0,this._colorsTexture=null,A=A||{color:Fh.DEFAULT_COLOR},this.visibility=A.visibility??1,this.useDash=A.useDash??!1,this.dashRatio=A.dashRatio??.5,this.dashOffset=A.dashOffset??0,this.dashCount=A.dashCount??1,this.width=A.width?A.width:A.sizeAttenuation&&A.cameraFacing?Fh.DEFAULT_WIDTH_ATTENUATED:Fh.DEFAULT_WIDTH,this.sizeAttenuation=A.sizeAttenuation??!1,this.color=A.color??L.d.White(),this.useColors=A.useColors??!1,this.colorsDistributionType=A.colorDistributionType??0,this.colorsSampling=A.colorsSampling??o.b.NEAREST_NEAREST,this.colorMode=A.colorMode??0,this._colors=A.Hh??null,this._cameraFacing=A.cameraFacing??!0,this.resolution=A.resolution??new j.h(b.getRenderWidth(),b.getRenderHeight()),A.colorsTexture?this.colorsTexture=A.colorsTexture:this._colors?this.colorsTexture=ch.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,d):(this._color=this._color??Fh.DEFAULT_COLOR,this.colorsTexture=ch.PrepareEmptyColorsTexture(d)),w){const h=new rh.c;h.setParameters(),h.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",h)}b.pd.add((()=>{ch.DisposeEmptyColorsTexture()}))}dispose(){var h;null===(h=this._colorsTexture)||void 0===h||h.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new j.h(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Hh(){return this._colors}set Hh(h){this.setColors(h)}setColors(h){var d;let m=arguments.length>1&&void 0!==arguments[1]&&arguments[1],j=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const A=(null===(d=this._colors)||void 0===d?void 0:d.length)??0;var b;if(this._colors=h,null!==h&&0!==h.length){if(!m||j)if(this._colorsTexture&&A===h.length&&!j){const d=ch.Color3toRGBAUint8(h);this._colorsTexture.update(d)}else{var w;null===(w=this._colorsTexture)||void 0===w||w.dispose(),this.colorsTexture=ch.CreateColorsTexture(`${this.name}-colors-texture`,h,this.colorsSampling,this.ih())}}else null===(b=this._colorsTexture)||void 0===b||b.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(h){this._colorsTexture=h,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(h){this._width=h,this.setFloat("grlWidth",h)}get useColors(){return this._useColors}set useColors(h){this._useColors=h,this.setFloat("grlUseColors",ch.BooleanToNumber(h))}get colorsSampling(){return this._colorsSampling}set colorsSampling(h){this._colorsSampling=h}get visibility(){return this._visibility}set visibility(h){this._visibility=h,this.setFloat("grlVisibility",h)}get useDash(){return this._useDash}set useDash(h){this._useDash=h,this.setFloat("grlUseDash",ch.BooleanToNumber(h))}get dashOffset(){return this._dashOffset}set dashOffset(h){this._dashOffset=h,this.setFloat("grlDashOffset",h)}get dashRatio(){return this._dashRatio}set dashRatio(h){this._dashRatio=h,this.setFloat("grlDashRatio",h)}get dashCount(){return this._dashCount}set dashCount(h){this._dashCount=h,this._dashArray=1/h,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(h){this._sizeAttenuation=h,this.setFloat("grlSizeAttenuation",ch.BooleanToNumber(h))}get color(){return this._color}set color(h){this.setColor(h)}setColor(h){h=h??Fh.DEFAULT_COLOR,this._color=h,this.setColor3("grlColor",h)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(h){this._colorsDistributionType=h,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(h){this._colorMode=h,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(h){this._resolution=h,this.setVector2("grlResolution",h),this.setFloat("grlAspect",h.x/h.y)}serialize(){const h=super.serialize(),d={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(d.Hh=this._colors),h.greasedLineMaterialOptions=d,h}parse(h,d,m){var j;const A=h.greasedLineMaterialOptions;null===(j=this._colorsTexture)||void 0===j||j.dispose(),A.color&&(this.color=A.color),A.colorDistributionType&&(this.colorsDistributionType=A.colorDistributionType),A.colorsSampling&&(this.colorsSampling=A.colorsSampling),A.colorMode&&(this.colorMode=A.colorMode),A.useColors&&(this.useColors=A.useColors),A.visibility&&(this.visibility=A.visibility),A.useDash&&(this.useDash=A.useDash),A.dashCount&&(this.dashCount=A.dashCount),A.dashRatio&&(this.dashRatio=A.dashRatio),A.dashOffset&&(this.dashOffset=A.dashOffset),A.width&&(this.width=A.width),A.sizeAttenuation&&(this.sizeAttenuation=A.sizeAttenuation),A.resolution&&(this.resolution=A.resolution),A.Hh?this.colorsTexture=ch.CreateColorsTexture(`${this.name}-colors-texture`,A.Hh,this.colorsSampling,this.ih()):this.colorsTexture=ch.PrepareEmptyColorsTexture(d),this._cameraFacing=A.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var xh,Qh,th;Yh.ForceGLSL=!1,function(h){h[h.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",h[h.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(xh||(xh={})),function(h){h[h.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",h[h.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",h[h.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Qh||(Qh={})),function(h){h[h.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",h[h.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",h[h.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",h[h.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",h[h.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(th||(th={}));class Uh extends Vh.d{constructor(h,d,m){super(h,d,null,null,!1,!1),this.name=h,this._options=m,this._lazy=!1,this._updatable=!1,this._engine=d.getEngine(),this._lazy=m.lazy??!1,this._updatable=m.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=m.colorPointers??[],this._widths=m.widths??new Array(m.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(h){let d=0;for(const j of this._points)d+=j.length;const m=d/3*2-this._widths.length;for(let j=0;j<m;j++)this._widths.push(h)}updateLazy(){var h,d;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(h=this._options.ribbonOptions)||void 0===h?void 0:h.smoothShading),!this.Wh&&this.refreshBoundingInfo(),null===(d=this.greasedLineMaterial)||void 0===d||d.updateLazy()}addPoints(h,d){for(const m of h)this._points.push(m);this._lazy||this.setPoints(this._points,d)}dispose(h){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(h,d)}isLazy(){return this._lazy}get kh(){return this._uvs}set kh(h){this._uvs=h instanceof Float32Array?h:new Float32Array(h),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(h){this.material instanceof Yh&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===h||void 0===h?void 0:h.length)>0),this._offsets=h,this._offsetsBuffer?this._offsetsBuffer.update(h):this._createOffsetsBuffer(h)}get widths(){return this._widths}set widths(h){this._widths=h,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(h)}get colorPointers(){return this._colorPointers}set colorPointers(h){this._colorPointers=h,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(h)}get greasedLineMaterial(){var h,d;if(this.material&&this.material instanceof Yh)return this.material;const m=null===(h=this.material)||void 0===h||null===(d=h.pluginManager)||void 0===d?void 0:d.getPlugin(lh.GREASED_LINE_MATERIAL_NAME);return m||void 0}get points(){const h=[];return Nh.e.DeepCopy(this._points,h),h}setPoints(h,d){this._points=ch.ConvertPoints(h,(null===d||void 0===d?void 0:d.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==d&&void 0!==d&&d.colorPointers||this._updateColorPointers(),this._setPoints(this._points,d)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,kh:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(h){super.serialize(h),h.type=this.getClassName(),h.lineOptions=this._createLineOptions()}_createVertexBuffers(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new Kh.c;return d.Fh=this._vertexPositions,d.indices=this._indices,d.kh=this._uvs,h&&(d.fh=[],Kh.c.ComputeNormals(this._vertexPositions,this._indices,d.fh)),d.Nh(this,this._options.updatable),d}_createOffsetsBuffer(h){const d=this._scene.getEngine(),m=new M.c(d,h,this._updatable,3);this.setVerticesBuffer(m.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=m}}class sh{constructor(h,d){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=h,this.wasAddedByNoopNode=d}getIndicesAccessor(h,d,m,j,A){var b,w,a,D;return null===(b=this._indicesAccessorMap.get(h))||void 0===b||null===(w=b.get(d))||void 0===w||null===(a=w.get(m))||void 0===a||null===(D=a.get(j))||void 0===D?void 0:D.get(A)}setIndicesAccessor(h,d,m,j,A,b){let w=this._indicesAccessorMap.get(h);w||(w=new Map,this._indicesAccessorMap.set(h,w));let a=w.get(d);a||(a=new Map,w.set(d,a));let D=a.get(m);D||(D=new Map,a.set(m,D));let S=D.get(j);S||(S=new Map,D.set(j,S)),S.set(A,b)}pushExportedNode(h){this._exportedNodes.has(h)||this._exportedNodes.add(h)}getNodesSet(){return this._exportedNodes}getVertexBufferView(h){return this._vertexBufferViewMap.get(h)}setVertexBufferView(h,d){this._vertexBufferViewMap.set(h,d)}setRemappedBufferView(h,d,m){this._remappedBufferView.set(h,new Map),this._remappedBufferView.get(h).set(d,m)}getRemappedBufferView(h,d){var m;return null===(m=this._remappedBufferView.get(h))||void 0===m?void 0:m.get(d)}getVertexAccessor(h,d,m){var j,A;return null===(j=this._vertexAccessorMap.get(h))||void 0===j||null===(A=j.get(d))||void 0===A?void 0:A.get(m)}setVertexAccessor(h,d,m,j){let A=this._vertexAccessorMap.get(h);A||(A=new Map,this._vertexAccessorMap.set(h,A));let b=A.get(d);b||(b=new Map,A.set(d,b)),b.set(m,j)}hasVertexColorAlpha(h){return this._vertexMapColorAlpha.get(h)||!1}setHasVertexColorAlpha(h,d){return this._vertexMapColorAlpha.set(h,d)}getMesh(h){return this._meshMap.get(h)}setMesh(h,d){this._meshMap.set(h,d)}bindMorphDataToMesh(h,d){const m=this._meshMorphTargetMap.get(h)||[];this._meshMorphTargetMap.set(h,m),-1===m.indexOf(d)&&m.push(d)}getMorphTargetsFromMesh(h){return this._meshMorphTargetMap.get(h)}}class Jh{_ApplyExtension(h,d,m,j){if(m>=d.length)return Promise.resolve(h);const A=j(d[m],h);return A?A.then((async h=>h?await this._ApplyExtension(h,d,m+1,j):null)):this._ApplyExtension(h,d,m+1,j)}_ApplyExtensions(h,d){const m=[];for(const j of Jh._ExtensionNames)m.push(this._extensions[j]);return this._ApplyExtension(h,m,0,d)}_extensionsPreExportTextureAsync(h,d,m){return this._ApplyExtensions(d,((d,j)=>d.preExportTextureAsync&&d.preExportTextureAsync(h,j,m)))}_extensionsPostExportNodeAsync(h,d,m,j,A){return this._ApplyExtensions(d,((d,b)=>d.postExportNodeAsync&&d.postExportNodeAsync(h,b,m,j,A,this._bufferManager)))}_extensionsPostExportMaterialAsync(h,d,m){return this._ApplyExtensions(d,((d,j)=>d.postExportMaterialAsync&&d.postExportMaterialAsync(h,j,m)))}_extensionsPostExportMaterialAdditionalTextures(h,d,m){const j=[];for(const A of Jh._ExtensionNames){const b=this._extensions[A];b.postExportMaterialAdditionalTextures&&j.push(...b.postExportMaterialAdditionalTextures(h,d,m))}return j}_extensionsPostExportTextures(h,d,m){for(const j of Jh._ExtensionNames){const A=this._extensions[j];A.postExportTexture&&A.postExportTexture(h,d,m)}}_extensionsPostExportMeshPrimitive(h){for(const d of Jh._ExtensionNames){const m=this._extensions[d];m.postExportMeshPrimitive&&m.postExportMeshPrimitive(h,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const h of Jh._ExtensionNames){const d=this._extensions[h];d.preGenerateBinaryAsync&&await d.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(h){for(const d of Jh._ExtensionNames){const m=this._extensions[d];m.enabled&&h(m)}}_extensionsOnExporting(){this._forEachExtensions((h=>{var d,m,j;h.wasUsed&&((d=this._glTF).extensionsUsed||(d.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(h.name)&&this._glTF.extensionsUsed.push(h.name),h.required&&((m=this._glTF).extensionsRequired||(m.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(h.name)&&this._glTF.extensionsRequired.push(h.name)),(j=this._glTF).extensions||(j.extensions={}),h.onExporting&&h.onExporting())}))}_loadExtensions(){for(const h of Jh._ExtensionNames){const d=Jh._ExtensionFactories[h](this);this._extensions[h]=d}}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Z.b.LastCreatedScene,d=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${R.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new r(this),this._extensions={},this._bufferManager=new Mh,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!h)throw new Error("No scene available to export");this._babylonScene=h,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:h=>{var d;return null===h||void 0===h||null===(d=h.mb)||void 0===d?void 0:d.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...d},this._loadExtensions()}dispose(){for(const h in this._extensions){this._extensions[h].dispose()}}get options(){return this._options}static RegisterExtension(h,d){Jh.UnregisterExtension(h)&&A.e.Warn(`Extension with the name ${h} already exists`),Jh._ExtensionFactories[h]=d,Jh._ExtensionNames.push(h)}static UnregisterExtension(h){if(!Jh._ExtensionFactories[h])return!1;delete Jh._ExtensionFactories[h];const d=Jh._ExtensionNames.indexOf(h);return-1!==d&&Jh._ExtensionNames.splice(d,1),!0}_generateJSON(h,d,m){const j={byteLength:h};return j.byteLength&&(this._glTF.buffers=[j]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Fd=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(j.uri=d+".bin"),m?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(h){const d=await this._generateBinaryAsync();this._extensionsOnExporting();const m=this._generateJSON(d.byteLength,h,!0),j=new Blob([d],{type:"application/octet-stream"}),A=h+".gltf",b=h+".bin",w=new S;if(w.files[A]=m,w.files[b]=j,this._imageData)for(const a in this._imageData)w.files[a]=new Blob([this._imageData[a].data],{type:this._imageData[a].mimeType});return w}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(h){const d=h%4;return 0===d?d:4-d}async generateGLBAsync(h){this._shouldUseGlb=!0;const d=await this._generateBinaryAsync();this._extensionsOnExporting();const m=this._generateJSON(d.byteLength),j=h+".glb";let A,b=m.length;if("undefined"!==typeof TextEncoder){A=(new TextEncoder).encode(m),b=A.length}const w=this._getPadding(b),a=this._getPadding(d.byteLength),D=28+b+w+d.byteLength+a,M=new Dh(D);if(M.writeUInt32(1179937895),M.writeUInt32(2),M.writeUInt32(D),M.writeUInt32(b+w),M.writeUInt32(1313821514),A)M.writeTypedArray(A);else{const h="_".charCodeAt(0);for(let d=0;d<b;++d){const j=m.charCodeAt(d);j!=m.codePointAt(d)?M.writeUInt8(h):M.writeUInt8(j)}}for(let S=0;S<w;++S)M.writeUInt8(32);M.writeUInt32(d.byteLength+a),M.writeUInt32(5130562),M.writeTypedArray(d);for(let S=0;S<a;++S)M.writeUInt8(0);const q=new S;return q.files[j]=new Blob([M.getOutputData()],{type:"application/octet-stream"}),q}_setNodeTransformation(h,d,m){if(d.getPivotPoint().equalsWithEpsilon(U,t.c)||A.e.Warn("Pivot points are not supported in the glTF serializer"),!d.position.equalsWithEpsilon(U,t.c)){const A=j.d.Qd[0].D(d.position);m&&u(A),h.translation=A.fd()}d.td.equalsWithEpsilon(J,t.c)||(h.scale=d.td.fd());const b=d.rotationQuaternion||j.c.FromEulerAngles(d.rotation.x,d.rotation.y,d.rotation.z);b.equalsWithEpsilon(s,t.c)||(m&&P(b),h.rotation=b.normalize().fd())}_setCameraTransformation(h,d,m){if(!d.position.equalsWithEpsilon(U,t.c)){const A=j.d.Qd[0].D(d.position);m&&u(A),h.translation=A.fd()}const A=d.rotationQuaternion||j.c.FromEulerAngles(d.rotation.x,d.rotation.y,d.rotation.z);m&&P(A),this._babylonScene.useRightHandedSystem||G(A),A.equalsWithEpsilon(s,t.c)||(h.rotation=A.fd())}_listAvailableCameras(){for(const h of this._babylonScene.cameras){const d={type:h.mode===Eh.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(h.name&&(d.name=h.name),"perspective"===d.type)d.perspective={aspectRatio:h.getEngine().getAspectRatio(h),yfov:h.fovMode===Eh.e.FOVMODE_VERTICAL_FIXED?h.fov:h.fov*h.getEngine().getAspectRatio(h),znear:h.jb,zfar:h.maxZ};else if("orthographic"===d.type){const m=h.orthoLeft&&h.orthoRight?.5*(h.orthoRight-h.orthoLeft):.5*h.getEngine().getRenderWidth(),j=h.orthoBottom&&h.orthoTop?.5*(h.orthoTop-h.orthoBottom):.5*h.getEngine().getRenderHeight();d.orthographic={xmag:m,ymag:j,znear:h.jb,zfar:h.maxZ}}this._camerasMap.set(h,d)}}_exportAndAssignCameras(){const h=Array.from(this._camerasMap.values());for(const d of h){const h=this._nodesCameraMap.get(d);if(void 0!==h){this._cameras.push(d);for(const d of h)d.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const h of this._babylonScene.skeletons){if(h.bones.length<=0)continue;const d={joints:[]};this._skinMap.set(h,d)}}_exportAndAssignSkeletons(){for(const h of this._babylonScene.skeletons){if(h.bones.length<=0)continue;const d=this._skinMap.get(h);if(void 0==d)continue;const m={},j=[];let b=-1;for(let A=0;A<h.bones.length;++A){const d=h.bones[A],j=d.getIndex()??A;-1!==j&&(m[j]=d,j>b&&(b=j))}for(let h=0;h<=b;++h){const b=m[h];j.push(b.getAbsoluteInverseBindMatrix());const w=b.getTransformNode();if(null!==w){const h=this._nodeMap.get(w);w&&null!==h&&void 0!==h?d.joints.push(h):A.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}else A.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}const w=this._nodesSkinMap.get(d);if(d.joints.length>0&&void 0!==w){const h=64*j.length,m=new Float32Array(h/4);j.forEach(((h,d)=>{m.set(h.m,16*d)}));const A=this._bufferManager.createBufferView(m);this._accessors.push(this._bufferManager.createAccessor(A,"MAT4",5126,j.length)),d.inverseBindMatrices=this._accessors.length-1,this._skins.push(d);for(const d of w)d.skin=this._skins.length-1}}}async _exportSceneAsync(){const h={nodes:[]};if(this._babylonScene.metadata){const d=this._options.metadataSelector(this._babylonScene.metadata);d&&(h.extras=d)}const d=new Array,m=new Array,j=new Array;for(const a of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&wh(a,this._babylonScene.useRightHandedSystem)?j.push(...a.getChildren()):this._babylonScene.useRightHandedSystem?d.push(a):m.push(a);this._listAvailableCameras(),this._listAvailableSkeletons();const A=new sh(!0,!1);h.nodes.push(...await this._exportNodesAsync(m,A));const b=new sh(!1,!1);h.nodes.push(...await this._exportNodesAsync(d,b));const w=new sh(!1,!0);h.nodes.push(...await this._exportNodesAsync(j,w)),h.nodes.length&&this._scenes.push(h),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Ch._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,A.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(h){let d=this._shouldExportNodeMap.get(h);return void 0===d&&(d=this._options.shouldExportNode(h),this._shouldExportNodeMap.set(h,d)),d}async _exportNodesAsync(h,d){const m=new Array;this._exportBuffers(h,d);for(const j of h)await this._exportNodeAsync(j,m,d);return m}_collectBuffers(h,d,m,j,A){if(this._shouldExportNode(h)&&h instanceof E.b&&h.Ld){const b=h.Ld.getVertexBuffers();if(b)for(const j in b){if(!e(j))continue;const w=b[j];A.setHasVertexColorAlpha(w,h.hasVertexAlpha);const a=w._buffer,D=d.get(a)||[];d.set(a,D),-1===D.indexOf(w)&&D.push(w);const S=m.get(w)||[];m.set(w,S),-1===S.indexOf(h)&&S.push(h)}const w=h.morphTargetManager;if(w)for(let d=0;d<w.numTargets;d++){const m=w.getTarget(d),A=j.get(m)||[];j.set(m,A),-1===A.indexOf(h)&&A.push(h)}}for(const b of h.getChildren())this._collectBuffers(b,d,m,j,A)}_exportBuffers(h,d){const m=new Map,j=new Map,A=new Map;for(const a of h)this._collectBuffers(a,m,j,A,d);const b=Array.from(m.keys());for(const a of b){const h=a.getData();if(!h)throw new Error("Buffer data is not available");const A=m.get(a);if(!A)continue;const b=A[0].byteStride;if(A.some((h=>h.byteStride!==b)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const w=mh(h).slice();for(const d of A){const h=j.get(d),{byteOffset:m,byteStride:A,componentCount:b,type:a,count:D,normalized:S,kind:q}=n(d,h);switch(q){case M.d.NormalKind:case M.d.TangentKind:(0,Y.h)(w,m,A,b,a,D,S,(h=>{const d=Math.sqrt(h[0]*h[0]+h[1]*h[1]+h[2]*h[2]);if(d>0){const m=1/d;h[0]*=m,h[1]*=m,h[2]*=m}}));break;case M.d.ColorKind:{const d=h.filter((h=>h.material instanceof Zh.b||null==h.material)).length;if(0==d)break;if(d!=h.length){x.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}a==M.d.UNSIGNED_BYTE&&x.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const j=new L.d,q=new L.f,E=this._babylonScene.getEngine().useExactSrgbConversions;(0,Y.h)(w,m,A,b,a,D,S,(h=>{3===h.length?(j.Hm(h,0),j.toLinearSpaceToRef(j,E),j.toArray(h,0)):(q.Hm(h,0),q.toLinearSpaceToRef(q,E),q.toArray(h,0))}))}}}if(d.convertToRightHanded){for(const h of A){const d=j.get(h),{byteOffset:m,byteStride:A,componentCount:b,type:a,count:D,normalized:S,kind:q}=n(h,d);switch(q){case M.d.PositionKind:case M.d.NormalKind:case M.d.TangentKind:(0,Y.h)(w,m,A,b,a,D,S,(h=>{h[0]=-h[0]}))}}d.convertedToRightHandedBuffers.set(a,w)}const D=this._bufferManager.createBufferView(w,b);d.setVertexBufferView(a,D);const S=new Map;for(const d of A){const h=j.get(d),{kind:m,totalVertices:A}=n(d,h);switch(m){case M.d.MatricesIndicesKind:case M.d.MatricesIndicesExtraKind:if(d.type==M.d.FLOAT){const h=d.getFloatData(A);null!==h&&S.set(d,h)}}}0!==S.size&&x.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const q=Array.from(S.keys());for(const m of q){const h=S.get(m);if(!h)continue;const j=h.some((h=>h>=256)),A=new(j?Uint16Array:Uint8Array)(h.length);for(let d=0;d<h.length;d++)A[d]=h[d];const b=this._bufferManager.createBufferView(A,4*(j?2:1));d.setRemappedBufferView(a,m,b)}}const w=Array.from(A.keys());for(const a of w){const h=A.get(a);if(!h)continue;const m=Th(a,h[0],this._bufferManager,this._bufferViews,this._accessors,d.convertToRightHanded);for(const j of h)d.bindMorphDataToMesh(j,m)}}async _exportNodeAsync(h,d,m){let j=this._nodeMap.get(h);if(void 0!==j)return void(d.includes(j)||d.push(j));const A=await this._createNodeAsync(h,m);if(A){j=this._nodes.length,this._nodes.push(A),this._nodeMap.set(h,j),m.pushExportedNode(h),d.push(j);const b={name:"runtime animations",channels:[],samplers:[]},w=[];this._babylonScene.animationGroups.length||(Ch._CreateMorphTargetAnimationFromMorphTargetAnimations(h,b,w,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,m.convertToRightHanded,this._options.shouldExportAnimation),h.animations.length&&Ch._CreateNodeAnimationFromNodeAnimations(h,b,w,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,m.convertToRightHanded,this._options.shouldExportAnimation)),b.channels.length&&b.samplers.length&&this._animations.push(b),w.forEach((h=>{h.channels.length&&h.samplers.length&&this._animations.push(h)}))}const b=A?[]:d;for(const w of h.getChildren())await this._exportNodeAsync(w,b,m);A&&b.length&&(A.children=b)}async _createNodeAsync(h,d){if(!this._shouldExportNode(h))return null;const m={};if(h.name&&(m.name=h.name),h.metadata){const d=this._options.metadataSelector(h.metadata);d&&(m.extras=d)}if(h instanceof q.c&&(this._setNodeTransformation(m,h,d.convertToRightHanded),h instanceof E.b)){const A=h instanceof I.b?h.sourceMesh:h;if(A.Ab&&A.Ab.length>0&&(m.mesh=await this._exportMeshAsync(A,d)),h.skeleton){const d=this._skinMap.get(h.skeleton);var j;if(void 0!==d)void 0===this._nodesSkinMap.get(d)&&this._nodesSkinMap.set(d,[]),null===(j=this._nodesSkinMap.get(d))||void 0===j||j.push(m)}}if(h instanceof Q.e){const j=this._camerasMap.get(h);if(j){var A;void 0===this._nodesCameraMap.get(j)&&this._nodesCameraMap.set(j,[]),this._setCameraTransformation(m,h,d.convertToRightHanded);const w=h.parent;if(null!==w&&dh(h,w)){const h=this._nodeMap.get(w);if(void 0!==h){var b;const d=this._nodes[h];return hh(m,d),null===(b=this._nodesCameraMap.get(j))||void 0===b||b.push(d),null}}null===(A=this._nodesCameraMap.get(j))||void 0===A||A.push(m)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",m,h,this._nodeMap,d.convertToRightHanded)?m:(x.c.Warn(`Not exporting node ${h.name}`),null)}_exportIndices(h,d,m,j,A,w,a,D,S){let M=h;S.mode=X(w);const q=a!==b.d.CounterClockWiseSideOrientation,E=!D.wasAddedByNoopNode&&q,I=function(h){switch(h){case b.d.TriangleFillMode:case b.d.TriangleStripDrawMode:case b.d.TriangleFanDrawMode:return!0}return!1}(w)&&E;if(I){if(w===b.d.TriangleStripDrawMode||w===b.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");S.mode=X(w);const a=d?new Uint32Array(j):new Uint16Array(j);if(h)for(let d=0;d+2<j;d+=3)a[d]=h[m+d]+A,a[d+1]=h[m+d+2]+A,a[d+2]=h[m+d+1]+A;else for(let h=0;h+2<j;h+=3)a[h]=h,a[h+1]=h+2,a[h+2]=h+1;M=a}else if(h&&0!==A){const b=d?new Uint32Array(j):new Uint16Array(j);for(let d=0;d<j;d++)b[d]=h[m+d]+A;M=b}if(M){let b=D.getIndicesAccessor(h,m,j,A,I);if(void 0===b){const w=function(h,d,m,j){if(h instanceof Uint16Array||h instanceof Uint32Array)return h;if(h instanceof Int32Array)return new Uint32Array(h.buffer,h.byteOffset,h.length);const A=h.slice(d,d+m);return j?new Uint32Array(A):new Uint16Array(A)}(M,0,j,d),a=this._bufferManager.createBufferView(w),S=d?5125:5123;this._accessors.push(this._bufferManager.createAccessor(a,"SCALAR",S,j,0)),b=this._accessors.length-1,D.setIndicesAccessor(h,m,j,A,I,b)}S.indices=b}}_exportVertexBuffer(h,d,m,j,A,b){const w=h.getKind();if(!e(w))return;if(w.startsWith("uv")&&!this._options.exportUnusedUVs&&(!d||!this._materialNeedsUVsSet.has(d)))return;let a=A.getVertexAccessor(h,m,j);if(void 0===a){const d=A.convertedToRightHandedBuffers.get(h._buffer)||h._buffer.getData(),b=w===M.d.PositionKind?function(h,d,m,j){const{byteOffset:A,byteStride:b,type:w,normalized:a}=d,D=d.getSize(),S=new Array(D).fill(1/0),M=new Array(D).fill(-1/0);return(0,Y.h)(h,A+m*b,b,D,w,j*D,a,(h=>{for(let d=0;d<D;d++)S[d]=Math.min(S[d],h[d]),M[d]=Math.max(M[d],h[d])})),{min:S,max:M}}(d,h,m,j):void 0,D=(w===M.d.MatricesIndicesKind||w===M.d.MatricesIndicesExtraKind)&&h.type===M.d.FLOAT,S=D?M.d.UNSIGNED_BYTE:h.type,q=D?void 0:h.normalized,E=D?A.getRemappedBufferView(h._buffer,h):A.getVertexBufferView(h._buffer),I=h.byteOffset+m*h.byteStride;this._accessors.push(this._bufferManager.createAccessor(E,function(h,d){if(h==M.d.ColorKind)return d?"VEC4":"VEC3";switch(h){case M.d.PositionKind:case M.d.NormalKind:return"VEC3";case M.d.TangentKind:case M.d.MatricesIndicesKind:case M.d.MatricesIndicesExtraKind:case M.d.MatricesWeightsKind:case M.d.MatricesWeightsExtraKind:return"VEC4";case M.d.UVKind:case M.d.UV2Kind:case M.d.UV3Kind:case M.d.UV4Kind:case M.d.UV5Kind:case M.d.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${h}`)}(w,A.hasVertexColorAlpha(h)),S,j,I,b,q)),a=this._accessors.length-1,A.setVertexAccessor(h,m,j,a)}b.attributes[function(h){switch(h){case M.d.PositionKind:return"POSITION";case M.d.NormalKind:return"NORMAL";case M.d.TangentKind:return"TANGENT";case M.d.ColorKind:return"COLOR_0";case M.d.UVKind:return"TEXCOORD_0";case M.d.UV2Kind:return"TEXCOORD_1";case M.d.UV3Kind:return"TEXCOORD_2";case M.d.UV4Kind:return"TEXCOORD_3";case M.d.UV5Kind:return"TEXCOORD_4";case M.d.UV6Kind:return"TEXCOORD_5";case M.d.MatricesIndicesKind:return"JOINTS_0";case M.d.MatricesIndicesExtraKind:return"JOINTS_1";case M.d.MatricesWeightsKind:return"WEIGHTS_0";case M.d.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${h}`)}(w)]=a}async _exportMaterialAsync(h,d,m,j){let A=this._materialMap.get(h);if(void 0===A){const j=d&&Object.keys(d).some((h=>h.startsWith("uv")));if((h=h instanceof Ih.e?h.bb[m.materialIndex]:h)instanceof Rh.d)A=await this._materialExporter.exportPBRMaterialAsync(h,"image/png",j);else{if(!(h instanceof Zh.b))return void x.c.Warn(`Unsupported material '${h.name}' with type ${h.getClassName()}`);A=await this._materialExporter.exportStandardMaterialAsync(h,"image/png",j)}this._materialMap.set(h,A)}j.material=A}async _exportMeshAsync(h,d){var m;let j=d.getMesh(h);if(void 0!==j)return j;const A={primitives:[]};j=this._meshes.length,this._meshes.push(A),d.setMesh(h,j);const w=h.isUnIndexed?null:h.Vd(),a=null===(m=h.Ld)||void 0===m?void 0:m.getVertexBuffers(),D=d.getMorphTargetsFromMesh(h),S=h instanceof oh.d,M=h instanceof Uh,q=h.Ab;if(a&&q&&q.length>0)for(const R of q){const m={attributes:{}},j=R.Qh()||this._babylonScene.defaultMaterial;if(M){var E,I;const d={name:j.name},A=h,b=L.d.White(),w=(null===(E=A.material)||void 0===E?void 0:E.alpha)??1,a=(null===(I=A.greasedLineMaterial)||void 0===I?void 0:I.color)??b;(!a.equalsWithEpsilon(b,t.c)||w<1)&&(d.pbrMetallicRoughness={baseColorFactor:[...a.fd(),w]}),this._materials.push(d),m.material=this._materials.length-1}else if(S){const d={name:j.name},A=h;(!A.color.equalsWithEpsilon(L.d.White(),t.c)||A.alpha<1)&&(d.pbrMetallicRoughness={baseColorFactor:[...A.color.fd(),A.alpha]}),this._materials.push(d),m.material=this._materials.length-1}else await this._exportMaterialAsync(j,a,R,m);const q=S||M?b.d.LineListDrawMode:h.overrideRenderingFillMode??j.fillMode,Z=j._getEffectiveOrientation(h);this._exportIndices(w,w?(0,Y.b)(w,R.indexCount,R.indexStart,R.verticesStart):R.verticesCount>65535,w?R.indexStart:R.verticesStart,w?R.indexCount:R.verticesCount,-R.verticesStart,q,Z,d,m);for(const h of Object.values(a))this._exportVertexBuffer(h,j,R.verticesStart,R.verticesCount,d,m);if(D){m.targets=[];for(const h of D)m.targets.push(h.attributes)}A.primitives.push(m),this._extensionsPostExportMeshPrimitive(m)}if(D){A.weights=[],A.extras||(A.extras={}),A.extras.targetNames=[];for(const h of D)A.weights.push(h.influence),A.extras.targetNames.push(h.name)}return j}}Jh._ExtensionNames=new Array,Jh._ExtensionFactories={};class Oh{static async GLTFAsync(h,d,m){m&&m.exportWithoutWaitingForScene||await h.whenReadyAsync();const j=new Jh(h,m),A=await j.generateGLTFAsync(d.replace(/\.[^/.]+$/,""));return j.dispose(),A}static async GLBAsync(h,d,m){m&&m.exportWithoutWaitingForScene||await h.whenReadyAsync();const j=new Jh(h,m),A=await j.generateGLBAsync(d.replace(/\.[^/.]+$/,""));return j.dispose(),A}}m(11767);const nh="EXT_mesh_gpu_instancing";class ph{constructor(h){this.name=nh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(h,d,m,A,b,w){return await new Promise((h=>{if(d&&m instanceof Vh.d&&m.hasThinInstances&&this._exporter){this._wasUsed=!0;const h=j.i.Zero(),A=j.c.Identity(),a=j.i.One(),D=m.thinInstanceGetWorldMatrices(),S=j.d.Qd[2],M=j.d.Quaternion[1],q=j.d.Qd[3];let E=!1,I=!1,R=!1;const Z=new Float32Array(3*m.wb),L=new Float32Array(4*m.wb),B=new Float32Array(3*m.wb);let V=0;for(const d of D)d.decompose(q,M,S),b&&(u(S),P(M)),Z.set(S.fd(),3*V),L.set(M.normalize().fd(),4*V),B.set(q.fd(),3*V),E=E||!S.equalsWithEpsilon(h),I=I||!M.equalsWithEpsilon(A),R=R||!q.equalsWithEpsilon(a),V++;const v={attributes:{}};E&&(v.attributes.TRANSLATION=this._buildAccessor(Z,"VEC3",m.wb,w)),I&&(v.attributes.ROTATION=this._buildAccessor(L,"VEC4",m.wb,w)),R&&(v.attributes.SCALE=this._buildAccessor(B,"VEC3",m.wb,w)),d.extensions=d.extensions||{},d.extensions[nh]=v}h(d)}))}_buildAccessor(h,d,m,j){const A=j.createBufferView(h),b=j.createAccessor(A,d,5126,m);return this._exporter._accessors.push(b),this._exporter._accessors.length-1}}Jh.RegisterExtension(nh,(h=>new ph(h)));var eh=m(11771),Xh=m(11786),zh=m(11794),uh=m(11803);function Ph(h){return h===zh.b.PositionKind?"POSITION":h===zh.b.NormalKind?"NORMAL":h===zh.b.ColorKind?"COLOR":h.startsWith(zh.b.UVKind)?"TEX_COORD":"GENERIC"}const Gh={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class hd extends eh.d{static get DefaultAvailable(){return(0,eh.h)(hd.DefaultConfiguration)}static get Default(){return hd._Default??(hd._Default=new hd),hd._Default}static ResetDefault(h){hd._Default&&(h||hd._Default.dispose(),hd._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(h,d){return{module:await(d||DracoEncoderModule)({wasmBinary:h})}}_getWorkerContent(){return`${Xh.j}(${Xh.m})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:hd.DefaultConfiguration)}async _encodeAsync(h,d,m){const j=m?(0,uh.d)(Gh,m):Gh;if(this._workerPoolPromise){const m=await this._workerPoolPromise;return await new Promise(((A,b)=>{m.push(((m,w)=>{const a=h=>{m.removeEventListener("error",a),m.removeEventListener("message",D),b(h),w()},D=h=>{"encodeMeshDone"===h.data.id&&(m.removeEventListener("error",a),m.removeEventListener("message",D),A(h.data.encodedMeshData),w())};m.addEventListener("error",a),m.addEventListener("message",D);const S=[];for(const d of h)S.push(d.data.buffer);d&&S.push(d.buffer),m.postMessage({id:"encodeMesh",attributes:h,indices:d,options:j},S)}))}))}if(this._modulePromise){const m=await this._modulePromise;return(0,Xh.j)(m.module,h,d,j)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(h,d){if(0==h.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");h instanceof Vh.d&&h.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===d||void 0===d?void 0:d.method)&&(x.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),d.method="MESH_SEQUENTIAL_ENCODING");const m=function(h){let d=h.Vd(void 0,!0);return!d||d instanceof Uint32Array||d instanceof Uint16Array||(d=((0,Y.b)(d,d.length)?Uint32Array:Uint16Array).from(d)),d}(h),j=function(h,d){const m=[];for(const j of h.getVerticesDataKinds()){if(null!==d&&void 0!==d&&d.includes(j)){if(j===zh.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const A=h.getVertexBuffer(j),b=A.getSize(),w=(0,Y.q)(A.getData(),b,A.type,A.byteOffset,A.byteStride,A.normalized,h.getTotalVertices(),!0);m.push({kind:j,dracoName:Ph(j),size:b,data:w})}return m}(h,null===d||void 0===d?void 0:d.excludedAttributes);return await this._encodeAsync(j,m,d)}}hd.DefaultConfiguration={wasmUrl:`${A.e._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${A.e._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${A.e._DefaultCdnUrl}/draco_encoder.js`},hd._Default=null;const dd="KHR_draco_mesh_compression";class md{get wasUsed(){return this._wasUsed}constructor(h){this.name=dd,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===h.options.meshCompressionMethod&&hd.DefaultAvailable}dispose(){}postExportMeshPrimitive(h,d,m){if(!this.enabled)return;if(4!==h.mode&&5!==h.mode)return void x.c.Warn("Cannot compress primitive with mode "+h.mode+".");const j=[],A=[];let b=null;if(void 0!==h.indices){const w=m[h.indices],a=d.getBufferView(w);b=d.getData(a).slice(),j.push(a),A.push(w)}const w=[];for(const[M,q]of Object.entries(h.attributes)){const h=m[q],b=d.getBufferView(h),D=p(h.type),S=(0,Y.q)(d.getData(b),D,h.componentType,h.byteOffset||0,b.byteStride||(0,Y.m)(h.componentType)*D,h.normalized||!1,h.count,!0);w.push({kind:M,dracoName:(a=M,"POSITION"===a?"POSITION":"NORMAL"===a?"NORMAL":a.startsWith("COLOR")?"COLOR":a.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:p(h.type),data:S}),j.push(b),A.push(h)}var a;const D={method:h.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},S=hd.Default._encodeAsync(w,b,D).then((m=>{if(!m)return void x.c.Error("Draco encoding failed for primitive.");const b={bufferView:-1,attributes:m.attributeIds},w=d.createBufferView(m.data);d.setBufferView(b,w);for(const h of j)this._bufferViewsUsed.add(h);for(const h of A)this._accessorsUsed.add(h);h.extensions||(h.extensions={}),h.extensions[dd]=b})).catch((h=>{x.c.Error("Draco encoding failed for primitive: "+h)}));this._encodePromises.push(S),this._wasUsed=!0}async preGenerateBinaryAsync(h){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((d=>{h.getPropertiesWithBufferView(d).every((h=>this._accessorsUsed.has(h)))&&h.removeBufferView(d)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Jh.RegisterExtension(dd,(h=>new md(h)));var jd=m(11809);const Ad="KHR_lights_punctual",bd={name:"",color:[1,1,1],ab:1,range:Number.MAX_VALUE},wd={innerConeAngle:0,outerConeAngle:Math.PI/4},ad=j.i.Backward();class Dd{constructor(h){this.name=Ad,this.enabled=!0,this.required=!1,this._exporter=h}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Ad]=this._lights}async postExportNodeAsync(h,d,m,A,b){return await new Promise((w=>{if(!(m instanceof vh.d))return void w(d);const a=m.getTypeID()==vh.d.LIGHTTYPEID_POINTLIGHT?"point":m.getTypeID()==vh.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":m.getTypeID()==vh.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!a||!(m instanceof jd.c))return x.c.Warn(`${h}: Light ${m.name} is not supported in ${Ad}`),void w(d);if(m.falloffType!==vh.d.FALLOFF_GLTF&&x.c.Warn(`${h}: Light falloff for ${m.name} does not match the ${Ad} specification!`),!m.position.equalsToFloats(0,0,0)){const h=j.d.Qd[0].D(m.position);b&&u(h),d.translation=h.fd()}if("point"!==a){const h=m.direction.normalizeToRef(j.d.Qd[0]);b&&u(h);const A=j.c.FromUnitVectorsToRef(ad,h,j.d.Quaternion[0]);j.c.IsIdentity(A)||(d.rotation=A.fd())}const D={type:a,name:m.name,color:m.Db.fd(),ab:m.ab,range:m.range};if(jh(D,bd),"spot"===a){const h=m;D.spot={innerConeAngle:h.innerAngle/2,outerConeAngle:h.angle/2},jh(D.spot,wd)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(D);const S={Rd:this._lights.lights.length-1},M=m.parent;if(M&&dh(m,M)){const h=A.get(M);if(h){const m=this._exporter._nodes[h];return hh(d,m),m.extensions||(m.extensions={}),m.extensions[Ad]=S,void w(null)}}d.extensions||(d.extensions={}),d.extensions[Ad]=S,w(d)}))}}Jh.RegisterExtension(Ad,(h=>new Dd(h)));var Sd=m(11602);const Md="KHR_materials_anisotropy";class qd{constructor(h){this.name=Md,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,m){const j=[];return m instanceof Sd.c&&m.anisotropy.isEnabled&&!m.anisotropy.legacy?(m.anisotropy.texture&&j.push(m.anisotropy.texture),j):[]}postExportMaterialAsync(h,d,m){return new Promise((h=>{if(m instanceof Sd.c){if(!m.anisotropy.isEnabled||m.anisotropy.legacy)return void h(d);this._wasUsed=!0,d.extensions=d.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(m.anisotropy.texture),A={anisotropyStrength:m.anisotropy.ab,anisotropyRotation:m.anisotropy.angle,anisotropyTexture:j??void 0};null!==A.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(m),d.extensions[Md]=A}h(d)}))}}Jh.RegisterExtension(Md,(h=>new qd(h)));const Ed="KHR_materials_clearcoat";class Id{constructor(h){this.name=Ed,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,m){const j=[];return m instanceof Sd.c&&m.clearCoat.isEnabled?(m.clearCoat.texture&&j.push(m.clearCoat.texture),!m.clearCoat.useRoughnessFromMainTexture&&m.clearCoat.textureRoughness&&j.push(m.clearCoat.textureRoughness),m.clearCoat.bumpTexture&&j.push(m.clearCoat.bumpTexture),j):[]}postExportMaterialAsync(h,d,m){return new Promise((h=>{if(m instanceof Sd.c){if(!m.clearCoat.isEnabled)return void h(d);this._wasUsed=!0,d.extensions=d.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(m.clearCoat.texture);let b;b=m.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(m.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(m.clearCoat.textureRoughness),m.clearCoat.isTintEnabled&&A.e.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${m.name}`),m.clearCoat.remapF0OnInterfaceChange&&A.e.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${m.name}`);const w=this._exporter._materialExporter.getTextureInfo(m.clearCoat.bumpTexture),a={clearcoatFactor:m.clearCoat.ab,clearcoatTexture:j??void 0,clearcoatRoughnessFactor:m.clearCoat.roughness,clearcoatRoughnessTexture:b??void 0,clearcoatNormalTexture:w??void 0};null===a.clearcoatTexture&&null===a.clearcoatRoughnessTexture&&null===a.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(m),d.extensions[Ed]=a}h(d)}))}}Jh.RegisterExtension(Ed,(h=>new Id(h)));const Rd="KHR_materials_diffuse_transmission";function Zd(h,d){const m=d.subSurface;let j=null;return m.translucencyIntensityTexture?j=m.translucencyIntensityTexture:m.thicknessTexture&&m.useMaskFromThicknessTexture&&(j=m.thicknessTexture),j&&!m.useGltfStyleTextures?(x.c.Warn(`${h}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${d.name}`,1),null):j}class Ld{constructor(h){this.name=Rd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,m){const j=[];if(m instanceof Rh.d&&this._isExtensionEnabled(m)){const d=Zd(h,m);return d&&j.push(d),m.subSurface.translucencyColorTexture&&j.push(m.subSurface.translucencyColorTexture),j}return j}_isExtensionEnabled(h){if(h.unlit)return!1;const d=h.subSurface;return!!d.isTranslucencyEnabled&&(!h.unlit&&!d.useAlbedoToTintTranslucency&&d.useGltfStyleTextures&&1===d.volumeIndexOfRefraction&&0===d.minimumThickness&&0===d.maximumThickness)}postExportMaterialAsync(h,d,m){return new Promise((j=>{if(m instanceof Rh.d&&this._isExtensionEnabled(m)){this._wasUsed=!0;const j=m.subSurface,A=Zd(h,m),b=0==j.translucencyIntensity?void 0:j.translucencyIntensity,w=this._exporter._materialExporter.getTextureInfo(A)??void 0,a=!j.translucencyColor||j.translucencyColor.equalsFloats(1,1,1)?void 0:j.translucencyColor.fd(),D=this._exporter._materialExporter.getTextureInfo(j.translucencyColorTexture)??void 0,S={diffuseTransmissionFactor:b,diffuseTransmissionTexture:w,diffuseTransmissionColorFactor:a,diffuseTransmissionColorTexture:D};(w||D)&&this._exporter._materialNeedsUVsSet.add(m),d.extensions=d.extensions||{},d.extensions[Rd]=S}j(d)}))}}Jh.RegisterExtension(Rd,(h=>new Ld(h)));const Bd="KHR_materials_dispersion";class Vd{constructor(){this.name=Bd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(h){if(h.unlit)return!1;const d=h.subSurface;return!(!d.isRefractionEnabled&&!d.isDispersionEnabled)}postExportMaterialAsync(h,d,m){return new Promise((h=>{if(m instanceof Rh.d&&this._isExtensionEnabled(m)){this._wasUsed=!0;const h={dispersion:m.subSurface.dispersion};d.extensions=d.extensions||{},d.extensions[Bd]=h}h(d)}))}}Jh.RegisterExtension(Bd,(()=>new Vd));const vd="KHR_materials_emissive_strength";class Cd{constructor(){this.name=vd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(h,d,m){return await new Promise((h=>{if(!(m instanceof Rh.d))return h(d);const j=m.emissiveColor.fd(),A=Math.max(...j);if(A>1){this._wasUsed=!0,d.extensions||(d.extensions={});const h={emissiveStrength:A},j=m.emissiveColor.scale(1/h.emissiveStrength);d.emissiveFactor=j.fd(),d.extensions[vd]=h}return h(d)}))}}Jh.RegisterExtension(vd,(h=>new Cd));const Td="KHR_materials_ior";class od{constructor(){this.name=Td,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(h){return!h.unlit&&(void 0!=h.indexOfRefraction&&1.5!=h.indexOfRefraction)}postExportMaterialAsync(h,d,m){return new Promise((h=>{if(m instanceof Rh.d&&this._isExtensionEnabled(m)){this._wasUsed=!0;const h={ior:m.indexOfRefraction};d.extensions=d.extensions||{},d.extensions[Td]=h}h(d)}))}}Jh.RegisterExtension(Td,(h=>new od));const yd="KHR_materials_iridescence";class id{constructor(h){this.name=yd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,m){const j=[];return m instanceof Sd.c&&m.iridescence.isEnabled?(m.iridescence.texture&&j.push(m.iridescence.texture),m.iridescence.thicknessTexture&&m.iridescence.thicknessTexture!==m.iridescence.texture&&j.push(m.iridescence.thicknessTexture),j):[]}postExportMaterialAsync(h,d,m){return new Promise((h=>{if(m instanceof Sd.c){if(!m.iridescence.isEnabled)return void h(d);this._wasUsed=!0,d.extensions=d.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(m.iridescence.texture),A=this._exporter._materialExporter.getTextureInfo(m.iridescence.thicknessTexture),b={iridescenceFactor:m.iridescence.ab,iridescenceIor:m.iridescence.indexOfRefraction,iridescenceThicknessMinimum:m.iridescence.minimumThickness,iridescenceThicknessMaximum:m.iridescence.maximumThickness,iridescenceTexture:j??void 0,iridescenceThicknessTexture:A??void 0};null===b.iridescenceTexture&&null===b.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(m),d.extensions[yd]=b}h(d)}))}}Jh.RegisterExtension(yd,(h=>new id(h)));const gd="KHR_materials_sheen";class Fd{constructor(h){this.name=gd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,m){return m instanceof Rh.d&&m.sheen.isEnabled&&m.sheen.texture?[m.sheen.texture]:[]}async postExportMaterialAsync(h,d,m){return await new Promise((h=>{if(m instanceof Rh.d){if(!m.sheen.isEnabled)return void h(d);this._wasUsed=!0,null==d.extensions&&(d.extensions={});const j={sheenColorFactor:m.sheen.color.fd(),sheenRoughnessFactor:m.sheen.roughness??0};null===j.sheenColorTexture&&null===j.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(m),m.sheen.texture&&(j.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(m.sheen.texture)??void 0),m.sheen.textureRoughness&&!m.sheen.useRoughnessFromMainTexture?j.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(m.sheen.textureRoughness)??void 0:m.sheen.texture&&m.sheen.useRoughnessFromMainTexture&&(j.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(m.sheen.texture)??void 0),d.extensions[gd]=j}h(d)}))}}Jh.RegisterExtension(gd,(h=>new Fd(h)));const fd="KHR_materials_specular";class Hd{constructor(h){this.name=fd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,m){const j=[];return m instanceof Rh.d&&this._isExtensionEnabled(m)?(m.metallicReflectanceTexture&&j.push(m.metallicReflectanceTexture),m.reflectanceTexture&&j.push(m.reflectanceTexture),j):j}_isExtensionEnabled(h){return!h.unlit&&(void 0!=h.metallicF0Factor&&1!=h.metallicF0Factor||void 0!=h.metallicReflectanceColor&&!h.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(h))}_hasTexturesExtension(h){return null!=h.metallicReflectanceTexture||null!=h.reflectanceTexture}postExportMaterialAsync(h,d,m){return new Promise((h=>{if(m instanceof Rh.d&&this._isExtensionEnabled(m)){this._wasUsed=!0,d.extensions=d.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(m.metallicReflectanceTexture)??void 0,j=this._exporter._materialExporter.getTextureInfo(m.reflectanceTexture)??void 0,A={specularFactor:1==m.metallicF0Factor?void 0:m.metallicF0Factor,specularTexture:h,specularColorFactor:m.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:m.metallicReflectanceColor.fd(),specularColorTexture:j};this._hasTexturesExtension(m)&&this._exporter._materialNeedsUVsSet.add(m),d.extensions[fd]=A}h(d)}))}}Jh.RegisterExtension(fd,(h=>new Hd(h)));const cd="KHR_materials_transmission";class kd{constructor(h){this.name=cd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,m){const j=[];return m instanceof Rh.d&&this._isExtensionEnabled(m)?(m.subSurface.thicknessTexture&&j.push(m.subSurface.thicknessTexture),j):j}_isExtensionEnabled(h){if(h.unlit)return!1;const d=h.subSurface;return d.isRefractionEnabled&&void 0!=d.refractionIntensity&&0!=d.refractionIntensity||this._hasTexturesExtension(h)}_hasTexturesExtension(h){return null!=h.subSurface.refractionIntensityTexture}async postExportMaterialAsync(h,d,m){if(m instanceof Rh.d&&this._isExtensionEnabled(m)){this._wasUsed=!0;const j=m.subSurface,A={transmissionFactor:0===j.refractionIntensity?void 0:j.refractionIntensity};if(this._hasTexturesExtension(m)&&this._exporter._materialNeedsUVsSet.add(m),j.refractionIntensityTexture)if(j.useGltfStyleTextures){const h=await this._exporter._materialExporter.exportTextureAsync(j.refractionIntensityTexture,"image/png");h&&(A.transmissionTexture=h)}else x.c.Warn(`${h}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);d.extensions||(d.extensions={}),d.extensions[cd]=A}return d}}Jh.RegisterExtension(cd,(h=>new kd(h)));const ld="KHR_materials_unlit";class Kd{constructor(){this.name=ld,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(h,d,m){return new Promise((h=>{let j=!1;m instanceof Rh.d?j=m.unlit:m instanceof Zh.b&&(j=m.disableLighting),j&&(this._wasUsed=!0,null==d.extensions&&(d.extensions={}),d.extensions[ld]={}),h(d)}))}}Jh.RegisterExtension(ld,(()=>new Kd));const Nd="KHR_materials_volume";class Wd{constructor(h){this.name=Nd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,m){const j=[];return m instanceof Rh.d&&this._isExtensionEnabled(m)?(m.subSurface.thicknessTexture&&j.push(m.subSurface.thicknessTexture),j):j}_isExtensionEnabled(h){if(h.unlit)return!1;const d=h.subSurface;return!(!d.isRefractionEnabled&&!d.isTranslucencyEnabled)&&(void 0!=d.maximumThickness&&0!=d.maximumThickness||void 0!=d.tintColorAtDistance&&d.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=d.tintColor&&d.tintColor!=L.d.White()||this._hasTexturesExtension(h))}_hasTexturesExtension(h){return null!=h.subSurface.thicknessTexture}postExportMaterialAsync(h,d,m){return new Promise((h=>{if(m instanceof Rh.d&&this._isExtensionEnabled(m)){this._wasUsed=!0;const h=m.subSurface,j={thicknessFactor:0==h.maximumThickness?void 0:h.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(h.thicknessTexture)??void 0,attenuationDistance:h.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:h.tintColorAtDistance,attenuationColor:h.tintColor.equalsFloats(1,1,1)?void 0:h.tintColor.fd()};this._hasTexturesExtension(m)&&this._exporter._materialNeedsUVsSet.add(m),d.extensions=d.extensions||{},d.extensions[Nd]=j}h(d)}))}}Jh.RegisterExtension(Nd,(h=>new Wd(h)));const rd="EXT_materials_diffuse_roughness";class Yd{constructor(h){this.name=rd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,m){const j=[];return m instanceof Sd.c&&m._baseDiffuseRoughness?(m._baseDiffuseRoughnessTexture&&j.push(m._baseDiffuseRoughnessTexture),j):[]}postExportMaterialAsync(h,d,m){return new Promise((h=>{if(m instanceof Sd.c){if(!m._baseDiffuseRoughness)return void h(d);this._wasUsed=!0,d.extensions=d.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(m._baseDiffuseRoughnessTexture),A={diffuseRoughnessFactor:m._baseDiffuseRoughness,diffuseRoughnessTexture:j??void 0};null!==A.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(m),d.extensions[rd]=A}h(d)}))}}Jh.RegisterExtension(rd,(h=>new Yd(h)));const xd="KHR_texture_transform";class Qd{constructor(){this.name=xd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(h,d,m){if(m.ih()||A.e.Warn(`${h}: /*@__KEY__*/"scene" is not defined for Babylon texture ${m.name}!`),(0!==m.uAng||0!==m.vAng)&&(A.e.Warn(`${h}: Texture ${m.name} with rotation in the u or v axis is not supported in glTF.`),0!==m.uRotationCenter||0!==m.vRotationCenter))return;const j={};let b=!1;if(0===m.uOffset&&0===m.vOffset||(j.offset=[m.uOffset,m.vOffset],b=!0),1===m.uScale&&1===m.vScale||(j.scale=[m.uScale,m.vScale],b=!0),0!==m.wAng){if(0!==m.uRotationCenter||0!==m.vRotationCenter){if(m.homogeneousRotationInUVTransform&&m.uScale!==m.vScale)return void A.e.Warn(`${h}: Texture ${m.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${xd}.`);A.e.Warn(`${h}: Texture ${m.name} with non-origin rotation center will be exported using an adjusted offset with ${xd}.`),j.offset=function(h){const{uOffset:d,vOffset:m,uRotationCenter:j,vRotationCenter:A,uScale:b,vScale:w,wAng:a}=h,D=Math.cos(a),S=Math.sin(a),M=j*b,q=A*w;return[d+(M*(1-D)+q*S),m+(q*(1-D)-M*S)]}(m)}j.rotation=-m.wAng,b=!0}0!==m.coordinatesIndex&&(j.texCoord=m.coordinatesIndex,b=!0),b&&(this._wasUsed=!0,d.extensions||(d.extensions={}),d.extensions[xd]=j)}}Jh.RegisterExtension(xd,(()=>new Qd));class td{static CreateSTL(h){let d=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],m=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",A=arguments.length>3&&void 0!==arguments[3]&&arguments[3],b=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],w=arguments.length>5&&void 0!==arguments[5]&&arguments[5],a=arguments.length>6&&void 0!==arguments[6]&&arguments[6],D=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const S=function(h,d,m){const A=[3*h[m],3*h[m+1],3*h[m+2]],b=[new j.i(d[A[0]],d[A[0]+2],d[A[0]+1]),new j.i(d[A[1]],d[A[1]+2],d[A[1]+1]),new j.i(d[A[2]],d[A[2]+2],d[A[2]+1])],w=b[0].fm(b[1]),a=b[2].fm(b[1]);return{v:b,n:j.i.Cross(a,w).normalize()}},q=function(h,d,m,j){return d=E(h,d,m.x,j),d=E(h,d,m.y,j),E(h,d,m.z,j)},E=function(h,d,m,j){return h.setFloat32(d,m,j),d+4},R=function(h){if(a){let d=h;h instanceof I.b&&(d=h.sourceMesh);const m=d.getVerticesData(M.d.PositionKind,!0,!0);if(!m)return[];const A=j.i.Zero();let b;for(b=0;b<m.length;b+=3)j.i.TransformCoordinatesFromFloatsToRef(m[b],m[b+1],m[b+2],h.Zd(!0),A).toArray(m,b);return m}return h.getVerticesData(M.d.PositionKind)||[]};a&&(w=!0);let Z="",L=0,B=0;if(A){for(let m=0;m<h.length;m++){const d=h[m].Vd();L+=d?d.length/3:0}const d=new ArrayBuffer(84+50*L);Z=new DataView(d),B+=80,Z.setUint32(B,L,b),B+=4}else D||(Z="solid stlmesh\r\n");for(let j=0;j<h.length;j++){const d=h[j];!A&&D&&(Z+="solid "+d.name+"\r\n"),!w&&d instanceof Vh.d&&d.bakeCurrentTransformIntoVertices();const m=R(d),a=d.Vd()||[];for(let h=0;h<a.length;h+=3){const d=S(a,m,h);A?(B=q(Z,B,d.n,b),B=q(Z,B,d.v[0],b),B=q(Z,B,d.v[1],b),B=q(Z,B,d.v[2],b),B+=2):(Z+="\tfacet normal "+d.n.x+" "+d.n.y+" "+d.n.z+"\r\n",Z+="\t\touter loop\r\n",Z+="\t\t\tvertex "+d.v[0].x+" "+d.v[0].y+" "+d.v[0].z+"\r\n",Z+="\t\t\tvertex "+d.v[1].x+" "+d.v[1].y+" "+d.v[1].z+"\r\n",Z+="\t\t\tvertex "+d.v[2].x+" "+d.v[2].y+" "+d.v[2].z+"\r\n",Z+="\t\tendloop\r\n",Z+="\tendfacet\r\n")}!A&&D&&(Z+="endsolid "+name+"\r\n")}if(A||D||(Z+="endsolid stlmesh"),d){const h=document.createElement("a"),d=new Blob([Z],{type:"application/octet-stream"});h.href=window.URL.createObjectURL(d),h.download=m+".stl",h.click()}return Z}}function Ud(h,d){let m=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const j=[];for(let A=0;A<h.length/m;A++){const b=h[A*m],w=h[A*m+1],a=h[A*m+2];j.push(`(${b.toPrecision(d.precision)}, ${w.toPrecision(d.precision)}, ${a.toPrecision(d.precision)})`)}return j.join(", ")}function sd(h,d){const m=[];for(let j=0;j<h.length/2;j++){const A=h[2*j],b=h[2*j+1];m.push(`(${A.toPrecision(d.precision)}, ${(1-b).toPrecision(d.precision)})`)}return m.join(", ")}function Jd(h,d){const m=h.getVerticesData(M.d.PositionKind),j=h.getVerticesData(M.d.NormalKind);if(m&&j)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(h){var d;const m=null!==(d=h.Vd())&&void 0!==d&&d.length?h.getTotalIndices():h.getTotalVertices();return Array(m/3).fill(3).join(", ")}(h)}]\n\t\tint[] faceVertexIndices = [${function(h){const d=h.Vd(),m=[];if(null!==d)for(let j=0;j<d.length;j++)m.push(d[j]);else{const d=h.getTotalVertices();for(let h=0;h<d;h++)m.push(h)}return m.join(", ")}(h)}]\n\t\tnormal3f[] normals = [${Ud(j,d)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Ud(m,d)}]\n        ${function(h,d){let m="";for(let A=0;A<4;A++){const j=A>0?A:"",b=h.getVerticesData(M.d.UVKind+(j?j+1:""));b&&(m+=`\n\t\ttexCoord2f[] primvars:st${j} = [${sd(b,d)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const j=h.getVerticesData(M.d.ColorKind);return j&&(m+=`\n\tcolor3f[] primvars:displayColor = [${Ud(j,d,j.length/h.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),m}(h,d)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Od(h,d){return`\n        def "Geometry"\n        {\n        ${Jd(h,d)}\n        }\n        `}function nd(h){let d='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return d+=h,fflate.strToU8(d)}function pd(h){const d=h.m;return`( ${ed(d,0)}, ${ed(d,4)}, ${ed(d,8)}, ${ed(d,12)} )`}function ed(h,d){return`(${h[d+0]}, ${h[d+1]}, ${h[d+2]}, ${h[d+3]})`}function Xd(h){const d="Object_"+h.uniqueId,m=function(h){const d=h.getWorldMatrix().clone(),m=h.ih().useRightHandedSystem;if(!m){let j=h.parent;for(;j;){if(wh(j,m)){d.multiplyToRef(j.getWorldMatrix().invert(),d);break}j=j.parent}}return d.determinant()<0&&A.e.Warn(`Exporting mesh ${h.name} with negative scale. Result may look incorrect in destination engine.`),d}(h),j=pd(m);return`def Xform "${d}" (\n\tprepend references = @./geometries/Geometry_${h.Ld.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${j}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${h.material.uniqueId}>\n}\n\n`}function zd(h){switch(h){case y.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case y.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case y.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function ud(h){return`(${h.x}, ${h.y})`}function Pd(h){return`(${h.r}, ${h.g}, ${h.b})`}function Gd(h,d,m,A,b,w){const a=h.getInternalTexture().uniqueId+"_"+h.invertY;b[a]=h;const D=h.coordinatesIndex>0?"st"+h.coordinatesIndex:"st",S=new j.h(h.uScale,h.vScale),M=new j.h(h.uOffset,h.vOffset),q=h.wAng,E=Math.sin(q),I=Math.cos(q);return M.y=1-M.y-S.y,M.x+=E*S.x,M.y+=(1-I)*S.y,`\n    def Shader "PrimvarReader_${m}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${D}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${m}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${d.uniqueId}/PrimvarReader_${m}.outputs:result>\n        float inputs:rotation = ${(q*(180/Math.PI)).toFixed(w.precision)}\n        float2 inputs:scale = ${ud(S)}\n        float2 inputs:translation = ${ud(M)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${h.uniqueId}_${m}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${a}.png@\n        float2 inputs:st.connect = </Materials/Material_${d.uniqueId}/Transform2d_${m}.outputs:result>\n        ${A?"float4 inputs:scale = "+function(h){return`(${h.r}, ${h.g}, ${h.b}, 1.0)`}(A):""}\n        token inputs:sourceColorSpace = "${h.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${zd(h.wrapU)}"\n        token inputs:wrapT = "${zd(h.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${d.needAlphaBlending()?"float outputs:a":""}\n    }`}function hm(h,d,m){const j="\t\t\t",A=[],b=[],{diffuseMap:w,Db:a,alphaCutOff:D,emissiveMap:S,emissive:M,normalMap:q,roughnessMap:E,roughnessChannel:I,roughness:R,metalnessMap:Z,metalnessChannel:B,metalness:V,aoMap:v,aoMapChannel:C,aoMapIntensity:T,alphaMap:o,ior:y,clearCoatEnabled:i,clearCoat:g,clearCoatMap:F,clearCoatRoughness:f,clearCoatRoughnessMap:H}=function(h){const d={diffuseMap:null,Db:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return h instanceof Zh.b?{...d,diffuseMap:h.diffuseTexture,Db:h.diffuseColor,alphaCutOff:h.alphaCutOff,emissiveMap:h.emissiveTexture,emissive:h.emissiveColor,roughness:1,alphaMap:h.opacityTexture}:h instanceof Sd.c?{...d,diffuseMap:h._albedoTexture,Db:h._albedoColor,alphaCutOff:h._alphaCutOff,emissiveMap:h._emissiveTexture,emissive:h._emissiveColor,normalMap:h._bumpTexture,roughnessMap:h._metallicTexture,roughnessChannel:h._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:h._roughness??1,metalnessMap:h._metallicTexture,metalnessChannel:h._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:h._metallic??0,aoMap:h._ambientTexture,aoMapChannel:h._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:h._ambientTextureStrength,alphaMap:h._opacityTexture,ior:h.subSurface.indexOfRefraction,clearCoatEnabled:h.clearCoat.isEnabled,clearCoat:h.clearCoat.ab,clearCoatMap:h.clearCoat.texture,clearCoatRoughness:h.clearCoat.roughness,clearCoatRoughnessMap:h.clearCoat.useRoughnessFromMainTexture?h.clearCoat.texture:h.clearCoat.textureRoughness}:d}(h);return null!==w?(A.push(`${j}color3f inputs:diffuseColor.connect = </Materials/Material_${h.uniqueId}/Texture_${w.uniqueId}_diffuse.outputs:rgb>`),h.needAlphaBlending()?A.push(`${j}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${w.uniqueId}_diffuse.outputs:a>`):h.needAlphaTesting()&&(A.push(`${j}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${w.uniqueId}_diffuse.outputs:a>`),A.push(`${j}float inputs:opacityThreshold = ${D}`)),b.push(Gd(w,h,"diffuse",a,d,m))):A.push(`${j}color3f inputs:diffuseColor = ${Pd(a||L.d.White())}`),null!==S?(A.push(`${j}color3f inputs:emissiveColor.connect = </Materials/Material_${h.uniqueId}/Texture_${S.uniqueId}_emissive.outputs:rgb>`),b.push(Gd(S,h,"emissive",M,d,m))):M&&M.toLuminance()>0&&A.push(`${j}color3f inputs:emissiveColor = ${Pd(M)}`),null!==q&&(A.push(`${j}normal3f inputs:normal.connect = </Materials/Material_${h.uniqueId}/Texture_${q.uniqueId}_normal.outputs:rgb>`),b.push(Gd(q,h,"Dd",null,d,m))),null!==v&&(A.push(`${j}float inputs:occlusion.connect = </Materials/Material_${h.uniqueId}/Texture_${v.uniqueId}_occlusion.outputs:${C}>`),b.push(Gd(v,h,"occlusion",new L.d(T,T,T),d,m))),null!==E?(A.push(`${j}float inputs:roughness.connect = </Materials/Material_${h.uniqueId}/Texture_${E.uniqueId}_roughness.outputs:${I}>`),b.push(Gd(E,h,"roughness",new L.d(R,R,R),d,m))):A.push(`${j}float inputs:roughness = ${R}`),null!==Z?(A.push(`${j}float inputs:metallic.connect = </Materials/Material_${h.uniqueId}/Texture_${Z.uniqueId}_metallic.outputs:${B}>`),b.push(Gd(Z,h,"metallic",new L.d(V,V,V),d,m))):A.push(`${j}float inputs:metallic = ${V}`),null!==o?(A.push(`${j}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${o.uniqueId}_opacity.outputs:r>`),A.push(`${j}float inputs:opacityThreshold = 0.0001`),b.push(Gd(o,h,"opacity",null,d,m))):A.push(`${j}float inputs:opacity = ${h.alpha}`),i&&(null!==F?(A.push(`${j}float inputs:clearcoat.connect = </Materials/Material_${h.uniqueId}/Texture_${F.uniqueId}_clearcoat.outputs:r>`),b.push(Gd(F,h,"clearcoat",new L.d(g,g,g),d,m))):A.push(`${j}float inputs:clearcoat = ${g}`),null!==H?(A.push(`${j}float inputs:clearcoatRoughness.connect = </Materials/Material_${h.uniqueId}/Texture_${H.uniqueId}_clearcoatRoughness.outputs:g>`),b.push(Gd(H,h,"clearcoatRoughness",new L.d(f,f,f),d,m))):A.push(`${j}float inputs:clearcoatRoughness = ${f}`)),A.push(`${j}float inputs:ior = ${y}`),`\n\tdef Material "Material_${h.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${A.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${h.uniqueId}/PreviewSurface.outputs:surface>\n\n${b.join("\n")}\n\n\t}\n`}async function dm(h,d,m){const b={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...d};"undefined"===typeof fflate&&await A.e.LoadScriptAsync(b.fflateUrl);const w={};w[b.modelFileName]=null;let a='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';a+=function(h){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===h.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${h.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${h.planeAnchoringAlignment}"`:""}\n            `}(b);const D={};for(const j of h.meshes){if(0===j.getTotalVertices())continue;const h=j,d=h.Ld,S=h.material;if(!S||!d||m&&!m(h))continue;if(-1!==["Sb","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(S.getClassName())){const m="geometries/Geometry_"+d.uniqueId+".usda";if(!(m in w)){const h=Od(d,b);w[m]=nd(h)}S.uniqueId in D||(D[S.uniqueId]=S),a+=Xd(h)}else A.e.Warn("USDZExportAsync does not support this material type: "+S.getClassName())}h.activeCamera&&b.exportCamera&&(a+=function(h,d){const m="Camera_"+h.uniqueId,A=pd(j.b.RotationY(Math.PI).multiply(h.getWorldMatrix()));if(h.mode===y.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${m}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${A}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${h.jb.toPrecision(d.precision)}, ${h.maxZ.toPrecision(d.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(h.orthoLeft||1)+Math.abs(h.orthoRight||1))).toPrecision(d.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(h.orthoTop||1)+Math.abs(h.orthoBottom||1))).toPrecision(d.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const j=h.getEngine().getAspectRatio(h),b=d.cameraSensorWidth||35;return`def Camera "${m}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${A}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${h.jb.toPrecision(d.precision)}, ${h.maxZ.toPrecision(d.precision)})\n\t\t\tfloat focalLength = ${(b/(2*Math.tan(.5*h.fov))).toPrecision(d.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(b*j).toPrecision(d.precision)}\n\t\t\tfloat verticalAperture = ${(b/j).toPrecision(d.precision)}            \n\t\t}\n\t\n\t`}}(h.activeCamera,b)),a+="\n            }\n        }\n    }";const S={};a+=function(h,d,m){const j=[];for(const A in h){const b=h[A];j.push(hm(b,d,m))}return`\n    def "Materials"\n{\n${j.join("")}\n}\n\n`}(D,S,b),w[b.modelFileName]=fflate.strToU8(a);for(const j in S){const h=S[j],d=h.getSize(),m=await h.readPixels();if(!m)throw new Error("Texture data is not available");const A=await i.DumpTools.DumpDataAsync(d.width,d.height,m,"image/png",void 0,!1,!0);w[`textures/Texture_${j}.png`]=new Uint8Array(A).slice()}let M=0;for(const j in w){const h=w[j];if(!h)continue;M+=34+j.length;const d=63&M;if(4!==d){const m=new Uint8Array(64-d);w[j]=[h,{extra:{12345:m}}]}M=h.length}return fflate.zipSync(w,{level:0})}}}]);