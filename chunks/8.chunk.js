"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{11134:(G,V,W)=>{W.r(V),W.d(V,{EXT_materials_diffuse_roughness:()=>NV,EXT_mesh_gpu_instancing:()=>EG,GLTF2Export:()=>QG,GLTFData:()=>P,KHR_draco_mesh_compression:()=>WV,KHR_lights_punctual:()=>XV,KHR_materials_anisotropy:()=>xV,KHR_materials_clearcoat:()=>LV,KHR_materials_diffuse_transmission:()=>gV,KHR_materials_dispersion:()=>SV,KHR_materials_emissive_strength:()=>bV,KHR_materials_ior:()=>yV,KHR_materials_iridescence:()=>HV,KHR_materials_sheen:()=>DV,KHR_materials_specular:()=>eV,KHR_materials_transmission:()=>fV,KHR_materials_unlit:()=>CV,KHR_materials_volume:()=>mV,KHR_texture_transform:()=>aV,OBJExport:()=>k,STLExport:()=>MV,USDZExportAsync:()=>VW,_ConvertToGLTFPBRMetallicRoughness:()=>v,_SolveMetallic:()=>f,__IGLTFExporterExtension:()=>z});var J=W(11136),R=W(11189),d=W(11313);class k{static OBJ(G,V,W,k){const z=[];let X=1,P=1;V&&(W||(W="mat"),z.push("mtllib "+W+".mtl"));for(let A=0;A<G.length;A++){const W=G[A],x=W.name||`mesh${A}}`;z.push(`o ${x}`);let q=null;if(k){const G=W.kd(!0);q=new J.c,G.invertToRef(q),W.bakeTransformIntoVertices(G)}if(V){const G=W.material;G&&z.push("usemtl "+G.id)}const L=W.zd;if(!L){R.h.Warn("No geometry is present on the mesh");continue}const t=L.getVerticesData("position"),Y=L.getVerticesData("IV"),g=L.getVerticesData("uv"),B=L.Pd();let S=0,p=0;if(!t||!B){R.h.Warn("There are no position vertices or indices on the mesh!");continue}const b=G[0].HG().useRightHandedSystem?1:-1;for(let G=0;G<t.length;G+=3)z.push("v "+t[G]*b+" "+t[G+1]+" "+t[G+2]),S++;if(null!=Y)for(let G=0;G<Y.length;G+=3)z.push("vn "+Y[G]*b+" "+Y[G+1]+" "+Y[G+2]);if(null!=g)for(let G=0;G<g.length;G+=2)z.push("vt "+g[G]+" "+g[G+1]),p++;const r=["","",""],y=(W.material||W.HG().defaultMaterial)._getEffectiveOrientation(W),[u,H]=y===d.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let G=0;G<B.length;G+=3){const V=[String(B[G]+X),String(B[G+u]+X),String(B[G+H]+X)],W=[String(B[G]+P),String(B[G+u]+P),String(B[G+H]+P)],J=V,R=null!=g?W:r,d=null!=Y?V:r;z.push("f "+J[0]+"/"+R[0]+"/"+d[0]+" "+J[1]+"/"+R[1]+"/"+d[1]+" "+J[2]+"/"+R[2]+"/"+d[2])}k&&q&&W.bakeTransformIntoVertices(q),X+=S,P+=p}return z.join("\n")}static MTL(G){const V=[],W=G.material;V.push("newmtl mat1"),V.push("  Ns "+W.specularPower.toFixed(4)),V.push("  Ni 1.5000"),V.push("  d "+W.alpha.toFixed(4)),V.push("  Tr 0.0000"),V.push("  Tf 1.0000 1.0000 1.0000"),V.push("  illum 2"),V.push("  Ka "+W.ambientColor.r.toFixed(4)+" "+W.ambientColor.g.toFixed(4)+" "+W.ambientColor.b.toFixed(4)),V.push("  Kd "+W.diffuseColor.r.toFixed(4)+" "+W.diffuseColor.g.toFixed(4)+" "+W.diffuseColor.b.toFixed(4)),V.push("  Ks "+W.specularColor.r.toFixed(4)+" "+W.specularColor.g.toFixed(4)+" "+W.specularColor.b.toFixed(4)),V.push("  Ke "+W.emissiveColor.r.toFixed(4)+" "+W.emissiveColor.g.toFixed(4)+" "+W.emissiveColor.b.toFixed(4));W.ambientTexture&&V.push("  map_Ka "+W.ambientTexture.name),W.diffuseTexture&&V.push("  map_Kd "+W.diffuseTexture.name),W.specularTexture&&V.push("  map_Ks "+W.specularTexture.name),W.bumpTexture&&V.push("  map_bump -imfchan z "+W.bumpTexture.name),W.opacityTexture&&V.push("  map_d "+W.opacityTexture.name);return V.join("\n")}}var z=0,X=W(11227);class P{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const G in this.files){const V=this.files[G],W=new Blob([V],{type:(0,X.g)(G)});R.h.Download(W,G)}}}var A=W(11345),x=W(11457),q=W(11473),L=W(11501),t=W(11564),Y=W(11169),g=W(11424),B=W(11182);const S=B.HighestCommonFactor,p={...B,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:S};var b=W(11663),r=W(11666),y=W(11701),u=W(11705),H=W(11710);const n=1e-6,D=new g.d(.04,.04,.04),i=1024,e=g.d.White(),F=g.d.Black();function f(G,V,W){if(V<D.r)return 0;const J=D.r,R=G*W/(1-D.r)+V-2*D.r,d=R*R-4*J*(D.r-V);return p.Clamp((-R+Math.sqrt(d))/(2*J),0,1)}function v(G){const V=G.diffuseColor.toLinearSpace(G.HG().getEngine().useExactSrgbConversions).scale(.5),W=G.alpha,R=function(G){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new J.k(0,1),W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new J.k(0,.1),R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new J.k(0,.1),d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new J.k(1300,.1);return function(G,V,W,J,R){return(1-G)*(1-G)*(1-G)*V+3*(1-G)*(1-G)*G*W+3*(1-G)*G*G*J+G*G*G*R}(Math.pow(G/d.x,.333333),V.y,W.y,R.y,d.y)}(p.Clamp(G.specularPower,0,i));return{baseColorFactor:[V.r,V.g,V.b,W],metallicFactor:0,roughnessFactor:R}}function C(G,V){V.needAlphaBlending()?G.alphaMode="BLEND":V.needAlphaTesting()&&(G.alphaMode="MASK",G.alphaCutoff=V.alphaCutOff)}function l(G,V,W){const J=new Uint8Array(G*V*4);for(let R=0;R<J.length;R+=4)J[R]=J[R+1]=J[R+2]=J[R+3]=255;return y.b.CreateRGBATexture(J,G,V,W)}function m(G){if(G instanceof Uint8Array){const V=G.length,W=new Float32Array(G.length);for(let J=0;J<V;++J)W[J]=G[J]/255;return W}if(G instanceof Float32Array)return G;throw new Error("Unsupported pixel format!")}class w{constructor(G){this._exporter=G,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(G){return G?this._textureMap.get(G)??null:null}async exportStandardMaterialAsync(G,V,W){const J=v(G),d={name:G.name};if(null==G.gd||G.gd||(G.twoSidedLighting||R.h.Warn(G.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),d.doubleSided=!0),W){const W=[],R=G.diffuseTexture;R&&W.push(this.exportTextureAsync(R,V).then((G=>{G&&(J.baseColorTexture=G)})));const k=G.bumpTexture;k&&W.push(this.exportTextureAsync(k,V).then((G=>{G&&(d.normalTexture=G,1!==k.level&&(d.normalTexture.scale=k.level))})));const z=G.emissiveTexture;z&&(d.emissiveFactor=[1,1,1],W.push(this.exportTextureAsync(z,V).then((G=>{G&&(d.emissiveTexture=G)}))));const X=G.ambientTexture;X&&W.push(this.exportTextureAsync(X,V).then((G=>{if(G){const V={index:G.index};d.occlusionTexture=V}}))),W.length>0&&(this._exporter._materialNeedsUVsSet.add(G),await Promise.all(W))}(G.alpha<1||G.opacityTexture)&&(G.alphaMode===u.d.ALPHA_COMBINE?d.alphaMode="BLEND":R.h.Warn(G.name+": glTF 2.0 does not support alpha mode: "+G.alphaMode.toString())),G.emissiveColor&&!G.emissiveColor.equalsWithEpsilon(F,n)&&(d.emissiveFactor=G.emissiveColor.Bd()),d.pbrMetallicRoughness=J,C(d,G),await this._finishMaterialAsync(d,G,V);const k=this._exporter._materials;return k.push(d),k.length-1}async _finishMaterialAsync(G,V,W){const J=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",G,V),R=[];for(const d of J)R.push(this.exportTextureAsync(d,W));await Promise.all(R),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",G,V)}async _getImageDataAsync(G,V,J,R){const d=u.d.TEXTURETYPE_UNSIGNED_BYTE,k=this._exporter._babylonScene,z=k.getEngine(),X=z.createRawTexture(G,V,J,u.d.TEXTUREFORMAT_RGBA,!1,!0,r.d.NEAREST_SAMPLINGMODE,null,d);z.isWebGPU?await W.e(36).then(W.bind(W,13819)):await W.e(37).then(W.bind(W,13822)),await b.n.ApplyPostProcess("pass",X,k,d,u.d.TEXTURE_NEAREST_SAMPLINGMODE,u.d.TEXTUREFORMAT_RGBA);const P=await z._readTexturePixels(X,V,J);return await H.DumpTools.DumpDataAsync(V,J,P,R,void 0,!0,!0)}_resizeTexturesToSameDimensions(G,V,W){const J=G?G.getSize():{width:0,height:0},R=V?V.getSize():{width:0,height:0};let d,k;return J.width<R.width?(d=G&&G instanceof r.d?b.n.CreateResizedCopy(G,R.width,R.height,!0):l(R.width,R.height,W),k=V):J.width>R.width?(k=V&&V instanceof r.d?b.n.CreateResizedCopy(V,J.width,J.height,!0):l(J.width,J.height,W),d=G):(d=G,k=V),{texture1:d,texture2:k}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(G,V,W,J){const R=new Array;if(!G&&!V)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const d=G?G.HG():V?V.HG():null;if(d){var k;const z=this._resizeTexturesToSameDimensions(G,V,d),X=null===(k=z.texture1)||void 0===k?void 0:k.getSize();let P,A;const x=X.width,q=X.height,L=await z.texture1.readPixels(),t=await z.texture2.readPixels();if(!L)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(P=m(L),!t)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");A=m(t);const Y=A.byteLength,B=new Uint8Array(Y),S=new Uint8Array(Y),p=4,b=F;let r=0,y=0;for(let G=0;G<q;++G)for(let V=0;V<x;++V){const J=(x*G+V)*p,R={diffuseColor:new g.d(P[J],P[J+1],P[J+2]).toLinearSpace(d.getEngine().useExactSrgbConversions).multiply(W.diffuseColor),specularColor:new g.d(A[J],A[J+1],A[J+2]).toLinearSpace(d.getEngine().useExactSrgbConversions).multiply(W.specularColor),glossiness:A[J+3]*W.glossiness},k=this._convertSpecularGlossinessToMetallicRoughness(R);b.r=Math.max(b.r,k.baseColor.r),b.g=Math.max(b.g,k.baseColor.g),b.b=Math.max(b.b,k.baseColor.b),r=Math.max(r,k.metallic),y=Math.max(y,k.roughness),S[J]=255*k.baseColor.r,S[J+1]=255*k.baseColor.g,S[J+2]=255*k.baseColor.b,S[J+3]=z.texture1.bd?255*P[J+3]:255,B[J]=0,B[J+1]=255*k.roughness,B[J+2]=255*k.metallic,B[J+3]=255}const u={baseColor:b,metallic:r,roughness:y};let H=!1,D=!1;for(let G=0;G<q;++G)for(let V=0;V<x;++V){const W=(x*G+V)*p;S[W]/=u.baseColor.r>n?u.baseColor.r:1,S[W+1]/=u.baseColor.g>n?u.baseColor.g:1,S[W+2]/=u.baseColor.b>n?u.baseColor.b:1;const J=g.d.FromInts(S[W],S[W+1],S[W+2]).toGammaSpace(d.getEngine().useExactSrgbConversions);S[W]=255*J.r,S[W+1]=255*J.g,S[W+2]=255*J.b,J.equalsWithEpsilon(e,n)||(D=!0),B[W+1]/=u.roughness>n?u.roughness:1,B[W+2]/=u.metallic>n?u.metallic:1;g.d.FromInts(255,B[W+1],B[W+2]).equalsWithEpsilon(e,n)||(H=!0)}return H&&R.push(this._getImageDataAsync(B,x,q,J).then((G=>{u.metallicRoughnessTextureData=G}))),D&&R.push(this._getImageDataAsync(S,x,q,J).then((G=>{u.baseColorTextureData=G}))),await Promise.all(R).then((()=>u))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(G){const V=this._getPerceivedBrightness(G.diffuseColor),W=this._getPerceivedBrightness(G.specularColor),J=1-this._getMaxComponent(G.specularColor),R=f(V,W,J),d=G.diffuseColor.scale(J/(1-D.r)/Math.max(1-R)),k=G.specularColor.zW(D.scale(1-R)).scale(1/Math.max(R));let z=g.d.Lerp(d,k,R*R);z=z.clampToRef(0,1,z);return{baseColor:z,metallic:R,roughness:1-G.glossiness}}_getPerceivedBrightness(G){return G?Math.sqrt(.299*G.r*G.r+.587*G.g*G.g+.114*G.b*G.b):0}_getMaxComponent(G){return G?Math.max(G.r,Math.max(G.g,G.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(G,V,W,J){const R=[],d={baseColor:G._albedoColor,metallic:G._metallic,roughness:G._roughness};if(J){G._albedoTexture&&R.push(this.exportTextureAsync(G._albedoTexture,V).then((G=>{G&&(W.baseColorTexture=G)})));const J=G._metallicTexture;J&&R.push(this.exportTextureAsync(J,V).then((G=>{G&&(W.metallicRoughnessTexture=G)})))}return R.length>0&&(this._exporter._materialNeedsUVsSet.add(G),await Promise.all(R)),d}_getTextureSampler(G){const V={};if(!G||!(G instanceof r.d))return V;const W=this._getGLTFTextureWrapMode(G.wrapU);10497!==W&&(V.wrapS=W);const J=this._getGLTFTextureWrapMode(G.wrapV);switch(10497!==J&&(V.wrapT=J),G.samplingMode){case r.d.LINEAR_LINEAR:V.magFilter=9729,V.minFilter=9729;break;case r.d.LINEAR_NEAREST:V.magFilter=9729,V.minFilter=9728;break;case r.d.NEAREST_LINEAR:V.magFilter=9728,V.minFilter=9729;break;case r.d.NEAREST_LINEAR_MIPLINEAR:V.magFilter=9728,V.minFilter=9987;break;case r.d.NEAREST_NEAREST:V.magFilter=9728,V.minFilter=9728;break;case r.d.NEAREST_LINEAR_MIPNEAREST:V.magFilter=9728,V.minFilter=9985;break;case r.d.LINEAR_NEAREST_MIPNEAREST:V.magFilter=9729,V.minFilter=9984;break;case r.d.LINEAR_NEAREST_MIPLINEAR:V.magFilter=9729,V.minFilter=9986;break;case r.d.NEAREST_NEAREST_MIPLINEAR:V.magFilter=9728,V.minFilter=9986;break;case r.d.LINEAR_LINEAR_MIPLINEAR:V.magFilter=9729,V.minFilter=9987;break;case r.d.LINEAR_LINEAR_MIPNEAREST:V.magFilter=9729,V.minFilter=9985;break;case r.d.NEAREST_NEAREST_MIPNEAREST:V.magFilter=9728,V.minFilter=9984}return V}_getGLTFTextureWrapMode(G){switch(G){case r.d.WRAP_ADDRESSMODE:return 10497;case r.d.CLAMP_ADDRESSMODE:return 33071;case r.d.MIRROR_ADDRESSMODE:return 33648;default:return R.h.Error(`Unsupported Texture Wrap Mode ${G}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(G,V,W,J){const R={diffuseColor:G._albedoColor,specularColor:G._reflectivityColor,glossiness:G._microSurface},d=G._albedoTexture,k=G._reflectivityTexture,z=G._useMicroSurfaceFromReflectivityMapAlpha;if(k&&!z)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((d||k)&&J){this._exporter._materialNeedsUVsSet.add(G);const J=this._exportTextureSampler(d||k),z=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(d,k,R,V),X=this._exporter._textures;if(z.baseColorTextureData){const G=this._exportImage(`baseColor${X.length}`,V,z.baseColorTextureData);W.baseColorTexture=this._exportTextureInfo(G,J,null===d||void 0===d?void 0:d.coordinatesIndex)}if(z.metallicRoughnessTextureData){const G=this._exportImage(`metallicRoughness${X.length}`,V,z.metallicRoughnessTextureData);W.metallicRoughnessTexture=this._exportTextureInfo(G,J,null===k||void 0===k?void 0:k.coordinatesIndex)}return z}return this._convertSpecularGlossinessToMetallicRoughness(R)}async exportPBRMaterialAsync(G,V,W){const J={},R={name:G.name},d=G.isMetallicWorkflow();if(d){const V=G._albedoColor,W=G.alpha;V&&(J.baseColorFactor=[V.r,V.g,V.b,W])}const k=d?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(G,V,J,W):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(G,V,J,W);await this._setMetallicRoughnessPbrMaterialAsync(k,G,R,J,V,W),await this._finishMaterialAsync(R,G,V);const z=this._exporter._materials;return z.push(R),z.length-1}async _setMetallicRoughnessPbrMaterialAsync(G,V,W,J,d,k){if(C(W,V),G.baseColor.equalsWithEpsilon(e,n)&&p.WithinEpsilon(V.alpha,1,n)||(J.baseColorFactor=[G.baseColor.r,G.baseColor.g,G.baseColor.b,V.alpha]),null!=G.metallic&&1!==G.metallic&&(J.metallicFactor=G.metallic),null!=G.roughness&&1!==G.roughness&&(J.roughnessFactor=G.roughness),null==V.gd||V.gd||(V._twoSidedLighting||R.h.Warn(V.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),W.doubleSided=!0),k){const G=[],J=V._bumpTexture;J&&G.push(this.exportTextureAsync(J,d).then((G=>{G&&(W.normalTexture=G,1!==J.level&&(W.normalTexture.scale=J.level))})));const R=V._ambientTexture;R&&G.push(this.exportTextureAsync(R,d).then((G=>{if(G){const J={index:G.index,texCoord:G.texCoord,extensions:G.extensions};W.occlusionTexture=J;const R=V._ambientTextureStrength;R&&(J.strength=R)}})));const k=V._emissiveTexture;k&&G.push(this.exportTextureAsync(k,d).then((G=>{G&&(W.emissiveTexture=G)}))),G.length>0&&(this._exporter._materialNeedsUVsSet.add(V),await Promise.all(G))}const z=V._emissiveColor;z.equalsWithEpsilon(F,n)||(W.emissiveFactor=z.Bd()),W.pbrMetallicRoughness=J}_getPixelsFromTextureAsync(G){return function(G){switch(G){case u.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case u.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case u.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case u.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case u.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case u.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case u.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case u.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case u.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case u.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case u.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case u.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case u.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case u.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case u.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case u.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case u.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case u.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case u.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case u.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case u.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(G.textureFormat)?(0,b.l)(G,G._texture.width,G._texture.height):(G.textureType,u.d.TEXTURETYPE_UNSIGNED_BYTE,G.readPixels())}async exportTextureAsync(G,V){const W=this._exporter._extensionsPreExportTextureAsync("exporter",G,V);return W?await W.then((async W=>W?await this._exportTextureInfoAsync(W,V):await this._exportTextureInfoAsync(G,V))):await this._exportTextureInfoAsync(G,V)}async _exportTextureInfoAsync(G,V){let W=this._textureMap.get(G);if(!W){const J=await this._getPixelsFromTextureAsync(G);if(!J)return null;const d=this._exportTextureSampler(G),k=G.mimeType;if(k)switch(k){case"image/jpeg":case"image/png":case"image/webp":V=k;break;default:R.h.Warn(`Unsupported media type: ${k}. Exporting texture as PNG.`)}const z=this._internalTextureToImage,X=G.getInternalTexture().uniqueId;z[X]||(z[X]={});let P=z[X][V];if(void 0===P){const W=G.getSize();P=(async()=>{const R=await this._getImageDataAsync(J,W.width,W.height,V);return this._exportImage(G.name,V,R)})(),z[X][V]=P}W=this._exportTextureInfo(await P,d,G.coordinatesIndex),this._textureMap.set(G,W),this._exporter._extensionsPostExportTextures("exporter",W,G)}return W}_exportImage(G,V,W){const J=this._exporter._images;let d;if(this._exporter._shouldUseGlb){d={name:G,mimeType:V,bufferView:void 0};const J=this._exporter._bufferManager.createBufferView(new Uint8Array(W));this._exporter._bufferManager.setBufferView(d,J)}else{const k=G.replace(/\.\/|\/|\.\\|\\/g,"_"),z=function(G){switch(G){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(V);let X=k+z;J.some((G=>G.uri===X))&&(X=`${k}_${R.h.RandomId()}${z}`),d={name:G,uri:X},this._exporter._imageData[X]={data:W,mimeType:V}}return J.push(d),J.length-1}_exportTextureInfo(G,V,W){const J=this._exporter._textures;let R=J.findIndex((W=>W.sampler==V&&W.source===G));-1===R&&(R=J.length,J.push({source:G,sampler:V}));const d={index:R};return W&&(d.texCoord=W),d}_exportTextureSampler(G){const V=this._getTextureSampler(G),W=this._exporter._samplers,J=W.findIndex((G=>G.minFilter===V.minFilter&&G.magFilter===V.magFilter&&G.wrapS===V.wrapS&&G.wrapT===V.wrapT));return-1!==J?J:(W.push(V),W.length-1)}}var N=W(11358),U=W(11201),a=W(11718),M=W(11145);const T=J.o.Zero(),K=J.g.Identity(),s=J.o.One(),Q=new J.o(-1,1,1);function Z(G,V){const{byteOffset:W,byteStride:J,type:R,normalized:d}=G,k=G.getSize(),z=V.reduce(((G,V)=>V.getTotalVertices()>G?V.getTotalVertices():G),-Number.MAX_VALUE);return{byteOffset:W,byteStride:J,componentCount:k,type:R,count:z*k,normalized:d,totalVertices:z,kind:G.getKind()}}function E(G){switch(G){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function h(G){switch(G){case A.c.PositionKind:case A.c.NormalKind:case A.c.TangentKind:case A.c.ColorKind:case A.c.MatricesIndicesKind:case A.c.MatricesIndicesExtraKind:case A.c.MatricesWeightsKind:case A.c.MatricesWeightsExtraKind:case A.c.UVKind:case A.c.UV2Kind:case A.c.UV3Kind:case A.c.UV4Kind:case A.c.UV5Kind:case A.c.UV6Kind:return!0}return!1}function o(G){switch(G){case d.e.TriangleFillMode:return 4;case d.e.TriangleStripDrawMode:return 5;case d.e.TriangleFanDrawMode:return 6;case d.e.PointListDrawMode:case d.e.PointFillMode:return 0;case d.e.LineLoopDrawMode:return 2;case d.e.LineListDrawMode:return 1;case d.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${G}`)}function c(G){const V=Math.sqrt(G.x*G.x+G.y*G.y+G.z*G.z);V>0&&(G.x/=V,G.y/=V,G.z/=V)}function j(G){return G.x*=-1,G}function I(G){if(G.x*G.x+G.y*G.y>.5){const V=Math.abs(G.x),W=Math.abs(G.y);if(V>W){const W=Math.sign(G.x);G.x=V,G.y*=-W,G.z*=-W,G.w*=W}else{const V=Math.sign(G.y);G.x*=-V,G.y=W,G.z*=V,G.w*=-V}}else{const V=Math.abs(G.z),W=Math.abs(G.w);if(V>W){const W=Math.sign(G.z);G.x*=-W,G.y*=W,G.z=V,G.w*=-W}else{const V=Math.sign(G.w);G.x*=V,G.y*=-V,G.z*=-V,G.w=W}}return G}function O(G){G.rd(-G.z,G.w,G.x,-G.y)}function GG(G,V){const W=J.o.FromArrayToRef(V.translation||[0,0,0],0,J.h.ed[0]),R=J.g.FromArrayToRef(V.rotation||[0,0,0,1],0,J.h.Quaternion[0]),d=J.c.ComposeToRef(s,R,W,J.h.Matrix[0]),k=J.o.FromArrayToRef(G.translation||[0,0,0],0,J.h.ed[2]),z=J.g.FromArrayToRef(G.rotation||[0,0,0,1],0,J.h.Quaternion[1]),X=J.c.ComposeToRef(s,z,k,J.h.Matrix[1]);d.multiplyToRef(X,X),X.decompose(void 0,R,W),W.equalsWithEpsilon(T,M.c)?delete V.translation:V.translation=W.Bd(),R.equalsWithEpsilon(K,M.c)?delete V.rotation:V.rotation=R.Bd(),V.scale&&delete V.scale}function VG(G,V){if(!(V instanceof x.b))return!1;if(!(1===V.getChildren().length&&0===G.getChildren().length&&G.parent===V))return!1;const W=G.HG(),J=G instanceof a.e&&!W.useRightHandedSystem?Q:s;return!!V.vd.equalsWithEpsilon(J,M.c)||(U.c.Warn(`Cannot collapse node ${G.name} into parent node ${V.name} with modified scaling.`),!1)}function WG(G){if(G instanceof Array){const V=new Float32Array(G);return new Uint8Array(V.buffer,V.byteOffset,V.byteLength)}return ArrayBuffer.isView(G)?new Uint8Array(G.buffer,G.byteOffset,G.byteLength):new Uint8Array(G)}function JG(G,V){for(const[W,J]of Object.entries(G)){const R=V[W];(Array.isArray(J)&&Array.isArray(R)&&RG(J,R)||J===R)&&delete G[W]}return G}function RG(G,V){return G.length===V.length&&G.every(((G,W)=>G===V[W]))}const dG=J.c.Compose(new J.o(-1,1,1),J.g.Identity(),J.o.Zero());function kG(G,V){if(!(G instanceof x.b))return!1;if(V){if(!G.getWorldMatrix().equalsWithEpsilon(J.c.IdentityReadOnly,M.c))return!1}else{if(!G.getWorldMatrix().multiplyToRef(dG,J.h.Matrix[0]).equalsWithEpsilon(J.c.IdentityReadOnly,M.c))return!1}return!(G instanceof q.b&&G.zd)}const zG=new Map([[Int8Array,(G,V,W)=>G.setInt8(V,W)],[Uint8Array,(G,V,W)=>G.setUint8(V,W)],[Uint8ClampedArray,(G,V,W)=>G.setUint8(V,W)],[Int16Array,(G,V,W)=>G.setInt16(V,W,!0)],[Uint16Array,(G,V,W)=>G.setUint16(V,W,!0)],[Int32Array,(G,V,W)=>G.setInt32(V,W,!0)],[Uint32Array,(G,V,W)=>G.setUint32(V,W,!0)],[Float32Array,(G,V,W)=>G.setFloat32(V,W,!0)],[Float64Array,(G,V,W)=>G.setFloat64(V,W,!0)]]);class XG{writeTypedArray(G){this._checkGrowBuffer(G.byteLength);const V=zG.get(G.constructor);for(let W=0;W<G.length;W++)V(this._dataView,this._byteOffset,G[W]),this._byteOffset+=G.BYTES_PER_ELEMENT}constructor(G){this._data=new Uint8Array(G),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(G){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,G),this._byteOffset++}writeInt8(G){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,G),this._byteOffset++}writeInt16(G){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,G,!0),this._byteOffset+=2}writeUInt16(G){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,G,!0),this._byteOffset+=2}writeInt32(G){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,G,!0),this._byteOffset+=4}writeUInt32(G){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,G,!0),this._byteOffset+=4}writeFloat32(G){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,G,!0),this._byteOffset+=4}writeFloat64(G){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,G,!0),this._byteOffset+=8}_checkGrowBuffer(G){const V=this.byteOffset+G;if(V>this._data.byteLength){const G=new Uint8Array(2*V);G.set(this._data),this._data=G,this._dataView=new DataView(this._data.buffer)}}}function PG(G){return G%4===0?4:G%2===0?2:1}class AG{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(G){let V=0;this._bufferViewToData.forEach((G=>{V+=G.byteLength}));const W=new XG(V),J=Array.from(this._bufferViewToData.keys()).sort(((G,V)=>PG(V.byteLength)-PG(G.byteLength)));for(const R of J){R.byteOffset=W.byteOffset,G.push(R);const V=G.length-1,J=this.getPropertiesWithBufferView(R);for(const G of J)G.bufferView=V;W.writeTypedArray(this._bufferViewToData.get(R)),this._bufferViewToData.delete(R)}return W.getOutputData()}createBufferView(G,V){const W={buffer:0,byteOffset:void 0,byteLength:G.byteLength,byteStride:V};return this._bufferViewToData.set(W,G),W}createAccessor(G,V,W,J,R,d,k){this._verifyBufferView(G);const z={bufferView:void 0,componentType:W,count:J,type:V,min:null===d||void 0===d?void 0:d.min,max:null===d||void 0===d?void 0:d.max,normalized:k,byteOffset:R};return this.setBufferView(z,G),this._accessorToBufferView.set(z,G),z}setBufferView(G,V){this._verifyBufferView(V);this.getPropertiesWithBufferView(V).push(G)}removeBufferView(G){const V=this.getPropertiesWithBufferView(G);for(const W of V)void 0!==W.bufferView&&delete W.bufferView;this._bufferViewToData.delete(G),this._bufferViewToProperties.delete(G),this._accessorToBufferView.forEach(((V,W)=>{V===G&&(void 0!==W.byteOffset&&delete W.byteOffset,this._accessorToBufferView.delete(W))}))}getBufferView(G){const V=this._accessorToBufferView.get(G);return this._verifyBufferView(V),V}getPropertiesWithBufferView(G){return this._verifyBufferView(G),this._bufferViewToProperties.set(G,this._bufferViewToProperties.get(G)??[]),this._bufferViewToProperties.get(G)}getData(G){return this._verifyBufferView(G),this._bufferViewToData.get(G)}_verifyBufferView(G){if(void 0===G||!this._bufferViewToData.has(G))throw new Error(`BufferView ${G} not found in BufferManager.`)}}var xG,qG=W(11516),LG=W(11557),tG=W(11720),YG=W(11845),gG=W(11847),BG=W(11864),SG=W(11510),pG=W(11868);!function(G){G[G.INTANGENT=0]="INTANGENT",G[G.OUTTANGENT=1]="OUTTANGENT"}(xG||(xG={}));class bG{static _IsTransformable(G){return G&&(G instanceof x.b||G instanceof qG.c||G instanceof pG.e)}static _CreateNodeAnimation(G,V,W,J,d){if(this._IsTransformable(G)){const k=[],z=[],X=V.getKeys(),P=bG._CalculateMinMaxKeyFrames(X),A=bG._DeduceInterpolation(X,W,J),x=A.interpolationType,q=A.shouldBakeAnimation;if(q?bG._CreateBakedAnimation(G,V,W,P.min,P.max,V.framePerSecond,d,k,z,P,J):"LINEAR"===x||"STEP"===x?bG._CreateLinearOrStepAnimation(G,V,W,k,z,J):"CUBICSPLINE"===x?bG._CreateCubicSplineAnimation(G,V,W,k,z,J):bG._CreateBakedAnimation(G,V,W,P.min,P.max,V.framePerSecond,d,k,z,P,J),k.length&&z.length){return{inputs:k,outputs:z,samplerInterpolation:x,inputsMin:q?P.min:R.h.FloatRound(P.min/V.framePerSecond),inputsMax:q?P.max:R.h.FloatRound(P.max/V.framePerSecond)}}}return null}static _DeduceAnimationInfo(G){let V=null,W="VEC3",J=!1;const d=G.targetProperty.split(".");switch(d[0]){case"vd":V="scale";break;case"position":V="translation";break;case"rotation":W="VEC4",V="rotation";break;case"rotationQuaternion":W="VEC4",J=!0,V="rotation";break;case"influence":W="SCALAR",V="weights";break;default:R.h.Error(`Unsupported animatable property ${d[0]}`)}return V?{animationChannelTargetPath:V,dataAccessorType:W,useQuaternion:J}:(R.h.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(G,V,W,J,R,d,k,z,X,P,A){let x;if(bG._IsTransformable(G)&&G.animations)for(const q of G.animations){if(A&&!A(q))continue;const R=bG._DeduceAnimationInfo(q);R&&(x={name:q.name,samplers:[],channels:[]},bG._AddAnimation(`${q.name}`,q.hasRunningRuntimeAnimations?V:x,G,q,R.dataAccessorType,R.animationChannelTargetPath,J,d,k,z,R.useQuaternion,X,P),x.samplers.length&&x.channels.length&&W.push(x))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(G,V,W,J,R,d,k,z,X,P,A){let x;if(G instanceof SG.b){const R=G.morphTargetManager;if(R)for(let q=0;q<R.numTargets;++q){const L=R.getTarget(q);for(const t of L.animations){if(A&&!A(t))continue;const L=new gG.e(`${t.name}`,"influence",t.framePerSecond,t.dataType,t.loopMode,t.enableBlending),Y=[],g=t.getKeys();for(let G=0;G<g.length;++G){const V=g[G];for(let G=0;G<R.numTargets;++G)G==q?Y.push(V):Y.push({frame:V.frame,value:0})}L.setKeys(Y);const B=bG._DeduceAnimationInfo(L);B&&(x={name:L.name,samplers:[],channels:[]},bG._AddAnimation(t.name,t.hasRunningRuntimeAnimations?V:x,G,L,B.dataAccessorType,B.animationChannelTargetPath,J,d,k,z,B.useQuaternion,X,P,R.numTargets),x.samplers.length&&x.channels.length&&W.push(x))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(G,V,W,J,R,d,k,z,X){let P;if(G.animationGroups){const x=G.animationGroups;for(const q of x){const x=new Map,L=new Map,t=new Set,Y=q.to-q.from;P={name:q.name,channels:[],samplers:[]};for(let V=0;V<q.targetedAnimations.length;++V){const Y=q.targetedAnimations[V],g=Y.target,B=Y.animation;if(X&&!X(B))continue;const S=z.has(g);if(this._IsTransformable(g)||1===g.length&&this._IsTransformable(g[0])){const G=bG._DeduceAnimationInfo(Y.animation);if(G){const V=this._IsTransformable(g)?g:this._IsTransformable(g[0])?g[0]:null;V&&bG._AddAnimation(`${B.name}`,P,V,B,G.dataAccessorType,G.animationChannelTargetPath,W,J,R,d,G.useQuaternion,k,S)}}else if(g instanceof BG.d||1===g.length&&g[0]instanceof BG.d){if(bG._DeduceAnimationInfo(Y.animation)){const V=g instanceof BG.d?g:g[0];if(V){const W=G.morphTargetManagers.find((G=>{for(let W=0;W<G.numTargets;++W)if(G.getTarget(W)===V)return!0;return!1}));if(W){const J=G.meshes.find((G=>G.morphTargetManager===W));var A;if(J)x.has(J)||x.set(J,new Map),null===(A=x.get(J))||void 0===A||A.set(V,B),t.add(J),L.set(J,B)}}}}}t.forEach((G=>{const V=G.morphTargetManager;let z=null;const X=[],A=L.get(G).getKeys(),t=A.length;for(let W=0;W<t;++W)for(let J=0;J<V.numTargets;++J){const R=V.getTarget(J),d=x.get(G);if(d){const V=d.get(R);V?(z||(z=new gG.e(`${q.name}_${G.name}_MorphWeightAnimation`,"influence",V.framePerSecond,gG.e.ANIMATIONTYPE_FLOAT,V.loopMode,V.enableBlending)),X.push(V.getKeys()[W])):X.push({frame:q.from+Y/t*W,value:R.influence,inTangent:A[0].inTangent?0:void 0,outTangent:A[0].outTangent?0:void 0})}}z.setKeys(X);const g=bG._DeduceAnimationInfo(z);g&&bG._AddAnimation(`${q.name}_${G.name}_MorphWeightAnimation`,P,G,z,g.dataAccessorType,g.animationChannelTargetPath,W,J,R,d,g.useQuaternion,k,!1,null===V||void 0===V?void 0:V.numTargets)})),P.channels.length&&P.samplers.length&&V.push(P)}}}static _AddAnimation(G,V,W,R,d,k,z,X,P,A,x,q,L,t){const Y=bG._CreateNodeAnimation(W,R,k,x,q);let g,B,S,p,b,r;if(Y){if(t){let G=0,V=0;const W=[];for(;Y.inputs.length>0;)V=Y.inputs.shift(),G%t==0&&W.push(V),G++;Y.inputs=W}const G=z.get(W),R=new Float32Array(Y.inputs);g=X.createBufferView(R),B=X.createAccessor(g,"SCALAR",5126,Y.inputs.length,void 0,{min:[Y.inputsMin],max:[Y.inputsMax]}),A.push(B),S=A.length-1;const P=new J.g,x=new J.o,q=new J.o,y=W instanceof qG.c,u=E(d),H=new Float32Array(Y.outputs.length*u);Y.outputs.forEach((function(G,V){let W=G;switch(k){case"translation":L&&(J.o.FromArrayToRef(G,0,q),j(q),q.toArray(W));break;case"rotation":4===G.length?J.g.FromArrayToRef(G,0,P):(W=new Array(4),J.o.FromArrayToRef(G,0,x),J.g.FromEulerVectorToRef(x,P)),L&&(I(P),y&&O(P)),P.toArray(W)}H.set(W,V*u)})),g=X.createBufferView(H),B=X.createAccessor(g,d,5126,Y.outputs.length),A.push(B),p=A.length-1,b={interpolation:Y.samplerInterpolation,input:S,output:p},V.samplers.push(b),r={sampler:V.samplers.length-1,target:{node:G,path:k}},V.channels.push(r)}}static _CreateBakedAnimation(G,V,W,d,k,z,X,P,A,x,q){let L;const t=J.g.Identity();let Y,g=null,B=null,S=null,p=null,b=null,r=null;x.min=R.h.FloatRound(d/z);const y=V.getKeys();for(let J=0,u=y.length;J<u;++J){if(r=null,S=y[J],J+1<u)if(p=y[J+1],S.value.equals&&S.value.equals(p.value)||S.value===p.value){if(0!==J)continue;r=S.frame}else r=p.frame;else{if(b=y[J-1],S.value.equals&&S.value.equals(b.value)||S.value===b.value)continue;r=k}if(r)for(let J=S.frame;J<=r;J+=X){if(Y=R.h.FloatRound(J/z),Y===g)continue;g=Y,B=Y;const d={key:0,repeatCount:0,loopMode:V.loopMode};L=V._interpolate(J,d),bG._SetInterpolatedValue(G,L,Y,V,W,t,P,A,q)}}B&&(x.max=B)}static _ConvertFactorToVector3OrQuaternion(G,V,W,d,k){const z=bG._GetBasePositionRotationOrScale(V,d,k),X=W.targetProperty.split("."),P=X?X[1]:"",A=k?J.g.ld(z).normalize():J.o.ld(z);switch(P){case"x":case"y":case"z":A[P]=G;break;case"w":A.w=G;break;default:R.h.Error(`glTFAnimation: Unsupported component name "${P}"!`)}return A}static _SetInterpolatedValue(G,V,W,R,d,k,z,X,P){let A;z.push(W),"weights"!==d?(R.dataType===gG.e.ANIMATIONTYPE_FLOAT&&(V=this._ConvertFactorToVector3OrQuaternion(V,G,R,d,P)),"rotation"===d?(P?k=V:(A=V,J.g.RotationYawPitchRollToRef(A.y,A.x,A.z,k)),X.push(k.Bd())):(A=V,X.push(A.Bd()))):X.push([V])}static _CreateLinearOrStepAnimation(G,V,W,J,R,d){for(const k of V.getKeys())J.push(k.frame/V.framePerSecond),bG._AddKeyframeValue(k,V,R,W,G,d)}static _CreateCubicSplineAnimation(G,V,W,J,R,d){V.getKeys().forEach((function(k){J.push(k.frame/V.framePerSecond),bG._AddSplineTangent(xG.INTANGENT,R,W,"CUBICSPLINE",k,d),bG._AddKeyframeValue(k,V,R,W,G,d),bG._AddSplineTangent(xG.OUTTANGENT,R,W,"CUBICSPLINE",k,d)}))}static _GetBasePositionRotationOrScale(G,V,W){let R;if("rotation"===V)if(W){R=(G.rotationQuaternion??J.g.Identity()).Bd()}else{R=(G.rotation??J.o.Zero()).Bd()}else if("translation"===V){R=(G.position??J.o.Zero()).Bd()}else{R=(G.vd??J.o.One()).Bd()}return R}static _AddKeyframeValue(G,V,W,d,k,z){let X;const P=V.dataType;if(P===gG.e.ANIMATIONTYPE_VECTOR3){let V=G.value.Bd();if("rotation"===d){const G=J.o.ld(V);V=J.g.RotationYawPitchRoll(G.y,G.x,G.z).Bd()}W.push(V)}else if(P===gG.e.ANIMATIONTYPE_FLOAT){if("weights"===d)W.push([G.value]);else if(X=this._ConvertFactorToVector3OrQuaternion(G.value,k,V,d,z),X){if("rotation"===d){const G=z?X:J.g.RotationYawPitchRoll(X.y,X.x,X.z).normalize();W.push(G.Bd())}W.push(X.Bd())}}else P===gG.e.ANIMATIONTYPE_QUATERNION?W.push(G.value.normalize().Bd()):R.h.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(G,V,W){let J,R,d=!1;if("rotation"===V&&!W)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let k=0,z=G.length;k<z;++k)if(R=G[k],R.inTangent||R.outTangent)if(J){if("CUBICSPLINE"!==J){J="LINEAR",d=!0;break}}else J="CUBICSPLINE";else if(J){if("CUBICSPLINE"===J||R.interpolation&&1===R.interpolation&&"STEP"!==J){J="LINEAR",d=!0;break}}else J=R.interpolation&&1===R.interpolation?"STEP":"LINEAR";return J||(J="LINEAR"),{interpolationType:J,shouldBakeAnimation:d}}static _AddSplineTangent(G,V,W,R,d,k){let z;const X=G===xG.INTANGENT?d.inTangent:d.outTangent;if("CUBICSPLINE"===R){if("rotation"===W)if(X)if(k)z=X.Bd();else{const G=X;z=J.g.RotationYawPitchRoll(G.y,G.x,G.z).Bd()}else z=[0,0,0,0];else z="weights"===W?X?[X]:[0]:X?X.Bd():[0,0,0];V.push(z)}}static _CalculateMinMaxKeyFrames(G){let V=1/0,W=-1/0;return G.forEach((function(G){V=Math.min(V,G.frame),W=Math.max(W,G.frame)})),{min:V,max:W}}}function rG(G,V,W,d,k,z){const X={attributes:{},influence:G.influence,name:G.name},P=V.zd;if(!P)return R.h.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),X;const x=z?-1:1,q=J.o.Zero();let L=0,t=0;if(G.hasPositions){const d=G.getPositions(),z=P.getVerticesData(A.c.PositionKind);if(z){const G=new Float32Array(z.length),V=[1/0,1/0,1/0],R=[-1/0,-1/0,-1/0];t=z.length/3,L=0;for(let W=L;W<t;++W){const k=J.o.ld(z,3*W);J.o.ld(d,3*W).subtractToRef(k,q),q.x*=x,V[0]=Math.min(V[0],q.x),R[0]=Math.max(R[0],q.x),V[1]=Math.min(V[1],q.y),R[1]=Math.max(R[1],q.y),V[2]=Math.min(V[2],q.z),R[2]=Math.max(R[2],q.z),G[3*W]=q.x,G[3*W+1]=q.y,G[3*W+2]=q.z}const P=W.createBufferView(G,12),A=W.createAccessor(P,"VEC3",5126,d.length/3,0,{min:V,max:R});k.push(A),X.attributes.POSITION=k.length-1}else R.h.Warn(`Morph target positions for mesh ${V.name} were not exported. Mesh does not have position vertex data`)}if(G.hasNormals){const d=G.getNormals(),z=P.getVerticesData(A.c.NormalKind);if(z){const G=new Float32Array(z.length);t=z.length/3,L=0;for(let W=L;W<t;++W){const V=J.o.ld(z,3*W).normalize();J.o.ld(d,3*W).normalize().subtractToRef(V,q),G[3*W]=q.x*x,G[3*W+1]=q.y,G[3*W+2]=q.z}const V=W.createBufferView(G,12),R=W.createAccessor(V,"VEC3",5126,d.length/3,0);k.push(R),X.attributes.NORMAL=k.length-1}else R.h.Warn(`Morph target normals for mesh ${V.name} were not exported. Mesh does not have normals vertex data`)}if(G.hasTangents){const d=G.getTangents(),z=P.getVerticesData(A.c.TangentKind);if(z){t=z.length/4;const G=new Float32Array(3*t);L=0;for(let W=L;W<t;++W){const V=J.o.ld(z,4*W);c(V);const R=J.o.ld(d,3*W);c(R),R.subtractToRef(V,q),G[3*W]=q.x*x,G[3*W+1]=q.y,G[3*W+2]=q.z}const V=W.createBufferView(G,12),R=W.createAccessor(V,"VEC3",5126,t,0);k.push(R),X.attributes.TANGENT=k.length-1}else R.h.Warn(`Morph target tangents for mesh ${V.name} were not exported. Mesh does not have tangents vertex data`)}if(G.hasColors){const d=G.getColors(),z=P.getVerticesData(A.c.ColorKind),x=P.getVertexBuffer(A.c.ColorKind);if(z&&x){const G=x.getSize();t=z.length/G;const V=new Float32Array(t*G);L=0;for(let W=L;W<t;++W)if(3===G){const R=J.o.ld(z,W*G);J.o.ld(d,W*G).subtractToRef(R,q),V[3*W]=q.x,V[3*W+1]=q.y,V[3*W+2]=q.z}else if(4===G){const R=new J.q,k=J.q.ld(z,W*G);J.q.ld(d,W*G).subtractToRef(k,R),V[4*W]=R.x,V[4*W+1]=R.y,V[4*W+2]=R.z,V[4*W+3]=R.w}else R.h.Warn(`Unsupported number of components for color attribute: ${G}`);const P=W.createBufferView(V,4*G),A=W.createAccessor(P,3===G?"VEC3":"VEC4",5126,t,0);k.push(A),X.attributes.COLOR_0=k.length-1}else R.h.Warn(`Morph target colors for mesh ${V.name} were not exported. Mesh does not have colors vertex data`)}return X}var yG=W(11877),uG=W(11798),HG=W(11794),nG=W(11159);class DG{}DG.DEFAULT_COLOR=g.d.White(),DG.DEFAULT_WIDTH_ATTENUATED=1,DG.DEFAULT_WIDTH=.1;var iG=W(11627),eG=W(11886);class FG{static ConvertPoints(G,V){if(G.length&&Array.isArray(G)&&"number"===typeof G[0])return[G];if(G.length&&Array.isArray(G[0])&&"number"===typeof G[0][0])return G;if(G.length&&!Array.isArray(G[0])&&G[0]instanceof J.o){const V=[];for(let W=0;W<G.length;W++){const J=G[W];V.push(J.x,J.y,J.z)}return[V]}if(G.length>0&&Array.isArray(G[0])&&G[0].length>0&&G[0][0]instanceof J.o){const V=[],W=G;for(const G of W)V.push(G.flatMap((G=>[G.x,G.y,G.z])));return V}if(G instanceof Float32Array){if(null!==V&&void 0!==V&&V.floatArrayStride){const W=[],J=3*V.floatArrayStride;for(let V=0;V<G.length;V+=J){const R=new Array(J);for(let W=0;W<J;W++)R[W]=G[V+W];W.push(R)}return W}return[Array.from(G)]}if(G.length&&G[0]instanceof Float32Array){const V=[];for(const W of G)V.push(Array.from(W));return V}return[]}static OmitZeroLengthPredicate(G,V,W){const J=[];return V.zW(G).lengthSquared()>0&&J.push([G,V]),W.zW(V).lengthSquared()>0&&J.push([V,W]),G.zW(W).lengthSquared()>0&&J.push([W,G]),0===J.length?null:J}static OmitDuplicatesPredicate(G,V,W,J){const R=[];return FG._SearchInPoints(G,V,J)||R.push([G,V]),FG._SearchInPoints(V,W,J)||R.push([V,W]),FG._SearchInPoints(W,G,J)||R.push([W,G]),0===R.length?null:R}static _SearchInPoints(G,V,W){for(const k of W)for(let W=0;W<k.length;W++){var J,R,d;if(null!==(J=k[W])&&void 0!==J&&J.equals(G))if(null!==(R=k[W+1])&&void 0!==R&&R.equals(V)||null!==(d=k[W-1])&&void 0!==d&&d.equals(V))return!0}return!1}static MeshesToLines(G,V){const W=[];for(let R=0;R<G.length;R++){const d=G[R],k=d.getVerticesData(A.c.PositionKind),z=d.Pd();if(k&&z)for(let G=0,X=0;G<z.length;G++){const P=3*z[X++],A=3*z[X++],x=3*z[X++],q=new J.o(k[P],k[P+1],k[P+2]),L=new J.o(k[A],k[A+1],k[A+2]),t=new J.o(k[x],k[x+1],k[x+2]);if(V){const J=V(q,L,t,W,G,P,d,R,k,z);if(J)for(const G of J)W.push(G)}else W.push([q,L],[L,t],[t,q])}}return W}static ToVector3Array(G){if(Array.isArray(G[0])){const V=[],W=G;for(const G of W){const W=[];for(let V=0;V<G.length;V+=3)W.push(new J.o(G[V],G[V+1],G[V+2]));V.push(W)}return V}const V=G,W=[];for(let R=0;R<V.length;R+=3)W.push(new J.o(V[R],V[R+1],V[R+2]));return W}static ToNumberArray(G){return G.flatMap((G=>[G.x,G.y,G.z]))}static GetPointsCountInfo(G){const V=new Array(G.length);let W=0;for(let J=G.length;J--;)V[J]=G[J].length/3,W+=V[J];return{total:W,counts:V}}static GetLineLength(G){if(0===G.length)return 0;let V;V="number"===typeof G[0]?FG.ToVector3Array(G):G;const W=J.h.ed[0];let R=0;for(let J=0;J<V.length-1;J++){const G=V[J];R+=V[J+1].subtractToRef(G,W).length()}return R}static GetLineLengthArray(G){const V=new Float32Array(G.length/3);let W=0;for(let J=0,R=G.length/3-1;J<R;J++){let R=G[3*J+0],d=G[3*J+1],k=G[3*J+2];R-=G[3*J+3],d-=G[3*J+4],k-=G[3*J+5];W+=Math.sqrt(R*R+d*d+k*k),V[J+1]=W}return V}static SegmentizeSegmentByCount(G,V,W){const R=[],d=V.zW(G),k=J.h.ed[0];k.Ud(W);const z=J.h.ed[1];d.divideToRef(k,z);let X=G.clone();R.push(X);for(let J=0;J<W;J++)X=X.clone(),R.push(X.addInPlace(z));return R}static SegmentizeLineBySegmentLength(G,V){const W=G[0]instanceof J.o?FG.GetLineSegments(G):"number"===typeof G[0]?FG.GetLineSegments(FG.ToVector3Array(G)):G,R=[];for(const J of W)if(J.length>V){const G=FG.SegmentizeSegmentByCount(J.point1,J.point2,Math.ceil(J.length/V));for(const V of G)R.push(V)}else R.push(J.point1),R.push(J.point2);return R}static SegmentizeLineBySegmentCount(G,V){const W="number"===typeof G[0]?FG.ToVector3Array(G):G,J=FG.GetLineLength(W)/V;return FG.SegmentizeLineBySegmentLength(W,J)}static GetLineSegments(G){const V=[];for(let W=0;W<G.length-1;W++){const J=G[W],R=G[W+1],d=R.zW(J).length();V.push({point1:J,point2:R,length:d})}return V}static GetMinMaxSegmentLength(G){const V=FG.GetLineSegments(G).sort((G=>G.length));return{min:V[0].length,max:V[V.length-1].length}}static GetPositionOnLineByVisibility(G,V,W){let R=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const d=V*W;let k=0,z=0;const X=G.length;for(let J=0;J<X;J++){if(d<=k+G[J].length){z=J;break}k+=G[J].length}const P=(d-k)/G[z].length;return G[z].point2.subtractToRef(G[z].point1,J.h.ed[0]),J.h.ed[1]=J.h.ed[0].multiplyByFloats(P,P,P),R||J.h.ed[1].addInPlace(G[z].point1),J.h.ed[1].clone()}static GetCircleLinePoints(G,V){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:G,d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/V;const k=[];for(let z=0;z<=V;z++)k.push(new J.o(Math.cos(z*d)*G,Math.sin(z*d)*R,W));return k}static GetBezierLinePoints(G,V,W,J){return iG.g.CreateQuadraticBezier(G,V,W,J).getPoints().flatMap((G=>[G.x,G.y,G.z]))}static GetArrowCap(G,V,W,J,R){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,k=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[G.clone(),G.add(V.multiplyByFloats(W,W,W))],widths:[J,R,d,k]}}static GetPointsFromText(G,V,W,J){let R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,d=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const k=[],z=(0,eG.c)(G,V,W,J);for(const X of z){for(const G of X.paths){const V=[],W=G.getPoints();for(const G of W)V.push(G.x,G.y,R);k.push(V)}if(d)for(const G of X.holes){const V=[],W=G.getPoints();for(const G of W)V.push(G.x,G.y,R);k.push(V)}}return k}static Color3toRGBAUint8(G){const V=new Uint8Array(4*G.length);for(let W=0,J=0;W<G.length;W++)V[J++]=255*G[W].r,V[J++]=255*G[W].g,V[J++]=255*G[W].b,V[J++]=255;return V}static CreateColorsTexture(G,V,W,J){const R=J.getEngine().getCaps().maxTextureSize??1,d=V.length>R?R:V.length,k=Math.ceil(V.length/R);k>1&&(V=[...V,...Array(d*k-V.length).fill(V[0])]);const z=FG.Color3toRGBAUint8(V),X=new y.b(z,d,k,t.c.TEXTUREFORMAT_RGBA,J,!1,!0,W);return X.name=G,X}static PrepareEmptyColorsTexture(G){if(!DG.EmptyColorsTexture){const V=new Uint8Array(4);DG.EmptyColorsTexture=new y.b(V,1,1,t.c.TEXTUREFORMAT_RGBA,G,!1,!1,y.b.NEAREST_NEAREST),DG.EmptyColorsTexture.name="grlEmptyColorsTexture"}return DG.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var G;null===(G=DG.EmptyColorsTexture)||void 0===G||G.dispose(),DG.EmptyColorsTexture=null}static BooleanToNumber(G){return G?1:0}}class fG extends HG.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class vG extends uG.b{isCompatible(G){return!0}constructor(G,V,W){var R;W=W||{color:DG.DEFAULT_COLOR};const d=new fG;d.GREASED_LINE_HAS_COLOR=!!W.color&&!W.useColors,d.GREASED_LINE_SIZE_ATTENUATION=W.sizeAttenuation??!1,d.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===W.colorDistributionType,d.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(V??G.HG()).useRightHandedSystem,d.GREASED_LINE_CAMERA_FACING=W.cameraFacing??!0,super(G,vG.GREASED_LINE_MATERIAL_NAME,200,d,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(R=W)||void 0===R?void 0:R.forceGLSL)||vG.ForceGLSL,this._scene=V??G.HG(),this._engine=this._scene.getEngine(),this._cameraFacing=W.cameraFacing??!0,this.visibility=W.visibility??1,this.useDash=W.useDash??!1,this.dashRatio=W.dashRatio??.5,this.dashOffset=W.dashOffset??0,this.width=W.width?W.width:W.sizeAttenuation?DG.DEFAULT_WIDTH_ATTENUATED:DG.DEFAULT_WIDTH,this._sizeAttenuation=W.sizeAttenuation??!1,this.colorMode=W.colorMode??0,this._color=W.color??null,this.useColors=W.useColors??!1,this._colorsDistributionType=W.colorDistributionType??0,this.colorsSampling=W.colorsSampling??y.b.NEAREST_NEAREST,this._colors=W.eG??null,this.dashCount=W.dashCount??1,this.resolution=W.resolution??new J.k(this._engine.getRenderWidth(),this._engine.getRenderHeight()),W.colorsTexture?this.colorsTexture=W.colorsTexture:this._colors?this.colorsTexture=FG.CreateColorsTexture(`${G.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??DG.DEFAULT_COLOR,FG.PrepareEmptyColorsTexture(this._scene)),this._engine.Md.add((()=>{FG.DisposeEmptyColorsTexture()}))}getAttributes(G){G.push("grl_offsets"),G.push("grl_widths"),G.push("grl_colorPointers"),G.push("grl_counters"),this._cameraFacing?(G.push("grl_previousAndSide"),G.push("grl_nextAndCounters")):G.push("grl_slopes")}getSamplers(G){G.push("grl_colors")}getActiveTextures(G){this.colorsTexture&&G.push(this.colorsTexture)}getUniforms(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const V=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&V.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===G&&V.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:V,vertex:this._cameraFacing&&this._isGLSL(G)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(G)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(G){if(this._cameraFacing){G.Td("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||G.Td("viewProjection",this._scene.getTransformMatrix());const V=J.h.Vector4[0];V.x=this._aspect,V.y=this._resolution.x,V.z=this._resolution.y,V.w=this.width,G.updateVector4("grl_aspect_resolution_lineWidth",V)}const V=J.h.Vector4[0];V.x=FG.BooleanToNumber(this.useDash),V.y=this._dashArray,V.z=this.dashOffset,V.w=this.dashRatio,G.updateVector4("grl_dashOptions",V);const W=J.h.Vector4[1];W.x=this.colorMode,W.y=this.visibility,W.z=this.colorsTexture?this.colorsTexture.getSize().width:0,W.w=FG.BooleanToNumber(this.useColors),G.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",W),this._color&&G.updateColor3("grl_singleColor",this._color);const R=this.colorsTexture??DG.EmptyColorsTexture;G.setTexture("grl_colors",R),G.updateFloat2("grl_textureSize",(null===R||void 0===R?void 0:R.getSize().width)??1,(null===R||void 0===R?void 0:R.getSize().height)??1)}prepareDefines(G,V,W){G.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,G.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,G.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,G.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=V.useRightHandedSystem,G.GREASED_LINE_CAMERA_FACING=this._cameraFacing,G.GREASED_LINE_USE_OFFSETS=!!W.offsets}getClassName(){return vG.GREASED_LINE_MATERIAL_NAME}getCustomCode(G){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(V)?function(G,V){if("vertex"===G){const G={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return V&&(G["!gl_Position\\=viewProjection\\*worldPos;"]="//"),G}return"fragment"===G?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(G,this._cameraFacing):function(G,V){if("vertex"===G){const G={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return V&&(G["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),G}return"fragment"===G?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(G,this._cameraFacing)}dispose(){var G;null===(G=this.colorsTexture)||void 0===G||G.dispose(),super.dispose()}get eG(){return this._colors}set eG(G){this.setColors(G)}setColors(G){var V;let W=arguments.length>1&&void 0!==arguments[1]&&arguments[1],J=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const R=(null===(V=this._colors)||void 0===V?void 0:V.length)??0;var d;if(this._colors=G,null!==G&&0!==G.length){if(!W||J)if(this.colorsTexture&&R===G.length&&!J){const V=FG.Color3toRGBAUint8(G);this.colorsTexture.update(V)}else{var k;null===(k=this.colorsTexture)||void 0===k||k.dispose(),this.colorsTexture=FG.CreateColorsTexture(`${this._material.name}-colors-texture`,G,this.colorsSampling,this._scene)}}else null===(d=this.colorsTexture)||void 0===d||d.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(G){this._dashCount=G,this._dashArray=1/G}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(G){this._sizeAttenuation=G,this.markAllDefinesAsDirty()}get color(){return this._color}set color(G){this.setColor(G)}setColor(G){let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==G||null!==this._color&&null===G?(this._color=G,V||this.markAllDefinesAsDirty()):this._color=G}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(G){this._colorsDistributionType=G,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(G){this._aspect=G.x/G.y,this._resolution=G}serialize(){const G=super.serialize(),V={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(V.eG=this._colors),this._color&&(V.color=this._color),G.greasedLineMaterialOptions=V,G}parse(G,V,W){var J;super.parse(G,V,W);const R=G.greasedLineMaterialOptions;null===(J=this.colorsTexture)||void 0===J||J.dispose(),R.color&&this.setColor(R.color,!0),R.colorDistributionType&&(this.colorsDistributionType=R.colorDistributionType),R.eG&&(this.eG=R.eG),R.colorsSampling&&(this.colorsSampling=R.colorsSampling),R.colorMode&&(this.colorMode=R.colorMode),R.useColors&&(this.useColors=R.useColors),R.visibility&&(this.visibility=R.visibility),R.useDash&&(this.useDash=R.useDash),R.dashCount&&(this.dashCount=R.dashCount),R.dashRatio&&(this.dashRatio=R.dashRatio),R.dashOffset&&(this.dashOffset=R.dashOffset),R.width&&(this.width=R.width),R.sizeAttenuation&&(this.sizeAttenuation=R.sizeAttenuation),R.resolution&&(this.resolution=R.resolution),this.eG?this.colorsTexture=FG.CreateColorsTexture(`${this._material.name}-colors-texture`,this.eG,this.colorsSampling,V):FG.PrepareEmptyColorsTexture(V),this.markAllDefinesAsDirty()}copyTo(G){var V;const W=G;null===(V=W.colorsTexture)||void 0===V||V.dispose(),this._colors&&(W.colorsTexture=FG.CreateColorsTexture(`${W._material.name}-colors-texture`,this._colors,W.colorsSampling,this._scene)),W.setColor(this.color,!0),W.colorsDistributionType=this.colorsDistributionType,W.colorsSampling=this.colorsSampling,W.colorMode=this.colorMode,W.useColors=this.useColors,W.visibility=this.visibility,W.useDash=this.useDash,W.dashCount=this.dashCount,W.dashRatio=this.dashRatio,W.dashOffset=this.dashOffset,W.width=this.width,W.sizeAttenuation=this.sizeAttenuation,W.resolution=this.resolution,W.markAllDefinesAsDirty()}_isGLSL(G){return 0===G||this._forceGLSL}}vG.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",vG.ForceGLSL=!1,(0,nG.d)(`BABYLON.${vG.GREASED_LINE_MATERIAL_NAME}`,vG);var CG=W(11482),lG=W(11204),mG=W(11881),wG=W(11292);class NG extends mG.d{constructor(G,V,R){const d=V.getEngine(),k=d.isWebGPU&&!(R.forceGLSL||NG.ForceGLSL),z=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];V.useRightHandedSystem&&z.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const X=["position","grl_widths","grl_offsets","grl_colorPointers"];R.cameraFacing?(z.push("GREASED_LINE_CAMERA_FACING"),X.push("grl_previousAndSide","grl_nextAndCounters")):(X.push("grl_slopes"),X.push("grl_counters"));const P=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(k||P.push("world","viewProjection","view","projection"),super(G,V,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:k?["Scene","Mesh"]:void 0,attributes:X,uniforms:P,samplers:k?[]:["grlColors"],defines:z,extraInitializationsAsync:async()=>{k?await Promise.all([W.e(47).then(W.bind(W,14439)),W.e(55).then(W.bind(W,14444))]):await Promise.all([W.e(50).then(W.bind(W,14451)),W.e(56).then(W.bind(W,14459))])},shaderLanguage:k?1:0}),this._color=g.d.White(),this._colorsDistributionType=0,this._colorsTexture=null,R=R||{color:DG.DEFAULT_COLOR},this.visibility=R.visibility??1,this.useDash=R.useDash??!1,this.dashRatio=R.dashRatio??.5,this.dashOffset=R.dashOffset??0,this.dashCount=R.dashCount??1,this.width=R.width?R.width:R.sizeAttenuation&&R.cameraFacing?DG.DEFAULT_WIDTH_ATTENUATED:DG.DEFAULT_WIDTH,this.sizeAttenuation=R.sizeAttenuation??!1,this.color=R.color??g.d.White(),this.useColors=R.useColors??!1,this.colorsDistributionType=R.colorDistributionType??0,this.colorsSampling=R.colorsSampling??y.b.NEAREST_NEAREST,this.colorMode=R.colorMode??0,this._colors=R.eG??null,this._cameraFacing=R.cameraFacing??!0,this.resolution=R.resolution??new J.k(d.getRenderWidth(),d.getRenderHeight()),R.colorsTexture?this.colorsTexture=R.colorsTexture:this._colors?this.colorsTexture=FG.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,V):(this._color=this._color??DG.DEFAULT_COLOR,this.colorsTexture=FG.PrepareEmptyColorsTexture(V)),k){const G=new wG.b;G.setParameters(),G.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",G)}d.Md.add((()=>{FG.DisposeEmptyColorsTexture()}))}dispose(){var G;null===(G=this._colorsTexture)||void 0===G||G.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new J.k(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get eG(){return this._colors}set eG(G){this.setColors(G)}setColors(G){var V;let W=arguments.length>1&&void 0!==arguments[1]&&arguments[1],J=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const R=(null===(V=this._colors)||void 0===V?void 0:V.length)??0;var d;if(this._colors=G,null!==G&&0!==G.length){if(!W||J)if(this._colorsTexture&&R===G.length&&!J){const V=FG.Color3toRGBAUint8(G);this._colorsTexture.update(V)}else{var k;null===(k=this._colorsTexture)||void 0===k||k.dispose(),this.colorsTexture=FG.CreateColorsTexture(`${this.name}-colors-texture`,G,this.colorsSampling,this.HG())}}else null===(d=this._colorsTexture)||void 0===d||d.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(G){this._colorsTexture=G,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(G){this._width=G,this.setFloat("grlWidth",G)}get useColors(){return this._useColors}set useColors(G){this._useColors=G,this.setFloat("grlUseColors",FG.BooleanToNumber(G))}get colorsSampling(){return this._colorsSampling}set colorsSampling(G){this._colorsSampling=G}get visibility(){return this._visibility}set visibility(G){this._visibility=G,this.setFloat("grlVisibility",G)}get useDash(){return this._useDash}set useDash(G){this._useDash=G,this.setFloat("grlUseDash",FG.BooleanToNumber(G))}get dashOffset(){return this._dashOffset}set dashOffset(G){this._dashOffset=G,this.setFloat("grlDashOffset",G)}get dashRatio(){return this._dashRatio}set dashRatio(G){this._dashRatio=G,this.setFloat("grlDashRatio",G)}get dashCount(){return this._dashCount}set dashCount(G){this._dashCount=G,this._dashArray=1/G,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(G){this._sizeAttenuation=G,this.setFloat("grlSizeAttenuation",FG.BooleanToNumber(G))}get color(){return this._color}set color(G){this.setColor(G)}setColor(G){G=G??DG.DEFAULT_COLOR,this._color=G,this.setColor3("grlColor",G)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(G){this._colorsDistributionType=G,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(G){this._colorMode=G,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(G){this._resolution=G,this.setVector2("grlResolution",G),this.setFloat("grlAspect",G.x/G.y)}serialize(){const G=super.serialize(),V={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(V.eG=this._colors),G.greasedLineMaterialOptions=V,G}parse(G,V,W){var J;const R=G.greasedLineMaterialOptions;null===(J=this._colorsTexture)||void 0===J||J.dispose(),R.color&&(this.color=R.color),R.colorDistributionType&&(this.colorsDistributionType=R.colorDistributionType),R.colorsSampling&&(this.colorsSampling=R.colorsSampling),R.colorMode&&(this.colorMode=R.colorMode),R.useColors&&(this.useColors=R.useColors),R.visibility&&(this.visibility=R.visibility),R.useDash&&(this.useDash=R.useDash),R.dashCount&&(this.dashCount=R.dashCount),R.dashRatio&&(this.dashRatio=R.dashRatio),R.dashOffset&&(this.dashOffset=R.dashOffset),R.width&&(this.width=R.width),R.sizeAttenuation&&(this.sizeAttenuation=R.sizeAttenuation),R.resolution&&(this.resolution=R.resolution),R.eG?this.colorsTexture=FG.CreateColorsTexture(`${this.name}-colors-texture`,R.eG,this.colorsSampling,this.HG()):this.colorsTexture=FG.PrepareEmptyColorsTexture(V),this._cameraFacing=R.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var UG,aG,MG;NG.ForceGLSL=!1,function(G){G[G.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",G[G.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(UG||(UG={})),function(G){G[G.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",G[G.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",G[G.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(aG||(aG={})),function(G){G[G.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",G[G.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",G[G.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",G[G.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",G[G.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(MG||(MG={}));class TG extends SG.b{constructor(G,V,W){super(G,V,null,null,!1,!1),this.name=G,this._options=W,this._lazy=!1,this._updatable=!1,this._engine=V.getEngine(),this._lazy=W.lazy??!1,this._updatable=W.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=W.colorPointers??[],this._widths=W.widths??new Array(W.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(G){let V=0;for(const J of this._points)V+=J.length;const W=V/3*2-this._widths.length;for(let J=0;J<W;J++)this._widths.push(G)}updateLazy(){var G,V;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(G=this._options.ribbonOptions)||void 0===G?void 0:G.smoothShading),!this.CG&&this.refreshBoundingInfo(),null===(V=this.greasedLineMaterial)||void 0===V||V.updateLazy()}addPoints(G,V){for(const W of G)this._points.push(W);this._lazy||this.setPoints(this._points,V)}dispose(G){let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(G,V)}isLazy(){return this._lazy}get FG(){return this._uvs}set FG(G){this._uvs=G instanceof Float32Array?G:new Float32Array(G),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(G){this.material instanceof NG&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===G||void 0===G?void 0:G.length)>0),this._offsets=G,this._offsetsBuffer?this._offsetsBuffer.update(G):this._createOffsetsBuffer(G)}get widths(){return this._widths}set widths(G){this._widths=G,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(G)}get colorPointers(){return this._colorPointers}set colorPointers(G){this._colorPointers=G,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(G)}get greasedLineMaterial(){var G,V;if(this.material&&this.material instanceof NG)return this.material;const W=null===(G=this.material)||void 0===G||null===(V=G.pluginManager)||void 0===V?void 0:V.getPlugin(vG.GREASED_LINE_MATERIAL_NAME);return W||void 0}get points(){const G=[];return lG.d.DeepCopy(this._points,G),G}setPoints(G,V){this._points=FG.ConvertPoints(G,(null===V||void 0===V?void 0:V.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==V&&void 0!==V&&V.colorPointers||this._updateColorPointers(),this._setPoints(this._points,V)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,FG:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(G){super.serialize(G),G.type=this.getClassName(),G.lineOptions=this._createLineOptions()}_createVertexBuffers(){let G=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const V=new CG.b;return V.DG=this._vertexPositions,V.indices=this._indices,V.FG=this._uvs,G&&(V.iG=[],CG.b.ComputeNormals(this._vertexPositions,this._indices,V.iG)),V.vG(this,this._options.updatable),V}_createOffsetsBuffer(G){const V=this._scene.getEngine(),W=new A.b(V,G,this._updatable,3);this.setVerticesBuffer(W.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=W}}class KG{constructor(G,V){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=G,this.wasAddedByNoopNode=V}getIndicesAccessor(G,V,W,J,R){var d,k,z,X;return null===(d=this._indicesAccessorMap.get(G))||void 0===d||null===(k=d.get(V))||void 0===k||null===(z=k.get(W))||void 0===z||null===(X=z.get(J))||void 0===X?void 0:X.get(R)}setIndicesAccessor(G,V,W,J,R,d){let k=this._indicesAccessorMap.get(G);k||(k=new Map,this._indicesAccessorMap.set(G,k));let z=k.get(V);z||(z=new Map,k.set(V,z));let X=z.get(W);X||(X=new Map,z.set(W,X));let P=X.get(J);P||(P=new Map,X.set(J,P)),P.set(R,d)}pushExportedNode(G){this._exportedNodes.has(G)||this._exportedNodes.add(G)}getNodesSet(){return this._exportedNodes}getVertexBufferView(G){return this._vertexBufferViewMap.get(G)}setVertexBufferView(G,V){this._vertexBufferViewMap.set(G,V)}setRemappedBufferView(G,V,W){this._remappedBufferView.set(G,new Map),this._remappedBufferView.get(G).set(V,W)}getRemappedBufferView(G,V){var W;return null===(W=this._remappedBufferView.get(G))||void 0===W?void 0:W.get(V)}getVertexAccessor(G,V,W){var J,R;return null===(J=this._vertexAccessorMap.get(G))||void 0===J||null===(R=J.get(V))||void 0===R?void 0:R.get(W)}setVertexAccessor(G,V,W,J){let R=this._vertexAccessorMap.get(G);R||(R=new Map,this._vertexAccessorMap.set(G,R));let d=R.get(V);d||(d=new Map,R.set(V,d)),d.set(W,J)}hasVertexColorAlpha(G){return this._vertexMapColorAlpha.get(G)||!1}setHasVertexColorAlpha(G,V){return this._vertexMapColorAlpha.set(G,V)}getMesh(G){return this._meshMap.get(G)}setMesh(G,V){this._meshMap.set(G,V)}bindMorphDataToMesh(G,V){const W=this._meshMorphTargetMap.get(G)||[];this._meshMorphTargetMap.set(G,W),-1===W.indexOf(V)&&W.push(V)}getMorphTargetsFromMesh(G){return this._meshMorphTargetMap.get(G)}}class sG{_ApplyExtension(G,V,W,J){if(W>=V.length)return Promise.resolve(G);const R=J(V[W],G);return R?R.then((async G=>G?await this._ApplyExtension(G,V,W+1,J):null)):this._ApplyExtension(G,V,W+1,J)}_ApplyExtensions(G,V){const W=[];for(const J of sG._ExtensionNames)W.push(this._extensions[J]);return this._ApplyExtension(G,W,0,V)}_extensionsPreExportTextureAsync(G,V,W){return this._ApplyExtensions(V,((V,J)=>V.preExportTextureAsync&&V.preExportTextureAsync(G,J,W)))}_extensionsPostExportNodeAsync(G,V,W,J,R){return this._ApplyExtensions(V,((V,d)=>V.postExportNodeAsync&&V.postExportNodeAsync(G,d,W,J,R,this._bufferManager)))}_extensionsPostExportMaterialAsync(G,V,W){return this._ApplyExtensions(V,((V,J)=>V.postExportMaterialAsync&&V.postExportMaterialAsync(G,J,W)))}_extensionsPostExportMaterialAdditionalTextures(G,V,W){const J=[];for(const R of sG._ExtensionNames){const d=this._extensions[R];d.postExportMaterialAdditionalTextures&&J.push(...d.postExportMaterialAdditionalTextures(G,V,W))}return J}_extensionsPostExportTextures(G,V,W){for(const J of sG._ExtensionNames){const R=this._extensions[J];R.postExportTexture&&R.postExportTexture(G,V,W)}}_extensionsPostExportMeshPrimitive(G){for(const V of sG._ExtensionNames){const W=this._extensions[V];W.postExportMeshPrimitive&&W.postExportMeshPrimitive(G,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const G of sG._ExtensionNames){const V=this._extensions[G];V.preGenerateBinaryAsync&&await V.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(G){for(const V of sG._ExtensionNames){const W=this._extensions[V];W.enabled&&G(W)}}_extensionsOnExporting(){this._forEachExtensions((G=>{var V,W,J;G.wasUsed&&((V=this._glTF).extensionsUsed||(V.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(G.name)&&this._glTF.extensionsUsed.push(G.name),G.required&&((W=this._glTF).extensionsRequired||(W.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(G.name)&&this._glTF.extensionsRequired.push(G.name)),(J=this._glTF).extensions||(J.extensions={}),G.onExporting&&G.onExporting())}))}_loadExtensions(){for(const G of sG._ExtensionNames){const V=sG._ExtensionFactories[G](this);this._extensions[G]=V}}constructor(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Y.c.LastCreatedScene,V=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${t.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new w(this),this._extensions={},this._bufferManager=new AG,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!G)throw new Error("No scene available to export");this._babylonScene=G,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:G=>{var V;return null===G||void 0===G||null===(V=G.sd)||void 0===V?void 0:V.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...V},this._loadExtensions()}dispose(){for(const G in this._extensions){this._extensions[G].dispose()}}get options(){return this._options}static RegisterExtension(G,V){sG.UnregisterExtension(G)&&R.h.Warn(`Extension with the name ${G} already exists`),sG._ExtensionFactories[G]=V,sG._ExtensionNames.push(G)}static UnregisterExtension(G){if(!sG._ExtensionFactories[G])return!1;delete sG._ExtensionFactories[G];const V=sG._ExtensionNames.indexOf(G);return-1!==V&&sG._ExtensionNames.splice(V,1),!0}_generateJSON(G,V,W){const J={byteLength:G};return J.byteLength&&(this._glTF.buffers=[J]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.tV=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(J.uri=V+".bin"),W?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(G){const V=await this._generateBinaryAsync();this._extensionsOnExporting();const W=this._generateJSON(V.byteLength,G,!0),J=new Blob([V],{type:"application/octet-stream"}),R=G+".gltf",d=G+".bin",k=new P;if(k.files[R]=W,k.files[d]=J,this._imageData)for(const z in this._imageData)k.files[z]=new Blob([this._imageData[z].data],{type:this._imageData[z].mimeType});return k}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(G){const V=G%4;return 0===V?V:4-V}async generateGLBAsync(G){this._shouldUseGlb=!0;const V=await this._generateBinaryAsync();this._extensionsOnExporting();const W=this._generateJSON(V.byteLength),J=G+".glb";let R,d=W.length;if("undefined"!==typeof TextEncoder){R=(new TextEncoder).encode(W),d=R.length}const k=this._getPadding(d),z=this._getPadding(V.byteLength),X=28+d+k+V.byteLength+z,A=new XG(X);if(A.writeUInt32(1179937895),A.writeUInt32(2),A.writeUInt32(X),A.writeUInt32(d+k),A.writeUInt32(1313821514),R)A.writeTypedArray(R);else{const G="_".charCodeAt(0);for(let V=0;V<d;++V){const J=W.charCodeAt(V);J!=W.codePointAt(V)?A.writeUInt8(G):A.writeUInt8(J)}}for(let P=0;P<k;++P)A.writeUInt8(32);A.writeUInt32(V.byteLength+z),A.writeUInt32(5130562),A.writeTypedArray(V);for(let P=0;P<z;++P)A.writeUInt8(0);const x=new P;return x.files[J]=new Blob([A.getOutputData()],{type:"application/octet-stream"}),x}_setNodeTransformation(G,V,W){if(V.getPivotPoint().equalsWithEpsilon(T,M.c)||R.h.Warn("Pivot points are not supported in the glTF serializer"),!V.position.equalsWithEpsilon(T,M.c)){const R=J.h.ed[0].J(V.position);W&&j(R),G.translation=R.Bd()}V.vd.equalsWithEpsilon(s,M.c)||(G.scale=V.vd.Bd());const d=V.rotationQuaternion||J.g.FromEulerAngles(V.rotation.x,V.rotation.y,V.rotation.z);d.equalsWithEpsilon(K,M.c)||(W&&I(d),G.rotation=d.normalize().Bd())}_setCameraTransformation(G,V,W){if(!V.position.equalsWithEpsilon(T,M.c)){const R=J.h.ed[0].J(V.position);W&&j(R),G.translation=R.Bd()}const R=V.rotationQuaternion||J.g.FromEulerAngles(V.rotation.x,V.rotation.y,V.rotation.z);W&&I(R),this._babylonScene.useRightHandedSystem||O(R),R.equalsWithEpsilon(K,M.c)||(G.rotation=R.Bd())}_listAvailableCameras(){for(const G of this._babylonScene.cameras){const V={type:G.mode===qG.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(G.name&&(V.name=G.name),"perspective"===V.type)V.perspective={aspectRatio:G.getEngine().getAspectRatio(G),yfov:G.fovMode===qG.c.FOVMODE_VERTICAL_FIXED?G.fov:G.fov*G.getEngine().getAspectRatio(G),znear:G.Zd,zfar:G.maxZ};else if("orthographic"===V.type){const W=G.orthoLeft&&G.orthoRight?.5*(G.orthoRight-G.orthoLeft):.5*G.getEngine().getRenderWidth(),J=G.orthoBottom&&G.orthoTop?.5*(G.orthoTop-G.orthoBottom):.5*G.getEngine().getRenderHeight();V.orthographic={xmag:W,ymag:J,znear:G.Zd,zfar:G.maxZ}}this._camerasMap.set(G,V)}}_exportAndAssignCameras(){const G=Array.from(this._camerasMap.values());for(const V of G){const G=this._nodesCameraMap.get(V);if(void 0!==G){this._cameras.push(V);for(const V of G)V.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const G of this._babylonScene.skeletons){if(G.bones.length<=0)continue;const V={joints:[]};this._skinMap.set(G,V)}}_exportAndAssignSkeletons(){for(const G of this._babylonScene.skeletons){if(G.bones.length<=0)continue;const V=this._skinMap.get(G);if(void 0==V)continue;const W={},J=[];let d=-1;for(let R=0;R<G.bones.length;++R){const V=G.bones[R],J=V.getIndex()??R;-1!==J&&(W[J]=V,J>d&&(d=J))}for(let G=0;G<=d;++G){const d=W[G];J.push(d.getAbsoluteInverseBindMatrix());const k=d.getTransformNode();if(null!==k){const G=this._nodeMap.get(k);k&&null!==G&&void 0!==G?V.joints.push(G):R.h.Warn("Exporting a bone without a linked transform node is currently unsupported")}else R.h.Warn("Exporting a bone without a linked transform node is currently unsupported")}const k=this._nodesSkinMap.get(V);if(V.joints.length>0&&void 0!==k){const G=64*J.length,W=new Float32Array(G/4);J.forEach(((G,V)=>{W.set(G.m,16*V)}));const R=this._bufferManager.createBufferView(W);this._accessors.push(this._bufferManager.createAccessor(R,"MAT4",5126,J.length)),V.inverseBindMatrices=this._accessors.length-1,this._skins.push(V);for(const V of k)V.skin=this._skins.length-1}}}async _exportSceneAsync(){const G={nodes:[]};if(this._babylonScene.metadata){const V=this._options.metadataSelector(this._babylonScene.metadata);V&&(G.extras=V)}const V=new Array,W=new Array,J=new Array;for(const z of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&kG(z,this._babylonScene.useRightHandedSystem)?J.push(...z.getChildren()):this._babylonScene.useRightHandedSystem?V.push(z):W.push(z);this._listAvailableCameras(),this._listAvailableSkeletons();const R=new KG(!0,!1);G.nodes.push(...await this._exportNodesAsync(W,R));const d=new KG(!1,!1);G.nodes.push(...await this._exportNodesAsync(V,d));const k=new KG(!1,!0);G.nodes.push(...await this._exportNodesAsync(J,k)),G.nodes.length&&this._scenes.push(G),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&bG._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,R.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(G){let V=this._shouldExportNodeMap.get(G);return void 0===V&&(V=this._options.shouldExportNode(G),this._shouldExportNodeMap.set(G,V)),V}async _exportNodesAsync(G,V){const W=new Array;this._exportBuffers(G,V);for(const J of G)await this._exportNodeAsync(J,W,V);return W}_collectBuffers(G,V,W,J,R){if(this._shouldExportNode(G)&&G instanceof q.b&&G.zd){const d=G.zd.getVertexBuffers();if(d)for(const J in d){if(!h(J))continue;const k=d[J];R.setHasVertexColorAlpha(k,G.hasVertexAlpha);const z=k._buffer,X=V.get(z)||[];V.set(z,X),-1===X.indexOf(k)&&X.push(k);const P=W.get(k)||[];W.set(k,P),-1===P.indexOf(G)&&P.push(G)}const k=G.morphTargetManager;if(k)for(let V=0;V<k.numTargets;V++){const W=k.getTarget(V),R=J.get(W)||[];J.set(W,R),-1===R.indexOf(G)&&R.push(G)}}for(const d of G.getChildren())this._collectBuffers(d,V,W,J,R)}_exportBuffers(G,V){const W=new Map,J=new Map,R=new Map;for(const z of G)this._collectBuffers(z,W,J,R,V);const d=Array.from(W.keys());for(const z of d){const G=z.getData();if(!G)throw new Error("Buffer data is not available");const R=W.get(z);if(!R)continue;const d=R[0].byteStride;if(R.some((G=>G.byteStride!==d)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const k=WG(G).slice();for(const V of R){const G=J.get(V),{byteOffset:W,byteStride:R,componentCount:d,type:z,count:X,normalized:P,kind:x}=Z(V,G);switch(x){case A.c.NormalKind:case A.c.TangentKind:(0,N.f)(k,W,R,d,z,X,P,(G=>{const V=Math.sqrt(G[0]*G[0]+G[1]*G[1]+G[2]*G[2]);if(V>0){const W=1/V;G[0]*=W,G[1]*=W,G[2]*=W}}));break;case A.c.ColorKind:{const V=G.filter((G=>G.material instanceof YG.d||null==G.material)).length;if(0==V)break;if(V!=G.length){U.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}z==A.c.UNSIGNED_BYTE&&U.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const J=new g.d,x=new g.h,q=this._babylonScene.getEngine().useExactSrgbConversions;(0,N.f)(k,W,R,d,z,X,P,(G=>{3===G.length?(J.XW(G,0),J.toLinearSpaceToRef(J,q),J.toArray(G,0)):(x.XW(G,0),x.toLinearSpaceToRef(x,q),x.toArray(G,0))}))}}}if(V.convertToRightHanded){for(const G of R){const V=J.get(G),{byteOffset:W,byteStride:R,componentCount:d,type:z,count:X,normalized:P,kind:x}=Z(G,V);switch(x){case A.c.PositionKind:case A.c.NormalKind:case A.c.TangentKind:(0,N.f)(k,W,R,d,z,X,P,(G=>{G[0]=-G[0]}))}}V.convertedToRightHandedBuffers.set(z,k)}const X=this._bufferManager.createBufferView(k,d);V.setVertexBufferView(z,X);const P=new Map;for(const V of R){const G=J.get(V),{kind:W,totalVertices:R}=Z(V,G);switch(W){case A.c.MatricesIndicesKind:case A.c.MatricesIndicesExtraKind:if(V.type==A.c.FLOAT){const G=V.getFloatData(R);null!==G&&P.set(V,G)}}}0!==P.size&&U.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const x=Array.from(P.keys());for(const W of x){const G=P.get(W);if(!G)continue;const J=G.some((G=>G>=256)),R=new(J?Uint16Array:Uint8Array)(G.length);for(let V=0;V<G.length;V++)R[V]=G[V];const d=this._bufferManager.createBufferView(R,4*(J?2:1));V.setRemappedBufferView(z,W,d)}}const k=Array.from(R.keys());for(const z of k){const G=R.get(z);if(!G)continue;const W=rG(z,G[0],this._bufferManager,this._bufferViews,this._accessors,V.convertToRightHanded);for(const J of G)V.bindMorphDataToMesh(J,W)}}async _exportNodeAsync(G,V,W){let J=this._nodeMap.get(G);if(void 0!==J)return void(V.includes(J)||V.push(J));const R=await this._createNodeAsync(G,W);if(R){J=this._nodes.length,this._nodes.push(R),this._nodeMap.set(G,J),W.pushExportedNode(G),V.push(J);const d={name:"runtime animations",channels:[],samplers:[]},k=[];this._babylonScene.animationGroups.length||(bG._CreateMorphTargetAnimationFromMorphTargetAnimations(G,d,k,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,W.convertToRightHanded,this._options.shouldExportAnimation),G.animations.length&&bG._CreateNodeAnimationFromNodeAnimations(G,d,k,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,W.convertToRightHanded,this._options.shouldExportAnimation)),d.channels.length&&d.samplers.length&&this._animations.push(d),k.forEach((G=>{G.channels.length&&G.samplers.length&&this._animations.push(G)}))}const d=R?[]:V;for(const k of G.getChildren())await this._exportNodeAsync(k,d,W);R&&d.length&&(R.children=d)}async _createNodeAsync(G,V){if(!this._shouldExportNode(G))return null;const W={};if(G.name&&(W.name=G.name),G.metadata){const V=this._options.metadataSelector(G.metadata);V&&(W.extras=V)}if(G instanceof x.b&&(this._setNodeTransformation(W,G,V.convertToRightHanded),G instanceof q.b)){const R=G instanceof L.c?G.sourceMesh:G;if(R.Ed&&R.Ed.length>0&&(W.mesh=await this._exportMeshAsync(R,V)),G.skeleton){const V=this._skinMap.get(G.skeleton);var J;if(void 0!==V)void 0===this._nodesSkinMap.get(V)&&this._nodesSkinMap.set(V,[]),null===(J=this._nodesSkinMap.get(V))||void 0===J||J.push(W)}}if(G instanceof a.e){const J=this._camerasMap.get(G);if(J){var R;void 0===this._nodesCameraMap.get(J)&&this._nodesCameraMap.set(J,[]),this._setCameraTransformation(W,G,V.convertToRightHanded);const k=G.parent;if(null!==k&&VG(G,k)){const G=this._nodeMap.get(k);if(void 0!==G){var d;const V=this._nodes[G];return GG(W,V),null===(d=this._nodesCameraMap.get(J))||void 0===d||d.push(V),null}}null===(R=this._nodesCameraMap.get(J))||void 0===R||R.push(W)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",W,G,this._nodeMap,V.convertToRightHanded)?W:(U.c.Warn(`Not exporting node ${G.name}`),null)}_exportIndices(G,V,W,J,R,k,z,X,P){let A=G;P.mode=o(k);const x=z!==d.e.CounterClockWiseSideOrientation,q=!X.wasAddedByNoopNode&&x,L=function(G){switch(G){case d.e.TriangleFillMode:case d.e.TriangleStripDrawMode:case d.e.TriangleFanDrawMode:return!0}return!1}(k)&&q;if(L){if(k===d.e.TriangleStripDrawMode||k===d.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");P.mode=o(k);const z=V?new Uint32Array(J):new Uint16Array(J);if(G)for(let V=0;V+2<J;V+=3)z[V]=G[W+V]+R,z[V+1]=G[W+V+2]+R,z[V+2]=G[W+V+1]+R;else for(let G=0;G+2<J;G+=3)z[G]=G,z[G+1]=G+2,z[G+2]=G+1;A=z}else if(G&&0!==R){const d=V?new Uint32Array(J):new Uint16Array(J);for(let V=0;V<J;V++)d[V]=G[W+V]+R;A=d}if(A){let d=X.getIndicesAccessor(G,W,J,R,L);if(void 0===d){const k=function(G,V,W,J){if(G instanceof Uint16Array||G instanceof Uint32Array)return G;if(G instanceof Int32Array)return new Uint32Array(G.buffer,G.byteOffset,G.length);const R=G.slice(V,V+W);return J?new Uint32Array(R):new Uint16Array(R)}(A,0,J,V),z=this._bufferManager.createBufferView(k),P=V?5125:5123;this._accessors.push(this._bufferManager.createAccessor(z,"SCALAR",P,J,0)),d=this._accessors.length-1,X.setIndicesAccessor(G,W,J,R,L,d)}P.indices=d}}_exportVertexBuffer(G,V,W,J,R,d){const k=G.getKind();if(!h(k))return;if(k.startsWith("uv")&&!this._options.exportUnusedUVs&&(!V||!this._materialNeedsUVsSet.has(V)))return;let z=R.getVertexAccessor(G,W,J);if(void 0===z){const V=R.convertedToRightHandedBuffers.get(G._buffer)||G._buffer.getData(),d=k===A.c.PositionKind?function(G,V,W,J){const{byteOffset:R,byteStride:d,type:k,normalized:z}=V,X=V.getSize(),P=new Array(X).fill(1/0),A=new Array(X).fill(-1/0);return(0,N.f)(G,R+W*d,d,X,k,J*X,z,(G=>{for(let V=0;V<X;V++)P[V]=Math.min(P[V],G[V]),A[V]=Math.max(A[V],G[V])})),{min:P,max:A}}(V,G,W,J):void 0,X=(k===A.c.MatricesIndicesKind||k===A.c.MatricesIndicesExtraKind)&&G.type===A.c.FLOAT,P=X?A.c.UNSIGNED_BYTE:G.type,x=X?void 0:G.normalized,q=X?R.getRemappedBufferView(G._buffer,G):R.getVertexBufferView(G._buffer),L=G.byteOffset+W*G.byteStride;this._accessors.push(this._bufferManager.createAccessor(q,function(G,V){if(G==A.c.ColorKind)return V?"VEC4":"VEC3";switch(G){case A.c.PositionKind:case A.c.NormalKind:return"VEC3";case A.c.TangentKind:case A.c.MatricesIndicesKind:case A.c.MatricesIndicesExtraKind:case A.c.MatricesWeightsKind:case A.c.MatricesWeightsExtraKind:return"VEC4";case A.c.UVKind:case A.c.UV2Kind:case A.c.UV3Kind:case A.c.UV4Kind:case A.c.UV5Kind:case A.c.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${G}`)}(k,R.hasVertexColorAlpha(G)),P,J,L,d,x)),z=this._accessors.length-1,R.setVertexAccessor(G,W,J,z)}d.attributes[function(G){switch(G){case A.c.PositionKind:return"POSITION";case A.c.NormalKind:return"NORMAL";case A.c.TangentKind:return"TANGENT";case A.c.ColorKind:return"COLOR_0";case A.c.UVKind:return"TEXCOORD_0";case A.c.UV2Kind:return"TEXCOORD_1";case A.c.UV3Kind:return"TEXCOORD_2";case A.c.UV4Kind:return"TEXCOORD_3";case A.c.UV5Kind:return"TEXCOORD_4";case A.c.UV6Kind:return"TEXCOORD_5";case A.c.MatricesIndicesKind:return"JOINTS_0";case A.c.MatricesIndicesExtraKind:return"JOINTS_1";case A.c.MatricesWeightsKind:return"WEIGHTS_0";case A.c.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${G}`)}(k)]=z}async _exportMaterialAsync(G,V,W,J){let R=this._materialMap.get(G);if(void 0===R){const J=V&&Object.keys(V).some((G=>G.startsWith("uv")));if((G=G instanceof LG.d?G.od[W.materialIndex]:G)instanceof tG.d)R=await this._materialExporter.exportPBRMaterialAsync(G,"image/png",J);else{if(!(G instanceof YG.d))return void U.c.Warn(`Unsupported material '${G.name}' with type ${G.getClassName()}`);R=await this._materialExporter.exportStandardMaterialAsync(G,"image/png",J)}this._materialMap.set(G,R)}J.material=R}async _exportMeshAsync(G,V){var W;let J=V.getMesh(G);if(void 0!==J)return J;const R={primitives:[]};J=this._meshes.length,this._meshes.push(R),V.setMesh(G,J);const k=G.isUnIndexed?null:G.Pd(),z=null===(W=G.zd)||void 0===W?void 0:W.getVertexBuffers(),X=V.getMorphTargetsFromMesh(G),P=G instanceof yG.e,A=G instanceof TG,x=G.Ed;if(z&&x&&x.length>0)for(const t of x){const W={attributes:{}},J=t.NG()||this._babylonScene.defaultMaterial;if(A){var q,L;const V={name:J.name},R=G,d=g.d.White(),k=(null===(q=R.material)||void 0===q?void 0:q.alpha)??1,z=(null===(L=R.greasedLineMaterial)||void 0===L?void 0:L.color)??d;(!z.equalsWithEpsilon(d,M.c)||k<1)&&(V.pbrMetallicRoughness={baseColorFactor:[...z.Bd(),k]}),this._materials.push(V),W.material=this._materials.length-1}else if(P){const V={name:J.name},R=G;(!R.color.equalsWithEpsilon(g.d.White(),M.c)||R.alpha<1)&&(V.pbrMetallicRoughness={baseColorFactor:[...R.color.Bd(),R.alpha]}),this._materials.push(V),W.material=this._materials.length-1}else await this._exportMaterialAsync(J,z,t,W);const x=P||A?d.e.LineListDrawMode:G.overrideRenderingFillMode??J.fillMode,Y=J._getEffectiveOrientation(G);this._exportIndices(k,k?(0,N.c)(k,t.indexCount,t.indexStart,t.verticesStart):t.verticesCount>65535,k?t.indexStart:t.verticesStart,k?t.indexCount:t.verticesCount,-t.verticesStart,x,Y,V,W);for(const G of Object.values(z))this._exportVertexBuffer(G,J,t.verticesStart,t.verticesCount,V,W);if(X){W.targets=[];for(const G of X)W.targets.push(G.attributes)}R.primitives.push(W),this._extensionsPostExportMeshPrimitive(W)}if(X){R.weights=[],R.extras||(R.extras={}),R.extras.targetNames=[];for(const G of X)R.weights.push(G.influence),R.extras.targetNames.push(G.name)}return J}}sG._ExtensionNames=new Array,sG._ExtensionFactories={};class QG{static async GLTFAsync(G,V,W){W&&W.exportWithoutWaitingForScene||await G.whenReadyAsync();const J=new sG(G,W),R=await J.generateGLTFAsync(V.replace(/\.[^/.]+$/,""));return J.dispose(),R}static async GLBAsync(G,V,W){W&&W.exportWithoutWaitingForScene||await G.whenReadyAsync();const J=new sG(G,W),R=await J.generateGLBAsync(V.replace(/\.[^/.]+$/,""));return J.dispose(),R}}W(11901);const ZG="EXT_mesh_gpu_instancing";class EG{constructor(G){this.name=ZG,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(G,V,W,R,d,k){return await new Promise((G=>{if(V&&W instanceof SG.b&&W.hasThinInstances&&this._exporter){this._wasUsed=!0;const G=J.o.Zero(),R=J.g.Identity(),z=J.o.One(),X=W.thinInstanceGetWorldMatrices(),P=J.h.ed[2],A=J.h.Quaternion[1],x=J.h.ed[3];let q=!1,L=!1,t=!1;const Y=new Float32Array(3*W.jd),g=new Float32Array(4*W.jd),B=new Float32Array(3*W.jd);let S=0;for(const V of X)V.decompose(x,A,P),d&&(j(P),I(A)),Y.set(P.Bd(),3*S),g.set(A.normalize().Bd(),4*S),B.set(x.Bd(),3*S),q=q||!P.equalsWithEpsilon(G),L=L||!A.equalsWithEpsilon(R),t=t||!x.equalsWithEpsilon(z),S++;const p={attributes:{}};q&&(p.attributes.TRANSLATION=this._buildAccessor(Y,"VEC3",W.jd,k)),L&&(p.attributes.ROTATION=this._buildAccessor(g,"VEC4",W.jd,k)),t&&(p.attributes.SCALE=this._buildAccessor(B,"VEC3",W.jd,k)),V.extensions=V.extensions||{},V.extensions[ZG]=p}G(V)}))}_buildAccessor(G,V,W,J){const R=J.createBufferView(G),d=J.createAccessor(R,V,5126,W);return this._exporter._accessors.push(d),this._exporter._accessors.length-1}}sG.RegisterExtension(ZG,(G=>new EG(G)));var hG=W(11908),oG=W(11920),cG=W(11929),jG=W(11935);function IG(G){return G===cG.d.PositionKind?"POSITION":G===cG.d.NormalKind?"NORMAL":G===cG.d.ColorKind?"COLOR":G.startsWith(cG.d.UVKind)?"TEX_COORD":"GENERIC"}const OG={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class GV extends hG.b{static get DefaultAvailable(){return(0,hG.i)(GV.DefaultConfiguration)}static get Default(){return GV._Default??(GV._Default=new GV),GV._Default}static ResetDefault(G){GV._Default&&(G||GV._Default.dispose(),GV._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(G,V){return{module:await(V||DracoEncoderModule)({wasmBinary:G})}}_getWorkerContent(){return`${oG.k}(${oG.n})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:GV.DefaultConfiguration)}async _encodeAsync(G,V,W){const J=W?(0,jG.d)(OG,W):OG;if(this._workerPoolPromise){const W=await this._workerPoolPromise;return await new Promise(((R,d)=>{W.push(((W,k)=>{const z=G=>{W.removeEventListener("error",z),W.removeEventListener("message",X),d(G),k()},X=G=>{"encodeMeshDone"===G.data.id&&(W.removeEventListener("error",z),W.removeEventListener("message",X),R(G.data.encodedMeshData),k())};W.addEventListener("error",z),W.addEventListener("message",X);const P=[];for(const V of G)P.push(V.data.buffer);V&&P.push(V.buffer),W.postMessage({id:"encodeMesh",attributes:G,indices:V,options:J},P)}))}))}if(this._modulePromise){const W=await this._modulePromise;return(0,oG.k)(W.module,G,V,J)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(G,V){if(0==G.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");G instanceof SG.b&&G.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===V||void 0===V?void 0:V.method)&&(U.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),V.method="MESH_SEQUENTIAL_ENCODING");const W=function(G){let V=G.Pd(void 0,!0);return!V||V instanceof Uint32Array||V instanceof Uint16Array||(V=((0,N.c)(V,V.length)?Uint32Array:Uint16Array).from(V)),V}(G),J=function(G,V){const W=[];for(const J of G.getVerticesDataKinds()){if(null!==V&&void 0!==V&&V.includes(J)){if(J===cG.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const R=G.getVertexBuffer(J),d=R.getSize(),k=(0,N.s)(R.getData(),d,R.type,R.byteOffset,R.byteStride,R.normalized,G.getTotalVertices(),!0);W.push({kind:J,dracoName:IG(J),size:d,data:k})}return W}(G,null===V||void 0===V?void 0:V.excludedAttributes);return await this._encodeAsync(J,W,V)}}GV.DefaultConfiguration={wasmUrl:`${R.h._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${R.h._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${R.h._DefaultCdnUrl}/draco_encoder.js`},GV._Default=null;const VV="KHR_draco_mesh_compression";class WV{get wasUsed(){return this._wasUsed}constructor(G){this.name=VV,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===G.options.meshCompressionMethod&&GV.DefaultAvailable}dispose(){}postExportMeshPrimitive(G,V,W){if(!this.enabled)return;if(4!==G.mode&&5!==G.mode)return void U.c.Warn("Cannot compress primitive with mode "+G.mode+".");const J=[],R=[];let d=null;if(void 0!==G.indices){const k=W[G.indices],z=V.getBufferView(k);d=V.getData(z).slice(),J.push(z),R.push(k)}const k=[];for(const[A,x]of Object.entries(G.attributes)){const G=W[x],d=V.getBufferView(G),X=E(G.type),P=(0,N.s)(V.getData(d),X,G.componentType,G.byteOffset||0,d.byteStride||(0,N.k)(G.componentType)*X,G.normalized||!1,G.count,!0);k.push({kind:A,dracoName:(z=A,"POSITION"===z?"POSITION":"NORMAL"===z?"NORMAL":z.startsWith("COLOR")?"COLOR":z.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:E(G.type),data:P}),J.push(d),R.push(G)}var z;const X={method:G.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},P=GV.Default._encodeAsync(k,d,X).then((W=>{if(!W)return void U.c.Error("Draco encoding failed for primitive.");const d={bufferView:-1,attributes:W.attributeIds},k=V.createBufferView(W.data);V.setBufferView(d,k);for(const G of J)this._bufferViewsUsed.add(G);for(const G of R)this._accessorsUsed.add(G);G.extensions||(G.extensions={}),G.extensions[VV]=d})).catch((G=>{U.c.Error("Draco encoding failed for primitive: "+G)}));this._encodePromises.push(P),this._wasUsed=!0}async preGenerateBinaryAsync(G){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((V=>{G.getPropertiesWithBufferView(V).every((G=>this._accessorsUsed.has(G)))&&G.removeBufferView(V)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}sG.RegisterExtension(VV,(G=>new WV(G)));var JV=W(11939);const RV="KHR_lights_punctual",dV={name:"",color:[1,1,1],Xz:1,range:Number.MAX_VALUE},kV={innerConeAngle:0,outerConeAngle:Math.PI/4},zV=J.o.Backward();class XV{constructor(G){this.name=RV,this.enabled=!0,this.required=!1,this._exporter=G}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[RV]=this._lights}async postExportNodeAsync(G,V,W,R,d){return await new Promise((k=>{if(!(W instanceof pG.e))return void k(V);const z=W.getTypeID()==pG.e.LIGHTTYPEID_POINTLIGHT?"point":W.getTypeID()==pG.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":W.getTypeID()==pG.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!z||!(W instanceof JV.b))return U.c.Warn(`${G}: Light ${W.name} is not supported in ${RV}`),void k(V);if(W.falloffType!==pG.e.FALLOFF_GLTF&&U.c.Warn(`${G}: Light falloff for ${W.name} does not match the ${RV} specification!`),!W.position.equalsToFloats(0,0,0)){const G=J.h.ed[0].J(W.position);d&&j(G),V.translation=G.Bd()}if("point"!==z){const G=W.direction.normalizeToRef(J.h.ed[0]);d&&j(G);const R=J.g.FromUnitVectorsToRef(zV,G,J.h.Quaternion[0]);J.g.IsIdentity(R)||(V.rotation=R.Bd())}const X={type:z,name:W.name,color:W.Pz.Bd(),Xz:W.Xz,range:W.range};if(JG(X,dV),"spot"===z){const G=W;X.spot={innerConeAngle:G.innerAngle/2,outerConeAngle:G.angle/2},JG(X.spot,kV)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(X);const P={Rd:this._lights.lights.length-1},A=W.parent;if(A&&VG(W,A)){const G=R.get(A);if(G){const W=this._exporter._nodes[G];return GG(V,W),W.extensions||(W.extensions={}),W.extensions[RV]=P,void k(null)}}V.extensions||(V.extensions={}),V.extensions[RV]=P,k(V)}))}}sG.RegisterExtension(RV,(G=>new XV(G)));var PV=W(11734);const AV="KHR_materials_anisotropy";class xV{constructor(G){this.name=AV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,V,W){const J=[];return W instanceof PV.b&&W.anisotropy.isEnabled&&!W.anisotropy.legacy?(W.anisotropy.texture&&J.push(W.anisotropy.texture),J):[]}postExportMaterialAsync(G,V,W){return new Promise((G=>{if(W instanceof PV.b){if(!W.anisotropy.isEnabled||W.anisotropy.legacy)return void G(V);this._wasUsed=!0,V.extensions=V.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(W.anisotropy.texture),R={anisotropyStrength:W.anisotropy.Xz,anisotropyRotation:W.anisotropy.angle,anisotropyTexture:J??void 0};null!==R.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(W),V.extensions[AV]=R}G(V)}))}}sG.RegisterExtension(AV,(G=>new xV(G)));const qV="KHR_materials_clearcoat";class LV{constructor(G){this.name=qV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,V,W){const J=[];return W instanceof PV.b&&W.clearCoat.isEnabled?(W.clearCoat.texture&&J.push(W.clearCoat.texture),!W.clearCoat.useRoughnessFromMainTexture&&W.clearCoat.textureRoughness&&J.push(W.clearCoat.textureRoughness),W.clearCoat.bumpTexture&&J.push(W.clearCoat.bumpTexture),J):[]}postExportMaterialAsync(G,V,W){return new Promise((G=>{if(W instanceof PV.b){if(!W.clearCoat.isEnabled)return void G(V);this._wasUsed=!0,V.extensions=V.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(W.clearCoat.texture);let d;d=W.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(W.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(W.clearCoat.textureRoughness),W.clearCoat.isTintEnabled&&R.h.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${W.name}`),W.clearCoat.remapF0OnInterfaceChange&&R.h.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${W.name}`);const k=this._exporter._materialExporter.getTextureInfo(W.clearCoat.bumpTexture),z={clearcoatFactor:W.clearCoat.Xz,clearcoatTexture:J??void 0,clearcoatRoughnessFactor:W.clearCoat.roughness,clearcoatRoughnessTexture:d??void 0,clearcoatNormalTexture:k??void 0};null===z.clearcoatTexture&&null===z.clearcoatRoughnessTexture&&null===z.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(W),V.extensions[qV]=z}G(V)}))}}sG.RegisterExtension(qV,(G=>new LV(G)));const tV="KHR_materials_diffuse_transmission";function YV(G,V){const W=V.subSurface;let J=null;return W.translucencyIntensityTexture?J=W.translucencyIntensityTexture:W.thicknessTexture&&W.useMaskFromThicknessTexture&&(J=W.thicknessTexture),J&&!W.useGltfStyleTextures?(U.c.Warn(`${G}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${V.name}`,1),null):J}class gV{constructor(G){this.name=tV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,V,W){const J=[];if(W instanceof tG.d&&this._isExtensionEnabled(W)){const V=YV(G,W);return V&&J.push(V),W.subSurface.translucencyColorTexture&&J.push(W.subSurface.translucencyColorTexture),J}return J}_isExtensionEnabled(G){if(G.unlit)return!1;const V=G.subSurface;return!!V.isTranslucencyEnabled&&(!G.unlit&&!V.useAlbedoToTintTranslucency&&V.useGltfStyleTextures&&1===V.volumeIndexOfRefraction&&0===V.minimumThickness&&0===V.maximumThickness)}postExportMaterialAsync(G,V,W){return new Promise((J=>{if(W instanceof tG.d&&this._isExtensionEnabled(W)){this._wasUsed=!0;const J=W.subSurface,R=YV(G,W),d=0==J.translucencyIntensity?void 0:J.translucencyIntensity,k=this._exporter._materialExporter.getTextureInfo(R)??void 0,z=!J.translucencyColor||J.translucencyColor.equalsFloats(1,1,1)?void 0:J.translucencyColor.Bd(),X=this._exporter._materialExporter.getTextureInfo(J.translucencyColorTexture)??void 0,P={diffuseTransmissionFactor:d,diffuseTransmissionTexture:k,diffuseTransmissionColorFactor:z,diffuseTransmissionColorTexture:X};(k||X)&&this._exporter._materialNeedsUVsSet.add(W),V.extensions=V.extensions||{},V.extensions[tV]=P}J(V)}))}}sG.RegisterExtension(tV,(G=>new gV(G)));const BV="KHR_materials_dispersion";class SV{constructor(){this.name=BV,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(G){if(G.unlit)return!1;const V=G.subSurface;return!(!V.isRefractionEnabled&&!V.isDispersionEnabled)}postExportMaterialAsync(G,V,W){return new Promise((G=>{if(W instanceof tG.d&&this._isExtensionEnabled(W)){this._wasUsed=!0;const G={dispersion:W.subSurface.dispersion};V.extensions=V.extensions||{},V.extensions[BV]=G}G(V)}))}}sG.RegisterExtension(BV,(()=>new SV));const pV="KHR_materials_emissive_strength";class bV{constructor(){this.name=pV,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(G,V,W){return await new Promise((G=>{if(!(W instanceof tG.d))return G(V);const J=W.emissiveColor.Bd(),R=Math.max(...J);if(R>1){this._wasUsed=!0,V.extensions||(V.extensions={});const G={emissiveStrength:R},J=W.emissiveColor.scale(1/G.emissiveStrength);V.emissiveFactor=J.Bd(),V.extensions[pV]=G}return G(V)}))}}sG.RegisterExtension(pV,(G=>new bV));const rV="KHR_materials_ior";class yV{constructor(){this.name=rV,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(G){return!G.unlit&&(void 0!=G.indexOfRefraction&&1.5!=G.indexOfRefraction)}postExportMaterialAsync(G,V,W){return new Promise((G=>{if(W instanceof tG.d&&this._isExtensionEnabled(W)){this._wasUsed=!0;const G={ior:W.indexOfRefraction};V.extensions=V.extensions||{},V.extensions[rV]=G}G(V)}))}}sG.RegisterExtension(rV,(G=>new yV));const uV="KHR_materials_iridescence";class HV{constructor(G){this.name=uV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,V,W){const J=[];return W instanceof PV.b&&W.iridescence.isEnabled?(W.iridescence.texture&&J.push(W.iridescence.texture),W.iridescence.thicknessTexture&&W.iridescence.thicknessTexture!==W.iridescence.texture&&J.push(W.iridescence.thicknessTexture),J):[]}postExportMaterialAsync(G,V,W){return new Promise((G=>{if(W instanceof PV.b){if(!W.iridescence.isEnabled)return void G(V);this._wasUsed=!0,V.extensions=V.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(W.iridescence.texture),R=this._exporter._materialExporter.getTextureInfo(W.iridescence.thicknessTexture),d={iridescenceFactor:W.iridescence.Xz,iridescenceIor:W.iridescence.indexOfRefraction,iridescenceThicknessMinimum:W.iridescence.minimumThickness,iridescenceThicknessMaximum:W.iridescence.maximumThickness,iridescenceTexture:J??void 0,iridescenceThicknessTexture:R??void 0};null===d.iridescenceTexture&&null===d.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(W),V.extensions[uV]=d}G(V)}))}}sG.RegisterExtension(uV,(G=>new HV(G)));const nV="KHR_materials_sheen";class DV{constructor(G){this.name=nV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,V,W){return W instanceof tG.d&&W.sheen.isEnabled&&W.sheen.texture?[W.sheen.texture]:[]}async postExportMaterialAsync(G,V,W){return await new Promise((G=>{if(W instanceof tG.d){if(!W.sheen.isEnabled)return void G(V);this._wasUsed=!0,null==V.extensions&&(V.extensions={});const J={sheenColorFactor:W.sheen.color.Bd(),sheenRoughnessFactor:W.sheen.roughness??0};null===J.sheenColorTexture&&null===J.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(W),W.sheen.texture&&(J.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(W.sheen.texture)??void 0),W.sheen.textureRoughness&&!W.sheen.useRoughnessFromMainTexture?J.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(W.sheen.textureRoughness)??void 0:W.sheen.texture&&W.sheen.useRoughnessFromMainTexture&&(J.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(W.sheen.texture)??void 0),V.extensions[nV]=J}G(V)}))}}sG.RegisterExtension(nV,(G=>new DV(G)));const iV="KHR_materials_specular";class eV{constructor(G){this.name=iV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,V,W){const J=[];return W instanceof tG.d&&this._isExtensionEnabled(W)?(W.metallicReflectanceTexture&&J.push(W.metallicReflectanceTexture),W.reflectanceTexture&&J.push(W.reflectanceTexture),J):J}_isExtensionEnabled(G){return!G.unlit&&(void 0!=G.metallicF0Factor&&1!=G.metallicF0Factor||void 0!=G.metallicReflectanceColor&&!G.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(G))}_hasTexturesExtension(G){return null!=G.metallicReflectanceTexture||null!=G.reflectanceTexture}postExportMaterialAsync(G,V,W){return new Promise((G=>{if(W instanceof tG.d&&this._isExtensionEnabled(W)){this._wasUsed=!0,V.extensions=V.extensions||{};const G=this._exporter._materialExporter.getTextureInfo(W.metallicReflectanceTexture)??void 0,J=this._exporter._materialExporter.getTextureInfo(W.reflectanceTexture)??void 0,R={specularFactor:1==W.metallicF0Factor?void 0:W.metallicF0Factor,specularTexture:G,specularColorFactor:W.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:W.metallicReflectanceColor.Bd(),specularColorTexture:J};this._hasTexturesExtension(W)&&this._exporter._materialNeedsUVsSet.add(W),V.extensions[iV]=R}G(V)}))}}sG.RegisterExtension(iV,(G=>new eV(G)));const FV="KHR_materials_transmission";class fV{constructor(G){this.name=FV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,V,W){const J=[];return W instanceof tG.d&&this._isExtensionEnabled(W)?(W.subSurface.thicknessTexture&&J.push(W.subSurface.thicknessTexture),J):J}_isExtensionEnabled(G){if(G.unlit)return!1;const V=G.subSurface;return V.isRefractionEnabled&&void 0!=V.refractionIntensity&&0!=V.refractionIntensity||this._hasTexturesExtension(G)}_hasTexturesExtension(G){return null!=G.subSurface.refractionIntensityTexture}async postExportMaterialAsync(G,V,W){if(W instanceof tG.d&&this._isExtensionEnabled(W)){this._wasUsed=!0;const J=W.subSurface,R={transmissionFactor:0===J.refractionIntensity?void 0:J.refractionIntensity};if(this._hasTexturesExtension(W)&&this._exporter._materialNeedsUVsSet.add(W),J.refractionIntensityTexture)if(J.useGltfStyleTextures){const G=await this._exporter._materialExporter.exportTextureAsync(J.refractionIntensityTexture,"image/png");G&&(R.transmissionTexture=G)}else U.c.Warn(`${G}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);V.extensions||(V.extensions={}),V.extensions[FV]=R}return V}}sG.RegisterExtension(FV,(G=>new fV(G)));const vV="KHR_materials_unlit";class CV{constructor(){this.name=vV,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(G,V,W){return new Promise((G=>{let J=!1;W instanceof tG.d?J=W.unlit:W instanceof YG.d&&(J=W.disableLighting),J&&(this._wasUsed=!0,null==V.extensions&&(V.extensions={}),V.extensions[vV]={}),G(V)}))}}sG.RegisterExtension(vV,(()=>new CV));const lV="KHR_materials_volume";class mV{constructor(G){this.name=lV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,V,W){const J=[];return W instanceof tG.d&&this._isExtensionEnabled(W)?(W.subSurface.thicknessTexture&&J.push(W.subSurface.thicknessTexture),J):J}_isExtensionEnabled(G){if(G.unlit)return!1;const V=G.subSurface;return!(!V.isRefractionEnabled&&!V.isTranslucencyEnabled)&&(void 0!=V.maximumThickness&&0!=V.maximumThickness||void 0!=V.tintColorAtDistance&&V.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=V.tintColor&&V.tintColor!=g.d.White()||this._hasTexturesExtension(G))}_hasTexturesExtension(G){return null!=G.subSurface.thicknessTexture}postExportMaterialAsync(G,V,W){return new Promise((G=>{if(W instanceof tG.d&&this._isExtensionEnabled(W)){this._wasUsed=!0;const G=W.subSurface,J={thicknessFactor:0==G.maximumThickness?void 0:G.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(G.thicknessTexture)??void 0,attenuationDistance:G.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:G.tintColorAtDistance,attenuationColor:G.tintColor.equalsFloats(1,1,1)?void 0:G.tintColor.Bd()};this._hasTexturesExtension(W)&&this._exporter._materialNeedsUVsSet.add(W),V.extensions=V.extensions||{},V.extensions[lV]=J}G(V)}))}}sG.RegisterExtension(lV,(G=>new mV(G)));const wV="EXT_materials_diffuse_roughness";class NV{constructor(G){this.name=wV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=G}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(G,V,W){const J=[];return W instanceof PV.b&&W._baseDiffuseRoughness?(W._baseDiffuseRoughnessTexture&&J.push(W._baseDiffuseRoughnessTexture),J):[]}postExportMaterialAsync(G,V,W){return new Promise((G=>{if(W instanceof PV.b){if(!W._baseDiffuseRoughness)return void G(V);this._wasUsed=!0,V.extensions=V.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(W._baseDiffuseRoughnessTexture),R={diffuseRoughnessFactor:W._baseDiffuseRoughness,diffuseRoughnessTexture:J??void 0};null!==R.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(W),V.extensions[wV]=R}G(V)}))}}sG.RegisterExtension(wV,(G=>new NV(G)));const UV="KHR_texture_transform";class aV{constructor(){this.name=UV,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(G,V,W){if(W.HG()||R.h.Warn(`${G}: /*@__KEY__*/"scene" is not defined for Babylon texture ${W.name}!`),(0!==W.uAng||0!==W.vAng)&&(R.h.Warn(`${G}: Texture ${W.name} with rotation in the u or v axis is not supported in glTF.`),0!==W.uRotationCenter||0!==W.vRotationCenter))return;const J={};let d=!1;if(0===W.uOffset&&0===W.vOffset||(J.offset=[W.uOffset,W.vOffset],d=!0),1===W.uScale&&1===W.vScale||(J.scale=[W.uScale,W.vScale],d=!0),0!==W.wAng){if(0!==W.uRotationCenter||0!==W.vRotationCenter){if(W.homogeneousRotationInUVTransform&&W.uScale!==W.vScale)return void R.h.Warn(`${G}: Texture ${W.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${UV}.`);R.h.Warn(`${G}: Texture ${W.name} with non-origin rotation center will be exported using an adjusted offset with ${UV}.`),J.offset=function(G){const{uOffset:V,vOffset:W,uRotationCenter:J,vRotationCenter:R,uScale:d,vScale:k,wAng:z}=G,X=Math.cos(z),P=Math.sin(z),A=J*d,x=R*k;return[V+(A*(1-X)+x*P),W+(x*(1-X)-A*P)]}(W)}J.rotation=-W.wAng,d=!0}0!==W.coordinatesIndex&&(J.texCoord=W.coordinatesIndex,d=!0),d&&(this._wasUsed=!0,V.extensions||(V.extensions={}),V.extensions[UV]=J)}}sG.RegisterExtension(UV,(()=>new aV));class MV{static CreateSTL(G){let V=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",R=arguments.length>3&&void 0!==arguments[3]&&arguments[3],d=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],k=arguments.length>5&&void 0!==arguments[5]&&arguments[5],z=arguments.length>6&&void 0!==arguments[6]&&arguments[6],X=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const P=function(G,V,W){const R=[3*G[W],3*G[W+1],3*G[W+2]],d=[new J.o(V[R[0]],V[R[0]+2],V[R[0]+1]),new J.o(V[R[1]],V[R[1]+2],V[R[1]+1]),new J.o(V[R[2]],V[R[2]+2],V[R[2]+1])],k=d[0].zW(d[1]),z=d[2].zW(d[1]);return{v:d,n:J.o.Cross(z,k).normalize()}},x=function(G,V,W,J){return V=q(G,V,W.x,J),V=q(G,V,W.y,J),q(G,V,W.z,J)},q=function(G,V,W,J){return G.setFloat32(V,W,J),V+4},t=function(G){if(z){let V=G;G instanceof L.c&&(V=G.sourceMesh);const W=V.getVerticesData(A.c.PositionKind,!0,!0);if(!W)return[];const R=J.o.Zero();let d;for(d=0;d<W.length;d+=3)J.o.TransformCoordinatesFromFloatsToRef(W[d],W[d+1],W[d+2],G.kd(!0),R).toArray(W,d);return W}return G.getVerticesData(A.c.PositionKind)||[]};z&&(k=!0);let Y="",g=0,B=0;if(R){for(let W=0;W<G.length;W++){const V=G[W].Pd();g+=V?V.length/3:0}const V=new ArrayBuffer(84+50*g);Y=new DataView(V),B+=80,Y.setUint32(B,g,d),B+=4}else X||(Y="solid stlmesh\r\n");for(let J=0;J<G.length;J++){const V=G[J];!R&&X&&(Y+="solid "+V.name+"\r\n"),!k&&V instanceof SG.b&&V.bakeCurrentTransformIntoVertices();const W=t(V),z=V.Pd()||[];for(let G=0;G<z.length;G+=3){const V=P(z,W,G);R?(B=x(Y,B,V.n,d),B=x(Y,B,V.v[0],d),B=x(Y,B,V.v[1],d),B=x(Y,B,V.v[2],d),B+=2):(Y+="\tfacet normal "+V.n.x+" "+V.n.y+" "+V.n.z+"\r\n",Y+="\t\touter loop\r\n",Y+="\t\t\tvertex "+V.v[0].x+" "+V.v[0].y+" "+V.v[0].z+"\r\n",Y+="\t\t\tvertex "+V.v[1].x+" "+V.v[1].y+" "+V.v[1].z+"\r\n",Y+="\t\t\tvertex "+V.v[2].x+" "+V.v[2].y+" "+V.v[2].z+"\r\n",Y+="\t\tendloop\r\n",Y+="\tendfacet\r\n")}!R&&X&&(Y+="endsolid "+name+"\r\n")}if(R||X||(Y+="endsolid stlmesh"),V){const G=document.createElement("a"),V=new Blob([Y],{type:"application/octet-stream"});G.href=window.URL.createObjectURL(V),G.download=W+".stl",G.click()}return Y}}function TV(G,V){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const J=[];for(let R=0;R<G.length/W;R++){const d=G[R*W],k=G[R*W+1],z=G[R*W+2];J.push(`(${d.toPrecision(V.precision)}, ${k.toPrecision(V.precision)}, ${z.toPrecision(V.precision)})`)}return J.join(", ")}function KV(G,V){const W=[];for(let J=0;J<G.length/2;J++){const R=G[2*J],d=G[2*J+1];W.push(`(${R.toPrecision(V.precision)}, ${(1-d).toPrecision(V.precision)})`)}return W.join(", ")}function sV(G,V){const W=G.getVerticesData(A.c.PositionKind),J=G.getVerticesData(A.c.NormalKind);if(W&&J)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(G){var V;const W=null!==(V=G.Pd())&&void 0!==V&&V.length?G.getTotalIndices():G.getTotalVertices();return Array(W/3).fill(3).join(", ")}(G)}]\n\t\tint[] faceVertexIndices = [${function(G){const V=G.Pd(),W=[];if(null!==V)for(let J=0;J<V.length;J++)W.push(V[J]);else{const V=G.getTotalVertices();for(let G=0;G<V;G++)W.push(G)}return W.join(", ")}(G)}]\n\t\tnormal3f[] normals = [${TV(J,V)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${TV(W,V)}]\n        ${function(G,V){let W="";for(let R=0;R<4;R++){const J=R>0?R:"",d=G.getVerticesData(A.c.UVKind+(J?J+1:""));d&&(W+=`\n\t\ttexCoord2f[] primvars:st${J} = [${KV(d,V)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const J=G.getVerticesData(A.c.ColorKind);return J&&(W+=`\n\tcolor3f[] primvars:displayColor = [${TV(J,V,J.length/G.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),W}(G,V)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function QV(G,V){return`\n        def "Geometry"\n        {\n        ${sV(G,V)}\n        }\n        `}function ZV(G){let V='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return V+=G,fflate.strToU8(V)}function EV(G){const V=G.m;return`( ${hV(V,0)}, ${hV(V,4)}, ${hV(V,8)}, ${hV(V,12)} )`}function hV(G,V){return`(${G[V+0]}, ${G[V+1]}, ${G[V+2]}, ${G[V+3]})`}function oV(G){const V="Object_"+G.uniqueId,W=function(G){const V=G.getWorldMatrix().clone(),W=G.HG().useRightHandedSystem;if(!W){let J=G.parent;for(;J;){if(kG(J,W)){V.multiplyToRef(J.getWorldMatrix().invert(),V);break}J=J.parent}}return V.determinant()<0&&R.h.Warn(`Exporting mesh ${G.name} with negative scale. Result may look incorrect in destination engine.`),V}(G),J=EV(W);return`def Xform "${V}" (\n\tprepend references = @./geometries/Geometry_${G.zd.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${J}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${G.material.uniqueId}>\n}\n\n`}function cV(G){switch(G){case u.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case u.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case u.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function jV(G){return`(${G.x}, ${G.y})`}function IV(G){return`(${G.r}, ${G.g}, ${G.b})`}function OV(G,V,W,R,d,k){const z=G.getInternalTexture().uniqueId+"_"+G.invertY;d[z]=G;const X=G.coordinatesIndex>0?"st"+G.coordinatesIndex:"st",P=new J.k(G.uScale,G.vScale),A=new J.k(G.uOffset,G.vOffset),x=G.wAng,q=Math.sin(x),L=Math.cos(x);return A.y=1-A.y-P.y,A.x+=q*P.x,A.y+=(1-L)*P.y,`\n    def Shader "PrimvarReader_${W}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${X}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${W}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${V.uniqueId}/PrimvarReader_${W}.outputs:result>\n        float inputs:rotation = ${(x*(180/Math.PI)).toFixed(k.precision)}\n        float2 inputs:scale = ${jV(P)}\n        float2 inputs:translation = ${jV(A)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${G.uniqueId}_${W}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${z}.png@\n        float2 inputs:st.connect = </Materials/Material_${V.uniqueId}/Transform2d_${W}.outputs:result>\n        ${R?"float4 inputs:scale = "+function(G){return`(${G.r}, ${G.g}, ${G.b}, 1.0)`}(R):""}\n        token inputs:sourceColorSpace = "${G.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${cV(G.wrapU)}"\n        token inputs:wrapT = "${cV(G.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${V.needAlphaBlending()?"float outputs:a":""}\n    }`}function GW(G,V,W){const J="\t\t\t",R=[],d=[],{diffuseMap:k,Pz:z,alphaCutOff:X,emissiveMap:P,emissive:A,normalMap:x,roughnessMap:q,roughnessChannel:L,roughness:t,metalnessMap:Y,metalnessChannel:B,metalness:S,aoMap:p,aoMapChannel:b,aoMapIntensity:r,alphaMap:y,ior:u,clearCoatEnabled:H,clearCoat:n,clearCoatMap:D,clearCoatRoughness:i,clearCoatRoughnessMap:e}=function(G){const V={diffuseMap:null,Pz:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return G instanceof YG.d?{...V,diffuseMap:G.diffuseTexture,Pz:G.diffuseColor,alphaCutOff:G.alphaCutOff,emissiveMap:G.emissiveTexture,emissive:G.emissiveColor,roughness:1,alphaMap:G.opacityTexture}:G instanceof PV.b?{...V,diffuseMap:G._albedoTexture,Pz:G._albedoColor,alphaCutOff:G._alphaCutOff,emissiveMap:G._emissiveTexture,emissive:G._emissiveColor,normalMap:G._bumpTexture,roughnessMap:G._metallicTexture,roughnessChannel:G._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:G._roughness??1,metalnessMap:G._metallicTexture,metalnessChannel:G._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:G._metallic??0,aoMap:G._ambientTexture,aoMapChannel:G._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:G._ambientTextureStrength,alphaMap:G._opacityTexture,ior:G.subSurface.indexOfRefraction,clearCoatEnabled:G.clearCoat.isEnabled,clearCoat:G.clearCoat.Xz,clearCoatMap:G.clearCoat.texture,clearCoatRoughness:G.clearCoat.roughness,clearCoatRoughnessMap:G.clearCoat.useRoughnessFromMainTexture?G.clearCoat.texture:G.clearCoat.textureRoughness}:V}(G);return null!==k?(R.push(`${J}color3f inputs:diffuseColor.connect = </Materials/Material_${G.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:rgb>`),G.needAlphaBlending()?R.push(`${J}float inputs:opacity.connect = </Materials/Material_${G.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:a>`):G.needAlphaTesting()&&(R.push(`${J}float inputs:opacity.connect = </Materials/Material_${G.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:a>`),R.push(`${J}float inputs:opacityThreshold = ${X}`)),d.push(OV(k,G,"diffuse",z,V,W))):R.push(`${J}color3f inputs:diffuseColor = ${IV(z||g.d.White())}`),null!==P?(R.push(`${J}color3f inputs:emissiveColor.connect = </Materials/Material_${G.uniqueId}/Texture_${P.uniqueId}_emissive.outputs:rgb>`),d.push(OV(P,G,"emissive",A,V,W))):A&&A.toLuminance()>0&&R.push(`${J}color3f inputs:emissiveColor = ${IV(A)}`),null!==x&&(R.push(`${J}normal3f inputs:normal.connect = </Materials/Material_${G.uniqueId}/Texture_${x.uniqueId}_normal.outputs:rgb>`),d.push(OV(x,G,"IV",null,V,W))),null!==p&&(R.push(`${J}float inputs:occlusion.connect = </Materials/Material_${G.uniqueId}/Texture_${p.uniqueId}_occlusion.outputs:${b}>`),d.push(OV(p,G,"occlusion",new g.d(r,r,r),V,W))),null!==q?(R.push(`${J}float inputs:roughness.connect = </Materials/Material_${G.uniqueId}/Texture_${q.uniqueId}_roughness.outputs:${L}>`),d.push(OV(q,G,"roughness",new g.d(t,t,t),V,W))):R.push(`${J}float inputs:roughness = ${t}`),null!==Y?(R.push(`${J}float inputs:metallic.connect = </Materials/Material_${G.uniqueId}/Texture_${Y.uniqueId}_metallic.outputs:${B}>`),d.push(OV(Y,G,"metallic",new g.d(S,S,S),V,W))):R.push(`${J}float inputs:metallic = ${S}`),null!==y?(R.push(`${J}float inputs:opacity.connect = </Materials/Material_${G.uniqueId}/Texture_${y.uniqueId}_opacity.outputs:r>`),R.push(`${J}float inputs:opacityThreshold = 0.0001`),d.push(OV(y,G,"opacity",null,V,W))):R.push(`${J}float inputs:opacity = ${G.alpha}`),H&&(null!==D?(R.push(`${J}float inputs:clearcoat.connect = </Materials/Material_${G.uniqueId}/Texture_${D.uniqueId}_clearcoat.outputs:r>`),d.push(OV(D,G,"clearcoat",new g.d(n,n,n),V,W))):R.push(`${J}float inputs:clearcoat = ${n}`),null!==e?(R.push(`${J}float inputs:clearcoatRoughness.connect = </Materials/Material_${G.uniqueId}/Texture_${e.uniqueId}_clearcoatRoughness.outputs:g>`),d.push(OV(e,G,"clearcoatRoughness",new g.d(i,i,i),V,W))):R.push(`${J}float inputs:clearcoatRoughness = ${i}`)),R.push(`${J}float inputs:ior = ${u}`),`\n\tdef Material "Material_${G.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${R.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${G.uniqueId}/PreviewSurface.outputs:surface>\n\n${d.join("\n")}\n\n\t}\n`}async function VW(G,V,W){const d={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...V};"undefined"===typeof fflate&&await R.h.LoadScriptAsync(d.fflateUrl);const k={};k[d.modelFileName]=null;let z='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';z+=function(G){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===G.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${G.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${G.planeAnchoringAlignment}"`:""}\n            `}(d);const X={};for(const J of G.meshes){if(0===J.getTotalVertices())continue;const G=J,V=G.zd,P=G.material;if(!P||!V||W&&!W(G))continue;if(-1!==["Az","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(P.getClassName())){const W="geometries/Geometry_"+V.uniqueId+".usda";if(!(W in k)){const G=QV(V,d);k[W]=ZV(G)}P.uniqueId in X||(X[P.uniqueId]=P),z+=oV(G)}else R.h.Warn("USDZExportAsync does not support this material type: "+P.getClassName())}G.activeCamera&&d.exportCamera&&(z+=function(G,V){const W="Camera_"+G.uniqueId,R=EV(J.c.RotationY(Math.PI).multiply(G.getWorldMatrix()));if(G.mode===u.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${W}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${R}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${G.Zd.toPrecision(V.precision)}, ${G.maxZ.toPrecision(V.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(G.orthoLeft||1)+Math.abs(G.orthoRight||1))).toPrecision(V.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(G.orthoTop||1)+Math.abs(G.orthoBottom||1))).toPrecision(V.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const J=G.getEngine().getAspectRatio(G),d=V.cameraSensorWidth||35;return`def Camera "${W}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${R}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${G.Zd.toPrecision(V.precision)}, ${G.maxZ.toPrecision(V.precision)})\n\t\t\tfloat focalLength = ${(d/(2*Math.tan(.5*G.fov))).toPrecision(V.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(d*J).toPrecision(V.precision)}\n\t\t\tfloat verticalAperture = ${(d/J).toPrecision(V.precision)}            \n\t\t}\n\t\n\t`}}(G.activeCamera,d)),z+="\n            }\n        }\n    }";const P={};z+=function(G,V,W){const J=[];for(const R in G){const d=G[R];J.push(GW(d,V,W))}return`\n    def "Materials"\n{\n${J.join("")}\n}\n\n`}(X,P,d),k[d.modelFileName]=fflate.strToU8(z);for(const J in P){const G=P[J],V=G.getSize(),W=await G.readPixels();if(!W)throw new Error("Texture data is not available");const R=await H.DumpTools.DumpDataAsync(V.width,V.height,W,"image/png",void 0,!1,!0);k[`textures/Texture_${J}.png`]=new Uint8Array(R).slice()}let A=0;for(const J in k){const G=k[J];if(!G)continue;A+=34+J.length;const V=63&A;if(4!==V){const W=new Uint8Array(64-V);k[J]=[G,{extra:{12345:W}}]}A=G.length}return fflate.zipSync(k,{level:0})}}}]);