"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{2131:(L,j,P)=>{P.r(j),P.d(j,{_BasisTextureLoader:()=>h});var A,R=P(475),o=P(2032),Y=P(589);function u(){const L=0,j=1,P=2,A=3,R=6,o=8,Y=9,u=10,a=14;let D=null;function S(L,j,P,A,R){const o=L.getImageTranscodedSizeInBytes(j,P,A);let Y=new Uint8Array(o);if(!L.transcodeImage(Y,j,P,A,1,0))return null;if(R){Y=function(L,j,P,A){const R=new Uint16Array(4),o=new Uint16Array(P*A),Y=P/4,u=A/4;for(let a=0;a<u;a++)for(let A=0;A<Y;A++){const u=j+8*(a*Y+A);R[0]=L[u]|L[u+1]<<8,R[1]=L[u+2]|L[u+3]<<8,R[2]=(2*(31&R[0])+1*(31&R[1]))/3|(2*(2016&R[0])+1*(2016&R[1]))/3&2016|(2*(63488&R[0])+1*(63488&R[1]))/3&63488,R[3]=(2*(31&R[1])+1*(31&R[0]))/3|(2*(2016&R[1])+1*(2016&R[0]))/3&2016|(2*(63488&R[1])+1*(63488&R[0]))/3&63488;for(let j=0;j<4;j++){const Y=L[u+4+j];let D=(4*a+j)*P+4*A;o[D++]=R[3&Y],o[D++]=R[Y>>2&3],o[D++]=R[Y>>4&3],o[D++]=R[Y>>6&3]}}return o}(Y,0,L.getImageWidth(j,P)+3&-4,L.getImageHeight(j,P)+3&-4)}return Y}onmessage=g=>{if("init"===g.data.action){if(g.data.url)try{importScripts(g.data.url)}catch(V){postMessage({action:"error",error:V})}D||(D=BASIS({wasmBinary:g.data.wasmBinary})),null!==D&&D.then((L=>{BASIS=L,L.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===g.data.action){const D=g.data.config,V=g.data.imageData,N=new BASIS.BasisFile(V),C=function(L){const j=L.getHasAlpha(),P=L.getNumImages(),A=[];for(let R=0;R<P;R++){const j={levels:[]},P=L.getNumLevels(R);for(let A=0;A<P;A++){const P={width:L.getImageWidth(R,A),height:L.getImageHeight(R,A)};j.levels.push(P)}A.push(j)}return{Jj:j,images:A}}(N);let b=g.data.ignoreSupportedFormats?null:function(D,S){let g=null;D.supportedCompressionFormats&&(g=D.supportedCompressionFormats.astc?u:D.supportedCompressionFormats.bc7?R:D.supportedCompressionFormats.s3tc?S.Jj?A:P:D.supportedCompressionFormats.pvrtc?S.Jj?Y:o:D.supportedCompressionFormats.etc2?j:D.supportedCompressionFormats.etc1?L:a);return g}(g.data.config,C),f=!1;null===b&&(f=!0,b=C.Jj?A:P);let h=!0;N.startTranscoding()||(h=!1);const K=[];for(let L=0;L<C.images.length&&h;L++){const j=C.images[L];if(void 0===D.loadSingleImage||D.loadSingleImage===L){let P=j.levels.length;!1===D.loadMipmapLevels&&(P=1);for(let A=0;A<P;A++){const P=j.levels[A],R=S(N,L,A,b,f);if(!R){h=!1;break}P.transcodedPixels=R,K.push(P.transcodedPixels.buffer)}}}N.close(),N.delete(),f&&(b=-1),h?postMessage({action:"transcode",success:h,id:g.data.id,fileInfo:C,format:b},K):postMessage({action:"transcode",success:h,id:g.data.id})}}}!function(L){L[L.cTFETC1=0]="cTFETC1",L[L.cTFETC2=1]="cTFETC2",L[L.cTFBC1=2]="cTFBC1",L[L.cTFBC3=3]="cTFBC3",L[L.cTFBC4=4]="cTFBC4",L[L.cTFBC5=5]="cTFBC5",L[L.cTFBC7=6]="cTFBC7",L[L.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",L[L.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",L[L.cTFASTC_4x4=10]="cTFASTC_4x4",L[L.cTFATC_RGB=11]="cTFATC_RGB",L[L.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",L[L.cTFRGBA32=13]="cTFRGBA32",L[L.cTFRGB565=14]="cTFRGB565",L[L.cTFBGR565=15]="cTFBGR565",L[L.cTFRGBA4444=16]="cTFRGBA4444",L[L.cTFFXT1_RGB=17]="cTFFXT1_RGB",L[L.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",L[L.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",L[L.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",L[L.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(A||(A={}));const a={JSModuleURL:`${R.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${R.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let D=null,S=null,g=0;const V=async()=>(D||(D=new Promise(((L,j)=>{S?L(S):R.d.LoadFileAsync(R.d.GetBabylonScriptURL(a.WasmModuleURL)).then((P=>{if("function"!==typeof URL)return j("Basis transcoder requires an environment with a URL constructor");const A=URL.createObjectURL(new Blob([`(${u})()`],{type:"application/javascript"}));S=new Worker(A),async function(L,j,P){return await new Promise(((A,o)=>{const Y=j=>{"init"===j.data.action?(L.removeEventListener("message",Y),A(L)):"error"===j.data.action&&o(j.data.error||"error initializing worker")};L.addEventListener("message",Y),L.postMessage({action:"init",url:P?R.d.GetBabylonScriptURL(P):void 0,wasmBinary:j},[j])}))}(S,P,a.JSModuleURL).then(L,j)})).catch(j)}))),await D),N=async(L,j)=>{const P=L instanceof ArrayBuffer?new Uint8Array(L):L;return await new Promise(((L,A)=>{V().then((()=>{const R=g++,o=j=>{"transcode"===j.data.action&&j.data.id===R&&(S.removeEventListener("message",o),j.data.success?L(j.data):A("Transcode is not supported on this device"))};S.addEventListener("message",o);const Y=new Uint8Array(P.byteLength);Y.set(new Uint8Array(P.buffer,P.byteOffset,P.byteLength)),S.postMessage({action:"transcode",id:R,imageData:Y,config:j,ignoreSupportedFormats:false},[Y.buffer])}),(L=>{A(L)}))}))},C=(L,j)=>{var P;let A=null===(P=j._gl)||void 0===P?void 0:P.TEXTURE_2D;var R;L.isCube&&(A=null===(R=j._gl)||void 0===R?void 0:R.TEXTURE_CUBE_MAP);j._bindTextureDirectly(A,L,!0)},b=(L,j)=>{const P=L.getEngine();for(let u=0;u<j.fileInfo.images.length;u++){const a=j.fileInfo.images[u].levels[0];if(L._invertVScale=L.invertY,-1===j.format||j.format===A.cTFRGB565)if(L.type=10,L.format=4,!P._features.basisNeedsPOT||Math.log2(a.width)%1===0&&Math.log2(a.height)%1===0)L._invertVScale=!L.invertY,L.width=a.width+3&-4,L.height=a.height+3&-4,L.samplingMode=2,C(L,P),P._uploadDataToTextureDirectly(L,new Uint16Array(a.transcodedPixels.buffer),u,0,4,!0);else{const j=new Y.c(P,2);L._invertVScale=L.invertY,j.type=10,j.format=4,j.width=a.width+3&-4,j.height=a.height+3&-4,C(j,P),P._uploadDataToTextureDirectly(j,new Uint16Array(a.transcodedPixels.buffer),u,0,4,!0),P._rescaleTexture(j,L,P.scenes[0],P._getInternalFormat(4),(()=>{P._releaseTexture(j),C(L,P)}))}else{L.width=a.width,L.height=a.height,L.generateMipMaps=j.fileInfo.images[u].levels.length>1;const A=f.GetInternalFormatFromBasisFormat(j.format,P);L.format=A,C(L,P);const Y=j.fileInfo.images[u].levels;for(let j=0;j<Y.length;j++){const R=Y[j];P._uploadCompressedDataToTextureDirectly(L,A,R.width,R.height,R.transcodedPixels,u,j)}!P._features.basisNeedsPOT||Math.log2(L.width)%1===0&&Math.log2(L.height)%1===0||(R.d.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),L._cachedWrapU=o.e.CLAMP_ADDRESSMODE,L._cachedWrapV=o.e.CLAMP_ADDRESSMODE)}}},f={JSModuleURL:a.JSModuleURL,WasmModuleURL:a.WasmModuleURL,GetInternalFormatFromBasisFormat:(L,j)=>{let P;switch(L){case A.cTFETC1:P=36196;break;case A.cTFBC1:P=33776;break;case A.cTFBC4:P=33779;break;case A.cTFASTC_4x4:P=37808;break;case A.cTFETC2:P=37496;break;case A.cTFBC7:P=36492}if(void 0===P)throw"The chosen Basis transcoder format is not currently supported";return P},TranscodeAsync:N,LoadTextureFromTranscodeResult:b};Object.defineProperty(f,"JSModuleURL",{get:function(){return a.JSModuleURL},set:function(L){a.JSModuleURL=L}}),Object.defineProperty(f,"WasmModuleURL",{get:function(){return a.WasmModuleURL},set:function(L){a.WasmModuleURL=L}});class h{constructor(){this.supportCascades=!1}loadCubeData(L,j,P,A,o){if(Array.isArray(L))return;const Y=j.getEngine().getCaps(),u={supportedCompressionFormats:{etc1:!!Y.etc1,s3tc:!!Y.s3tc,pvrtc:!!Y.pvrtc,etc2:!!Y.etc2,astc:!!Y.astc,bc7:!!Y.bptc}};N(L,u).then((L=>{const P=L.fileInfo.images[0].levels.length>1&&j.generateMipMaps;b(j,L),j.getEngine()._setCubeMapTextureParams(j,P),j.isReady=!0,j.onLoadedObservable.notifyObservers(j),j.onLoadedObservable.clear(),A&&A()})).catch((L=>{R.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),j.isReady=!0,o&&o(L)}))}loadData(L,j,P){const A=j.getEngine().getCaps(),o={supportedCompressionFormats:{etc1:!!A.etc1,s3tc:!!A.s3tc,pvrtc:!!A.pvrtc,etc2:!!A.etc2,astc:!!A.astc,bc7:!!A.bptc}};N(L,o).then((L=>{const A=L.fileInfo.images[0].levels[0],R=L.fileInfo.images[0].levels.length>1&&j.generateMipMaps;P(A.width,A.height,R,-1!==L.format,(()=>{b(j,L)}))})).catch((L=>{R.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),R.d.Warn(`Failed to transcode Basis file: ${L}`),P(0,0,!1,!1,(()=>{}),!0)}))}}}}]);