"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10943:(D,j,W)=>{W.r(j),W.d(j,{_HDRTextureLoader:()=>F});var Q=W(966);class C{static ConvertPanoramaToCubemap(D,j,W,Q){let C=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!D)throw"ConvertPanoramaToCubemap: input cannot be null";if(D.length!=j*W*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(Q,this.FACE_FRONT,D,j,W,C),back:this.CreateCubemapTexture(Q,this.FACE_BACK,D,j,W,C),left:this.CreateCubemapTexture(Q,this.FACE_LEFT,D,j,W,C),right:this.CreateCubemapTexture(Q,this.FACE_RIGHT,D,j,W,C),up:this.CreateCubemapTexture(Q,this.FACE_UP,D,j,W,C),down:this.CreateCubemapTexture(Q,this.FACE_DOWN,D,j,W,C),size:Q,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(D,j,W,Q,C){let k=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const M=new ArrayBuffer(D*D*4*3),O=new Float32Array(M),E=k?Math.max(1,Math.round(Q/4/D)):1,f=1/E,F=f*f,Z=j[1].Qc(j[0]).scale(f/D),P=j[3].Qc(j[2]).scale(f/D),X=1/D;let x=0;for(let R=0;R<D;R++)for(let k=0;k<E;k++){let k=j[0],M=j[2];for(let j=0;j<D;j++)for(let f=0;f<E;f++){const E=M.Qc(k).scale(x).add(k);E.normalize();const f=this.CalcProjectionSpherical(E,W,Q,C);O[R*D*3+3*j+0]+=f.r*F,O[R*D*3+3*j+1]+=f.g*F,O[R*D*3+3*j+2]+=f.b*F,k=k.add(Z),M=M.add(P)}x+=X*f}return O}static CalcProjectionSpherical(D,j,W,Q){let C=Math.atan2(D.z,D.x);const k=Math.acos(D.y);for(;C<-Math.PI;)C+=2*Math.PI;for(;C>Math.PI;)C-=2*Math.PI;let M=C/Math.PI;const O=k/Math.PI;M=.5*M+.5;let E=Math.round(M*W);E<0?E=0:E>=W&&(E=W-1);let f=Math.round(O*Q);f<0?f=0:f>=Q&&(f=Q-1);const F=Q-f-1;return{r:j[F*W*3+3*E+0],g:j[F*W*3+3*E+1],b:j[F*W*3+3*E+2]}}}function k(D,j,W,Q,C,k){C>0?(C=function(D,j){return j>1023?D*Math.pow(2,1023)*Math.pow(2,j-1023):j<-1074?D*Math.pow(2,-1074)*Math.pow(2,j+1074):D*Math.pow(2,j)}(1,C-136),D[k+0]=j*C,D[k+1]=W*C,D[k+2]=Q*C):(D[k+0]=0,D[k+1]=0,D[k+2]=0)}function M(D,j){let W="",Q="";for(let C=j;C<D.length-j&&(Q=String.fromCharCode(D[C]),"\n"!=Q);C++)W+=Q;return W}function O(D){let j=0,W=0,Q=M(D,0);if("#"!=Q[0]||"?"!=Q[1])throw"Bad HDR Format.";let C=!1,k=!1,O=0;do{O+=Q.length+1,Q=M(D,O),"FORMAT=32-bit_rle_rgbe"==Q?k=!0:0==Q.length&&(C=!0)}while(!C);if(!k)throw"HDR Bad header format, unsupported FORMAT";O+=Q.length+1,Q=M(D,O);const E=/^-Y (.*) \+X (.*)$/g.exec(Q);if(!E||E.length<3)throw"HDR Bad header format, no size";if(W=parseInt(E[2]),j=parseInt(E[1]),W<8||W>32767)throw"HDR Bad header format, unsupported size";return O+=Q.length+1,{height:j,width:W,dataPosition:O}}function E(D,j){return function(D,j){let W=j.height;const Q=j.width;let C,M,O,E,F,Z=j.dataPosition,P=0,X=0,x=0;const R=new ArrayBuffer(4*Q),V=new Uint8Array(R),U=new ArrayBuffer(j.width*j.height*4*3),g=new Float32Array(U);for(;W>0;){if(C=D[Z++],M=D[Z++],O=D[Z++],E=D[Z++],2!=C||2!=M||128&O||j.width<8||j.width>32767)return f(D,j);if((O<<8|E)!=Q)throw"HDR Bad header format, wrong scan line width";for(P=0,x=0;x<4;x++)for(X=(x+1)*Q;P<X;)if(C=D[Z++],M=D[Z++],C>128){if(F=C-128,0==F||F>X-P)throw"HDR Bad Format, bad scanline data (run)";for(;F-- >0;)V[P++]=M}else{if(F=C,0==F||F>X-P)throw"HDR Bad Format, bad scanline data (non-run)";if(V[P++]=M,--F>0)for(let j=0;j<F;j++)V[P++]=D[Z++]}for(x=0;x<Q;x++)C=V[x],M=V[x+Q],O=V[x+2*Q],E=V[x+3*Q],k(g,C,M,O,E,(j.height-W)*Q*3+3*x);W--}return g}(D,j)}function f(D,j){let W=j.height;const Q=j.width;let C,M,O,E,f,F=j.dataPosition;const Z=new ArrayBuffer(j.width*j.height*4*3),P=new Float32Array(Z);for(;W>0;){for(f=0;f<j.width;f++)C=D[F++],M=D[F++],O=D[F++],E=D[F++],k(P,C,M,O,E,(j.height-W)*Q*3+3*f);W--}return P}C.FACE_LEFT=[new Q.j(-1,-1,-1),new Q.j(1,-1,-1),new Q.j(-1,1,-1),new Q.j(1,1,-1)],C.FACE_RIGHT=[new Q.j(1,-1,1),new Q.j(-1,-1,1),new Q.j(1,1,1),new Q.j(-1,1,1)],C.FACE_FRONT=[new Q.j(1,-1,-1),new Q.j(1,-1,1),new Q.j(1,1,-1),new Q.j(1,1,1)],C.FACE_BACK=[new Q.j(-1,-1,1),new Q.j(-1,-1,-1),new Q.j(-1,1,1),new Q.j(-1,1,-1)],C.FACE_DOWN=[new Q.j(1,1,-1),new Q.j(1,1,1),new Q.j(-1,1,-1),new Q.j(-1,1,1)],C.FACE_UP=[new Q.j(-1,-1,-1),new Q.j(-1,-1,1),new Q.j(1,-1,-1),new Q.j(1,-1,1)];class F{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(D,j,W){const Q=new Uint8Array(D.buffer,D.byteOffset,D.byteLength),C=O(Q),k=E(Q,C),M=C.width*C.height,f=new Float32Array(4*M);for(let O=0;O<M;O+=1)f[4*O]=k[3*O],f[4*O+1]=k[3*O+1],f[4*O+2]=k[3*O+2],f[4*O+3]=1;W(C.width,C.height,j.generateMipMaps,!1,(()=>{const D=j.getEngine();j.type=1,j.format=5,j._gammaSpace=!1,D._uploadDataToTextureDirectly(j,f)}))}}}}]);