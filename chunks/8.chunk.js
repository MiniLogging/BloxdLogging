"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10697:(j,S,h)=>{h.r(S),h.d(S,{_HDRTextureLoader:()=>M});var m=h(970);class I{static ConvertPanoramaToCubemap(j,S,h,m){let I=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!j)throw"ConvertPanoramaToCubemap: input cannot be null";if(j.length!=S*h*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(m,this.FACE_FRONT,j,S,h,I),back:this.CreateCubemapTexture(m,this.FACE_BACK,j,S,h,I),left:this.CreateCubemapTexture(m,this.FACE_LEFT,j,S,h,I),right:this.CreateCubemapTexture(m,this.FACE_RIGHT,j,S,h,I),up:this.CreateCubemapTexture(m,this.FACE_UP,j,S,h,I),down:this.CreateCubemapTexture(m,this.FACE_DOWN,j,S,h,I),size:m,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(j,S,h,m,I){let d=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const U=new ArrayBuffer(j*j*4*3),f=new Float32Array(U),r=d?Math.max(1,Math.round(m/4/j)):1,a=1/r,M=a*a,O=S[1].cc(S[0]).scale(a/j),p=S[3].cc(S[2]).scale(a/j),e=1/j;let w=0;for(let l=0;l<j;l++)for(let d=0;d<r;d++){let d=S[0],U=S[2];for(let S=0;S<j;S++)for(let a=0;a<r;a++){const r=U.cc(d).scale(w).add(d);r.normalize();const a=this.CalcProjectionSpherical(r,h,m,I);f[l*j*3+3*S+0]+=a.r*M,f[l*j*3+3*S+1]+=a.g*M,f[l*j*3+3*S+2]+=a.b*M,d=d.add(O),U=U.add(p)}w+=e*a}return f}static CalcProjectionSpherical(j,S,h,m){let I=Math.atan2(j.z,j.x);const d=Math.acos(j.y);for(;I<-Math.PI;)I+=2*Math.PI;for(;I>Math.PI;)I-=2*Math.PI;let U=I/Math.PI;const f=d/Math.PI;U=.5*U+.5;let r=Math.round(U*h);r<0?r=0:r>=h&&(r=h-1);let a=Math.round(f*m);a<0?a=0:a>=m&&(a=m-1);const M=m-a-1;return{r:S[M*h*3+3*r+0],g:S[M*h*3+3*r+1],b:S[M*h*3+3*r+2]}}}function d(j,S,h,m,I,d){I>0?(I=function(j,S){return S>1023?j*Math.pow(2,1023)*Math.pow(2,S-1023):S<-1074?j*Math.pow(2,-1074)*Math.pow(2,S+1074):j*Math.pow(2,S)}(1,I-136),j[d+0]=S*I,j[d+1]=h*I,j[d+2]=m*I):(j[d+0]=0,j[d+1]=0,j[d+2]=0)}function U(j,S){let h="",m="";for(let I=S;I<j.length-S&&(m=String.fromCharCode(j[I]),"\n"!=m);I++)h+=m;return h}function f(j){let S=0,h=0,m=U(j,0);if("#"!=m[0]||"?"!=m[1])throw"Bad HDR Format.";let I=!1,d=!1,f=0;do{f+=m.length+1,m=U(j,f),"FORMAT=32-bit_rle_rgbe"==m?d=!0:0==m.length&&(I=!0)}while(!I);if(!d)throw"HDR Bad header format, unsupported FORMAT";f+=m.length+1,m=U(j,f);const r=/^-Y (.*) \+X (.*)$/g.exec(m);if(!r||r.length<3)throw"HDR Bad header format, no size";if(h=parseInt(r[2]),S=parseInt(r[1]),h<8||h>32767)throw"HDR Bad header format, unsupported size";return f+=m.length+1,{height:S,width:h,dataPosition:f}}function r(j,S){return function(j,S){let h=S.height;const m=S.width;let I,U,f,r,M,O=S.dataPosition,p=0,e=0,w=0;const l=new ArrayBuffer(4*m),P=new Uint8Array(l),v=new ArrayBuffer(S.width*S.height*4*3),o=new Float32Array(v);for(;h>0;){if(I=j[O++],U=j[O++],f=j[O++],r=j[O++],2!=I||2!=U||128&f||S.width<8||S.width>32767)return a(j,S);if((f<<8|r)!=m)throw"HDR Bad header format, wrong scan line width";for(p=0,w=0;w<4;w++)for(e=(w+1)*m;p<e;)if(I=j[O++],U=j[O++],I>128){if(M=I-128,0==M||M>e-p)throw"HDR Bad Format, bad scanline data (run)";for(;M-- >0;)P[p++]=U}else{if(M=I,0==M||M>e-p)throw"HDR Bad Format, bad scanline data (non-run)";if(P[p++]=U,--M>0)for(let S=0;S<M;S++)P[p++]=j[O++]}for(w=0;w<m;w++)I=P[w],U=P[w+m],f=P[w+2*m],r=P[w+3*m],d(o,I,U,f,r,(S.height-h)*m*3+3*w);h--}return o}(j,S)}function a(j,S){let h=S.height;const m=S.width;let I,U,f,r,a,M=S.dataPosition;const O=new ArrayBuffer(S.width*S.height*4*3),p=new Float32Array(O);for(;h>0;){for(a=0;a<S.width;a++)I=j[M++],U=j[M++],f=j[M++],r=j[M++],d(p,I,U,f,r,(S.height-h)*m*3+3*a);h--}return p}I.FACE_LEFT=[new m.m(-1,-1,-1),new m.m(1,-1,-1),new m.m(-1,1,-1),new m.m(1,1,-1)],I.FACE_RIGHT=[new m.m(1,-1,1),new m.m(-1,-1,1),new m.m(1,1,1),new m.m(-1,1,1)],I.FACE_FRONT=[new m.m(1,-1,-1),new m.m(1,-1,1),new m.m(1,1,-1),new m.m(1,1,1)],I.FACE_BACK=[new m.m(-1,-1,1),new m.m(-1,-1,-1),new m.m(-1,1,1),new m.m(-1,1,-1)],I.FACE_DOWN=[new m.m(1,1,-1),new m.m(1,1,1),new m.m(-1,1,-1),new m.m(-1,1,1)],I.FACE_UP=[new m.m(-1,-1,-1),new m.m(-1,-1,1),new m.m(1,-1,-1),new m.m(1,-1,1)];class M{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(j,S,h){const m=new Uint8Array(j.buffer,j.byteOffset,j.byteLength),I=f(m),d=r(m,I),U=I.width*I.height,a=new Float32Array(4*U);for(let f=0;f<U;f+=1)a[4*f]=d[3*f],a[4*f+1]=d[3*f+1],a[4*f+2]=d[3*f+2],a[4*f+3]=1;h(I.width,I.height,S.generateMipMaps,!1,(()=>{const j=S.getEngine();S.type=1,S.format=5,S._gammaSpace=!1,j._uploadDataToTextureDirectly(S,a)}))}}}}]);