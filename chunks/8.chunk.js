"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{11034:(V,I,m)=>{m.r(I),m.d(I,{EXT_materials_diffuse_roughness:()=>RI,EXT_mesh_gpu_instancing:()=>wV,GLTF2Export:()=>MV,GLTFData:()=>E,KHR_draco_mesh_compression:()=>mI,KHR_lights_punctual:()=>jI,KHR_materials_anisotropy:()=>YI,KHR_materials_clearcoat:()=>OI,KHR_materials_diffuse_transmission:()=>tI,KHR_materials_dispersion:()=>bI,KHR_materials_emissive_strength:()=>nI,KHR_materials_ior:()=>SI,KHR_materials_iridescence:()=>HI,KHR_materials_sheen:()=>zI,KHR_materials_specular:()=>BI,KHR_materials_transmission:()=>QI,KHR_materials_unlit:()=>rI,KHR_materials_volume:()=>hI,KHR_texture_transform:()=>qI,OBJExport:()=>F,STLExport:()=>PI,USDZExportAsync:()=>Im,_ConvertToGLTFPBRMetallicRoughness:()=>G,_SolveMetallic:()=>Q,__IGLTFExporterExtension:()=>k});var C=m(11040),l=m(11076),s=m(11202);class F{static OBJ(V,I,m,F){const k=[];let j=1,E=1;I&&(m||(m="mat"),k.push("mtllib "+m+".mtl"));for(let K=0;K<V.length;K++){const m=V[K],Y=m.name||`mesh${K}}`;k.push(`o ${Y}`);let X=null;if(F){const V=m.fF(!0);X=new C.b,V.invertToRef(X),m.bakeTransformIntoVertices(V)}if(I){const V=m.material;V&&k.push("usemtl "+V.id)}const O=m.wF;if(!O){l.d.Warn("No geometry is present on the mesh");continue}const v=O.getVerticesData("position"),N=O.getVerticesData("XC"),t=O.getVerticesData("uv"),D=O.AF();let b=0,T=0;if(!v||!D){l.d.Warn("There are no position vertices or indices on the mesh!");continue}const n=V[0].cV().useRightHandedSystem?1:-1;for(let V=0;V<v.length;V+=3)k.push("v "+v[V]*n+" "+v[V+1]+" "+v[V+2]),b++;if(null!=N)for(let V=0;V<N.length;V+=3)k.push("vn "+N[V]*n+" "+N[V+1]+" "+N[V+2]);if(null!=t)for(let V=0;V<t.length;V+=2)k.push("vt "+t[V]+" "+t[V+1]),T++;const x=["","",""],S=(m.material||m.cV().defaultMaterial)._getEffectiveOrientation(m),[c,H]=S===s.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let V=0;V<D.length;V+=3){const I=[String(D[V]+j),String(D[V+c]+j),String(D[V+H]+j)],m=[String(D[V]+E),String(D[V+c]+E),String(D[V+H]+E)],C=I,l=null!=t?m:x,s=null!=N?I:x;k.push("f "+C[0]+"/"+l[0]+"/"+s[0]+" "+C[1]+"/"+l[1]+"/"+s[1]+" "+C[2]+"/"+l[2]+"/"+s[2])}F&&X&&m.bakeTransformIntoVertices(X),j+=b,E+=T}return k.join("\n")}static MTL(V){const I=[],m=V.material;I.push("newmtl mat1"),I.push("  Ns "+m.specularPower.toFixed(4)),I.push("  Ni 1.5000"),I.push("  d "+m.alpha.toFixed(4)),I.push("  Tr 0.0000"),I.push("  Tf 1.0000 1.0000 1.0000"),I.push("  illum 2"),I.push("  Ka "+m.ambientColor.r.toFixed(4)+" "+m.ambientColor.g.toFixed(4)+" "+m.ambientColor.b.toFixed(4)),I.push("  Kd "+m.diffuseColor.r.toFixed(4)+" "+m.diffuseColor.g.toFixed(4)+" "+m.diffuseColor.b.toFixed(4)),I.push("  Ks "+m.specularColor.r.toFixed(4)+" "+m.specularColor.g.toFixed(4)+" "+m.specularColor.b.toFixed(4)),I.push("  Ke "+m.emissiveColor.r.toFixed(4)+" "+m.emissiveColor.g.toFixed(4)+" "+m.emissiveColor.b.toFixed(4));m.ambientTexture&&I.push("  map_Ka "+m.ambientTexture.name),m.diffuseTexture&&I.push("  map_Kd "+m.diffuseTexture.name),m.specularTexture&&I.push("  map_Ks "+m.specularTexture.name),m.bumpTexture&&I.push("  map_bump -imfchan z "+m.bumpTexture.name),m.opacityTexture&&I.push("  map_d "+m.opacityTexture.name);return I.join("\n")}}var k=0,j=m(11102);class E{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const V in this.files){const I=this.files[V],m=new Blob([I],{type:(0,j.j)(V)});l.d.Download(m,V)}}}var K=m(11233),Y=m(11332),X=m(11342),O=m(11380),v=m(11428),N=m(11061),t=m(11312),D=m(11074);const b=D.HighestCommonFactor,T={...D,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:b};var n=m(11514),x=m(11518),S=m(11543),c=m(11551),H=m(11560);const y=1e-6,z=new t.c(.04,.04,.04),Z=1024,B=t.c.White(),W=t.c.Black();function Q(V,I,m){if(I<z.r)return 0;const C=z.r,l=V*m/(1-z.r)+I-2*z.r,s=l*l-4*C*(z.r-I);return T.Clamp((-l+Math.sqrt(s))/(2*C),0,1)}function G(V){const I=V.diffuseColor.toLinearSpace(V.cV().getEngine().useExactSrgbConversions).scale(.5),m=V.alpha,l=function(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new C.k(0,1),m=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new C.k(0,.1),l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new C.k(0,.1),s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new C.k(1300,.1);return function(V,I,m,C,l){return(1-V)*(1-V)*(1-V)*I+3*(1-V)*(1-V)*V*m+3*(1-V)*V*V*C+V*V*V*l}(Math.pow(V/s.x,.333333),I.y,m.y,l.y,s.y)}(T.Clamp(V.specularPower,0,Z));return{baseColorFactor:[I.r,I.g,I.b,m],metallicFactor:0,roughnessFactor:l}}function r(V,I){I.needAlphaBlending()?V.alphaMode="BLEND":I.needAlphaTesting()&&(V.alphaMode="MASK",V.alphaCutoff=I.alphaCutOff)}function g(V,I,m){const C=new Uint8Array(V*I*4);for(let l=0;l<C.length;l+=4)C[l]=C[l+1]=C[l+2]=C[l+3]=255;return S.d.CreateRGBATexture(C,V,I,m)}function h(V){if(V instanceof Uint8Array){const I=V.length,m=new Float32Array(V.length);for(let C=0;C<I;++C)m[C]=V[C]/255;return m}if(V instanceof Float32Array)return V;throw new Error("Unsupported pixel format!")}class d{constructor(V){this._exporter=V,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(V){return V?this._textureMap.get(V)??null:null}async exportStandardMaterialAsync(V,I,m){const C=G(V),s={name:V.name};if(null==V.JF||V.JF||(V.twoSidedLighting||l.d.Warn(V.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),s.doubleSided=!0),m){const m=[],l=V.diffuseTexture;l&&m.push(this.exportTextureAsync(l,I).then((V=>{V&&(C.baseColorTexture=V)})));const F=V.bumpTexture;F&&m.push(this.exportTextureAsync(F,I).then((V=>{V&&(s.normalTexture=V,1!==F.level&&(s.normalTexture.scale=F.level))})));const k=V.emissiveTexture;k&&(s.emissiveFactor=[1,1,1],m.push(this.exportTextureAsync(k,I).then((V=>{V&&(s.emissiveTexture=V)}))));const j=V.ambientTexture;j&&m.push(this.exportTextureAsync(j,I).then((V=>{if(V){const I={index:V.index};s.occlusionTexture=I}}))),m.length>0&&(this._exporter._materialNeedsUVsSet.add(V),await Promise.all(m))}(V.alpha<1||V.opacityTexture)&&(V.alphaMode===c.d.ALPHA_COMBINE?s.alphaMode="BLEND":l.d.Warn(V.name+": glTF 2.0 does not support alpha mode: "+V.alphaMode.toString())),V.emissiveColor&&!V.emissiveColor.equalsWithEpsilon(W,y)&&(s.emissiveFactor=V.emissiveColor.UF()),s.pbrMetallicRoughness=C,r(s,V),await this._finishMaterialAsync(s,V,I);const F=this._exporter._materials;return F.push(s),F.length-1}async _finishMaterialAsync(V,I,m){const C=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",V,I),l=[];for(const s of C)l.push(this.exportTextureAsync(s,m));await Promise.all(l),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",V,I)}async _getImageDataAsync(V,I,C,l){const s=c.d.TEXTURETYPE_UNSIGNED_BYTE,F=this._exporter._babylonScene,k=F.getEngine(),j=k.createRawTexture(V,I,C,c.d.TEXTUREFORMAT_RGBA,!1,!0,x.e.NEAREST_SAMPLINGMODE,null,s);k.isWebGPU?await m.e(36).then(m.bind(m,13699)):await m.e(37).then(m.bind(m,13706)),await n.j.ApplyPostProcess("pass",j,F,s,c.d.TEXTURE_NEAREST_SAMPLINGMODE,c.d.TEXTUREFORMAT_RGBA);const E=await k._readTexturePixels(j,I,C);return await H.DumpTools.DumpDataAsync(I,C,E,l,void 0,!0,!0)}_resizeTexturesToSameDimensions(V,I,m){const C=V?V.getSize():{width:0,height:0},l=I?I.getSize():{width:0,height:0};let s,F;return C.width<l.width?(s=V&&V instanceof x.e?n.j.CreateResizedCopy(V,l.width,l.height,!0):g(l.width,l.height,m),F=I):C.width>l.width?(F=I&&I instanceof x.e?n.j.CreateResizedCopy(I,C.width,C.height,!0):g(C.width,C.height,m),s=V):(s=V,F=I),{texture1:s,texture2:F}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(V,I,m,C){const l=new Array;if(!V&&!I)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const s=V?V.cV():I?I.cV():null;if(s){var F;const k=this._resizeTexturesToSameDimensions(V,I,s),j=null===(F=k.texture1)||void 0===F?void 0:F.getSize();let E,K;const Y=j.width,X=j.height,O=await k.texture1.readPixels(),v=await k.texture2.readPixels();if(!O)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(E=h(O),!v)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");K=h(v);const N=K.byteLength,D=new Uint8Array(N),b=new Uint8Array(N),T=4,n=W;let x=0,S=0;for(let V=0;V<X;++V)for(let I=0;I<Y;++I){const C=(Y*V+I)*T,l={diffuseColor:new t.c(E[C],E[C+1],E[C+2]).toLinearSpace(s.getEngine().useExactSrgbConversions).multiply(m.diffuseColor),specularColor:new t.c(K[C],K[C+1],K[C+2]).toLinearSpace(s.getEngine().useExactSrgbConversions).multiply(m.specularColor),glossiness:K[C+3]*m.glossiness},F=this._convertSpecularGlossinessToMetallicRoughness(l);n.r=Math.max(n.r,F.baseColor.r),n.g=Math.max(n.g,F.baseColor.g),n.b=Math.max(n.b,F.baseColor.b),x=Math.max(x,F.metallic),S=Math.max(S,F.roughness),b[C]=255*F.baseColor.r,b[C+1]=255*F.baseColor.g,b[C+2]=255*F.baseColor.b,b[C+3]=k.texture1.eF?255*E[C+3]:255,D[C]=0,D[C+1]=255*F.roughness,D[C+2]=255*F.metallic,D[C+3]=255}const c={baseColor:n,metallic:x,roughness:S};let H=!1,z=!1;for(let V=0;V<X;++V)for(let I=0;I<Y;++I){const m=(Y*V+I)*T;b[m]/=c.baseColor.r>y?c.baseColor.r:1,b[m+1]/=c.baseColor.g>y?c.baseColor.g:1,b[m+2]/=c.baseColor.b>y?c.baseColor.b:1;const C=t.c.FromInts(b[m],b[m+1],b[m+2]).toGammaSpace(s.getEngine().useExactSrgbConversions);b[m]=255*C.r,b[m+1]=255*C.g,b[m+2]=255*C.b,C.equalsWithEpsilon(B,y)||(z=!0),D[m+1]/=c.roughness>y?c.roughness:1,D[m+2]/=c.metallic>y?c.metallic:1;t.c.FromInts(255,D[m+1],D[m+2]).equalsWithEpsilon(B,y)||(H=!0)}return H&&l.push(this._getImageDataAsync(D,Y,X,C).then((V=>{c.metallicRoughnessTextureData=V}))),z&&l.push(this._getImageDataAsync(b,Y,X,C).then((V=>{c.baseColorTextureData=V}))),await Promise.all(l).then((()=>c))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(V){const I=this._getPerceivedBrightness(V.diffuseColor),m=this._getPerceivedBrightness(V.specularColor),C=1-this._getMaxComponent(V.specularColor),l=Q(I,m,C),s=V.diffuseColor.scale(C/(1-z.r)/Math.max(1-l)),F=V.specularColor.Fm(z.scale(1-l)).scale(1/Math.max(l));let k=t.c.Lerp(s,F,l*l);k=k.clampToRef(0,1,k);return{baseColor:k,metallic:l,roughness:1-V.glossiness}}_getPerceivedBrightness(V){return V?Math.sqrt(.299*V.r*V.r+.587*V.g*V.g+.114*V.b*V.b):0}_getMaxComponent(V){return V?Math.max(V.r,Math.max(V.g,V.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(V,I,m,C){const l=[],s={baseColor:V._albedoColor,metallic:V._metallic,roughness:V._roughness};if(C){V._albedoTexture&&l.push(this.exportTextureAsync(V._albedoTexture,I).then((V=>{V&&(m.baseColorTexture=V)})));const C=V._metallicTexture;C&&l.push(this.exportTextureAsync(C,I).then((V=>{V&&(m.metallicRoughnessTexture=V)})))}return l.length>0&&(this._exporter._materialNeedsUVsSet.add(V),await Promise.all(l)),s}_getTextureSampler(V){const I={};if(!V||!(V instanceof x.e))return I;const m=this._getGLTFTextureWrapMode(V.wrapU);10497!==m&&(I.wrapS=m);const C=this._getGLTFTextureWrapMode(V.wrapV);switch(10497!==C&&(I.wrapT=C),V.samplingMode){case x.e.LINEAR_LINEAR:I.magFilter=9729,I.minFilter=9729;break;case x.e.LINEAR_NEAREST:I.magFilter=9729,I.minFilter=9728;break;case x.e.NEAREST_LINEAR:I.magFilter=9728,I.minFilter=9729;break;case x.e.NEAREST_LINEAR_MIPLINEAR:I.magFilter=9728,I.minFilter=9987;break;case x.e.NEAREST_NEAREST:I.magFilter=9728,I.minFilter=9728;break;case x.e.NEAREST_LINEAR_MIPNEAREST:I.magFilter=9728,I.minFilter=9985;break;case x.e.LINEAR_NEAREST_MIPNEAREST:I.magFilter=9729,I.minFilter=9984;break;case x.e.LINEAR_NEAREST_MIPLINEAR:I.magFilter=9729,I.minFilter=9986;break;case x.e.NEAREST_NEAREST_MIPLINEAR:I.magFilter=9728,I.minFilter=9986;break;case x.e.LINEAR_LINEAR_MIPLINEAR:I.magFilter=9729,I.minFilter=9987;break;case x.e.LINEAR_LINEAR_MIPNEAREST:I.magFilter=9729,I.minFilter=9985;break;case x.e.NEAREST_NEAREST_MIPNEAREST:I.magFilter=9728,I.minFilter=9984}return I}_getGLTFTextureWrapMode(V){switch(V){case x.e.WRAP_ADDRESSMODE:return 10497;case x.e.CLAMP_ADDRESSMODE:return 33071;case x.e.MIRROR_ADDRESSMODE:return 33648;default:return l.d.Error(`Unsupported Texture Wrap Mode ${V}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(V,I,m,C){const l={diffuseColor:V._albedoColor,specularColor:V._reflectivityColor,glossiness:V._microSurface},s=V._albedoTexture,F=V._reflectivityTexture,k=V._useMicroSurfaceFromReflectivityMapAlpha;if(F&&!k)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((s||F)&&C){this._exporter._materialNeedsUVsSet.add(V);const C=this._exportTextureSampler(s||F),k=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(s,F,l,I),j=this._exporter._textures;if(k.baseColorTextureData){const V=this._exportImage(`baseColor${j.length}`,I,k.baseColorTextureData);m.baseColorTexture=this._exportTextureInfo(V,C,null===s||void 0===s?void 0:s.coordinatesIndex)}if(k.metallicRoughnessTextureData){const V=this._exportImage(`metallicRoughness${j.length}`,I,k.metallicRoughnessTextureData);m.metallicRoughnessTexture=this._exportTextureInfo(V,C,null===F||void 0===F?void 0:F.coordinatesIndex)}return k}return this._convertSpecularGlossinessToMetallicRoughness(l)}async exportPBRMaterialAsync(V,I,m){const C={},l={name:V.name},s=V.isMetallicWorkflow();if(s){const I=V._albedoColor,m=V.alpha;I&&(C.baseColorFactor=[I.r,I.g,I.b,m])}const F=s?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(V,I,C,m):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(V,I,C,m);await this._setMetallicRoughnessPbrMaterialAsync(F,V,l,C,I,m),await this._finishMaterialAsync(l,V,I);const k=this._exporter._materials;return k.push(l),k.length-1}async _setMetallicRoughnessPbrMaterialAsync(V,I,m,C,s,F){if(r(m,I),V.baseColor.equalsWithEpsilon(B,y)&&T.WithinEpsilon(I.alpha,1,y)||(C.baseColorFactor=[V.baseColor.r,V.baseColor.g,V.baseColor.b,I.alpha]),null!=V.metallic&&1!==V.metallic&&(C.metallicFactor=V.metallic),null!=V.roughness&&1!==V.roughness&&(C.roughnessFactor=V.roughness),null==I.JF||I.JF||(I._twoSidedLighting||l.d.Warn(I.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),m.doubleSided=!0),F){const V=[],C=I._bumpTexture;C&&V.push(this.exportTextureAsync(C,s).then((V=>{V&&(m.normalTexture=V,1!==C.level&&(m.normalTexture.scale=C.level))})));const l=I._ambientTexture;l&&V.push(this.exportTextureAsync(l,s).then((V=>{if(V){const C={index:V.index,texCoord:V.texCoord,extensions:V.extensions};m.occlusionTexture=C;const l=I._ambientTextureStrength;l&&(C.strength=l)}})));const F=I._emissiveTexture;F&&V.push(this.exportTextureAsync(F,s).then((V=>{V&&(m.emissiveTexture=V)}))),V.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(V))}const k=I._emissiveColor;k.equalsWithEpsilon(W,y)||(m.emissiveFactor=k.UF()),m.pbrMetallicRoughness=C}_getPixelsFromTextureAsync(V){return function(V){switch(V){case c.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case c.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case c.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case c.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case c.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case c.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case c.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case c.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case c.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case c.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case c.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case c.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case c.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case c.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case c.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case c.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case c.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case c.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case c.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case c.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case c.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(V.textureFormat)?(0,n.f)(V,V._texture.width,V._texture.height):(V.textureType,c.d.TEXTURETYPE_UNSIGNED_BYTE,V.readPixels())}async exportTextureAsync(V,I){const m=this._exporter._extensionsPreExportTextureAsync("exporter",V,I);return m?await m.then((async m=>m?await this._exportTextureInfoAsync(m,I):await this._exportTextureInfoAsync(V,I))):await this._exportTextureInfoAsync(V,I)}async _exportTextureInfoAsync(V,I){let m=this._textureMap.get(V);if(!m){const C=await this._getPixelsFromTextureAsync(V);if(!C)return null;const s=this._exportTextureSampler(V),F=V.mimeType;if(F)switch(F){case"image/jpeg":case"image/png":case"image/webp":I=F;break;default:l.d.Warn(`Unsupported media type: ${F}. Exporting texture as PNG.`)}const k=this._internalTextureToImage,j=V.getInternalTexture().uniqueId;k[j]||(k[j]={});let E=k[j][I];if(void 0===E){const m=V.getSize();E=(async()=>{const l=await this._getImageDataAsync(C,m.width,m.height,I);return this._exportImage(V.name,I,l)})(),k[j][I]=E}m=this._exportTextureInfo(await E,s,V.coordinatesIndex),this._textureMap.set(V,m),this._exporter._extensionsPostExportTextures("exporter",m,V)}return m}_exportImage(V,I,m){const C=this._exporter._images;let s;if(this._exporter._shouldUseGlb){s={name:V,mimeType:I,bufferView:void 0};const C=this._exporter._bufferManager.createBufferView(new Uint8Array(m));this._exporter._bufferManager.setBufferView(s,C)}else{const F=V.replace(/\.\/|\/|\.\\|\\/g,"_"),k=function(V){switch(V){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(I);let j=F+k;C.some((V=>V.uri===j))&&(j=`${F}_${l.d.RandomId()}${k}`),s={name:V,uri:j},this._exporter._imageData[j]={data:m,mimeType:I}}return C.push(s),C.length-1}_exportTextureInfo(V,I,m){const C=this._exporter._textures;let l=C.findIndex((m=>m.sampler==I&&m.source===V));-1===l&&(l=C.length,C.push({source:V,sampler:I}));const s={index:l};return m&&(s.texCoord=m),s}_exportTextureSampler(V){const I=this._getTextureSampler(V),m=this._exporter._samplers,C=m.findIndex((V=>V.minFilter===I.minFilter&&V.magFilter===I.magFilter&&V.wrapS===I.wrapS&&V.wrapT===I.wrapT));return-1!==C?C:(m.push(I),m.length-1)}}var R=m(11240),i=m(11085),q=m(11564),P=m(11044);const u=C.m.Zero(),o=C.e.Identity(),p=C.m.One(),M=new C.m(-1,1,1);function f(V,I){const{byteOffset:m,byteStride:C,type:l,normalized:s}=V,F=V.getSize(),k=I.reduce(((V,I)=>I.getTotalVertices()>V?I.getTotalVertices():V),-Number.MAX_VALUE);return{byteOffset:m,byteStride:C,componentCount:F,type:l,count:k*F,normalized:s,totalVertices:k,kind:V.getKind()}}function w(V){switch(V){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function A(V){switch(V){case K.e.PositionKind:case K.e.NormalKind:case K.e.TangentKind:case K.e.ColorKind:case K.e.MatricesIndicesKind:case K.e.MatricesIndicesExtraKind:case K.e.MatricesWeightsKind:case K.e.MatricesWeightsExtraKind:case K.e.UVKind:case K.e.UV2Kind:case K.e.UV3Kind:case K.e.UV4Kind:case K.e.UV5Kind:case K.e.UV6Kind:return!0}return!1}function J(V){switch(V){case s.d.TriangleFillMode:return 4;case s.d.TriangleStripDrawMode:return 5;case s.d.TriangleFanDrawMode:return 6;case s.d.PointListDrawMode:case s.d.PointFillMode:return 0;case s.d.LineLoopDrawMode:return 2;case s.d.LineListDrawMode:return 1;case s.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${V}`)}function U(V){const I=Math.sqrt(V.x*V.x+V.y*V.y+V.z*V.z);I>0&&(V.x/=I,V.y/=I,V.z/=I)}function e(V){return V.x*=-1,V}function a(V){if(V.x*V.x+V.y*V.y>.5){const I=Math.abs(V.x),m=Math.abs(V.y);if(I>m){const m=Math.sign(V.x);V.x=I,V.y*=-m,V.z*=-m,V.w*=m}else{const I=Math.sign(V.y);V.x*=-I,V.y=m,V.z*=I,V.w*=-I}}else{const I=Math.abs(V.z),m=Math.abs(V.w);if(I>m){const m=Math.sign(V.z);V.x*=-m,V.y*=m,V.z=I,V.w*=-m}else{const I=Math.sign(V.w);V.x*=I,V.y*=-I,V.z*=-I,V.w=m}}return V}function L(V){V.aF(-V.z,V.w,V.x,-V.y)}function VV(V,I){const m=C.m.FromArrayToRef(I.translation||[0,0,0],0,C.g.LF[0]),l=C.e.FromArrayToRef(I.rotation||[0,0,0,1],0,C.g.Quaternion[0]),s=C.b.ComposeToRef(p,l,m,C.g.Matrix[0]),F=C.m.FromArrayToRef(V.translation||[0,0,0],0,C.g.LF[2]),k=C.e.FromArrayToRef(V.rotation||[0,0,0,1],0,C.g.Quaternion[1]),j=C.b.ComposeToRef(p,k,F,C.g.Matrix[1]);s.multiplyToRef(j,j),j.decompose(void 0,l,m),m.equalsWithEpsilon(u,P.c)?delete I.translation:I.translation=m.UF(),l.equalsWithEpsilon(o,P.c)?delete I.rotation:I.rotation=l.UF(),I.scale&&delete I.scale}function IV(V,I){if(!(I instanceof Y.c))return!1;if(!(1===I.getChildren().length&&0===V.getChildren().length&&V.parent===I))return!1;const m=V.cV(),C=V instanceof q.e&&!m.useRightHandedSystem?M:p;return!!I.Vk.equalsWithEpsilon(C,P.c)||(i.d.Warn(`Cannot collapse node ${V.name} into parent node ${I.name} with modified scaling.`),!1)}function mV(V){if(V instanceof Array){const I=new Float32Array(V);return new Uint8Array(I.buffer,I.byteOffset,I.byteLength)}return ArrayBuffer.isView(V)?new Uint8Array(V.buffer,V.byteOffset,V.byteLength):new Uint8Array(V)}function CV(V,I){for(const[m,C]of Object.entries(V)){const l=I[m];(Array.isArray(C)&&Array.isArray(l)&&lV(C,l)||C===l)&&delete V[m]}return V}function lV(V,I){return V.length===I.length&&V.every(((V,m)=>V===I[m]))}const sV=C.b.Compose(new C.m(-1,1,1),C.e.Identity(),C.m.Zero());function FV(V,I){if(!(V instanceof Y.c))return!1;if(I){if(!V.getWorldMatrix().equalsWithEpsilon(C.b.IdentityReadOnly,P.c))return!1}else{if(!V.getWorldMatrix().multiplyToRef(sV,C.g.Matrix[0]).equalsWithEpsilon(C.b.IdentityReadOnly,P.c))return!1}return!(V instanceof X.e&&V.wF)}const kV=new Map([[Int8Array,(V,I,m)=>V.setInt8(I,m)],[Uint8Array,(V,I,m)=>V.setUint8(I,m)],[Uint8ClampedArray,(V,I,m)=>V.setUint8(I,m)],[Int16Array,(V,I,m)=>V.setInt16(I,m,!0)],[Uint16Array,(V,I,m)=>V.setUint16(I,m,!0)],[Int32Array,(V,I,m)=>V.setInt32(I,m,!0)],[Uint32Array,(V,I,m)=>V.setUint32(I,m,!0)],[Float32Array,(V,I,m)=>V.setFloat32(I,m,!0)],[Float64Array,(V,I,m)=>V.setFloat64(I,m,!0)]]);class jV{writeTypedArray(V){this._checkGrowBuffer(V.byteLength);const I=kV.get(V.constructor);for(let m=0;m<V.length;m++)I(this._dataView,this._byteOffset,V[m]),this._byteOffset+=V.BYTES_PER_ELEMENT}constructor(V){this._data=new Uint8Array(V),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(V){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,V),this._byteOffset++}writeInt8(V){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,V),this._byteOffset++}writeInt16(V){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,V,!0),this._byteOffset+=2}writeUInt16(V){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,V,!0),this._byteOffset+=2}writeInt32(V){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,V,!0),this._byteOffset+=4}writeUInt32(V){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,V,!0),this._byteOffset+=4}writeFloat32(V){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,V,!0),this._byteOffset+=4}writeFloat64(V){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,V,!0),this._byteOffset+=8}_checkGrowBuffer(V){const I=this.byteOffset+V;if(I>this._data.byteLength){const V=new Uint8Array(2*I);V.set(this._data),this._data=V,this._dataView=new DataView(this._data.buffer)}}}function EV(V){return V%4===0?4:V%2===0?2:1}class KV{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(V){let I=0;this._bufferViewToData.forEach((V=>{I+=V.byteLength}));const m=new jV(I),C=Array.from(this._bufferViewToData.keys()).sort(((V,I)=>EV(I.byteLength)-EV(V.byteLength)));for(const l of C){l.byteOffset=m.byteOffset,V.push(l);const I=V.length-1,C=this.getPropertiesWithBufferView(l);for(const V of C)V.bufferView=I;m.writeTypedArray(this._bufferViewToData.get(l)),this._bufferViewToData.delete(l)}return m.getOutputData()}createBufferView(V,I){const m={buffer:0,byteOffset:void 0,byteLength:V.byteLength,byteStride:I};return this._bufferViewToData.set(m,V),m}createAccessor(V,I,m,C,l,s,F){this._verifyBufferView(V);const k={bufferView:void 0,componentType:m,count:C,type:I,min:null===s||void 0===s?void 0:s.min,max:null===s||void 0===s?void 0:s.max,normalized:F,byteOffset:l};return this.setBufferView(k,V),this._accessorToBufferView.set(k,V),k}setBufferView(V,I){this._verifyBufferView(I);this.getPropertiesWithBufferView(I).push(V)}removeBufferView(V){const I=this.getPropertiesWithBufferView(V);for(const m of I)void 0!==m.bufferView&&delete m.bufferView;this._bufferViewToData.delete(V),this._bufferViewToProperties.delete(V),this._accessorToBufferView.forEach(((I,m)=>{I===V&&(void 0!==m.byteOffset&&delete m.byteOffset,this._accessorToBufferView.delete(m))}))}getBufferView(V){const I=this._accessorToBufferView.get(V);return this._verifyBufferView(I),I}getPropertiesWithBufferView(V){return this._verifyBufferView(V),this._bufferViewToProperties.set(V,this._bufferViewToProperties.get(V)??[]),this._bufferViewToProperties.get(V)}getData(V){return this._verifyBufferView(V),this._bufferViewToData.get(V)}_verifyBufferView(V){if(void 0===V||!this._bufferViewToData.has(V))throw new Error(`BufferView ${V} not found in BufferManager.`)}}var YV,XV=m(11386),OV=m(11419),vV=m(11570),NV=m(11691),tV=m(11700),DV=m(11705),bV=m(11384),TV=m(11708);!function(V){V[V.INTANGENT=0]="INTANGENT",V[V.OUTTANGENT=1]="OUTTANGENT"}(YV||(YV={}));class nV{static _IsTransformable(V){return V&&(V instanceof Y.c||V instanceof XV.c||V instanceof TV.d)}static _CreateNodeAnimation(V,I,m,C,s){if(this._IsTransformable(V)){const F=[],k=[],j=I.getKeys(),E=nV._CalculateMinMaxKeyFrames(j),K=nV._DeduceInterpolation(j,m,C),Y=K.interpolationType,X=K.shouldBakeAnimation;if(X?nV._CreateBakedAnimation(V,I,m,E.min,E.max,I.framePerSecond,s,F,k,E,C):"LINEAR"===Y||"STEP"===Y?nV._CreateLinearOrStepAnimation(V,I,m,F,k,C):"CUBICSPLINE"===Y?nV._CreateCubicSplineAnimation(V,I,m,F,k,C):nV._CreateBakedAnimation(V,I,m,E.min,E.max,I.framePerSecond,s,F,k,E,C),F.length&&k.length){return{inputs:F,outputs:k,samplerInterpolation:Y,inputsMin:X?E.min:l.d.FloatRound(E.min/I.framePerSecond),inputsMax:X?E.max:l.d.FloatRound(E.max/I.framePerSecond)}}}return null}static _DeduceAnimationInfo(V){let I=null,m="VEC3",C=!1;const s=V.targetProperty.split(".");switch(s[0]){case"Vk":I="scale";break;case"position":I="translation";break;case"rotation":m="VEC4",I="rotation";break;case"rotationQuaternion":m="VEC4",C=!0,I="rotation";break;case"influence":m="SCALAR",I="weights";break;default:l.d.Error(`Unsupported animatable property ${s[0]}`)}return I?{animationChannelTargetPath:I,dataAccessorType:m,useQuaternion:C}:(l.d.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(V,I,m,C,l,s,F,k,j,E,K){let Y;if(nV._IsTransformable(V)&&V.animations)for(const X of V.animations){if(K&&!K(X))continue;const l=nV._DeduceAnimationInfo(X);l&&(Y={name:X.name,samplers:[],channels:[]},nV._AddAnimation(`${X.name}`,X.hasRunningRuntimeAnimations?I:Y,V,X,l.dataAccessorType,l.animationChannelTargetPath,C,s,F,k,l.useQuaternion,j,E),Y.samplers.length&&Y.channels.length&&m.push(Y))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(V,I,m,C,l,s,F,k,j,E,K){let Y;if(V instanceof bV.c){const l=V.morphTargetManager;if(l)for(let X=0;X<l.numTargets;++X){const O=l.getTarget(X);for(const v of O.animations){if(K&&!K(v))continue;const O=new tV.c(`${v.name}`,"influence",v.framePerSecond,v.dataType,v.loopMode,v.enableBlending),N=[],t=v.getKeys();for(let V=0;V<t.length;++V){const I=t[V];for(let V=0;V<l.numTargets;++V)V==X?N.push(I):N.push({frame:I.frame,value:0})}O.setKeys(N);const D=nV._DeduceAnimationInfo(O);D&&(Y={name:O.name,samplers:[],channels:[]},nV._AddAnimation(v.name,v.hasRunningRuntimeAnimations?I:Y,V,O,D.dataAccessorType,D.animationChannelTargetPath,C,s,F,k,D.useQuaternion,j,E,l.numTargets),Y.samplers.length&&Y.channels.length&&m.push(Y))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(V,I,m,C,l,s,F,k,j){let E;if(V.animationGroups){const Y=V.animationGroups;for(const X of Y){const Y=new Map,O=new Map,v=new Set,N=X.to-X.from;E={name:X.name,channels:[],samplers:[]};for(let I=0;I<X.targetedAnimations.length;++I){const N=X.targetedAnimations[I],t=N.target,D=N.animation;if(j&&!j(D))continue;const b=k.has(t);if(this._IsTransformable(t)||1===t.length&&this._IsTransformable(t[0])){const V=nV._DeduceAnimationInfo(N.animation);if(V){const I=this._IsTransformable(t)?t:this._IsTransformable(t[0])?t[0]:null;I&&nV._AddAnimation(`${D.name}`,E,I,D,V.dataAccessorType,V.animationChannelTargetPath,m,C,l,s,V.useQuaternion,F,b)}}else if(t instanceof DV.e||1===t.length&&t[0]instanceof DV.e){if(nV._DeduceAnimationInfo(N.animation)){const I=t instanceof DV.e?t:t[0];if(I){const m=V.morphTargetManagers.find((V=>{for(let m=0;m<V.numTargets;++m)if(V.getTarget(m)===I)return!0;return!1}));if(m){const C=V.meshes.find((V=>V.morphTargetManager===m));var K;if(C)Y.has(C)||Y.set(C,new Map),null===(K=Y.get(C))||void 0===K||K.set(I,D),v.add(C),O.set(C,D)}}}}}v.forEach((V=>{const I=V.morphTargetManager;let k=null;const j=[],K=O.get(V).getKeys(),v=K.length;for(let m=0;m<v;++m)for(let C=0;C<I.numTargets;++C){const l=I.getTarget(C),s=Y.get(V);if(s){const I=s.get(l);I?(k||(k=new tV.c(`${X.name}_${V.name}_MorphWeightAnimation`,"influence",I.framePerSecond,tV.c.ANIMATIONTYPE_FLOAT,I.loopMode,I.enableBlending)),j.push(I.getKeys()[m])):j.push({frame:X.from+N/v*m,value:l.influence,inTangent:K[0].inTangent?0:void 0,outTangent:K[0].outTangent?0:void 0})}}k.setKeys(j);const t=nV._DeduceAnimationInfo(k);t&&nV._AddAnimation(`${X.name}_${V.name}_MorphWeightAnimation`,E,V,k,t.dataAccessorType,t.animationChannelTargetPath,m,C,l,s,t.useQuaternion,F,!1,null===I||void 0===I?void 0:I.numTargets)})),E.channels.length&&E.samplers.length&&I.push(E)}}}static _AddAnimation(V,I,m,l,s,F,k,j,E,K,Y,X,O,v){const N=nV._CreateNodeAnimation(m,l,F,Y,X);let t,D,b,T,n,x;if(N){if(v){let V=0,I=0;const m=[];for(;N.inputs.length>0;)I=N.inputs.shift(),V%v==0&&m.push(I),V++;N.inputs=m}const V=k.get(m),l=new Float32Array(N.inputs);t=j.createBufferView(l),D=j.createAccessor(t,"SCALAR",5126,N.inputs.length,void 0,{min:[N.inputsMin],max:[N.inputsMax]}),K.push(D),b=K.length-1;const E=new C.e,Y=new C.m,X=new C.m,S=m instanceof XV.c,c=w(s),H=new Float32Array(N.outputs.length*c);N.outputs.forEach((function(V,I){let m=V;switch(F){case"translation":O&&(C.m.FromArrayToRef(V,0,X),e(X),X.toArray(m));break;case"rotation":4===V.length?C.e.FromArrayToRef(V,0,E):(m=new Array(4),C.m.FromArrayToRef(V,0,Y),C.e.FromEulerVectorToRef(Y,E)),O&&(a(E),S&&L(E)),E.toArray(m)}H.set(m,I*c)})),t=j.createBufferView(H),D=j.createAccessor(t,s,5126,N.outputs.length),K.push(D),T=K.length-1,n={interpolation:N.samplerInterpolation,input:b,output:T},I.samplers.push(n),x={sampler:I.samplers.length-1,target:{node:V,path:F}},I.channels.push(x)}}static _CreateBakedAnimation(V,I,m,s,F,k,j,E,K,Y,X){let O;const v=C.e.Identity();let N,t=null,D=null,b=null,T=null,n=null,x=null;Y.min=l.d.FloatRound(s/k);const S=I.getKeys();for(let C=0,c=S.length;C<c;++C){if(x=null,b=S[C],C+1<c)if(T=S[C+1],b.value.equals&&b.value.equals(T.value)||b.value===T.value){if(0!==C)continue;x=b.frame}else x=T.frame;else{if(n=S[C-1],b.value.equals&&b.value.equals(n.value)||b.value===n.value)continue;x=F}if(x)for(let C=b.frame;C<=x;C+=j){if(N=l.d.FloatRound(C/k),N===t)continue;t=N,D=N;const s={key:0,repeatCount:0,loopMode:I.loopMode};O=I._interpolate(C,s),nV._SetInterpolatedValue(V,O,N,I,m,v,E,K,X)}}D&&(Y.max=D)}static _ConvertFactorToVector3OrQuaternion(V,I,m,s,F){const k=nV._GetBasePositionRotationOrScale(I,s,F),j=m.targetProperty.split("."),E=j?j[1]:"",K=F?C.e.Ik(k).normalize():C.m.Ik(k);switch(E){case"x":case"y":case"z":K[E]=V;break;case"w":K.w=V;break;default:l.d.Error(`glTFAnimation: Unsupported component name "${E}"!`)}return K}static _SetInterpolatedValue(V,I,m,l,s,F,k,j,E){let K;k.push(m),"weights"!==s?(l.dataType===tV.c.ANIMATIONTYPE_FLOAT&&(I=this._ConvertFactorToVector3OrQuaternion(I,V,l,s,E)),"rotation"===s?(E?F=I:(K=I,C.e.RotationYawPitchRollToRef(K.y,K.x,K.z,F)),j.push(F.UF())):(K=I,j.push(K.UF()))):j.push([I])}static _CreateLinearOrStepAnimation(V,I,m,C,l,s){for(const F of I.getKeys())C.push(F.frame/I.framePerSecond),nV._AddKeyframeValue(F,I,l,m,V,s)}static _CreateCubicSplineAnimation(V,I,m,C,l,s){I.getKeys().forEach((function(F){C.push(F.frame/I.framePerSecond),nV._AddSplineTangent(YV.INTANGENT,l,m,"CUBICSPLINE",F,s),nV._AddKeyframeValue(F,I,l,m,V,s),nV._AddSplineTangent(YV.OUTTANGENT,l,m,"CUBICSPLINE",F,s)}))}static _GetBasePositionRotationOrScale(V,I,m){let l;if("rotation"===I)if(m){l=(V.rotationQuaternion??C.e.Identity()).UF()}else{l=(V.rotation??C.m.Zero()).UF()}else if("translation"===I){l=(V.position??C.m.Zero()).UF()}else{l=(V.Vk??C.m.One()).UF()}return l}static _AddKeyframeValue(V,I,m,s,F,k){let j;const E=I.dataType;if(E===tV.c.ANIMATIONTYPE_VECTOR3){let I=V.value.UF();if("rotation"===s){const V=C.m.Ik(I);I=C.e.RotationYawPitchRoll(V.y,V.x,V.z).UF()}m.push(I)}else if(E===tV.c.ANIMATIONTYPE_FLOAT){if("weights"===s)m.push([V.value]);else if(j=this._ConvertFactorToVector3OrQuaternion(V.value,F,I,s,k),j){if("rotation"===s){const V=k?j:C.e.RotationYawPitchRoll(j.y,j.x,j.z).normalize();m.push(V.UF())}m.push(j.UF())}}else E===tV.c.ANIMATIONTYPE_QUATERNION?m.push(V.value.normalize().UF()):l.d.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(V,I,m){let C,l,s=!1;if("rotation"===I&&!m)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let F=0,k=V.length;F<k;++F)if(l=V[F],l.inTangent||l.outTangent)if(C){if("CUBICSPLINE"!==C){C="LINEAR",s=!0;break}}else C="CUBICSPLINE";else if(C){if("CUBICSPLINE"===C||l.interpolation&&1===l.interpolation&&"STEP"!==C){C="LINEAR",s=!0;break}}else C=l.interpolation&&1===l.interpolation?"STEP":"LINEAR";return C||(C="LINEAR"),{interpolationType:C,shouldBakeAnimation:s}}static _AddSplineTangent(V,I,m,l,s,F){let k;const j=V===YV.INTANGENT?s.inTangent:s.outTangent;if("CUBICSPLINE"===l){if("rotation"===m)if(j)if(F)k=j.UF();else{const V=j;k=C.e.RotationYawPitchRoll(V.y,V.x,V.z).UF()}else k=[0,0,0,0];else k="weights"===m?j?[j]:[0]:j?j.UF():[0,0,0];I.push(k)}}static _CalculateMinMaxKeyFrames(V){let I=1/0,m=-1/0;return V.forEach((function(V){I=Math.min(I,V.frame),m=Math.max(m,V.frame)})),{min:I,max:m}}}function xV(V,I,m,s,F,k){const j={attributes:{},influence:V.influence,name:V.name},E=I.wF;if(!E)return l.d.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),j;const Y=k?-1:1,X=C.m.Zero();let O=0,v=0;if(V.hasPositions){const s=V.getPositions(),k=E.getVerticesData(K.e.PositionKind);if(k){const V=new Float32Array(k.length),I=[1/0,1/0,1/0],l=[-1/0,-1/0,-1/0];v=k.length/3,O=0;for(let m=O;m<v;++m){const F=C.m.Ik(k,3*m);C.m.Ik(s,3*m).subtractToRef(F,X),X.x*=Y,I[0]=Math.min(I[0],X.x),l[0]=Math.max(l[0],X.x),I[1]=Math.min(I[1],X.y),l[1]=Math.max(l[1],X.y),I[2]=Math.min(I[2],X.z),l[2]=Math.max(l[2],X.z),V[3*m]=X.x,V[3*m+1]=X.y,V[3*m+2]=X.z}const E=m.createBufferView(V,12),K=m.createAccessor(E,"VEC3",5126,s.length/3,0,{min:I,max:l});F.push(K),j.attributes.POSITION=F.length-1}else l.d.Warn(`Morph target positions for mesh ${I.name} were not exported. Mesh does not have position vertex data`)}if(V.hasNormals){const s=V.getNormals(),k=E.getVerticesData(K.e.NormalKind);if(k){const V=new Float32Array(k.length);v=k.length/3,O=0;for(let m=O;m<v;++m){const I=C.m.Ik(k,3*m).normalize();C.m.Ik(s,3*m).normalize().subtractToRef(I,X),V[3*m]=X.x*Y,V[3*m+1]=X.y,V[3*m+2]=X.z}const I=m.createBufferView(V,12),l=m.createAccessor(I,"VEC3",5126,s.length/3,0);F.push(l),j.attributes.NORMAL=F.length-1}else l.d.Warn(`Morph target normals for mesh ${I.name} were not exported. Mesh does not have normals vertex data`)}if(V.hasTangents){const s=V.getTangents(),k=E.getVerticesData(K.e.TangentKind);if(k){v=k.length/4;const V=new Float32Array(3*v);O=0;for(let m=O;m<v;++m){const I=C.m.Ik(k,4*m);U(I);const l=C.m.Ik(s,3*m);U(l),l.subtractToRef(I,X),V[3*m]=X.x*Y,V[3*m+1]=X.y,V[3*m+2]=X.z}const I=m.createBufferView(V,12),l=m.createAccessor(I,"VEC3",5126,v,0);F.push(l),j.attributes.TANGENT=F.length-1}else l.d.Warn(`Morph target tangents for mesh ${I.name} were not exported. Mesh does not have tangents vertex data`)}if(V.hasColors){const s=V.getColors(),k=E.getVerticesData(K.e.ColorKind),Y=E.getVertexBuffer(K.e.ColorKind);if(k&&Y){const V=Y.getSize();v=k.length/V;const I=new Float32Array(v*V);O=0;for(let m=O;m<v;++m)if(3===V){const l=C.m.Ik(k,m*V);C.m.Ik(s,m*V).subtractToRef(l,X),I[3*m]=X.x,I[3*m+1]=X.y,I[3*m+2]=X.z}else if(4===V){const l=new C.n,F=C.n.Ik(k,m*V);C.n.Ik(s,m*V).subtractToRef(F,l),I[4*m]=l.x,I[4*m+1]=l.y,I[4*m+2]=l.z,I[4*m+3]=l.w}else l.d.Warn(`Unsupported number of components for color attribute: ${V}`);const E=m.createBufferView(I,4*V),K=m.createAccessor(E,3===V?"VEC3":"VEC4",5126,v,0);F.push(K),j.attributes.COLOR_0=F.length-1}else l.d.Warn(`Morph target colors for mesh ${I.name} were not exported. Mesh does not have colors vertex data`)}return j}var SV=m(11715),cV=m(11649),HV=m(11642),yV=m(11048);class zV{}zV.DEFAULT_COLOR=t.c.White(),zV.DEFAULT_WIDTH_ATTENUATED=1,zV.DEFAULT_WIDTH=.1;var ZV=m(11498),BV=m(11731);class WV{static ConvertPoints(V,I){if(V.length&&Array.isArray(V)&&"number"===typeof V[0])return[V];if(V.length&&Array.isArray(V[0])&&"number"===typeof V[0][0])return V;if(V.length&&!Array.isArray(V[0])&&V[0]instanceof C.m){const I=[];for(let m=0;m<V.length;m++){const C=V[m];I.push(C.x,C.y,C.z)}return[I]}if(V.length>0&&Array.isArray(V[0])&&V[0].length>0&&V[0][0]instanceof C.m){const I=[],m=V;for(const V of m)I.push(V.flatMap((V=>[V.x,V.y,V.z])));return I}if(V instanceof Float32Array){if(null!==I&&void 0!==I&&I.floatArrayStride){const m=[],C=3*I.floatArrayStride;for(let I=0;I<V.length;I+=C){const l=new Array(C);for(let m=0;m<C;m++)l[m]=V[I+m];m.push(l)}return m}return[Array.from(V)]}if(V.length&&V[0]instanceof Float32Array){const I=[];for(const m of V)I.push(Array.from(m));return I}return[]}static OmitZeroLengthPredicate(V,I,m){const C=[];return I.Fm(V).lengthSquared()>0&&C.push([V,I]),m.Fm(I).lengthSquared()>0&&C.push([I,m]),V.Fm(m).lengthSquared()>0&&C.push([m,V]),0===C.length?null:C}static OmitDuplicatesPredicate(V,I,m,C){const l=[];return WV._SearchInPoints(V,I,C)||l.push([V,I]),WV._SearchInPoints(I,m,C)||l.push([I,m]),WV._SearchInPoints(m,V,C)||l.push([m,V]),0===l.length?null:l}static _SearchInPoints(V,I,m){for(const F of m)for(let m=0;m<F.length;m++){var C,l,s;if(null!==(C=F[m])&&void 0!==C&&C.equals(V))if(null!==(l=F[m+1])&&void 0!==l&&l.equals(I)||null!==(s=F[m-1])&&void 0!==s&&s.equals(I))return!0}return!1}static MeshesToLines(V,I){const m=[];for(let l=0;l<V.length;l++){const s=V[l],F=s.getVerticesData(K.e.PositionKind),k=s.AF();if(F&&k)for(let V=0,j=0;V<k.length;V++){const E=3*k[j++],K=3*k[j++],Y=3*k[j++],X=new C.m(F[E],F[E+1],F[E+2]),O=new C.m(F[K],F[K+1],F[K+2]),v=new C.m(F[Y],F[Y+1],F[Y+2]);if(I){const C=I(X,O,v,m,V,E,s,l,F,k);if(C)for(const V of C)m.push(V)}else m.push([X,O],[O,v],[v,X])}}return m}static ToVector3Array(V){if(Array.isArray(V[0])){const I=[],m=V;for(const V of m){const m=[];for(let I=0;I<V.length;I+=3)m.push(new C.m(V[I],V[I+1],V[I+2]));I.push(m)}return I}const I=V,m=[];for(let l=0;l<I.length;l+=3)m.push(new C.m(I[l],I[l+1],I[l+2]));return m}static ToNumberArray(V){return V.flatMap((V=>[V.x,V.y,V.z]))}static GetPointsCountInfo(V){const I=new Array(V.length);let m=0;for(let C=V.length;C--;)I[C]=V[C].length/3,m+=I[C];return{total:m,counts:I}}static GetLineLength(V){if(0===V.length)return 0;let I;I="number"===typeof V[0]?WV.ToVector3Array(V):V;const m=C.g.LF[0];let l=0;for(let C=0;C<I.length-1;C++){const V=I[C];l+=I[C+1].subtractToRef(V,m).length()}return l}static GetLineLengthArray(V){const I=new Float32Array(V.length/3);let m=0;for(let C=0,l=V.length/3-1;C<l;C++){let l=V[3*C+0],s=V[3*C+1],F=V[3*C+2];l-=V[3*C+3],s-=V[3*C+4],F-=V[3*C+5];m+=Math.sqrt(l*l+s*s+F*F),I[C+1]=m}return I}static SegmentizeSegmentByCount(V,I,m){const l=[],s=I.Fm(V),F=C.g.LF[0];F.mk(m);const k=C.g.LF[1];s.divideToRef(F,k);let j=V.clone();l.push(j);for(let C=0;C<m;C++)j=j.clone(),l.push(j.addInPlace(k));return l}static SegmentizeLineBySegmentLength(V,I){const m=V[0]instanceof C.m?WV.GetLineSegments(V):"number"===typeof V[0]?WV.GetLineSegments(WV.ToVector3Array(V)):V,l=[];for(const C of m)if(C.length>I){const V=WV.SegmentizeSegmentByCount(C.point1,C.point2,Math.ceil(C.length/I));for(const I of V)l.push(I)}else l.push(C.point1),l.push(C.point2);return l}static SegmentizeLineBySegmentCount(V,I){const m="number"===typeof V[0]?WV.ToVector3Array(V):V,C=WV.GetLineLength(m)/I;return WV.SegmentizeLineBySegmentLength(m,C)}static GetLineSegments(V){const I=[];for(let m=0;m<V.length-1;m++){const C=V[m],l=V[m+1],s=l.Fm(C).length();I.push({point1:C,point2:l,length:s})}return I}static GetMinMaxSegmentLength(V){const I=WV.GetLineSegments(V).sort((V=>V.length));return{min:I[0].length,max:I[I.length-1].length}}static GetPositionOnLineByVisibility(V,I,m){let l=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=I*m;let F=0,k=0;const j=V.length;for(let C=0;C<j;C++){if(s<=F+V[C].length){k=C;break}F+=V[C].length}const E=(s-F)/V[k].length;return V[k].point2.subtractToRef(V[k].point1,C.g.LF[0]),C.g.LF[1]=C.g.LF[0].multiplyByFloats(E,E,E),l||C.g.LF[1].addInPlace(V[k].point1),C.g.LF[1].clone()}static GetCircleLinePoints(V,I){let m=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/I;const F=[];for(let k=0;k<=I;k++)F.push(new C.m(Math.cos(k*s)*V,Math.sin(k*s)*l,m));return F}static GetBezierLinePoints(V,I,m,C){return ZV.e.CreateQuadraticBezier(V,I,m,C).getPoints().flatMap((V=>[V.x,V.y,V.z]))}static GetArrowCap(V,I,m,C,l){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,F=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[V.clone(),V.add(I.multiplyByFloats(m,m,m))],widths:[C,l,s,F]}}static GetPointsFromText(V,I,m,C){let l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const F=[],k=(0,BV.e)(V,I,m,C);for(const j of k){for(const V of j.paths){const I=[],m=V.getPoints();for(const V of m)I.push(V.x,V.y,l);F.push(I)}if(s)for(const V of j.holes){const I=[],m=V.getPoints();for(const V of m)I.push(V.x,V.y,l);F.push(I)}}return F}static Color3toRGBAUint8(V){const I=new Uint8Array(4*V.length);for(let m=0,C=0;m<V.length;m++)I[C++]=255*V[m].r,I[C++]=255*V[m].g,I[C++]=255*V[m].b,I[C++]=255;return I}static CreateColorsTexture(V,I,m,C){const l=C.getEngine().getCaps().maxTextureSize??1,s=I.length>l?l:I.length,F=Math.ceil(I.length/l);F>1&&(I=[...I,...Array(s*F-I.length).fill(I[0])]);const k=WV.Color3toRGBAUint8(I),j=new S.d(k,s,F,v.c.TEXTUREFORMAT_RGBA,C,!1,!0,m);return j.name=V,j}static PrepareEmptyColorsTexture(V){if(!zV.EmptyColorsTexture){const I=new Uint8Array(4);zV.EmptyColorsTexture=new S.d(I,1,1,v.c.TEXTUREFORMAT_RGBA,V,!1,!1,S.d.NEAREST_NEAREST),zV.EmptyColorsTexture.name="grlEmptyColorsTexture"}return zV.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var V;null===(V=zV.EmptyColorsTexture)||void 0===V||V.dispose(),zV.EmptyColorsTexture=null}static BooleanToNumber(V){return V?1:0}}class QV extends HV.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class GV extends cV.b{isCompatible(V){return!0}constructor(V,I,m){var l;m=m||{color:zV.DEFAULT_COLOR};const s=new QV;s.GREASED_LINE_HAS_COLOR=!!m.color&&!m.useColors,s.GREASED_LINE_SIZE_ATTENUATION=m.sizeAttenuation??!1,s.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===m.colorDistributionType,s.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(I??V.cV()).useRightHandedSystem,s.GREASED_LINE_CAMERA_FACING=m.cameraFacing??!0,super(V,GV.GREASED_LINE_MATERIAL_NAME,200,s,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(l=m)||void 0===l?void 0:l.forceGLSL)||GV.ForceGLSL,this._scene=I??V.cV(),this._engine=this._scene.getEngine(),this._cameraFacing=m.cameraFacing??!0,this.visibility=m.visibility??1,this.useDash=m.useDash??!1,this.dashRatio=m.dashRatio??.5,this.dashOffset=m.dashOffset??0,this.width=m.width?m.width:m.sizeAttenuation?zV.DEFAULT_WIDTH_ATTENUATED:zV.DEFAULT_WIDTH,this._sizeAttenuation=m.sizeAttenuation??!1,this.colorMode=m.colorMode??0,this._color=m.color??null,this.useColors=m.useColors??!1,this._colorsDistributionType=m.colorDistributionType??0,this.colorsSampling=m.colorsSampling??S.d.NEAREST_NEAREST,this._colors=m.ZV??null,this.dashCount=m.dashCount??1,this.resolution=m.resolution??new C.k(this._engine.getRenderWidth(),this._engine.getRenderHeight()),m.colorsTexture?this.colorsTexture=m.colorsTexture:this._colors?this.colorsTexture=WV.CreateColorsTexture(`${V.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??zV.DEFAULT_COLOR,WV.PrepareEmptyColorsTexture(this._scene)),this._engine.Ck.add((()=>{WV.DisposeEmptyColorsTexture()}))}getAttributes(V){V.push("grl_offsets"),V.push("grl_widths"),V.push("grl_colorPointers"),V.push("grl_counters"),this._cameraFacing?(V.push("grl_previousAndSide"),V.push("grl_nextAndCounters")):V.push("grl_slopes")}getSamplers(V){V.push("grl_colors")}getActiveTextures(V){this.colorsTexture&&V.push(this.colorsTexture)}getUniforms(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const I=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&I.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===V&&I.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:I,vertex:this._cameraFacing&&this._isGLSL(V)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(V)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(V){if(this._cameraFacing){V.lk("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||V.lk("viewProjection",this._scene.getTransformMatrix());const I=C.g.Vector4[0];I.x=this._aspect,I.y=this._resolution.x,I.z=this._resolution.y,I.w=this.width,V.updateVector4("grl_aspect_resolution_lineWidth",I)}const I=C.g.Vector4[0];I.x=WV.BooleanToNumber(this.useDash),I.y=this._dashArray,I.z=this.dashOffset,I.w=this.dashRatio,V.updateVector4("grl_dashOptions",I);const m=C.g.Vector4[1];m.x=this.colorMode,m.y=this.visibility,m.z=this.colorsTexture?this.colorsTexture.getSize().width:0,m.w=WV.BooleanToNumber(this.useColors),V.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",m),this._color&&V.updateColor3("grl_singleColor",this._color);const l=this.colorsTexture??zV.EmptyColorsTexture;V.setTexture("grl_colors",l),V.updateFloat2("grl_textureSize",(null===l||void 0===l?void 0:l.getSize().width)??1,(null===l||void 0===l?void 0:l.getSize().height)??1)}prepareDefines(V,I,m){V.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,V.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,V.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,V.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=I.useRightHandedSystem,V.GREASED_LINE_CAMERA_FACING=this._cameraFacing,V.GREASED_LINE_USE_OFFSETS=!!m.offsets}getClassName(){return GV.GREASED_LINE_MATERIAL_NAME}getCustomCode(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(I)?function(V,I){if("vertex"===V){const V={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return I&&(V["!gl_Position\\=viewProjection\\*worldPos;"]="//"),V}return"fragment"===V?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(V,this._cameraFacing):function(V,I){if("vertex"===V){const V={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return I&&(V["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),V}return"fragment"===V?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(V,this._cameraFacing)}dispose(){var V;null===(V=this.colorsTexture)||void 0===V||V.dispose(),super.dispose()}get ZV(){return this._colors}set ZV(V){this.setColors(V)}setColors(V){var I;let m=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const l=(null===(I=this._colors)||void 0===I?void 0:I.length)??0;var s;if(this._colors=V,null!==V&&0!==V.length){if(!m||C)if(this.colorsTexture&&l===V.length&&!C){const I=WV.Color3toRGBAUint8(V);this.colorsTexture.update(I)}else{var F;null===(F=this.colorsTexture)||void 0===F||F.dispose(),this.colorsTexture=WV.CreateColorsTexture(`${this._material.name}-colors-texture`,V,this.colorsSampling,this._scene)}}else null===(s=this.colorsTexture)||void 0===s||s.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(V){this._dashCount=V,this._dashArray=1/V}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(V){this._sizeAttenuation=V,this.markAllDefinesAsDirty()}get color(){return this._color}set color(V){this.setColor(V)}setColor(V){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==V||null!==this._color&&null===V?(this._color=V,I||this.markAllDefinesAsDirty()):this._color=V}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(V){this._colorsDistributionType=V,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(V){this._aspect=V.x/V.y,this._resolution=V}serialize(){const V=super.serialize(),I={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(I.ZV=this._colors),this._color&&(I.color=this._color),V.greasedLineMaterialOptions=I,V}parse(V,I,m){var C;super.parse(V,I,m);const l=V.greasedLineMaterialOptions;null===(C=this.colorsTexture)||void 0===C||C.dispose(),l.color&&this.setColor(l.color,!0),l.colorDistributionType&&(this.colorsDistributionType=l.colorDistributionType),l.ZV&&(this.ZV=l.ZV),l.colorsSampling&&(this.colorsSampling=l.colorsSampling),l.colorMode&&(this.colorMode=l.colorMode),l.useColors&&(this.useColors=l.useColors),l.visibility&&(this.visibility=l.visibility),l.useDash&&(this.useDash=l.useDash),l.dashCount&&(this.dashCount=l.dashCount),l.dashRatio&&(this.dashRatio=l.dashRatio),l.dashOffset&&(this.dashOffset=l.dashOffset),l.width&&(this.width=l.width),l.sizeAttenuation&&(this.sizeAttenuation=l.sizeAttenuation),l.resolution&&(this.resolution=l.resolution),this.ZV?this.colorsTexture=WV.CreateColorsTexture(`${this._material.name}-colors-texture`,this.ZV,this.colorsSampling,I):WV.PrepareEmptyColorsTexture(I),this.markAllDefinesAsDirty()}copyTo(V){var I;const m=V;null===(I=m.colorsTexture)||void 0===I||I.dispose(),this._colors&&(m.colorsTexture=WV.CreateColorsTexture(`${m._material.name}-colors-texture`,this._colors,m.colorsSampling,this._scene)),m.setColor(this.color,!0),m.colorsDistributionType=this.colorsDistributionType,m.colorsSampling=this.colorsSampling,m.colorMode=this.colorMode,m.useColors=this.useColors,m.visibility=this.visibility,m.useDash=this.useDash,m.dashCount=this.dashCount,m.dashRatio=this.dashRatio,m.dashOffset=this.dashOffset,m.width=this.width,m.sizeAttenuation=this.sizeAttenuation,m.resolution=this.resolution,m.markAllDefinesAsDirty()}_isGLSL(V){return 0===V||this._forceGLSL}}GV.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",GV.ForceGLSL=!1,(0,yV.h)(`BABYLON.${GV.GREASED_LINE_MATERIAL_NAME}`,GV);var rV=m(11350),gV=m(11089),hV=m(11724),dV=m(11170);class RV extends hV.d{constructor(V,I,l){const s=I.getEngine(),F=s.isWebGPU&&!(l.forceGLSL||RV.ForceGLSL),k=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];I.useRightHandedSystem&&k.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const j=["position","grl_widths","grl_offsets","grl_colorPointers"];l.cameraFacing?(k.push("GREASED_LINE_CAMERA_FACING"),j.push("grl_previousAndSide","grl_nextAndCounters")):(j.push("grl_slopes"),j.push("grl_counters"));const E=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(F||E.push("world","viewProjection","view","projection"),super(V,I,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:F?["Scene","Mesh"]:void 0,attributes:j,uniforms:E,samplers:F?[]:["grlColors"],defines:k,extraInitializationsAsync:async()=>{F?await Promise.all([m.e(47).then(m.bind(m,14342)),m.e(55).then(m.bind(m,14350))]):await Promise.all([m.e(50).then(m.bind(m,14358)),m.e(56).then(m.bind(m,14363))])},shaderLanguage:F?1:0}),this._color=t.c.White(),this._colorsDistributionType=0,this._colorsTexture=null,l=l||{color:zV.DEFAULT_COLOR},this.visibility=l.visibility??1,this.useDash=l.useDash??!1,this.dashRatio=l.dashRatio??.5,this.dashOffset=l.dashOffset??0,this.dashCount=l.dashCount??1,this.width=l.width?l.width:l.sizeAttenuation&&l.cameraFacing?zV.DEFAULT_WIDTH_ATTENUATED:zV.DEFAULT_WIDTH,this.sizeAttenuation=l.sizeAttenuation??!1,this.color=l.color??t.c.White(),this.useColors=l.useColors??!1,this.colorsDistributionType=l.colorDistributionType??0,this.colorsSampling=l.colorsSampling??S.d.NEAREST_NEAREST,this.colorMode=l.colorMode??0,this._colors=l.ZV??null,this._cameraFacing=l.cameraFacing??!0,this.resolution=l.resolution??new C.k(s.getRenderWidth(),s.getRenderHeight()),l.colorsTexture?this.colorsTexture=l.colorsTexture:this._colors?this.colorsTexture=WV.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,I):(this._color=this._color??zV.DEFAULT_COLOR,this.colorsTexture=WV.PrepareEmptyColorsTexture(I)),F){const V=new dV.c;V.setParameters(),V.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",V)}s.Ck.add((()=>{WV.DisposeEmptyColorsTexture()}))}dispose(){var V;null===(V=this._colorsTexture)||void 0===V||V.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new C.k(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get ZV(){return this._colors}set ZV(V){this.setColors(V)}setColors(V){var I;let m=arguments.length>1&&void 0!==arguments[1]&&arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const l=(null===(I=this._colors)||void 0===I?void 0:I.length)??0;var s;if(this._colors=V,null!==V&&0!==V.length){if(!m||C)if(this._colorsTexture&&l===V.length&&!C){const I=WV.Color3toRGBAUint8(V);this._colorsTexture.update(I)}else{var F;null===(F=this._colorsTexture)||void 0===F||F.dispose(),this.colorsTexture=WV.CreateColorsTexture(`${this.name}-colors-texture`,V,this.colorsSampling,this.cV())}}else null===(s=this._colorsTexture)||void 0===s||s.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(V){this._colorsTexture=V,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(V){this._width=V,this.setFloat("grlWidth",V)}get useColors(){return this._useColors}set useColors(V){this._useColors=V,this.setFloat("grlUseColors",WV.BooleanToNumber(V))}get colorsSampling(){return this._colorsSampling}set colorsSampling(V){this._colorsSampling=V}get visibility(){return this._visibility}set visibility(V){this._visibility=V,this.setFloat("grlVisibility",V)}get useDash(){return this._useDash}set useDash(V){this._useDash=V,this.setFloat("grlUseDash",WV.BooleanToNumber(V))}get dashOffset(){return this._dashOffset}set dashOffset(V){this._dashOffset=V,this.setFloat("grlDashOffset",V)}get dashRatio(){return this._dashRatio}set dashRatio(V){this._dashRatio=V,this.setFloat("grlDashRatio",V)}get dashCount(){return this._dashCount}set dashCount(V){this._dashCount=V,this._dashArray=1/V,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(V){this._sizeAttenuation=V,this.setFloat("grlSizeAttenuation",WV.BooleanToNumber(V))}get color(){return this._color}set color(V){this.setColor(V)}setColor(V){V=V??zV.DEFAULT_COLOR,this._color=V,this.setColor3("grlColor",V)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(V){this._colorsDistributionType=V,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(V){this._colorMode=V,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(V){this._resolution=V,this.setVector2("grlResolution",V),this.setFloat("grlAspect",V.x/V.y)}serialize(){const V=super.serialize(),I={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(I.ZV=this._colors),V.greasedLineMaterialOptions=I,V}parse(V,I,m){var C;const l=V.greasedLineMaterialOptions;null===(C=this._colorsTexture)||void 0===C||C.dispose(),l.color&&(this.color=l.color),l.colorDistributionType&&(this.colorsDistributionType=l.colorDistributionType),l.colorsSampling&&(this.colorsSampling=l.colorsSampling),l.colorMode&&(this.colorMode=l.colorMode),l.useColors&&(this.useColors=l.useColors),l.visibility&&(this.visibility=l.visibility),l.useDash&&(this.useDash=l.useDash),l.dashCount&&(this.dashCount=l.dashCount),l.dashRatio&&(this.dashRatio=l.dashRatio),l.dashOffset&&(this.dashOffset=l.dashOffset),l.width&&(this.width=l.width),l.sizeAttenuation&&(this.sizeAttenuation=l.sizeAttenuation),l.resolution&&(this.resolution=l.resolution),l.ZV?this.colorsTexture=WV.CreateColorsTexture(`${this.name}-colors-texture`,l.ZV,this.colorsSampling,this.cV()):this.colorsTexture=WV.PrepareEmptyColorsTexture(I),this._cameraFacing=l.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var iV,qV,PV;RV.ForceGLSL=!1,function(V){V[V.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",V[V.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(iV||(iV={})),function(V){V[V.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",V[V.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",V[V.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(qV||(qV={})),function(V){V[V.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",V[V.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",V[V.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",V[V.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",V[V.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(PV||(PV={}));class uV extends bV.c{constructor(V,I,m){super(V,I,null,null,!1,!1),this.name=V,this._options=m,this._lazy=!1,this._updatable=!1,this._engine=I.getEngine(),this._lazy=m.lazy??!1,this._updatable=m.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=m.colorPointers??[],this._widths=m.widths??new Array(m.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(V){let I=0;for(const C of this._points)I+=C.length;const m=I/3*2-this._widths.length;for(let C=0;C<m;C++)this._widths.push(V)}updateLazy(){var V,I;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(V=this._options.ribbonOptions)||void 0===V?void 0:V.smoothShading),!this.GV&&this.refreshBoundingInfo(),null===(I=this.greasedLineMaterial)||void 0===I||I.updateLazy()}addPoints(V,I){for(const m of V)this._points.push(m);this._lazy||this.setPoints(this._points,I)}dispose(V){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(V,I)}isLazy(){return this._lazy}get BV(){return this._uvs}set BV(V){this._uvs=V instanceof Float32Array?V:new Float32Array(V),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(V){this.material instanceof RV&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===V||void 0===V?void 0:V.length)>0),this._offsets=V,this._offsetsBuffer?this._offsetsBuffer.update(V):this._createOffsetsBuffer(V)}get widths(){return this._widths}set widths(V){this._widths=V,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(V)}get colorPointers(){return this._colorPointers}set colorPointers(V){this._colorPointers=V,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(V)}get greasedLineMaterial(){var V,I;if(this.material&&this.material instanceof RV)return this.material;const m=null===(V=this.material)||void 0===V||null===(I=V.pluginManager)||void 0===I?void 0:I.getPlugin(GV.GREASED_LINE_MATERIAL_NAME);return m||void 0}get points(){const V=[];return gV.e.DeepCopy(this._points,V),V}setPoints(V,I){this._points=WV.ConvertPoints(V,(null===I||void 0===I?void 0:I.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==I&&void 0!==I&&I.colorPointers||this._updateColorPointers(),this._setPoints(this._points,I)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,BV:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(V){super.serialize(V),V.type=this.getClassName(),V.lineOptions=this._createLineOptions()}_createVertexBuffers(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new rV.c;return I.yV=this._vertexPositions,I.indices=this._indices,I.BV=this._uvs,V&&(I.zV=[],rV.c.ComputeNormals(this._vertexPositions,this._indices,I.zV)),I.QV(this,this._options.updatable),I}_createOffsetsBuffer(V){const I=this._scene.getEngine(),m=new K.c(I,V,this._updatable,3);this.setVerticesBuffer(m.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=m}}class oV{constructor(V,I){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=V,this.wasAddedByNoopNode=I}getIndicesAccessor(V,I,m,C,l){var s,F,k,j;return null===(s=this._indicesAccessorMap.get(V))||void 0===s||null===(F=s.get(I))||void 0===F||null===(k=F.get(m))||void 0===k||null===(j=k.get(C))||void 0===j?void 0:j.get(l)}setIndicesAccessor(V,I,m,C,l,s){let F=this._indicesAccessorMap.get(V);F||(F=new Map,this._indicesAccessorMap.set(V,F));let k=F.get(I);k||(k=new Map,F.set(I,k));let j=k.get(m);j||(j=new Map,k.set(m,j));let E=j.get(C);E||(E=new Map,j.set(C,E)),E.set(l,s)}pushExportedNode(V){this._exportedNodes.has(V)||this._exportedNodes.add(V)}getNodesSet(){return this._exportedNodes}getVertexBufferView(V){return this._vertexBufferViewMap.get(V)}setVertexBufferView(V,I){this._vertexBufferViewMap.set(V,I)}setRemappedBufferView(V,I,m){this._remappedBufferView.set(V,new Map),this._remappedBufferView.get(V).set(I,m)}getRemappedBufferView(V,I){var m;return null===(m=this._remappedBufferView.get(V))||void 0===m?void 0:m.get(I)}getVertexAccessor(V,I,m){var C,l;return null===(C=this._vertexAccessorMap.get(V))||void 0===C||null===(l=C.get(I))||void 0===l?void 0:l.get(m)}setVertexAccessor(V,I,m,C){let l=this._vertexAccessorMap.get(V);l||(l=new Map,this._vertexAccessorMap.set(V,l));let s=l.get(I);s||(s=new Map,l.set(I,s)),s.set(m,C)}hasVertexColorAlpha(V){return this._vertexMapColorAlpha.get(V)||!1}setHasVertexColorAlpha(V,I){return this._vertexMapColorAlpha.set(V,I)}getMesh(V){return this._meshMap.get(V)}setMesh(V,I){this._meshMap.set(V,I)}bindMorphDataToMesh(V,I){const m=this._meshMorphTargetMap.get(V)||[];this._meshMorphTargetMap.set(V,m),-1===m.indexOf(I)&&m.push(I)}getMorphTargetsFromMesh(V){return this._meshMorphTargetMap.get(V)}}class pV{_ApplyExtension(V,I,m,C){if(m>=I.length)return Promise.resolve(V);const l=C(I[m],V);return l?l.then((async V=>V?await this._ApplyExtension(V,I,m+1,C):null)):this._ApplyExtension(V,I,m+1,C)}_ApplyExtensions(V,I){const m=[];for(const C of pV._ExtensionNames)m.push(this._extensions[C]);return this._ApplyExtension(V,m,0,I)}_extensionsPreExportTextureAsync(V,I,m){return this._ApplyExtensions(I,((I,C)=>I.preExportTextureAsync&&I.preExportTextureAsync(V,C,m)))}_extensionsPostExportNodeAsync(V,I,m,C,l){return this._ApplyExtensions(I,((I,s)=>I.postExportNodeAsync&&I.postExportNodeAsync(V,s,m,C,l,this._bufferManager)))}_extensionsPostExportMaterialAsync(V,I,m){return this._ApplyExtensions(I,((I,C)=>I.postExportMaterialAsync&&I.postExportMaterialAsync(V,C,m)))}_extensionsPostExportMaterialAdditionalTextures(V,I,m){const C=[];for(const l of pV._ExtensionNames){const s=this._extensions[l];s.postExportMaterialAdditionalTextures&&C.push(...s.postExportMaterialAdditionalTextures(V,I,m))}return C}_extensionsPostExportTextures(V,I,m){for(const C of pV._ExtensionNames){const l=this._extensions[C];l.postExportTexture&&l.postExportTexture(V,I,m)}}_extensionsPostExportMeshPrimitive(V){for(const I of pV._ExtensionNames){const m=this._extensions[I];m.postExportMeshPrimitive&&m.postExportMeshPrimitive(V,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const V of pV._ExtensionNames){const I=this._extensions[V];I.preGenerateBinaryAsync&&await I.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(V){for(const I of pV._ExtensionNames){const m=this._extensions[I];m.enabled&&V(m)}}_extensionsOnExporting(){this._forEachExtensions((V=>{var I,m,C;V.wasUsed&&((I=this._glTF).extensionsUsed||(I.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(V.name)&&this._glTF.extensionsUsed.push(V.name),V.required&&((m=this._glTF).extensionsRequired||(m.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(V.name)&&this._glTF.extensionsRequired.push(V.name)),(C=this._glTF).extensions||(C.extensions={}),V.onExporting&&V.onExporting())}))}_loadExtensions(){for(const V of pV._ExtensionNames){const I=pV._ExtensionFactories[V](this);this._extensions[V]=I}}constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:N.c.LastCreatedScene,I=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${v.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new d(this),this._extensions={},this._bufferManager=new KV,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!V)throw new Error("No scene available to export");this._babylonScene=V,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:V=>{var I;return null===V||void 0===V||null===(I=V.sk)||void 0===I?void 0:I.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...I},this._loadExtensions()}dispose(){for(const V in this._extensions){this._extensions[V].dispose()}}get options(){return this._options}static RegisterExtension(V,I){pV.UnregisterExtension(V)&&l.d.Warn(`Extension with the name ${V} already exists`),pV._ExtensionFactories[V]=I,pV._ExtensionNames.push(V)}static UnregisterExtension(V){if(!pV._ExtensionFactories[V])return!1;delete pV._ExtensionFactories[V];const I=pV._ExtensionNames.indexOf(V);return-1!==I&&pV._ExtensionNames.splice(I,1),!0}_generateJSON(V,I,m){const C={byteLength:V};return C.byteLength&&(this._glTF.buffers=[C]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.OI=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(C.uri=I+".bin"),m?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(V){const I=await this._generateBinaryAsync();this._extensionsOnExporting();const m=this._generateJSON(I.byteLength,V,!0),C=new Blob([I],{type:"application/octet-stream"}),l=V+".gltf",s=V+".bin",F=new E;if(F.files[l]=m,F.files[s]=C,this._imageData)for(const k in this._imageData)F.files[k]=new Blob([this._imageData[k].data],{type:this._imageData[k].mimeType});return F}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(V){const I=V%4;return 0===I?I:4-I}async generateGLBAsync(V){this._shouldUseGlb=!0;const I=await this._generateBinaryAsync();this._extensionsOnExporting();const m=this._generateJSON(I.byteLength),C=V+".glb";let l,s=m.length;if("undefined"!==typeof TextEncoder){l=(new TextEncoder).encode(m),s=l.length}const F=this._getPadding(s),k=this._getPadding(I.byteLength),j=28+s+F+I.byteLength+k,K=new jV(j);if(K.writeUInt32(1179937895),K.writeUInt32(2),K.writeUInt32(j),K.writeUInt32(s+F),K.writeUInt32(1313821514),l)K.writeTypedArray(l);else{const V="_".charCodeAt(0);for(let I=0;I<s;++I){const C=m.charCodeAt(I);C!=m.codePointAt(I)?K.writeUInt8(V):K.writeUInt8(C)}}for(let E=0;E<F;++E)K.writeUInt8(32);K.writeUInt32(I.byteLength+k),K.writeUInt32(5130562),K.writeTypedArray(I);for(let E=0;E<k;++E)K.writeUInt8(0);const Y=new E;return Y.files[C]=new Blob([K.getOutputData()],{type:"application/octet-stream"}),Y}_setNodeTransformation(V,I,m){if(I.getPivotPoint().equalsWithEpsilon(u,P.c)||l.d.Warn("Pivot points are not supported in the glTF serializer"),!I.position.equalsWithEpsilon(u,P.c)){const l=C.g.LF[0].C(I.position);m&&e(l),V.translation=l.UF()}I.Vk.equalsWithEpsilon(p,P.c)||(V.scale=I.Vk.UF());const s=I.rotationQuaternion||C.e.FromEulerAngles(I.rotation.x,I.rotation.y,I.rotation.z);s.equalsWithEpsilon(o,P.c)||(m&&a(s),V.rotation=s.normalize().UF())}_setCameraTransformation(V,I,m){if(!I.position.equalsWithEpsilon(u,P.c)){const l=C.g.LF[0].C(I.position);m&&e(l),V.translation=l.UF()}const l=I.rotationQuaternion||C.e.FromEulerAngles(I.rotation.x,I.rotation.y,I.rotation.z);m&&a(l),this._babylonScene.useRightHandedSystem||L(l),l.equalsWithEpsilon(o,P.c)||(V.rotation=l.UF())}_listAvailableCameras(){for(const V of this._babylonScene.cameras){const I={type:V.mode===XV.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(V.name&&(I.name=V.name),"perspective"===I.type)I.perspective={aspectRatio:V.getEngine().getAspectRatio(V),yfov:V.fovMode===XV.c.FOVMODE_VERTICAL_FIXED?V.fov:V.fov*V.getEngine().getAspectRatio(V),znear:V.Fk,zfar:V.maxZ};else if("orthographic"===I.type){const m=V.orthoLeft&&V.orthoRight?.5*(V.orthoRight-V.orthoLeft):.5*V.getEngine().getRenderWidth(),C=V.orthoBottom&&V.orthoTop?.5*(V.orthoTop-V.orthoBottom):.5*V.getEngine().getRenderHeight();I.orthographic={xmag:m,ymag:C,znear:V.Fk,zfar:V.maxZ}}this._camerasMap.set(V,I)}}_exportAndAssignCameras(){const V=Array.from(this._camerasMap.values());for(const I of V){const V=this._nodesCameraMap.get(I);if(void 0!==V){this._cameras.push(I);for(const I of V)I.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const V of this._babylonScene.skeletons){if(V.bones.length<=0)continue;const I={joints:[]};this._skinMap.set(V,I)}}_exportAndAssignSkeletons(){for(const V of this._babylonScene.skeletons){if(V.bones.length<=0)continue;const I=this._skinMap.get(V);if(void 0==I)continue;const m={},C=[];let s=-1;for(let l=0;l<V.bones.length;++l){const I=V.bones[l],C=I.getIndex()??l;-1!==C&&(m[C]=I,C>s&&(s=C))}for(let V=0;V<=s;++V){const s=m[V];C.push(s.getAbsoluteInverseBindMatrix());const F=s.getTransformNode();if(null!==F){const V=this._nodeMap.get(F);F&&null!==V&&void 0!==V?I.joints.push(V):l.d.Warn("Exporting a bone without a linked transform node is currently unsupported")}else l.d.Warn("Exporting a bone without a linked transform node is currently unsupported")}const F=this._nodesSkinMap.get(I);if(I.joints.length>0&&void 0!==F){const V=64*C.length,m=new Float32Array(V/4);C.forEach(((V,I)=>{m.set(V.m,16*I)}));const l=this._bufferManager.createBufferView(m);this._accessors.push(this._bufferManager.createAccessor(l,"MAT4",5126,C.length)),I.inverseBindMatrices=this._accessors.length-1,this._skins.push(I);for(const I of F)I.skin=this._skins.length-1}}}async _exportSceneAsync(){const V={nodes:[]};if(this._babylonScene.metadata){const I=this._options.metadataSelector(this._babylonScene.metadata);I&&(V.extras=I)}const I=new Array,m=new Array,C=new Array;for(const k of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&FV(k,this._babylonScene.useRightHandedSystem)?C.push(...k.getChildren()):this._babylonScene.useRightHandedSystem?I.push(k):m.push(k);this._listAvailableCameras(),this._listAvailableSkeletons();const l=new oV(!0,!1);V.nodes.push(...await this._exportNodesAsync(m,l));const s=new oV(!1,!1);V.nodes.push(...await this._exportNodesAsync(I,s));const F=new oV(!1,!0);V.nodes.push(...await this._exportNodesAsync(C,F)),V.nodes.length&&this._scenes.push(V),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&nV._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,l.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(V){let I=this._shouldExportNodeMap.get(V);return void 0===I&&(I=this._options.shouldExportNode(V),this._shouldExportNodeMap.set(V,I)),I}async _exportNodesAsync(V,I){const m=new Array;this._exportBuffers(V,I);for(const C of V)await this._exportNodeAsync(C,m,I);return m}_collectBuffers(V,I,m,C,l){if(this._shouldExportNode(V)&&V instanceof X.e&&V.wF){const s=V.wF.getVertexBuffers();if(s)for(const C in s){if(!A(C))continue;const F=s[C];l.setHasVertexColorAlpha(F,V.hasVertexAlpha);const k=F._buffer,j=I.get(k)||[];I.set(k,j),-1===j.indexOf(F)&&j.push(F);const E=m.get(F)||[];m.set(F,E),-1===E.indexOf(V)&&E.push(V)}const F=V.morphTargetManager;if(F)for(let I=0;I<F.numTargets;I++){const m=F.getTarget(I),l=C.get(m)||[];C.set(m,l),-1===l.indexOf(V)&&l.push(V)}}for(const s of V.getChildren())this._collectBuffers(s,I,m,C,l)}_exportBuffers(V,I){const m=new Map,C=new Map,l=new Map;for(const k of V)this._collectBuffers(k,m,C,l,I);const s=Array.from(m.keys());for(const k of s){const V=k.getData();if(!V)throw new Error("Buffer data is not available");const l=m.get(k);if(!l)continue;const s=l[0].byteStride;if(l.some((V=>V.byteStride!==s)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const F=mV(V).slice();for(const I of l){const V=C.get(I),{byteOffset:m,byteStride:l,componentCount:s,type:k,count:j,normalized:E,kind:Y}=f(I,V);switch(Y){case K.e.NormalKind:case K.e.TangentKind:(0,R.k)(F,m,l,s,k,j,E,(V=>{const I=Math.sqrt(V[0]*V[0]+V[1]*V[1]+V[2]*V[2]);if(I>0){const m=1/I;V[0]*=m,V[1]*=m,V[2]*=m}}));break;case K.e.ColorKind:{const I=V.filter((V=>V.material instanceof NV.d||null==V.material)).length;if(0==I)break;if(I!=V.length){i.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}k==K.e.UNSIGNED_BYTE&&i.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const C=new t.c,Y=new t.d,X=this._babylonScene.getEngine().useExactSrgbConversions;(0,R.k)(F,m,l,s,k,j,E,(V=>{3===V.length?(C.km(V,0),C.toLinearSpaceToRef(C,X),C.toArray(V,0)):(Y.km(V,0),Y.toLinearSpaceToRef(Y,X),Y.toArray(V,0))}))}}}if(I.convertToRightHanded){for(const V of l){const I=C.get(V),{byteOffset:m,byteStride:l,componentCount:s,type:k,count:j,normalized:E,kind:Y}=f(V,I);switch(Y){case K.e.PositionKind:case K.e.NormalKind:case K.e.TangentKind:(0,R.k)(F,m,l,s,k,j,E,(V=>{V[0]=-V[0]}))}}I.convertedToRightHandedBuffers.set(k,F)}const j=this._bufferManager.createBufferView(F,s);I.setVertexBufferView(k,j);const E=new Map;for(const I of l){const V=C.get(I),{kind:m,totalVertices:l}=f(I,V);switch(m){case K.e.MatricesIndicesKind:case K.e.MatricesIndicesExtraKind:if(I.type==K.e.FLOAT){const V=I.getFloatData(l);null!==V&&E.set(I,V)}}}0!==E.size&&i.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const Y=Array.from(E.keys());for(const m of Y){const V=E.get(m);if(!V)continue;const C=V.some((V=>V>=256)),l=new(C?Uint16Array:Uint8Array)(V.length);for(let I=0;I<V.length;I++)l[I]=V[I];const s=this._bufferManager.createBufferView(l,4*(C?2:1));I.setRemappedBufferView(k,m,s)}}const F=Array.from(l.keys());for(const k of F){const V=l.get(k);if(!V)continue;const m=xV(k,V[0],this._bufferManager,this._bufferViews,this._accessors,I.convertToRightHanded);for(const C of V)I.bindMorphDataToMesh(C,m)}}async _exportNodeAsync(V,I,m){let C=this._nodeMap.get(V);if(void 0!==C)return void(I.includes(C)||I.push(C));const l=await this._createNodeAsync(V,m);if(l){C=this._nodes.length,this._nodes.push(l),this._nodeMap.set(V,C),m.pushExportedNode(V),I.push(C);const s={name:"runtime animations",channels:[],samplers:[]},F=[];this._babylonScene.animationGroups.length||(nV._CreateMorphTargetAnimationFromMorphTargetAnimations(V,s,F,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,m.convertToRightHanded,this._options.shouldExportAnimation),V.animations.length&&nV._CreateNodeAnimationFromNodeAnimations(V,s,F,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,m.convertToRightHanded,this._options.shouldExportAnimation)),s.channels.length&&s.samplers.length&&this._animations.push(s),F.forEach((V=>{V.channels.length&&V.samplers.length&&this._animations.push(V)}))}const s=l?[]:I;for(const F of V.getChildren())await this._exportNodeAsync(F,s,m);l&&s.length&&(l.children=s)}async _createNodeAsync(V,I){if(!this._shouldExportNode(V))return null;const m={};if(V.name&&(m.name=V.name),V.metadata){const I=this._options.metadataSelector(V.metadata);I&&(m.extras=I)}if(V instanceof Y.c&&(this._setNodeTransformation(m,V,I.convertToRightHanded),V instanceof X.e)){const l=V instanceof O.c?V.sourceMesh:V;if(l.kk&&l.kk.length>0&&(m.mesh=await this._exportMeshAsync(l,I)),V.skeleton){const I=this._skinMap.get(V.skeleton);var C;if(void 0!==I)void 0===this._nodesSkinMap.get(I)&&this._nodesSkinMap.set(I,[]),null===(C=this._nodesSkinMap.get(I))||void 0===C||C.push(m)}}if(V instanceof q.e){const C=this._camerasMap.get(V);if(C){var l;void 0===this._nodesCameraMap.get(C)&&this._nodesCameraMap.set(C,[]),this._setCameraTransformation(m,V,I.convertToRightHanded);const F=V.parent;if(null!==F&&IV(V,F)){const V=this._nodeMap.get(F);if(void 0!==V){var s;const I=this._nodes[V];return VV(m,I),null===(s=this._nodesCameraMap.get(C))||void 0===s||s.push(I),null}}null===(l=this._nodesCameraMap.get(C))||void 0===l||l.push(m)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",m,V,this._nodeMap,I.convertToRightHanded)?m:(i.d.Warn(`Not exporting node ${V.name}`),null)}_exportIndices(V,I,m,C,l,F,k,j,E){let K=V;E.mode=J(F);const Y=k!==s.d.CounterClockWiseSideOrientation,X=!j.wasAddedByNoopNode&&Y,O=function(V){switch(V){case s.d.TriangleFillMode:case s.d.TriangleStripDrawMode:case s.d.TriangleFanDrawMode:return!0}return!1}(F)&&X;if(O){if(F===s.d.TriangleStripDrawMode||F===s.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");E.mode=J(F);const k=I?new Uint32Array(C):new Uint16Array(C);if(V)for(let I=0;I+2<C;I+=3)k[I]=V[m+I]+l,k[I+1]=V[m+I+2]+l,k[I+2]=V[m+I+1]+l;else for(let V=0;V+2<C;V+=3)k[V]=V,k[V+1]=V+2,k[V+2]=V+1;K=k}else if(V&&0!==l){const s=I?new Uint32Array(C):new Uint16Array(C);for(let I=0;I<C;I++)s[I]=V[m+I]+l;K=s}if(K){let s=j.getIndicesAccessor(V,m,C,l,O);if(void 0===s){const F=function(V,I,m,C){if(V instanceof Uint16Array||V instanceof Uint32Array)return V;if(V instanceof Int32Array)return new Uint32Array(V.buffer,V.byteOffset,V.length);const l=V.slice(I,I+m);return C?new Uint32Array(l):new Uint16Array(l)}(K,0,C,I),k=this._bufferManager.createBufferView(F),E=I?5125:5123;this._accessors.push(this._bufferManager.createAccessor(k,"SCALAR",E,C,0)),s=this._accessors.length-1,j.setIndicesAccessor(V,m,C,l,O,s)}E.indices=s}}_exportVertexBuffer(V,I,m,C,l,s){const F=V.getKind();if(!A(F))return;if(F.startsWith("uv")&&!this._options.exportUnusedUVs&&(!I||!this._materialNeedsUVsSet.has(I)))return;let k=l.getVertexAccessor(V,m,C);if(void 0===k){const I=l.convertedToRightHandedBuffers.get(V._buffer)||V._buffer.getData(),s=F===K.e.PositionKind?function(V,I,m,C){const{byteOffset:l,byteStride:s,type:F,normalized:k}=I,j=I.getSize(),E=new Array(j).fill(1/0),K=new Array(j).fill(-1/0);return(0,R.k)(V,l+m*s,s,j,F,C*j,k,(V=>{for(let I=0;I<j;I++)E[I]=Math.min(E[I],V[I]),K[I]=Math.max(K[I],V[I])})),{min:E,max:K}}(I,V,m,C):void 0,j=(F===K.e.MatricesIndicesKind||F===K.e.MatricesIndicesExtraKind)&&V.type===K.e.FLOAT,E=j?K.e.UNSIGNED_BYTE:V.type,Y=j?void 0:V.normalized,X=j?l.getRemappedBufferView(V._buffer,V):l.getVertexBufferView(V._buffer),O=V.byteOffset+m*V.byteStride;this._accessors.push(this._bufferManager.createAccessor(X,function(V,I){if(V==K.e.ColorKind)return I?"VEC4":"VEC3";switch(V){case K.e.PositionKind:case K.e.NormalKind:return"VEC3";case K.e.TangentKind:case K.e.MatricesIndicesKind:case K.e.MatricesIndicesExtraKind:case K.e.MatricesWeightsKind:case K.e.MatricesWeightsExtraKind:return"VEC4";case K.e.UVKind:case K.e.UV2Kind:case K.e.UV3Kind:case K.e.UV4Kind:case K.e.UV5Kind:case K.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${V}`)}(F,l.hasVertexColorAlpha(V)),E,C,O,s,Y)),k=this._accessors.length-1,l.setVertexAccessor(V,m,C,k)}s.attributes[function(V){switch(V){case K.e.PositionKind:return"POSITION";case K.e.NormalKind:return"NORMAL";case K.e.TangentKind:return"TANGENT";case K.e.ColorKind:return"COLOR_0";case K.e.UVKind:return"TEXCOORD_0";case K.e.UV2Kind:return"TEXCOORD_1";case K.e.UV3Kind:return"TEXCOORD_2";case K.e.UV4Kind:return"TEXCOORD_3";case K.e.UV5Kind:return"TEXCOORD_4";case K.e.UV6Kind:return"TEXCOORD_5";case K.e.MatricesIndicesKind:return"JOINTS_0";case K.e.MatricesIndicesExtraKind:return"JOINTS_1";case K.e.MatricesWeightsKind:return"WEIGHTS_0";case K.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${V}`)}(F)]=k}async _exportMaterialAsync(V,I,m,C){let l=this._materialMap.get(V);if(void 0===l){const C=I&&Object.keys(I).some((V=>V.startsWith("uv")));if((V=V instanceof OV.d?V.jk[m.materialIndex]:V)instanceof vV.c)l=await this._materialExporter.exportPBRMaterialAsync(V,"image/png",C);else{if(!(V instanceof NV.d))return void i.d.Warn(`Unsupported material '${V.name}' with type ${V.getClassName()}`);l=await this._materialExporter.exportStandardMaterialAsync(V,"image/png",C)}this._materialMap.set(V,l)}C.material=l}async _exportMeshAsync(V,I){var m;let C=I.getMesh(V);if(void 0!==C)return C;const l={primitives:[]};C=this._meshes.length,this._meshes.push(l),I.setMesh(V,C);const F=V.isUnIndexed?null:V.AF(),k=null===(m=V.wF)||void 0===m?void 0:m.getVertexBuffers(),j=I.getMorphTargetsFromMesh(V),E=V instanceof SV.e,K=V instanceof uV,Y=V.kk;if(k&&Y&&Y.length>0)for(const v of Y){const m={attributes:{}},C=v.dV()||this._babylonScene.defaultMaterial;if(K){var X,O;const I={name:C.name},l=V,s=t.c.White(),F=(null===(X=l.material)||void 0===X?void 0:X.alpha)??1,k=(null===(O=l.greasedLineMaterial)||void 0===O?void 0:O.color)??s;(!k.equalsWithEpsilon(s,P.c)||F<1)&&(I.pbrMetallicRoughness={baseColorFactor:[...k.UF(),F]}),this._materials.push(I),m.material=this._materials.length-1}else if(E){const I={name:C.name},l=V;(!l.color.equalsWithEpsilon(t.c.White(),P.c)||l.alpha<1)&&(I.pbrMetallicRoughness={baseColorFactor:[...l.color.UF(),l.alpha]}),this._materials.push(I),m.material=this._materials.length-1}else await this._exportMaterialAsync(C,k,v,m);const Y=E||K?s.d.LineListDrawMode:V.overrideRenderingFillMode??C.fillMode,N=C._getEffectiveOrientation(V);this._exportIndices(F,F?(0,R.e)(F,v.indexCount,v.indexStart,v.verticesStart):v.verticesCount>65535,F?v.indexStart:v.verticesStart,F?v.indexCount:v.verticesCount,-v.verticesStart,Y,N,I,m);for(const V of Object.values(k))this._exportVertexBuffer(V,C,v.verticesStart,v.verticesCount,I,m);if(j){m.targets=[];for(const V of j)m.targets.push(V.attributes)}l.primitives.push(m),this._extensionsPostExportMeshPrimitive(m)}if(j){l.weights=[],l.extras||(l.extras={}),l.extras.targetNames=[];for(const V of j)l.weights.push(V.influence),l.extras.targetNames.push(V.name)}return C}}pV._ExtensionNames=new Array,pV._ExtensionFactories={};class MV{static async GLTFAsync(V,I,m){m&&m.exportWithoutWaitingForScene||await V.whenReadyAsync();const C=new pV(V,m),l=await C.generateGLTFAsync(I.replace(/\.[^/.]+$/,""));return C.dispose(),l}static async GLBAsync(V,I,m){m&&m.exportWithoutWaitingForScene||await V.whenReadyAsync();const C=new pV(V,m),l=await C.generateGLBAsync(I.replace(/\.[^/.]+$/,""));return C.dispose(),l}}m(11744);const fV="EXT_mesh_gpu_instancing";class wV{constructor(V){this.name=fV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(V,I,m,l,s,F){return await new Promise((V=>{if(I&&m instanceof bV.c&&m.hasThinInstances&&this._exporter){this._wasUsed=!0;const V=C.m.Zero(),l=C.e.Identity(),k=C.m.One(),j=m.thinInstanceGetWorldMatrices(),E=C.g.LF[2],K=C.g.Quaternion[1],Y=C.g.LF[3];let X=!1,O=!1,v=!1;const N=new Float32Array(3*m.Ek),t=new Float32Array(4*m.Ek),D=new Float32Array(3*m.Ek);let b=0;for(const I of j)I.decompose(Y,K,E),s&&(e(E),a(K)),N.set(E.UF(),3*b),t.set(K.normalize().UF(),4*b),D.set(Y.UF(),3*b),X=X||!E.equalsWithEpsilon(V),O=O||!K.equalsWithEpsilon(l),v=v||!Y.equalsWithEpsilon(k),b++;const T={attributes:{}};X&&(T.attributes.TRANSLATION=this._buildAccessor(N,"VEC3",m.Ek,F)),O&&(T.attributes.ROTATION=this._buildAccessor(t,"VEC4",m.Ek,F)),v&&(T.attributes.SCALE=this._buildAccessor(D,"VEC3",m.Ek,F)),I.extensions=I.extensions||{},I.extensions[fV]=T}V(I)}))}_buildAccessor(V,I,m,C){const l=C.createBufferView(V),s=C.createAccessor(l,I,5126,m);return this._exporter._accessors.push(s),this._exporter._accessors.length-1}}pV.RegisterExtension(fV,(V=>new wV(V)));var AV=m(11748),JV=m(11760),UV=m(11765),eV=m(11769);function aV(V){return V===UV.e.PositionKind?"POSITION":V===UV.e.NormalKind?"NORMAL":V===UV.e.ColorKind?"COLOR":V.startsWith(UV.e.UVKind)?"TEX_COORD":"GENERIC"}const LV={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class VI extends AV.e{static get DefaultAvailable(){return(0,AV.k)(VI.DefaultConfiguration)}static get Default(){return VI._Default??(VI._Default=new VI),VI._Default}static ResetDefault(V){VI._Default&&(V||VI._Default.dispose(),VI._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(V,I){return{module:await(I||DracoEncoderModule)({wasmBinary:V})}}_getWorkerContent(){return`${JV.f}(${JV.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:VI.DefaultConfiguration)}async _encodeAsync(V,I,m){const C=m?(0,eV.c)(LV,m):LV;if(this._workerPoolPromise){const m=await this._workerPoolPromise;return await new Promise(((l,s)=>{m.push(((m,F)=>{const k=V=>{m.removeEventListener("error",k),m.removeEventListener("message",j),s(V),F()},j=V=>{"encodeMeshDone"===V.data.id&&(m.removeEventListener("error",k),m.removeEventListener("message",j),l(V.data.encodedMeshData),F())};m.addEventListener("error",k),m.addEventListener("message",j);const E=[];for(const I of V)E.push(I.data.buffer);I&&E.push(I.buffer),m.postMessage({id:"encodeMesh",attributes:V,indices:I,options:C},E)}))}))}if(this._modulePromise){const m=await this._modulePromise;return(0,JV.f)(m.module,V,I,C)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(V,I){if(0==V.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");V instanceof bV.c&&V.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===I||void 0===I?void 0:I.method)&&(i.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),I.method="MESH_SEQUENTIAL_ENCODING");const m=function(V){let I=V.AF(void 0,!0);return!I||I instanceof Uint32Array||I instanceof Uint16Array||(I=((0,R.e)(I,I.length)?Uint32Array:Uint16Array).from(I)),I}(V),C=function(V,I){const m=[];for(const C of V.getVerticesDataKinds()){if(null!==I&&void 0!==I&&I.includes(C)){if(C===UV.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const l=V.getVertexBuffer(C),s=l.getSize(),F=(0,R.t)(l.getData(),s,l.type,l.byteOffset,l.byteStride,l.normalized,V.getTotalVertices(),!0);m.push({kind:C,dracoName:aV(C),size:s,data:F})}return m}(V,null===I||void 0===I?void 0:I.excludedAttributes);return await this._encodeAsync(C,m,I)}}VI.DefaultConfiguration={wasmUrl:`${l.d._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${l.d._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${l.d._DefaultCdnUrl}/draco_encoder.js`},VI._Default=null;const II="KHR_draco_mesh_compression";class mI{get wasUsed(){return this._wasUsed}constructor(V){this.name=II,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===V.options.meshCompressionMethod&&VI.DefaultAvailable}dispose(){}postExportMeshPrimitive(V,I,m){if(!this.enabled)return;if(4!==V.mode&&5!==V.mode)return void i.d.Warn("Cannot compress primitive with mode "+V.mode+".");const C=[],l=[];let s=null;if(void 0!==V.indices){const F=m[V.indices],k=I.getBufferView(F);s=I.getData(k).slice(),C.push(k),l.push(F)}const F=[];for(const[K,Y]of Object.entries(V.attributes)){const V=m[Y],s=I.getBufferView(V),j=w(V.type),E=(0,R.t)(I.getData(s),j,V.componentType,V.byteOffset||0,s.byteStride||(0,R.q)(V.componentType)*j,V.normalized||!1,V.count,!0);F.push({kind:K,dracoName:(k=K,"POSITION"===k?"POSITION":"NORMAL"===k?"NORMAL":k.startsWith("COLOR")?"COLOR":k.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:w(V.type),data:E}),C.push(s),l.push(V)}var k;const j={method:V.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},E=VI.Default._encodeAsync(F,s,j).then((m=>{if(!m)return void i.d.Error("Draco encoding failed for primitive.");const s={bufferView:-1,attributes:m.attributeIds},F=I.createBufferView(m.data);I.setBufferView(s,F);for(const V of C)this._bufferViewsUsed.add(V);for(const V of l)this._accessorsUsed.add(V);V.extensions||(V.extensions={}),V.extensions[II]=s})).catch((V=>{i.d.Error("Draco encoding failed for primitive: "+V)}));this._encodePromises.push(E),this._wasUsed=!0}async preGenerateBinaryAsync(V){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((I=>{V.getPropertiesWithBufferView(I).every((V=>this._accessorsUsed.has(V)))&&V.removeBufferView(I)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}pV.RegisterExtension(II,(V=>new mI(V)));var CI=m(11776);const lI="KHR_lights_punctual",sI={name:"",color:[1,1,1],Kk:1,range:Number.MAX_VALUE},FI={innerConeAngle:0,outerConeAngle:Math.PI/4},kI=C.m.Backward();class jI{constructor(V){this.name=lI,this.enabled=!0,this.required=!1,this._exporter=V}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[lI]=this._lights}async postExportNodeAsync(V,I,m,l,s){return await new Promise((F=>{if(!(m instanceof TV.d))return void F(I);const k=m.getTypeID()==TV.d.LIGHTTYPEID_POINTLIGHT?"point":m.getTypeID()==TV.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":m.getTypeID()==TV.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!k||!(m instanceof CI.c))return i.d.Warn(`${V}: Light ${m.name} is not supported in ${lI}`),void F(I);if(m.falloffType!==TV.d.FALLOFF_GLTF&&i.d.Warn(`${V}: Light falloff for ${m.name} does not match the ${lI} specification!`),!m.position.equalsToFloats(0,0,0)){const V=C.g.LF[0].C(m.position);s&&e(V),I.translation=V.UF()}if("point"!==k){const V=m.direction.normalizeToRef(C.g.LF[0]);s&&e(V);const l=C.e.FromUnitVectorsToRef(kI,V,C.g.Quaternion[0]);C.e.IsIdentity(l)||(I.rotation=l.UF())}const j={type:k,name:m.name,color:m.Yk.UF(),Kk:m.Kk,range:m.range};if(CV(j,sI),"spot"===k){const V=m;j.spot={innerConeAngle:V.innerAngle/2,outerConeAngle:V.angle/2},CV(j.spot,FI)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(j);const E={MF:this._lights.lights.length-1},K=m.parent;if(K&&IV(m,K)){const V=l.get(K);if(V){const m=this._exporter._nodes[V];return VV(I,m),m.extensions||(m.extensions={}),m.extensions[lI]=E,void F(null)}}I.extensions||(I.extensions={}),I.extensions[lI]=E,F(I)}))}}pV.RegisterExtension(lI,(V=>new jI(V)));var EI=m(11587);const KI="KHR_materials_anisotropy";class YI{constructor(V){this.name=KI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,m){const C=[];return m instanceof EI.b&&m.anisotropy.isEnabled&&!m.anisotropy.legacy?(m.anisotropy.texture&&C.push(m.anisotropy.texture),C):[]}postExportMaterialAsync(V,I,m){return new Promise((V=>{if(m instanceof EI.b){if(!m.anisotropy.isEnabled||m.anisotropy.legacy)return void V(I);this._wasUsed=!0,I.extensions=I.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(m.anisotropy.texture),l={anisotropyStrength:m.anisotropy.Kk,anisotropyRotation:m.anisotropy.angle,anisotropyTexture:C??void 0};null!==l.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(m),I.extensions[KI]=l}V(I)}))}}pV.RegisterExtension(KI,(V=>new YI(V)));const XI="KHR_materials_clearcoat";class OI{constructor(V){this.name=XI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,m){const C=[];return m instanceof EI.b&&m.clearCoat.isEnabled?(m.clearCoat.texture&&C.push(m.clearCoat.texture),!m.clearCoat.useRoughnessFromMainTexture&&m.clearCoat.textureRoughness&&C.push(m.clearCoat.textureRoughness),m.clearCoat.bumpTexture&&C.push(m.clearCoat.bumpTexture),C):[]}postExportMaterialAsync(V,I,m){return new Promise((V=>{if(m instanceof EI.b){if(!m.clearCoat.isEnabled)return void V(I);this._wasUsed=!0,I.extensions=I.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(m.clearCoat.texture);let s;s=m.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(m.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(m.clearCoat.textureRoughness),m.clearCoat.isTintEnabled&&l.d.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${m.name}`),m.clearCoat.remapF0OnInterfaceChange&&l.d.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${m.name}`);const F=this._exporter._materialExporter.getTextureInfo(m.clearCoat.bumpTexture),k={clearcoatFactor:m.clearCoat.Kk,clearcoatTexture:C??void 0,clearcoatRoughnessFactor:m.clearCoat.roughness,clearcoatRoughnessTexture:s??void 0,clearcoatNormalTexture:F??void 0};null===k.clearcoatTexture&&null===k.clearcoatRoughnessTexture&&null===k.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(m),I.extensions[XI]=k}V(I)}))}}pV.RegisterExtension(XI,(V=>new OI(V)));const vI="KHR_materials_diffuse_transmission";function NI(V,I){const m=I.subSurface;let C=null;return m.translucencyIntensityTexture?C=m.translucencyIntensityTexture:m.thicknessTexture&&m.useMaskFromThicknessTexture&&(C=m.thicknessTexture),C&&!m.useGltfStyleTextures?(i.d.Warn(`${V}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${I.name}`,1),null):C}class tI{constructor(V){this.name=vI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,m){const C=[];if(m instanceof vV.c&&this._isExtensionEnabled(m)){const I=NI(V,m);return I&&C.push(I),m.subSurface.translucencyColorTexture&&C.push(m.subSurface.translucencyColorTexture),C}return C}_isExtensionEnabled(V){if(V.unlit)return!1;const I=V.subSurface;return!!I.isTranslucencyEnabled&&(!V.unlit&&!I.useAlbedoToTintTranslucency&&I.useGltfStyleTextures&&1===I.volumeIndexOfRefraction&&0===I.minimumThickness&&0===I.maximumThickness)}postExportMaterialAsync(V,I,m){return new Promise((C=>{if(m instanceof vV.c&&this._isExtensionEnabled(m)){this._wasUsed=!0;const C=m.subSurface,l=NI(V,m),s=0==C.translucencyIntensity?void 0:C.translucencyIntensity,F=this._exporter._materialExporter.getTextureInfo(l)??void 0,k=!C.translucencyColor||C.translucencyColor.equalsFloats(1,1,1)?void 0:C.translucencyColor.UF(),j=this._exporter._materialExporter.getTextureInfo(C.translucencyColorTexture)??void 0,E={diffuseTransmissionFactor:s,diffuseTransmissionTexture:F,diffuseTransmissionColorFactor:k,diffuseTransmissionColorTexture:j};(F||j)&&this._exporter._materialNeedsUVsSet.add(m),I.extensions=I.extensions||{},I.extensions[vI]=E}C(I)}))}}pV.RegisterExtension(vI,(V=>new tI(V)));const DI="KHR_materials_dispersion";class bI{constructor(){this.name=DI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(V){if(V.unlit)return!1;const I=V.subSurface;return!(!I.isRefractionEnabled&&!I.isDispersionEnabled)}postExportMaterialAsync(V,I,m){return new Promise((V=>{if(m instanceof vV.c&&this._isExtensionEnabled(m)){this._wasUsed=!0;const V={dispersion:m.subSurface.dispersion};I.extensions=I.extensions||{},I.extensions[DI]=V}V(I)}))}}pV.RegisterExtension(DI,(()=>new bI));const TI="KHR_materials_emissive_strength";class nI{constructor(){this.name=TI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(V,I,m){return await new Promise((V=>{if(!(m instanceof vV.c))return V(I);const C=m.emissiveColor.UF(),l=Math.max(...C);if(l>1){this._wasUsed=!0,I.extensions||(I.extensions={});const V={emissiveStrength:l},C=m.emissiveColor.scale(1/V.emissiveStrength);I.emissiveFactor=C.UF(),I.extensions[TI]=V}return V(I)}))}}pV.RegisterExtension(TI,(V=>new nI));const xI="KHR_materials_ior";class SI{constructor(){this.name=xI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(V){return!V.unlit&&(void 0!=V.indexOfRefraction&&1.5!=V.indexOfRefraction)}postExportMaterialAsync(V,I,m){return new Promise((V=>{if(m instanceof vV.c&&this._isExtensionEnabled(m)){this._wasUsed=!0;const V={ior:m.indexOfRefraction};I.extensions=I.extensions||{},I.extensions[xI]=V}V(I)}))}}pV.RegisterExtension(xI,(V=>new SI));const cI="KHR_materials_iridescence";class HI{constructor(V){this.name=cI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,m){const C=[];return m instanceof EI.b&&m.iridescence.isEnabled?(m.iridescence.texture&&C.push(m.iridescence.texture),m.iridescence.thicknessTexture&&m.iridescence.thicknessTexture!==m.iridescence.texture&&C.push(m.iridescence.thicknessTexture),C):[]}postExportMaterialAsync(V,I,m){return new Promise((V=>{if(m instanceof EI.b){if(!m.iridescence.isEnabled)return void V(I);this._wasUsed=!0,I.extensions=I.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(m.iridescence.texture),l=this._exporter._materialExporter.getTextureInfo(m.iridescence.thicknessTexture),s={iridescenceFactor:m.iridescence.Kk,iridescenceIor:m.iridescence.indexOfRefraction,iridescenceThicknessMinimum:m.iridescence.minimumThickness,iridescenceThicknessMaximum:m.iridescence.maximumThickness,iridescenceTexture:C??void 0,iridescenceThicknessTexture:l??void 0};null===s.iridescenceTexture&&null===s.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(m),I.extensions[cI]=s}V(I)}))}}pV.RegisterExtension(cI,(V=>new HI(V)));const yI="KHR_materials_sheen";class zI{constructor(V){this.name=yI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,m){return m instanceof vV.c&&m.sheen.isEnabled&&m.sheen.texture?[m.sheen.texture]:[]}async postExportMaterialAsync(V,I,m){return await new Promise((V=>{if(m instanceof vV.c){if(!m.sheen.isEnabled)return void V(I);this._wasUsed=!0,null==I.extensions&&(I.extensions={});const C={sheenColorFactor:m.sheen.color.UF(),sheenRoughnessFactor:m.sheen.roughness??0};null===C.sheenColorTexture&&null===C.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(m),m.sheen.texture&&(C.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(m.sheen.texture)??void 0),m.sheen.textureRoughness&&!m.sheen.useRoughnessFromMainTexture?C.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(m.sheen.textureRoughness)??void 0:m.sheen.texture&&m.sheen.useRoughnessFromMainTexture&&(C.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(m.sheen.texture)??void 0),I.extensions[yI]=C}V(I)}))}}pV.RegisterExtension(yI,(V=>new zI(V)));const ZI="KHR_materials_specular";class BI{constructor(V){this.name=ZI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,m){const C=[];return m instanceof vV.c&&this._isExtensionEnabled(m)?(m.metallicReflectanceTexture&&C.push(m.metallicReflectanceTexture),m.reflectanceTexture&&C.push(m.reflectanceTexture),C):C}_isExtensionEnabled(V){return!V.unlit&&(void 0!=V.metallicF0Factor&&1!=V.metallicF0Factor||void 0!=V.metallicReflectanceColor&&!V.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(V))}_hasTexturesExtension(V){return null!=V.metallicReflectanceTexture||null!=V.reflectanceTexture}postExportMaterialAsync(V,I,m){return new Promise((V=>{if(m instanceof vV.c&&this._isExtensionEnabled(m)){this._wasUsed=!0,I.extensions=I.extensions||{};const V=this._exporter._materialExporter.getTextureInfo(m.metallicReflectanceTexture)??void 0,C=this._exporter._materialExporter.getTextureInfo(m.reflectanceTexture)??void 0,l={specularFactor:1==m.metallicF0Factor?void 0:m.metallicF0Factor,specularTexture:V,specularColorFactor:m.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:m.metallicReflectanceColor.UF(),specularColorTexture:C};this._hasTexturesExtension(m)&&this._exporter._materialNeedsUVsSet.add(m),I.extensions[ZI]=l}V(I)}))}}pV.RegisterExtension(ZI,(V=>new BI(V)));const WI="KHR_materials_transmission";class QI{constructor(V){this.name=WI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,m){const C=[];return m instanceof vV.c&&this._isExtensionEnabled(m)?(m.subSurface.thicknessTexture&&C.push(m.subSurface.thicknessTexture),C):C}_isExtensionEnabled(V){if(V.unlit)return!1;const I=V.subSurface;return I.isRefractionEnabled&&void 0!=I.refractionIntensity&&0!=I.refractionIntensity||this._hasTexturesExtension(V)}_hasTexturesExtension(V){return null!=V.subSurface.refractionIntensityTexture}async postExportMaterialAsync(V,I,m){if(m instanceof vV.c&&this._isExtensionEnabled(m)){this._wasUsed=!0;const C=m.subSurface,l={transmissionFactor:0===C.refractionIntensity?void 0:C.refractionIntensity};if(this._hasTexturesExtension(m)&&this._exporter._materialNeedsUVsSet.add(m),C.refractionIntensityTexture)if(C.useGltfStyleTextures){const V=await this._exporter._materialExporter.exportTextureAsync(C.refractionIntensityTexture,"image/png");V&&(l.transmissionTexture=V)}else i.d.Warn(`${V}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);I.extensions||(I.extensions={}),I.extensions[WI]=l}return I}}pV.RegisterExtension(WI,(V=>new QI(V)));const GI="KHR_materials_unlit";class rI{constructor(){this.name=GI,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(V,I,m){return new Promise((V=>{let C=!1;m instanceof vV.c?C=m.unlit:m instanceof NV.d&&(C=m.disableLighting),C&&(this._wasUsed=!0,null==I.extensions&&(I.extensions={}),I.extensions[GI]={}),V(I)}))}}pV.RegisterExtension(GI,(()=>new rI));const gI="KHR_materials_volume";class hI{constructor(V){this.name=gI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,m){const C=[];return m instanceof vV.c&&this._isExtensionEnabled(m)?(m.subSurface.thicknessTexture&&C.push(m.subSurface.thicknessTexture),C):C}_isExtensionEnabled(V){if(V.unlit)return!1;const I=V.subSurface;return!(!I.isRefractionEnabled&&!I.isTranslucencyEnabled)&&(void 0!=I.maximumThickness&&0!=I.maximumThickness||void 0!=I.tintColorAtDistance&&I.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=I.tintColor&&I.tintColor!=t.c.White()||this._hasTexturesExtension(V))}_hasTexturesExtension(V){return null!=V.subSurface.thicknessTexture}postExportMaterialAsync(V,I,m){return new Promise((V=>{if(m instanceof vV.c&&this._isExtensionEnabled(m)){this._wasUsed=!0;const V=m.subSurface,C={thicknessFactor:0==V.maximumThickness?void 0:V.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(V.thicknessTexture)??void 0,attenuationDistance:V.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:V.tintColorAtDistance,attenuationColor:V.tintColor.equalsFloats(1,1,1)?void 0:V.tintColor.UF()};this._hasTexturesExtension(m)&&this._exporter._materialNeedsUVsSet.add(m),I.extensions=I.extensions||{},I.extensions[gI]=C}V(I)}))}}pV.RegisterExtension(gI,(V=>new hI(V)));const dI="EXT_materials_diffuse_roughness";class RI{constructor(V){this.name=dI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=V}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(V,I,m){const C=[];return m instanceof EI.b&&m._baseDiffuseRoughness?(m._baseDiffuseRoughnessTexture&&C.push(m._baseDiffuseRoughnessTexture),C):[]}postExportMaterialAsync(V,I,m){return new Promise((V=>{if(m instanceof EI.b){if(!m._baseDiffuseRoughness)return void V(I);this._wasUsed=!0,I.extensions=I.extensions||{};const C=this._exporter._materialExporter.getTextureInfo(m._baseDiffuseRoughnessTexture),l={diffuseRoughnessFactor:m._baseDiffuseRoughness,diffuseRoughnessTexture:C??void 0};null!==l.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(m),I.extensions[dI]=l}V(I)}))}}pV.RegisterExtension(dI,(V=>new RI(V)));const iI="KHR_texture_transform";class qI{constructor(){this.name=iI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(V,I,m){if(m.cV()||l.d.Warn(`${V}: /*@__KEY__*/"scene" is not defined for Babylon texture ${m.name}!`),(0!==m.uAng||0!==m.vAng)&&(l.d.Warn(`${V}: Texture ${m.name} with rotation in the u or v axis is not supported in glTF.`),0!==m.uRotationCenter||0!==m.vRotationCenter))return;const C={};let s=!1;if(0===m.uOffset&&0===m.vOffset||(C.offset=[m.uOffset,m.vOffset],s=!0),1===m.uScale&&1===m.vScale||(C.scale=[m.uScale,m.vScale],s=!0),0!==m.wAng){if(0!==m.uRotationCenter||0!==m.vRotationCenter){if(m.homogeneousRotationInUVTransform&&m.uScale!==m.vScale)return void l.d.Warn(`${V}: Texture ${m.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${iI}.`);l.d.Warn(`${V}: Texture ${m.name} with non-origin rotation center will be exported using an adjusted offset with ${iI}.`),C.offset=function(V){const{uOffset:I,vOffset:m,uRotationCenter:C,vRotationCenter:l,uScale:s,vScale:F,wAng:k}=V,j=Math.cos(k),E=Math.sin(k),K=C*s,Y=l*F;return[I+(K*(1-j)+Y*E),m+(Y*(1-j)-K*E)]}(m)}C.rotation=-m.wAng,s=!0}0!==m.coordinatesIndex&&(C.texCoord=m.coordinatesIndex,s=!0),s&&(this._wasUsed=!0,I.extensions||(I.extensions={}),I.extensions[iI]=C)}}pV.RegisterExtension(iI,(()=>new qI));class PI{static CreateSTL(V){let I=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],m=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",l=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],F=arguments.length>5&&void 0!==arguments[5]&&arguments[5],k=arguments.length>6&&void 0!==arguments[6]&&arguments[6],j=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const E=function(V,I,m){const l=[3*V[m],3*V[m+1],3*V[m+2]],s=[new C.m(I[l[0]],I[l[0]+2],I[l[0]+1]),new C.m(I[l[1]],I[l[1]+2],I[l[1]+1]),new C.m(I[l[2]],I[l[2]+2],I[l[2]+1])],F=s[0].Fm(s[1]),k=s[2].Fm(s[1]);return{v:s,n:C.m.Cross(k,F).normalize()}},Y=function(V,I,m,C){return I=X(V,I,m.x,C),I=X(V,I,m.y,C),X(V,I,m.z,C)},X=function(V,I,m,C){return V.setFloat32(I,m,C),I+4},v=function(V){if(k){let I=V;V instanceof O.c&&(I=V.sourceMesh);const m=I.getVerticesData(K.e.PositionKind,!0,!0);if(!m)return[];const l=C.m.Zero();let s;for(s=0;s<m.length;s+=3)C.m.TransformCoordinatesFromFloatsToRef(m[s],m[s+1],m[s+2],V.fF(!0),l).toArray(m,s);return m}return V.getVerticesData(K.e.PositionKind)||[]};k&&(F=!0);let N="",t=0,D=0;if(l){for(let m=0;m<V.length;m++){const I=V[m].AF();t+=I?I.length/3:0}const I=new ArrayBuffer(84+50*t);N=new DataView(I),D+=80,N.setUint32(D,t,s),D+=4}else j||(N="solid stlmesh\r\n");for(let C=0;C<V.length;C++){const I=V[C];!l&&j&&(N+="solid "+I.name+"\r\n"),!F&&I instanceof bV.c&&I.bakeCurrentTransformIntoVertices();const m=v(I),k=I.AF()||[];for(let V=0;V<k.length;V+=3){const I=E(k,m,V);l?(D=Y(N,D,I.n,s),D=Y(N,D,I.v[0],s),D=Y(N,D,I.v[1],s),D=Y(N,D,I.v[2],s),D+=2):(N+="\tfacet normal "+I.n.x+" "+I.n.y+" "+I.n.z+"\r\n",N+="\t\touter loop\r\n",N+="\t\t\tvertex "+I.v[0].x+" "+I.v[0].y+" "+I.v[0].z+"\r\n",N+="\t\t\tvertex "+I.v[1].x+" "+I.v[1].y+" "+I.v[1].z+"\r\n",N+="\t\t\tvertex "+I.v[2].x+" "+I.v[2].y+" "+I.v[2].z+"\r\n",N+="\t\tendloop\r\n",N+="\tendfacet\r\n")}!l&&j&&(N+="endsolid "+name+"\r\n")}if(l||j||(N+="endsolid stlmesh"),I){const V=document.createElement("a"),I=new Blob([N],{type:"application/octet-stream"});V.href=window.URL.createObjectURL(I),V.download=m+".stl",V.click()}return N}}function uI(V,I){let m=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const C=[];for(let l=0;l<V.length/m;l++){const s=V[l*m],F=V[l*m+1],k=V[l*m+2];C.push(`(${s.toPrecision(I.precision)}, ${F.toPrecision(I.precision)}, ${k.toPrecision(I.precision)})`)}return C.join(", ")}function oI(V,I){const m=[];for(let C=0;C<V.length/2;C++){const l=V[2*C],s=V[2*C+1];m.push(`(${l.toPrecision(I.precision)}, ${(1-s).toPrecision(I.precision)})`)}return m.join(", ")}function pI(V,I){const m=V.getVerticesData(K.e.PositionKind),C=V.getVerticesData(K.e.NormalKind);if(m&&C)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(V){var I;const m=null!==(I=V.AF())&&void 0!==I&&I.length?V.getTotalIndices():V.getTotalVertices();return Array(m/3).fill(3).join(", ")}(V)}]\n\t\tint[] faceVertexIndices = [${function(V){const I=V.AF(),m=[];if(null!==I)for(let C=0;C<I.length;C++)m.push(I[C]);else{const I=V.getTotalVertices();for(let V=0;V<I;V++)m.push(V)}return m.join(", ")}(V)}]\n\t\tnormal3f[] normals = [${uI(C,I)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${uI(m,I)}]\n        ${function(V,I){let m="";for(let l=0;l<4;l++){const C=l>0?l:"",s=V.getVerticesData(K.e.UVKind+(C?C+1:""));s&&(m+=`\n\t\ttexCoord2f[] primvars:st${C} = [${oI(s,I)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const C=V.getVerticesData(K.e.ColorKind);return C&&(m+=`\n\tcolor3f[] primvars:displayColor = [${uI(C,I,C.length/V.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),m}(V,I)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function MI(V,I){return`\n        def "Geometry"\n        {\n        ${pI(V,I)}\n        }\n        `}function fI(V){let I='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return I+=V,fflate.strToU8(I)}function wI(V){const I=V.m;return`( ${AI(I,0)}, ${AI(I,4)}, ${AI(I,8)}, ${AI(I,12)} )`}function AI(V,I){return`(${V[I+0]}, ${V[I+1]}, ${V[I+2]}, ${V[I+3]})`}function JI(V){const I="Object_"+V.uniqueId,m=function(V){const I=V.getWorldMatrix().clone(),m=V.cV().useRightHandedSystem;if(!m){let C=V.parent;for(;C;){if(FV(C,m)){I.multiplyToRef(C.getWorldMatrix().invert(),I);break}C=C.parent}}return I.determinant()<0&&l.d.Warn(`Exporting mesh ${V.name} with negative scale. Result may look incorrect in destination engine.`),I}(V),C=wI(m);return`def Xform "${I}" (\n\tprepend references = @./geometries/Geometry_${V.wF.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${C}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${V.material.uniqueId}>\n}\n\n`}function UI(V){switch(V){case c.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case c.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case c.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function eI(V){return`(${V.x}, ${V.y})`}function aI(V){return`(${V.r}, ${V.g}, ${V.b})`}function LI(V,I,m,l,s,F){const k=V.getInternalTexture().uniqueId+"_"+V.invertY;s[k]=V;const j=V.coordinatesIndex>0?"st"+V.coordinatesIndex:"st",E=new C.k(V.uScale,V.vScale),K=new C.k(V.uOffset,V.vOffset),Y=V.wAng,X=Math.sin(Y),O=Math.cos(Y);return K.y=1-K.y-E.y,K.x+=X*E.x,K.y+=(1-O)*E.y,`\n    def Shader "PrimvarReader_${m}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${j}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${m}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${I.uniqueId}/PrimvarReader_${m}.outputs:result>\n        float inputs:rotation = ${(Y*(180/Math.PI)).toFixed(F.precision)}\n        float2 inputs:scale = ${eI(E)}\n        float2 inputs:translation = ${eI(K)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${V.uniqueId}_${m}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${k}.png@\n        float2 inputs:st.connect = </Materials/Material_${I.uniqueId}/Transform2d_${m}.outputs:result>\n        ${l?"float4 inputs:scale = "+function(V){return`(${V.r}, ${V.g}, ${V.b}, 1.0)`}(l):""}\n        token inputs:sourceColorSpace = "${V.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${UI(V.wrapU)}"\n        token inputs:wrapT = "${UI(V.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${I.needAlphaBlending()?"float outputs:a":""}\n    }`}function Vm(V,I,m){const C="\t\t\t",l=[],s=[],{diffuseMap:F,Yk:k,alphaCutOff:j,emissiveMap:E,emissive:K,normalMap:Y,roughnessMap:X,roughnessChannel:O,roughness:v,metalnessMap:N,metalnessChannel:D,metalness:b,aoMap:T,aoMapChannel:n,aoMapIntensity:x,alphaMap:S,ior:c,clearCoatEnabled:H,clearCoat:y,clearCoatMap:z,clearCoatRoughness:Z,clearCoatRoughnessMap:B}=function(V){const I={diffuseMap:null,Yk:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return V instanceof NV.d?{...I,diffuseMap:V.diffuseTexture,Yk:V.diffuseColor,alphaCutOff:V.alphaCutOff,emissiveMap:V.emissiveTexture,emissive:V.emissiveColor,roughness:1,alphaMap:V.opacityTexture}:V instanceof EI.b?{...I,diffuseMap:V._albedoTexture,Yk:V._albedoColor,alphaCutOff:V._alphaCutOff,emissiveMap:V._emissiveTexture,emissive:V._emissiveColor,normalMap:V._bumpTexture,roughnessMap:V._metallicTexture,roughnessChannel:V._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:V._roughness??1,metalnessMap:V._metallicTexture,metalnessChannel:V._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:V._metallic??0,aoMap:V._ambientTexture,aoMapChannel:V._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:V._ambientTextureStrength,alphaMap:V._opacityTexture,ior:V.subSurface.indexOfRefraction,clearCoatEnabled:V.clearCoat.isEnabled,clearCoat:V.clearCoat.Kk,clearCoatMap:V.clearCoat.texture,clearCoatRoughness:V.clearCoat.roughness,clearCoatRoughnessMap:V.clearCoat.useRoughnessFromMainTexture?V.clearCoat.texture:V.clearCoat.textureRoughness}:I}(V);return null!==F?(l.push(`${C}color3f inputs:diffuseColor.connect = </Materials/Material_${V.uniqueId}/Texture_${F.uniqueId}_diffuse.outputs:rgb>`),V.needAlphaBlending()?l.push(`${C}float inputs:opacity.connect = </Materials/Material_${V.uniqueId}/Texture_${F.uniqueId}_diffuse.outputs:a>`):V.needAlphaTesting()&&(l.push(`${C}float inputs:opacity.connect = </Materials/Material_${V.uniqueId}/Texture_${F.uniqueId}_diffuse.outputs:a>`),l.push(`${C}float inputs:opacityThreshold = ${j}`)),s.push(LI(F,V,"diffuse",k,I,m))):l.push(`${C}color3f inputs:diffuseColor = ${aI(k||t.c.White())}`),null!==E?(l.push(`${C}color3f inputs:emissiveColor.connect = </Materials/Material_${V.uniqueId}/Texture_${E.uniqueId}_emissive.outputs:rgb>`),s.push(LI(E,V,"emissive",K,I,m))):K&&K.toLuminance()>0&&l.push(`${C}color3f inputs:emissiveColor = ${aI(K)}`),null!==Y&&(l.push(`${C}normal3f inputs:normal.connect = </Materials/Material_${V.uniqueId}/Texture_${Y.uniqueId}_normal.outputs:rgb>`),s.push(LI(Y,V,"XC",null,I,m))),null!==T&&(l.push(`${C}float inputs:occlusion.connect = </Materials/Material_${V.uniqueId}/Texture_${T.uniqueId}_occlusion.outputs:${n}>`),s.push(LI(T,V,"occlusion",new t.c(x,x,x),I,m))),null!==X?(l.push(`${C}float inputs:roughness.connect = </Materials/Material_${V.uniqueId}/Texture_${X.uniqueId}_roughness.outputs:${O}>`),s.push(LI(X,V,"roughness",new t.c(v,v,v),I,m))):l.push(`${C}float inputs:roughness = ${v}`),null!==N?(l.push(`${C}float inputs:metallic.connect = </Materials/Material_${V.uniqueId}/Texture_${N.uniqueId}_metallic.outputs:${D}>`),s.push(LI(N,V,"metallic",new t.c(b,b,b),I,m))):l.push(`${C}float inputs:metallic = ${b}`),null!==S?(l.push(`${C}float inputs:opacity.connect = </Materials/Material_${V.uniqueId}/Texture_${S.uniqueId}_opacity.outputs:r>`),l.push(`${C}float inputs:opacityThreshold = 0.0001`),s.push(LI(S,V,"opacity",null,I,m))):l.push(`${C}float inputs:opacity = ${V.alpha}`),H&&(null!==z?(l.push(`${C}float inputs:clearcoat.connect = </Materials/Material_${V.uniqueId}/Texture_${z.uniqueId}_clearcoat.outputs:r>`),s.push(LI(z,V,"clearcoat",new t.c(y,y,y),I,m))):l.push(`${C}float inputs:clearcoat = ${y}`),null!==B?(l.push(`${C}float inputs:clearcoatRoughness.connect = </Materials/Material_${V.uniqueId}/Texture_${B.uniqueId}_clearcoatRoughness.outputs:g>`),s.push(LI(B,V,"clearcoatRoughness",new t.c(Z,Z,Z),I,m))):l.push(`${C}float inputs:clearcoatRoughness = ${Z}`)),l.push(`${C}float inputs:ior = ${c}`),`\n\tdef Material "Material_${V.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${l.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${V.uniqueId}/PreviewSurface.outputs:surface>\n\n${s.join("\n")}\n\n\t}\n`}async function Im(V,I,m){const s={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...I};"undefined"===typeof fflate&&await l.d.LoadScriptAsync(s.fflateUrl);const F={};F[s.modelFileName]=null;let k='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';k+=function(V){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===V.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${V.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${V.planeAnchoringAlignment}"`:""}\n            `}(s);const j={};for(const C of V.meshes){if(0===C.getTotalVertices())continue;const V=C,I=V.wF,E=V.material;if(!E||!I||m&&!m(V))continue;if(-1!==["Xk","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(E.getClassName())){const m="geometries/Geometry_"+I.uniqueId+".usda";if(!(m in F)){const V=MI(I,s);F[m]=fI(V)}E.uniqueId in j||(j[E.uniqueId]=E),k+=JI(V)}else l.d.Warn("USDZExportAsync does not support this material type: "+E.getClassName())}V.activeCamera&&s.exportCamera&&(k+=function(V,I){const m="Camera_"+V.uniqueId,l=wI(C.b.RotationY(Math.PI).multiply(V.getWorldMatrix()));if(V.mode===c.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${m}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${l}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${V.Fk.toPrecision(I.precision)}, ${V.maxZ.toPrecision(I.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(V.orthoLeft||1)+Math.abs(V.orthoRight||1))).toPrecision(I.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(V.orthoTop||1)+Math.abs(V.orthoBottom||1))).toPrecision(I.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const C=V.getEngine().getAspectRatio(V),s=I.cameraSensorWidth||35;return`def Camera "${m}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${l}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${V.Fk.toPrecision(I.precision)}, ${V.maxZ.toPrecision(I.precision)})\n\t\t\tfloat focalLength = ${(s/(2*Math.tan(.5*V.fov))).toPrecision(I.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(s*C).toPrecision(I.precision)}\n\t\t\tfloat verticalAperture = ${(s/C).toPrecision(I.precision)}            \n\t\t}\n\t\n\t`}}(V.activeCamera,s)),k+="\n            }\n        }\n    }";const E={};k+=function(V,I,m){const C=[];for(const l in V){const s=V[l];C.push(Vm(s,I,m))}return`\n    def "Materials"\n{\n${C.join("")}\n}\n\n`}(j,E,s),F[s.modelFileName]=fflate.strToU8(k);for(const C in E){const V=E[C],I=V.getSize(),m=await V.readPixels();if(!m)throw new Error("Texture data is not available");const l=await H.DumpTools.DumpDataAsync(I.width,I.height,m,"image/png",void 0,!1,!0);F[`textures/Texture_${C}.png`]=new Uint8Array(l).slice()}let K=0;for(const C in F){const V=F[C];if(!V)continue;K+=34+C.length;const I=63&K;if(4!==I){const m=new Uint8Array(64-I);F[C]=[V,{extra:{12345:m}}]}K=V.length}return fflate.zipSync(F,{level:0})}}}]);