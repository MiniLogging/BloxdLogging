"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10462:(U,b,e)=>{e.r(b),e.d(b,{_HDRTextureLoader:()=>r});var K=e(951);class p{static ConvertPanoramaToCubemap(U,b,e,K){let p=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!U)throw"ConvertPanoramaToCubemap: input cannot be null";if(U.length!=b*e*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(K,this.FACE_FRONT,U,b,e,p),back:this.CreateCubemapTexture(K,this.FACE_BACK,U,b,e,p),left:this.CreateCubemapTexture(K,this.FACE_LEFT,U,b,e,p),right:this.CreateCubemapTexture(K,this.FACE_RIGHT,U,b,e,p),up:this.CreateCubemapTexture(K,this.FACE_UP,U,b,e,p),down:this.CreateCubemapTexture(K,this.FACE_DOWN,U,b,e,p),size:K,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(U,b,e,K,p){let m=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=new ArrayBuffer(U*U*4*3),D=new Float32Array(i),S=m?Math.max(1,Math.round(K/4/U)):1,u=1/S,r=u*u,W=b[1].wc(b[0]).scale(u/U),f=b[3].wc(b[2]).scale(u/U),l=1/U;let P=0;for(let G=0;G<U;G++)for(let m=0;m<S;m++){let m=b[0],i=b[2];for(let b=0;b<U;b++)for(let u=0;u<S;u++){const S=i.wc(m).scale(P).add(m);S.normalize();const u=this.CalcProjectionSpherical(S,e,K,p);D[G*U*3+3*b+0]+=u.r*r,D[G*U*3+3*b+1]+=u.g*r,D[G*U*3+3*b+2]+=u.b*r,m=m.add(W),i=i.add(f)}P+=l*u}return D}static CalcProjectionSpherical(U,b,e,K){let p=Math.atan2(U.z,U.x);const m=Math.acos(U.y);for(;p<-Math.PI;)p+=2*Math.PI;for(;p>Math.PI;)p-=2*Math.PI;let i=p/Math.PI;const D=m/Math.PI;i=.5*i+.5;let S=Math.round(i*e);S<0?S=0:S>=e&&(S=e-1);let u=Math.round(D*K);u<0?u=0:u>=K&&(u=K-1);const r=K-u-1;return{r:b[r*e*3+3*S+0],g:b[r*e*3+3*S+1],b:b[r*e*3+3*S+2]}}}function m(U,b,e,K,p,m){p>0?(p=function(U,b){return b>1023?U*Math.pow(2,1023)*Math.pow(2,b-1023):b<-1074?U*Math.pow(2,-1074)*Math.pow(2,b+1074):U*Math.pow(2,b)}(1,p-136),U[m+0]=b*p,U[m+1]=e*p,U[m+2]=K*p):(U[m+0]=0,U[m+1]=0,U[m+2]=0)}function i(U,b){let e="",K="";for(let p=b;p<U.length-b&&(K=String.fromCharCode(U[p]),"\n"!=K);p++)e+=K;return e}function D(U){let b=0,e=0,K=i(U,0);if("#"!=K[0]||"?"!=K[1])throw"Bad HDR Format.";let p=!1,m=!1,D=0;do{D+=K.length+1,K=i(U,D),"FORMAT=32-bit_rle_rgbe"==K?m=!0:0==K.length&&(p=!0)}while(!p);if(!m)throw"HDR Bad header format, unsupported FORMAT";D+=K.length+1,K=i(U,D);const S=/^-Y (.*) \+X (.*)$/g.exec(K);if(!S||S.length<3)throw"HDR Bad header format, no size";if(e=parseInt(S[2]),b=parseInt(S[1]),e<8||e>32767)throw"HDR Bad header format, unsupported size";return D+=K.length+1,{height:b,width:e,dataPosition:D}}function S(U,b){return function(U,b){let e=b.height;const K=b.width;let p,i,D,S,r,W=b.dataPosition,f=0,l=0,P=0;const G=new ArrayBuffer(4*K),E=new Uint8Array(G),A=new ArrayBuffer(b.width*b.height*4*3),Y=new Float32Array(A);for(;e>0;){if(p=U[W++],i=U[W++],D=U[W++],S=U[W++],2!=p||2!=i||128&D||b.width<8||b.width>32767)return u(U,b);if((D<<8|S)!=K)throw"HDR Bad header format, wrong scan line width";for(f=0,P=0;P<4;P++)for(l=(P+1)*K;f<l;)if(p=U[W++],i=U[W++],p>128){if(r=p-128,0==r||r>l-f)throw"HDR Bad Format, bad scanline data (run)";for(;r-- >0;)E[f++]=i}else{if(r=p,0==r||r>l-f)throw"HDR Bad Format, bad scanline data (non-run)";if(E[f++]=i,--r>0)for(let b=0;b<r;b++)E[f++]=U[W++]}for(P=0;P<K;P++)p=E[P],i=E[P+K],D=E[P+2*K],S=E[P+3*K],m(Y,p,i,D,S,(b.height-e)*K*3+3*P);e--}return Y}(U,b)}function u(U,b){let e=b.height;const K=b.width;let p,i,D,S,u,r=b.dataPosition;const W=new ArrayBuffer(b.width*b.height*4*3),f=new Float32Array(W);for(;e>0;){for(u=0;u<b.width;u++)p=U[r++],i=U[r++],D=U[r++],S=U[r++],m(f,p,i,D,S,(b.height-e)*K*3+3*u);e--}return f}p.FACE_LEFT=[new K.o(-1,-1,-1),new K.o(1,-1,-1),new K.o(-1,1,-1),new K.o(1,1,-1)],p.FACE_RIGHT=[new K.o(1,-1,1),new K.o(-1,-1,1),new K.o(1,1,1),new K.o(-1,1,1)],p.FACE_FRONT=[new K.o(1,-1,-1),new K.o(1,-1,1),new K.o(1,1,-1),new K.o(1,1,1)],p.FACE_BACK=[new K.o(-1,-1,1),new K.o(-1,-1,-1),new K.o(-1,1,1),new K.o(-1,1,-1)],p.FACE_DOWN=[new K.o(1,1,-1),new K.o(1,1,1),new K.o(-1,1,-1),new K.o(-1,1,1)],p.FACE_UP=[new K.o(-1,-1,-1),new K.o(-1,-1,1),new K.o(1,-1,-1),new K.o(1,-1,1)];class r{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(U,b,e){const K=new Uint8Array(U.buffer,U.byteOffset,U.byteLength),p=D(K),m=S(K,p),i=p.width*p.height,u=new Float32Array(4*i);for(let D=0;D<i;D+=1)u[4*D]=m[3*D],u[4*D+1]=m[3*D+1],u[4*D+2]=m[3*D+2],u[4*D+3]=1;e(p.width,p.height,b.generateMipMaps,!1,(()=>{const U=b.getEngine();b.type=1,b.format=5,b._gammaSpace=!1,U._uploadDataToTextureDirectly(b,u)}))}}}}]);