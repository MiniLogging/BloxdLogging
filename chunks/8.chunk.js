"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10264:(B,q,C)=>{C.r(q),C.d(q,{_HDRTextureLoader:()=>l});var v=C(946);class m{static ConvertPanoramaToCubemap(B,q,C,v){let m=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!B)throw"ConvertPanoramaToCubemap: input cannot be null";if(B.length!=q*C*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(v,this.FACE_FRONT,B,q,C,m),back:this.CreateCubemapTexture(v,this.FACE_BACK,B,q,C,m),left:this.CreateCubemapTexture(v,this.FACE_LEFT,B,q,C,m),right:this.CreateCubemapTexture(v,this.FACE_RIGHT,B,q,C,m),up:this.CreateCubemapTexture(v,this.FACE_UP,B,q,C,m),down:this.CreateCubemapTexture(v,this.FACE_DOWN,B,q,C,m),size:v,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(B,q,C,v,m){let O=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const S=new ArrayBuffer(B*B*4*3),D=new Float32Array(S),R=O?Math.max(1,Math.round(v/4/B)):1,T=1/R,l=T*T,z=q[1].Fc(q[0]).scale(T/B),W=q[3].Fc(q[2]).scale(T/B),Z=1/B;let G=0;for(let y=0;y<B;y++)for(let O=0;O<R;O++){let O=q[0],S=q[2];for(let q=0;q<B;q++)for(let T=0;T<R;T++){const R=S.Fc(O).scale(G).add(O);R.normalize();const T=this.CalcProjectionSpherical(R,C,v,m);D[y*B*3+3*q+0]+=T.r*l,D[y*B*3+3*q+1]+=T.g*l,D[y*B*3+3*q+2]+=T.b*l,O=O.add(z),S=S.add(W)}G+=Z*T}return D}static CalcProjectionSpherical(B,q,C,v){let m=Math.atan2(B.z,B.x);const O=Math.acos(B.y);for(;m<-Math.PI;)m+=2*Math.PI;for(;m>Math.PI;)m-=2*Math.PI;let S=m/Math.PI;const D=O/Math.PI;S=.5*S+.5;let R=Math.round(S*C);R<0?R=0:R>=C&&(R=C-1);let T=Math.round(D*v);T<0?T=0:T>=v&&(T=v-1);const l=v-T-1;return{r:q[l*C*3+3*R+0],g:q[l*C*3+3*R+1],b:q[l*C*3+3*R+2]}}}function O(B,q,C,v,m,O){m>0?(m=function(B,q){return q>1023?B*Math.pow(2,1023)*Math.pow(2,q-1023):q<-1074?B*Math.pow(2,-1074)*Math.pow(2,q+1074):B*Math.pow(2,q)}(1,m-136),B[O+0]=q*m,B[O+1]=C*m,B[O+2]=v*m):(B[O+0]=0,B[O+1]=0,B[O+2]=0)}function S(B,q){let C="",v="";for(let m=q;m<B.length-q&&(v=String.fromCharCode(B[m]),"\n"!=v);m++)C+=v;return C}function D(B){let q=0,C=0,v=S(B,0);if("#"!=v[0]||"?"!=v[1])throw"Bad HDR Format.";let m=!1,O=!1,D=0;do{D+=v.length+1,v=S(B,D),"FORMAT=32-bit_rle_rgbe"==v?O=!0:0==v.length&&(m=!0)}while(!m);if(!O)throw"HDR Bad header format, unsupported FORMAT";D+=v.length+1,v=S(B,D);const R=/^-Y (.*) \+X (.*)$/g.exec(v);if(!R||R.length<3)throw"HDR Bad header format, no size";if(C=parseInt(R[2]),q=parseInt(R[1]),C<8||C>32767)throw"HDR Bad header format, unsupported size";return D+=v.length+1,{height:q,width:C,dataPosition:D}}function R(B,q){return function(B,q){let C=q.height;const v=q.width;let m,S,D,R,l,z=q.dataPosition,W=0,Z=0,G=0;const y=new ArrayBuffer(4*v),e=new Uint8Array(y),U=new ArrayBuffer(q.width*q.height*4*3),s=new Float32Array(U);for(;C>0;){if(m=B[z++],S=B[z++],D=B[z++],R=B[z++],2!=m||2!=S||128&D||q.width<8||q.width>32767)return T(B,q);if((D<<8|R)!=v)throw"HDR Bad header format, wrong scan line width";for(W=0,G=0;G<4;G++)for(Z=(G+1)*v;W<Z;)if(m=B[z++],S=B[z++],m>128){if(l=m-128,0==l||l>Z-W)throw"HDR Bad Format, bad scanline data (run)";for(;l-- >0;)e[W++]=S}else{if(l=m,0==l||l>Z-W)throw"HDR Bad Format, bad scanline data (non-run)";if(e[W++]=S,--l>0)for(let q=0;q<l;q++)e[W++]=B[z++]}for(G=0;G<v;G++)m=e[G],S=e[G+v],D=e[G+2*v],R=e[G+3*v],O(s,m,S,D,R,(q.height-C)*v*3+3*G);C--}return s}(B,q)}function T(B,q){let C=q.height;const v=q.width;let m,S,D,R,T,l=q.dataPosition;const z=new ArrayBuffer(q.width*q.height*4*3),W=new Float32Array(z);for(;C>0;){for(T=0;T<q.width;T++)m=B[l++],S=B[l++],D=B[l++],R=B[l++],O(W,m,S,D,R,(q.height-C)*v*3+3*T);C--}return W}m.FACE_LEFT=[new v.i(-1,-1,-1),new v.i(1,-1,-1),new v.i(-1,1,-1),new v.i(1,1,-1)],m.FACE_RIGHT=[new v.i(1,-1,1),new v.i(-1,-1,1),new v.i(1,1,1),new v.i(-1,1,1)],m.FACE_FRONT=[new v.i(1,-1,-1),new v.i(1,-1,1),new v.i(1,1,-1),new v.i(1,1,1)],m.FACE_BACK=[new v.i(-1,-1,1),new v.i(-1,-1,-1),new v.i(-1,1,1),new v.i(-1,1,-1)],m.FACE_DOWN=[new v.i(1,1,-1),new v.i(1,1,1),new v.i(-1,1,-1),new v.i(-1,1,1)],m.FACE_UP=[new v.i(-1,-1,-1),new v.i(-1,-1,1),new v.i(1,-1,-1),new v.i(1,-1,1)];class l{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(B,q,C){const v=new Uint8Array(B.buffer,B.byteOffset,B.byteLength),m=D(v),O=R(v,m),S=m.width*m.height,T=new Float32Array(4*S);for(let D=0;D<S;D+=1)T[4*D]=O[3*D],T[4*D+1]=O[3*D+1],T[4*D+2]=O[3*D+2],T[4*D+3]=1;C(m.width,m.height,q.generateMipMaps,!1,(()=>{const B=q.getEngine();q.type=1,q.format=5,q._gammaSpace=!1,B._uploadDataToTextureDirectly(q,T)}))}}}}]);