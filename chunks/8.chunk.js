"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10248:(q,X,Q)=>{Q.r(X),Q.d(X,{_HDRTextureLoader:()=>R});var y=Q(1002);class x{static ConvertPanoramaToCubemap(q,X,Q,y){let x=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!q)throw"ConvertPanoramaToCubemap: input cannot be null";if(q.length!=X*Q*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(y,this.FACE_FRONT,q,X,Q,x),back:this.CreateCubemapTexture(y,this.FACE_BACK,q,X,Q,x),left:this.CreateCubemapTexture(y,this.FACE_LEFT,q,X,Q,x),right:this.CreateCubemapTexture(y,this.FACE_RIGHT,q,X,Q,x),up:this.CreateCubemapTexture(y,this.FACE_UP,q,X,Q,x),down:this.CreateCubemapTexture(y,this.FACE_DOWN,q,X,Q,x),size:y,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(q,X,Q,y,x){let u=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const H=new ArrayBuffer(q*q*4*3),b=new Float32Array(H),D=u?Math.max(1,Math.round(y/4/q)):1,a=1/D,R=a*a,L=X[1].Sc(X[0]).scale(a/q),f=X[3].Sc(X[2]).scale(a/q),k=1/q;let j=0;for(let I=0;I<q;I++)for(let u=0;u<D;u++){let u=X[0],H=X[2];for(let X=0;X<q;X++)for(let a=0;a<D;a++){const D=H.Sc(u).scale(j).add(u);D.normalize();const a=this.CalcProjectionSpherical(D,Q,y,x);b[I*q*3+3*X+0]+=a.r*R,b[I*q*3+3*X+1]+=a.g*R,b[I*q*3+3*X+2]+=a.b*R,u=u.add(L),H=H.add(f)}j+=k*a}return b}static CalcProjectionSpherical(q,X,Q,y){let x=Math.atan2(q.z,q.x);const u=Math.acos(q.y);for(;x<-Math.PI;)x+=2*Math.PI;for(;x>Math.PI;)x-=2*Math.PI;let H=x/Math.PI;const b=u/Math.PI;H=.5*H+.5;let D=Math.round(H*Q);D<0?D=0:D>=Q&&(D=Q-1);let a=Math.round(b*y);a<0?a=0:a>=y&&(a=y-1);const R=y-a-1;return{r:X[R*Q*3+3*D+0],g:X[R*Q*3+3*D+1],b:X[R*Q*3+3*D+2]}}}function u(q,X,Q,y,x,u){x>0?(x=function(q,X){return X>1023?q*Math.pow(2,1023)*Math.pow(2,X-1023):X<-1074?q*Math.pow(2,-1074)*Math.pow(2,X+1074):q*Math.pow(2,X)}(1,x-136),q[u+0]=X*x,q[u+1]=Q*x,q[u+2]=y*x):(q[u+0]=0,q[u+1]=0,q[u+2]=0)}function H(q,X){let Q="",y="";for(let x=X;x<q.length-X&&(y=String.fromCharCode(q[x]),"\n"!=y);x++)Q+=y;return Q}function b(q){let X=0,Q=0,y=H(q,0);if("#"!=y[0]||"?"!=y[1])throw"Bad HDR Format.";let x=!1,u=!1,b=0;do{b+=y.length+1,y=H(q,b),"FORMAT=32-bit_rle_rgbe"==y?u=!0:0==y.length&&(x=!0)}while(!x);if(!u)throw"HDR Bad header format, unsupported FORMAT";b+=y.length+1,y=H(q,b);const D=/^-Y (.*) \+X (.*)$/g.exec(y);if(!D||D.length<3)throw"HDR Bad header format, no size";if(Q=parseInt(D[2]),X=parseInt(D[1]),Q<8||Q>32767)throw"HDR Bad header format, unsupported size";return b+=y.length+1,{height:X,width:Q,dataPosition:b}}function D(q,X){return function(q,X){let Q=X.height;const y=X.width;let x,H,b,D,R,L=X.dataPosition,f=0,k=0,j=0;const I=new ArrayBuffer(4*y),d=new Uint8Array(I),e=new ArrayBuffer(X.width*X.height*4*3),i=new Float32Array(e);for(;Q>0;){if(x=q[L++],H=q[L++],b=q[L++],D=q[L++],2!=x||2!=H||128&b||X.width<8||X.width>32767)return a(q,X);if((b<<8|D)!=y)throw"HDR Bad header format, wrong scan line width";for(f=0,j=0;j<4;j++)for(k=(j+1)*y;f<k;)if(x=q[L++],H=q[L++],x>128){if(R=x-128,0==R||R>k-f)throw"HDR Bad Format, bad scanline data (run)";for(;R-- >0;)d[f++]=H}else{if(R=x,0==R||R>k-f)throw"HDR Bad Format, bad scanline data (non-run)";if(d[f++]=H,--R>0)for(let X=0;X<R;X++)d[f++]=q[L++]}for(j=0;j<y;j++)x=d[j],H=d[j+y],b=d[j+2*y],D=d[j+3*y],u(i,x,H,b,D,(X.height-Q)*y*3+3*j);Q--}return i}(q,X)}function a(q,X){let Q=X.height;const y=X.width;let x,H,b,D,a,R=X.dataPosition;const L=new ArrayBuffer(X.width*X.height*4*3),f=new Float32Array(L);for(;Q>0;){for(a=0;a<X.width;a++)x=q[R++],H=q[R++],b=q[R++],D=q[R++],u(f,x,H,b,D,(X.height-Q)*y*3+3*a);Q--}return f}x.FACE_LEFT=[new y.n(-1,-1,-1),new y.n(1,-1,-1),new y.n(-1,1,-1),new y.n(1,1,-1)],x.FACE_RIGHT=[new y.n(1,-1,1),new y.n(-1,-1,1),new y.n(1,1,1),new y.n(-1,1,1)],x.FACE_FRONT=[new y.n(1,-1,-1),new y.n(1,-1,1),new y.n(1,1,-1),new y.n(1,1,1)],x.FACE_BACK=[new y.n(-1,-1,1),new y.n(-1,-1,-1),new y.n(-1,1,1),new y.n(-1,1,-1)],x.FACE_DOWN=[new y.n(1,1,-1),new y.n(1,1,1),new y.n(-1,1,-1),new y.n(-1,1,1)],x.FACE_UP=[new y.n(-1,-1,-1),new y.n(-1,-1,1),new y.n(1,-1,-1),new y.n(1,-1,1)];class R{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(q,X,Q){const y=new Uint8Array(q.buffer,q.byteOffset,q.byteLength),x=b(y),u=D(y,x),H=x.width*x.height,a=new Float32Array(4*H);for(let b=0;b<H;b+=1)a[4*b]=u[3*b],a[4*b+1]=u[3*b+1],a[4*b+2]=u[3*b+2],a[4*b+3]=1;Q(x.width,x.height,X.generateMipMaps,!1,(()=>{const q=X.getEngine();X.type=1,X.format=5,X._gammaSpace=!1,q._uploadDataToTextureDirectly(X,a)}))}}}}]);