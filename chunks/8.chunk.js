"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10934:(q,f,j)=>{j.r(f),j.d(f,{EXT_materials_diffuse_roughness:()=>Rf,EXT_mesh_gpu_instancing:()=>Pq,GLTF2Export:()=>Vq,GLTFData:()=>r,KHR_draco_mesh_compression:()=>jf,KHR_lights_punctual:()=>Hf,KHR_materials_anisotropy:()=>Xf,KHR_materials_clearcoat:()=>Bf,KHR_materials_diffuse_transmission:()=>Of,KHR_materials_dispersion:()=>wf,KHR_materials_emissive_strength:()=>sf,KHR_materials_ior:()=>ef,KHR_materials_iridescence:()=>If,KHR_materials_sheen:()=>Wf,KHR_materials_specular:()=>Uf,KHR_materials_transmission:()=>vf,KHR_materials_unlit:()=>Mf,KHR_materials_volume:()=>bf,KHR_texture_transform:()=>kf,OBJExport:()=>L,STLExport:()=>yf,USDZExportAsync:()=>jj,_ConvertToGLTFPBRMetallicRoughness:()=>v,_SolveMetallic:()=>Y,__IGLTFExporterExtension:()=>Q});var d=j(10941),g=j(10992),h=j(11118);class L{static OBJ(q,f,j,L){const Q=[];let H=1,r=1;f&&(j||(j="mat"),Q.push("mtllib "+j+".mtl"));for(let u=0;u<q.length;u++){const j=q[u],X=j.name||`mesh${u}}`;Q.push(`o ${X}`);let z=null;if(L){const q=j.Nf(!0);z=new d.b,q.invertToRef(z),j.bakeTransformIntoVertices(q)}if(f){const q=j.material;q&&Q.push("usemtl "+q.id)}const B=j.wf;if(!B){g.h.Warn("No geometry is present on the mesh");continue}const D=B.getVerticesData("position"),i=B.getVerticesData("df"),t=B.getVerticesData("uv"),O=B.sf();let N=0,w=0;if(!D||!O){g.h.Warn("There are no position vertices or indices on the mesh!");continue}const E=q[0].eq().useRightHandedSystem?1:-1;for(let q=0;q<D.length;q+=3)Q.push("v "+D[q]*E+" "+D[q+1]+" "+D[q+2]),N++;if(null!=i)for(let q=0;q<i.length;q+=3)Q.push("vn "+i[q]*E+" "+i[q+1]+" "+i[q+2]);if(null!=t)for(let q=0;q<t.length;q+=2)Q.push("vt "+t[q]+" "+t[q+1]),w++;const s=["","",""],S=(j.material||j.eq().defaultMaterial)._getEffectiveOrientation(j),[e,Z]=S===h.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let q=0;q<O.length;q+=3){const f=[String(O[q]+H),String(O[q+e]+H),String(O[q+Z]+H)],j=[String(O[q]+r),String(O[q+e]+r),String(O[q+Z]+r)],d=f,g=null!=t?j:s,h=null!=i?f:s;Q.push("f "+d[0]+"/"+g[0]+"/"+h[0]+" "+d[1]+"/"+g[1]+"/"+h[1]+" "+d[2]+"/"+g[2]+"/"+h[2])}L&&z&&j.bakeTransformIntoVertices(z),H+=N,r+=w}return Q.join("\n")}static MTL(q){const f=[],j=q.material;f.push("newmtl mat1"),f.push("  Ns "+j.specularPower.toFixed(4)),f.push("  Ni 1.5000"),f.push("  d "+j.alpha.toFixed(4)),f.push("  Tr 0.0000"),f.push("  Tf 1.0000 1.0000 1.0000"),f.push("  illum 2"),f.push("  Ka "+j.ambientColor.r.toFixed(4)+" "+j.ambientColor.g.toFixed(4)+" "+j.ambientColor.b.toFixed(4)),f.push("  Kd "+j.diffuseColor.r.toFixed(4)+" "+j.diffuseColor.g.toFixed(4)+" "+j.diffuseColor.b.toFixed(4)),f.push("  Ks "+j.specularColor.r.toFixed(4)+" "+j.specularColor.g.toFixed(4)+" "+j.specularColor.b.toFixed(4)),f.push("  Ke "+j.emissiveColor.r.toFixed(4)+" "+j.emissiveColor.g.toFixed(4)+" "+j.emissiveColor.b.toFixed(4));j.ambientTexture&&f.push("  map_Ka "+j.ambientTexture.name),j.diffuseTexture&&f.push("  map_Kd "+j.diffuseTexture.name),j.specularTexture&&f.push("  map_Ks "+j.specularTexture.name),j.bumpTexture&&f.push("  map_bump -imfchan z "+j.bumpTexture.name),j.opacityTexture&&f.push("  map_d "+j.opacityTexture.name);return f.join("\n")}}var Q=0,H=j(11030);class r{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const q in this.files){const f=this.files[q],j=new Blob([f],{type:(0,H.f)(q)});g.h.Download(j,q)}}}var u=j(11151),X=j(11245),z=j(11249),B=j(11280),D=j(11331),i=j(10980),t=j(11210),O=j(10985);const N=O.HighestCommonFactor,w={...O,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:N};var E=j(11433),s=j(11438),S=j(11468),e=j(11472),Z=j(11476);const I=1e-6,T=new t.c(.04,.04,.04),W=1024,n=t.c.White(),U=t.c.Black();function Y(q,f,j){if(f<T.r)return 0;const d=T.r,g=q*j/(1-T.r)+f-2*T.r,h=g*g-4*d*(T.r-f);return w.Clamp((-g+Math.sqrt(h))/(2*d),0,1)}function v(q){const f=q.diffuseColor.toLinearSpace(q.eq().getEngine().useExactSrgbConversions).scale(.5),j=q.alpha,g=function(q){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new d.i(0,1),j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new d.i(0,.1),g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new d.i(0,.1),h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new d.i(1300,.1);return function(q,f,j,d,g){return(1-q)*(1-q)*(1-q)*f+3*(1-q)*(1-q)*q*j+3*(1-q)*q*q*d+q*q*q*g}(Math.pow(q/h.x,.333333),f.y,j.y,g.y,h.y)}(w.Clamp(q.specularPower,0,W));return{baseColorFactor:[f.r,f.g,f.b,j],metallicFactor:0,roughnessFactor:g}}function F(q,f){f.needAlphaBlending()?q.alphaMode="BLEND":f.needAlphaTesting()&&(q.alphaMode="MASK",q.alphaCutoff=f.alphaCutOff)}function M(q,f,j){const d=new Uint8Array(q*f*4);for(let g=0;g<d.length;g+=4)d[g]=d[g+1]=d[g+2]=d[g+3]=255;return S.c.CreateRGBATexture(d,q,f,j)}function o(q){if(q instanceof Uint8Array){const f=q.length,j=new Float32Array(q.length);for(let d=0;d<f;++d)j[d]=q[d]/255;return j}if(q instanceof Float32Array)return q;throw new Error("Unsupported pixel format!")}class b{constructor(q){this._exporter=q,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(q){return q?this._textureMap.get(q)??null:null}async exportStandardMaterialAsync(q,f,j){const d=v(q),h={name:q.name};if(null==q.ef||q.ef||(q.twoSidedLighting||g.h.Warn(q.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),h.doubleSided=!0),j){const j=[],g=q.diffuseTexture;g&&j.push(this.exportTextureAsync(g,f).then((q=>{q&&(d.baseColorTexture=q)})));const L=q.bumpTexture;L&&j.push(this.exportTextureAsync(L,f).then((q=>{q&&(h.normalTexture=q,1!==L.level&&(h.normalTexture.scale=L.level))})));const Q=q.emissiveTexture;Q&&(h.emissiveFactor=[1,1,1],j.push(this.exportTextureAsync(Q,f).then((q=>{q&&(h.emissiveTexture=q)}))));const H=q.ambientTexture;H&&j.push(this.exportTextureAsync(H,f).then((q=>{if(q){const f={index:q.index};h.occlusionTexture=f}}))),j.length>0&&(this._exporter._materialNeedsUVsSet.add(q),await Promise.all(j))}(q.alpha<1||q.opacityTexture)&&(q.alphaMode===e.b.ALPHA_COMBINE?h.alphaMode="BLEND":g.h.Warn(q.name+": glTF 2.0 does not support alpha mode: "+q.alphaMode.toString())),q.emissiveColor&&!q.emissiveColor.equalsWithEpsilon(U,I)&&(h.emissiveFactor=q.emissiveColor.Yf()),h.pbrMetallicRoughness=d,F(h,q),await this._finishMaterialAsync(h,q,f);const L=this._exporter._materials;return L.push(h),L.length-1}async _finishMaterialAsync(q,f,j){const d=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",q,f),g=[];for(const h of d)g.push(this.exportTextureAsync(h,j));await Promise.all(g),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",q,f)}async _getImageDataAsync(q,f,d,g){const h=e.b.TEXTURETYPE_UNSIGNED_BYTE,L=this._exporter._babylonScene,Q=L.getEngine(),H=Q.createRawTexture(q,f,d,e.b.TEXTUREFORMAT_RGBA,!1,!0,s.e.NEAREST_SAMPLINGMODE,null,h);Q.isWebGPU?await j.e(36).then(j.bind(j,13471)):await j.e(37).then(j.bind(j,13480)),await E.m.ApplyPostProcess("pass",H,L,h,e.b.TEXTURE_NEAREST_SAMPLINGMODE,e.b.TEXTUREFORMAT_RGBA);const r=await Q._readTexturePixels(H,f,d);return await Z.DumpTools.DumpDataAsync(f,d,r,g,void 0,!0,!0)}_resizeTexturesToSameDimensions(q,f,j){const d=q?q.getSize():{width:0,height:0},g=f?f.getSize():{width:0,height:0};let h,L;return d.width<g.width?(h=q&&q instanceof s.e?E.m.CreateResizedCopy(q,g.width,g.height,!0):M(g.width,g.height,j),L=f):d.width>g.width?(L=f&&f instanceof s.e?E.m.CreateResizedCopy(f,d.width,d.height,!0):M(d.width,d.height,j),h=q):(h=q,L=f),{texture1:h,texture2:L}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(q,f,j,d){const g=new Array;if(!q&&!f)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const h=q?q.eq():f?f.eq():null;if(h){var L;const Q=this._resizeTexturesToSameDimensions(q,f,h),H=null===(L=Q.texture1)||void 0===L?void 0:L.getSize();let r,u;const X=H.width,z=H.height,B=await Q.texture1.readPixels(),D=await Q.texture2.readPixels();if(!B)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(r=o(B),!D)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");u=o(D);const i=u.byteLength,O=new Uint8Array(i),N=new Uint8Array(i),w=4,E=U;let s=0,S=0;for(let q=0;q<z;++q)for(let f=0;f<X;++f){const d=(X*q+f)*w,g={diffuseColor:new t.c(r[d],r[d+1],r[d+2]).toLinearSpace(h.getEngine().useExactSrgbConversions).multiply(j.diffuseColor),specularColor:new t.c(u[d],u[d+1],u[d+2]).toLinearSpace(h.getEngine().useExactSrgbConversions).multiply(j.specularColor),glossiness:u[d+3]*j.glossiness},L=this._convertSpecularGlossinessToMetallicRoughness(g);E.r=Math.max(E.r,L.baseColor.r),E.g=Math.max(E.g,L.baseColor.g),E.b=Math.max(E.b,L.baseColor.b),s=Math.max(s,L.metallic),S=Math.max(S,L.roughness),N[d]=255*L.baseColor.r,N[d+1]=255*L.baseColor.g,N[d+2]=255*L.baseColor.b,N[d+3]=Q.texture1.Rf?255*r[d+3]:255,O[d]=0,O[d+1]=255*L.roughness,O[d+2]=255*L.metallic,O[d+3]=255}const e={baseColor:E,metallic:s,roughness:S};let Z=!1,T=!1;for(let q=0;q<z;++q)for(let f=0;f<X;++f){const j=(X*q+f)*w;N[j]/=e.baseColor.r>I?e.baseColor.r:1,N[j+1]/=e.baseColor.g>I?e.baseColor.g:1,N[j+2]/=e.baseColor.b>I?e.baseColor.b:1;const d=t.c.FromInts(N[j],N[j+1],N[j+2]).toGammaSpace(h.getEngine().useExactSrgbConversions);N[j]=255*d.r,N[j+1]=255*d.g,N[j+2]=255*d.b,d.equalsWithEpsilon(n,I)||(T=!0),O[j+1]/=e.roughness>I?e.roughness:1,O[j+2]/=e.metallic>I?e.metallic:1;t.c.FromInts(255,O[j+1],O[j+2]).equalsWithEpsilon(n,I)||(Z=!0)}return Z&&g.push(this._getImageDataAsync(O,X,z,d).then((q=>{e.metallicRoughnessTextureData=q}))),T&&g.push(this._getImageDataAsync(N,X,z,d).then((q=>{e.baseColorTextureData=q}))),await Promise.all(g).then((()=>e))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(q){const f=this._getPerceivedBrightness(q.diffuseColor),j=this._getPerceivedBrightness(q.specularColor),d=1-this._getMaxComponent(q.specularColor),g=Y(f,j,d),h=q.diffuseColor.scale(d/(1-T.r)/Math.max(1-g)),L=q.specularColor.ej(T.scale(1-g)).scale(1/Math.max(g));let Q=t.c.Lerp(h,L,g*g);Q=Q.clampToRef(0,1,Q);return{baseColor:Q,metallic:g,roughness:1-q.glossiness}}_getPerceivedBrightness(q){return q?Math.sqrt(.299*q.r*q.r+.587*q.g*q.g+.114*q.b*q.b):0}_getMaxComponent(q){return q?Math.max(q.r,Math.max(q.g,q.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(q,f,j,d){const g=[],h={baseColor:q._albedoColor,metallic:q._metallic,roughness:q._roughness};if(d){q._albedoTexture&&g.push(this.exportTextureAsync(q._albedoTexture,f).then((q=>{q&&(j.baseColorTexture=q)})));const d=q._metallicTexture;d&&g.push(this.exportTextureAsync(d,f).then((q=>{q&&(j.metallicRoughnessTexture=q)})))}return g.length>0&&(this._exporter._materialNeedsUVsSet.add(q),await Promise.all(g)),h}_getTextureSampler(q){const f={};if(!q||!(q instanceof s.e))return f;const j=this._getGLTFTextureWrapMode(q.wrapU);10497!==j&&(f.wrapS=j);const d=this._getGLTFTextureWrapMode(q.wrapV);switch(10497!==d&&(f.wrapT=d),q.samplingMode){case s.e.LINEAR_LINEAR:f.magFilter=9729,f.minFilter=9729;break;case s.e.LINEAR_NEAREST:f.magFilter=9729,f.minFilter=9728;break;case s.e.NEAREST_LINEAR:f.magFilter=9728,f.minFilter=9729;break;case s.e.NEAREST_LINEAR_MIPLINEAR:f.magFilter=9728,f.minFilter=9987;break;case s.e.NEAREST_NEAREST:f.magFilter=9728,f.minFilter=9728;break;case s.e.NEAREST_LINEAR_MIPNEAREST:f.magFilter=9728,f.minFilter=9985;break;case s.e.LINEAR_NEAREST_MIPNEAREST:f.magFilter=9729,f.minFilter=9984;break;case s.e.LINEAR_NEAREST_MIPLINEAR:f.magFilter=9729,f.minFilter=9986;break;case s.e.NEAREST_NEAREST_MIPLINEAR:f.magFilter=9728,f.minFilter=9986;break;case s.e.LINEAR_LINEAR_MIPLINEAR:f.magFilter=9729,f.minFilter=9987;break;case s.e.LINEAR_LINEAR_MIPNEAREST:f.magFilter=9729,f.minFilter=9985;break;case s.e.NEAREST_NEAREST_MIPNEAREST:f.magFilter=9728,f.minFilter=9984}return f}_getGLTFTextureWrapMode(q){switch(q){case s.e.WRAP_ADDRESSMODE:return 10497;case s.e.CLAMP_ADDRESSMODE:return 33071;case s.e.MIRROR_ADDRESSMODE:return 33648;default:return g.h.Error(`Unsupported Texture Wrap Mode ${q}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(q,f,j,d){const g={diffuseColor:q._albedoColor,specularColor:q._reflectivityColor,glossiness:q._microSurface},h=q._albedoTexture,L=q._reflectivityTexture,Q=q._useMicroSurfaceFromReflectivityMapAlpha;if(L&&!Q)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((h||L)&&d){this._exporter._materialNeedsUVsSet.add(q);const d=this._exportTextureSampler(h||L),Q=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(h,L,g,f),H=this._exporter._textures;if(Q.baseColorTextureData){const q=this._exportImage(`baseColor${H.length}`,f,Q.baseColorTextureData);j.baseColorTexture=this._exportTextureInfo(q,d,null===h||void 0===h?void 0:h.coordinatesIndex)}if(Q.metallicRoughnessTextureData){const q=this._exportImage(`metallicRoughness${H.length}`,f,Q.metallicRoughnessTextureData);j.metallicRoughnessTexture=this._exportTextureInfo(q,d,null===L||void 0===L?void 0:L.coordinatesIndex)}return Q}return this._convertSpecularGlossinessToMetallicRoughness(g)}async exportPBRMaterialAsync(q,f,j){const d={},g={name:q.name},h=q.isMetallicWorkflow();if(h){const f=q._albedoColor,j=q.alpha;f&&(d.baseColorFactor=[f.r,f.g,f.b,j])}const L=h?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(q,f,d,j):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(q,f,d,j);await this._setMetallicRoughnessPbrMaterialAsync(L,q,g,d,f,j),await this._finishMaterialAsync(g,q,f);const Q=this._exporter._materials;return Q.push(g),Q.length-1}async _setMetallicRoughnessPbrMaterialAsync(q,f,j,d,h,L){if(F(j,f),q.baseColor.equalsWithEpsilon(n,I)&&w.WithinEpsilon(f.alpha,1,I)||(d.baseColorFactor=[q.baseColor.r,q.baseColor.g,q.baseColor.b,f.alpha]),null!=q.metallic&&1!==q.metallic&&(d.metallicFactor=q.metallic),null!=q.roughness&&1!==q.roughness&&(d.roughnessFactor=q.roughness),null==f.ef||f.ef||(f._twoSidedLighting||g.h.Warn(f.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),j.doubleSided=!0),L){const q=[],d=f._bumpTexture;d&&q.push(this.exportTextureAsync(d,h).then((q=>{q&&(j.normalTexture=q,1!==d.level&&(j.normalTexture.scale=d.level))})));const g=f._ambientTexture;g&&q.push(this.exportTextureAsync(g,h).then((q=>{if(q){const d={index:q.index,texCoord:q.texCoord,extensions:q.extensions};j.occlusionTexture=d;const g=f._ambientTextureStrength;g&&(d.strength=g)}})));const L=f._emissiveTexture;L&&q.push(this.exportTextureAsync(L,h).then((q=>{q&&(j.emissiveTexture=q)}))),q.length>0&&(this._exporter._materialNeedsUVsSet.add(f),await Promise.all(q))}const Q=f._emissiveColor;Q.equalsWithEpsilon(U,I)||(j.emissiveFactor=Q.Yf()),j.pbrMetallicRoughness=d}_getPixelsFromTextureAsync(q){return function(q){switch(q){case e.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case e.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case e.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case e.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case e.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case e.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case e.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case e.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case e.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case e.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case e.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case e.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case e.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case e.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case e.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case e.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case e.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case e.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case e.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case e.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case e.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(q.textureFormat)?(0,E.i)(q,q._texture.width,q._texture.height):(q.textureType,e.b.TEXTURETYPE_UNSIGNED_BYTE,q.readPixels())}async exportTextureAsync(q,f){const j=this._exporter._extensionsPreExportTextureAsync("exporter",q,f);return j?await j.then((async j=>j?await this._exportTextureInfoAsync(j,f):await this._exportTextureInfoAsync(q,f))):await this._exportTextureInfoAsync(q,f)}async _exportTextureInfoAsync(q,f){let j=this._textureMap.get(q);if(!j){const d=await this._getPixelsFromTextureAsync(q);if(!d)return null;const h=this._exportTextureSampler(q),L=q.mimeType;if(L)switch(L){case"image/jpeg":case"image/png":case"image/webp":f=L;break;default:g.h.Warn(`Unsupported media type: ${L}. Exporting texture as PNG.`)}const Q=this._internalTextureToImage,H=q.getInternalTexture().uniqueId;Q[H]||(Q[H]={});let r=Q[H][f];if(void 0===r){const j=q.getSize();r=(async()=>{const g=await this._getImageDataAsync(d,j.width,j.height,f);return this._exportImage(q.name,f,g)})(),Q[H][f]=r}j=this._exportTextureInfo(await r,h,q.coordinatesIndex),this._textureMap.set(q,j),this._exporter._extensionsPostExportTextures("exporter",j,q)}return j}_exportImage(q,f,j){const d=this._exporter._images;let h;if(this._exporter._shouldUseGlb){h={name:q,mimeType:f,bufferView:void 0};const d=this._exporter._bufferManager.createBufferView(new Uint8Array(j));this._exporter._bufferManager.setBufferView(h,d)}else{const L=q.replace(/\.\/|\/|\.\\|\\/g,"_"),Q=function(q){switch(q){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(f);let H=L+Q;d.some((q=>q.uri===H))&&(H=`${L}_${g.h.RandomId()}${Q}`),h={name:q,uri:H},this._exporter._imageData[H]={data:j,mimeType:f}}return d.push(h),d.length-1}_exportTextureInfo(q,f,j){const d=this._exporter._textures;let g=d.findIndex((j=>j.sampler==f&&j.source===q));-1===g&&(g=d.length,d.push({source:q,sampler:f}));const h={index:g};return j&&(h.texCoord=j),h}_exportTextureSampler(q){const f=this._getTextureSampler(q),j=this._exporter._samplers,d=j.findIndex((q=>q.minFilter===f.minFilter&&q.magFilter===f.magFilter&&q.wrapS===f.wrapS&&q.wrapT===f.wrapT));return-1!==d?d:(j.push(f),j.length-1)}}var x=j(11155),R=j(11005),A=j(11481),k=j(10950);const y=d.j.Zero(),p=d.e.Identity(),l=d.j.One(),V=new d.j(-1,1,1);function a(q,f){const{byteOffset:j,byteStride:d,type:g,normalized:h}=q,L=q.getSize(),Q=f.reduce(((q,f)=>f.getTotalVertices()>q?f.getTotalVertices():q),-Number.MAX_VALUE);return{byteOffset:j,byteStride:d,componentCount:L,type:g,count:Q*L,normalized:h,totalVertices:Q,kind:q.getKind()}}function P(q){switch(q){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function C(q){switch(q){case u.i.PositionKind:case u.i.NormalKind:case u.i.TangentKind:case u.i.ColorKind:case u.i.MatricesIndicesKind:case u.i.MatricesIndicesExtraKind:case u.i.MatricesWeightsKind:case u.i.MatricesWeightsExtraKind:case u.i.UVKind:case u.i.UV2Kind:case u.i.UV3Kind:case u.i.UV4Kind:case u.i.UV5Kind:case u.i.UV6Kind:return!0}return!1}function c(q){switch(q){case h.b.TriangleFillMode:return 4;case h.b.TriangleStripDrawMode:return 5;case h.b.TriangleFanDrawMode:return 6;case h.b.PointListDrawMode:case h.b.PointFillMode:return 0;case h.b.LineLoopDrawMode:return 2;case h.b.LineListDrawMode:return 1;case h.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${q}`)}function G(q){const f=Math.sqrt(q.x*q.x+q.y*q.y+q.z*q.z);f>0&&(q.x/=f,q.y/=f,q.z/=f)}function m(q){return q.x*=-1,q}function K(q){if(q.x*q.x+q.y*q.y>.5){const f=Math.abs(q.x),j=Math.abs(q.y);if(f>j){const j=Math.sign(q.x);q.x=f,q.y*=-j,q.z*=-j,q.w*=j}else{const f=Math.sign(q.y);q.x*=-f,q.y=j,q.z*=f,q.w*=-f}}else{const f=Math.abs(q.z),j=Math.abs(q.w);if(f>j){const j=Math.sign(q.z);q.x*=-j,q.y*=j,q.z=f,q.w*=-j}else{const f=Math.sign(q.w);q.x*=f,q.y*=-f,q.z*=-f,q.w=j}}return q}function J(q){q.Af(-q.z,q.w,q.x,-q.y)}function qq(q,f){const j=d.j.FromArrayToRef(f.translation||[0,0,0],0,d.f.kf[0]),g=d.e.FromArrayToRef(f.rotation||[0,0,0,1],0,d.f.Quaternion[0]),h=d.b.ComposeToRef(l,g,j,d.f.Matrix[0]),L=d.j.FromArrayToRef(q.translation||[0,0,0],0,d.f.kf[2]),Q=d.e.FromArrayToRef(q.rotation||[0,0,0,1],0,d.f.Quaternion[1]),H=d.b.ComposeToRef(l,Q,L,d.f.Matrix[1]);h.multiplyToRef(H,H),H.decompose(void 0,g,j),j.equalsWithEpsilon(y,k.d)?delete f.translation:f.translation=j.Yf(),g.equalsWithEpsilon(p,k.d)?delete f.rotation:f.rotation=g.Yf(),f.scale&&delete f.scale}function fq(q,f){if(!(f instanceof X.b))return!1;if(!(1===f.getChildren().length&&0===q.getChildren().length&&q.parent===f))return!1;const j=q.eq(),d=q instanceof A.b&&!j.useRightHandedSystem?V:l;return!!f.Vf.equalsWithEpsilon(d,k.d)||(R.e.Warn(`Cannot collapse node ${q.name} into parent node ${f.name} with modified scaling.`),!1)}function jq(q){if(q instanceof Array){const f=new Float32Array(q);return new Uint8Array(f.buffer,f.byteOffset,f.byteLength)}return ArrayBuffer.isView(q)?new Uint8Array(q.buffer,q.byteOffset,q.byteLength):new Uint8Array(q)}function dq(q,f){for(const[j,d]of Object.entries(q)){const g=f[j];(Array.isArray(d)&&Array.isArray(g)&&gq(d,g)||d===g)&&delete q[j]}return q}function gq(q,f){return q.length===f.length&&q.every(((q,j)=>q===f[j]))}const hq=d.b.Compose(new d.j(-1,1,1),d.e.Identity(),d.j.Zero());function Lq(q,f){if(!(q instanceof X.b))return!1;if(f){if(!q.getWorldMatrix().equalsWithEpsilon(d.b.IdentityReadOnly,k.d))return!1}else{if(!q.getWorldMatrix().multiplyToRef(hq,d.f.Matrix[0]).equalsWithEpsilon(d.b.IdentityReadOnly,k.d))return!1}return!(q instanceof z.e&&q.wf)}const Qq=new Map([[Int8Array,(q,f,j)=>q.setInt8(f,j)],[Uint8Array,(q,f,j)=>q.setUint8(f,j)],[Uint8ClampedArray,(q,f,j)=>q.setUint8(f,j)],[Int16Array,(q,f,j)=>q.setInt16(f,j,!0)],[Uint16Array,(q,f,j)=>q.setUint16(f,j,!0)],[Int32Array,(q,f,j)=>q.setInt32(f,j,!0)],[Uint32Array,(q,f,j)=>q.setUint32(f,j,!0)],[Float32Array,(q,f,j)=>q.setFloat32(f,j,!0)],[Float64Array,(q,f,j)=>q.setFloat64(f,j,!0)]]);class Hq{writeTypedArray(q){this._checkGrowBuffer(q.byteLength);const f=Qq.get(q.constructor);for(let j=0;j<q.length;j++)f(this._dataView,this._byteOffset,q[j]),this._byteOffset+=q.BYTES_PER_ELEMENT}constructor(q){this._data=new Uint8Array(q),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(q){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,q),this._byteOffset++}writeInt8(q){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,q),this._byteOffset++}writeInt16(q){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,q,!0),this._byteOffset+=2}writeUInt16(q){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,q,!0),this._byteOffset+=2}writeInt32(q){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,q,!0),this._byteOffset+=4}writeUInt32(q){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,q,!0),this._byteOffset+=4}writeFloat32(q){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,q,!0),this._byteOffset+=4}writeFloat64(q){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,q,!0),this._byteOffset+=8}_checkGrowBuffer(q){const f=this.byteOffset+q;if(f>this._data.byteLength){const q=new Uint8Array(2*f);q.set(this._data),this._data=q,this._dataView=new DataView(this._data.buffer)}}}function rq(q){return q%4===0?4:q%2===0?2:1}class uq{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(q){let f=0;this._bufferViewToData.forEach((q=>{f+=q.byteLength}));const j=new Hq(f),d=Array.from(this._bufferViewToData.keys()).sort(((q,f)=>rq(f.byteLength)-rq(q.byteLength)));for(const g of d){g.byteOffset=j.byteOffset,q.push(g);const f=q.length-1,d=this.getPropertiesWithBufferView(g);for(const q of d)q.bufferView=f;j.writeTypedArray(this._bufferViewToData.get(g)),this._bufferViewToData.delete(g)}return j.getOutputData()}createBufferView(q,f){const j={buffer:0,byteOffset:void 0,byteLength:q.byteLength,byteStride:f};return this._bufferViewToData.set(j,q),j}createAccessor(q,f,j,d,g,h,L){this._verifyBufferView(q);const Q={bufferView:void 0,componentType:j,count:d,type:f,min:null===h||void 0===h?void 0:h.min,max:null===h||void 0===h?void 0:h.max,normalized:L,byteOffset:g};return this.setBufferView(Q,q),this._accessorToBufferView.set(Q,q),Q}setBufferView(q,f){this._verifyBufferView(f);this.getPropertiesWithBufferView(f).push(q)}removeBufferView(q){const f=this.getPropertiesWithBufferView(q);for(const j of f)void 0!==j.bufferView&&delete j.bufferView;this._bufferViewToData.delete(q),this._bufferViewToProperties.delete(q),this._accessorToBufferView.forEach(((f,j)=>{f===q&&(void 0!==j.byteOffset&&delete j.byteOffset,this._accessorToBufferView.delete(j))}))}getBufferView(q){const f=this._accessorToBufferView.get(q);return this._verifyBufferView(f),f}getPropertiesWithBufferView(q){return this._verifyBufferView(q),this._bufferViewToProperties.set(q,this._bufferViewToProperties.get(q)??[]),this._bufferViewToProperties.get(q)}getData(q){return this._verifyBufferView(q),this._bufferViewToData.get(q)}_verifyBufferView(q){if(void 0===q||!this._bufferViewToData.has(q))throw new Error(`BufferView ${q} not found in BufferManager.`)}}var Xq,zq=j(11293),Bq=j(11320),Dq=j(11483),iq=j(11603),tq=j(11609),Oq=j(11623),Nq=j(11289),wq=j(11632);!function(q){q[q.INTANGENT=0]="INTANGENT",q[q.OUTTANGENT=1]="OUTTANGENT"}(Xq||(Xq={}));class Eq{static _IsTransformable(q){return q&&(q instanceof X.b||q instanceof zq.d||q instanceof wq.e)}static _CreateNodeAnimation(q,f,j,d,h){if(this._IsTransformable(q)){const L=[],Q=[],H=f.getKeys(),r=Eq._CalculateMinMaxKeyFrames(H),u=Eq._DeduceInterpolation(H,j,d),X=u.interpolationType,z=u.shouldBakeAnimation;if(z?Eq._CreateBakedAnimation(q,f,j,r.min,r.max,f.framePerSecond,h,L,Q,r,d):"LINEAR"===X||"STEP"===X?Eq._CreateLinearOrStepAnimation(q,f,j,L,Q,d):"CUBICSPLINE"===X?Eq._CreateCubicSplineAnimation(q,f,j,L,Q,d):Eq._CreateBakedAnimation(q,f,j,r.min,r.max,f.framePerSecond,h,L,Q,r,d),L.length&&Q.length){return{inputs:L,outputs:Q,samplerInterpolation:X,inputsMin:z?r.min:g.h.FloatRound(r.min/f.framePerSecond),inputsMax:z?r.max:g.h.FloatRound(r.max/f.framePerSecond)}}}return null}static _DeduceAnimationInfo(q){let f=null,j="VEC3",d=!1;const h=q.targetProperty.split(".");switch(h[0]){case"Vf":f="scale";break;case"position":f="translation";break;case"rotation":j="VEC4",f="rotation";break;case"rotationQuaternion":j="VEC4",d=!0,f="rotation";break;case"influence":j="SCALAR",f="weights";break;default:g.h.Error(`Unsupported animatable property ${h[0]}`)}return f?{animationChannelTargetPath:f,dataAccessorType:j,useQuaternion:d}:(g.h.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(q,f,j,d,g,h,L,Q,H,r,u){let X;if(Eq._IsTransformable(q)&&q.animations)for(const z of q.animations){if(u&&!u(z))continue;const g=Eq._DeduceAnimationInfo(z);g&&(X={name:z.name,samplers:[],channels:[]},Eq._AddAnimation(`${z.name}`,z.hasRunningRuntimeAnimations?f:X,q,z,g.dataAccessorType,g.animationChannelTargetPath,d,h,L,Q,g.useQuaternion,H,r),X.samplers.length&&X.channels.length&&j.push(X))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(q,f,j,d,g,h,L,Q,H,r,u){let X;if(q instanceof Nq.e){const g=q.morphTargetManager;if(g)for(let z=0;z<g.numTargets;++z){const B=g.getTarget(z);for(const D of B.animations){if(u&&!u(D))continue;const B=new tq.e(`${D.name}`,"influence",D.framePerSecond,D.dataType,D.loopMode,D.enableBlending),i=[],t=D.getKeys();for(let q=0;q<t.length;++q){const f=t[q];for(let q=0;q<g.numTargets;++q)q==z?i.push(f):i.push({frame:f.frame,value:0})}B.setKeys(i);const O=Eq._DeduceAnimationInfo(B);O&&(X={name:B.name,samplers:[],channels:[]},Eq._AddAnimation(D.name,D.hasRunningRuntimeAnimations?f:X,q,B,O.dataAccessorType,O.animationChannelTargetPath,d,h,L,Q,O.useQuaternion,H,r,g.numTargets),X.samplers.length&&X.channels.length&&j.push(X))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(q,f,j,d,g,h,L,Q,H){let r;if(q.animationGroups){const X=q.animationGroups;for(const z of X){const X=new Map,B=new Map,D=new Set,i=z.to-z.from;r={name:z.name,channels:[],samplers:[]};for(let f=0;f<z.targetedAnimations.length;++f){const i=z.targetedAnimations[f],t=i.target,O=i.animation;if(H&&!H(O))continue;const N=Q.has(t);if(this._IsTransformable(t)||1===t.length&&this._IsTransformable(t[0])){const q=Eq._DeduceAnimationInfo(i.animation);if(q){const f=this._IsTransformable(t)?t:this._IsTransformable(t[0])?t[0]:null;f&&Eq._AddAnimation(`${O.name}`,r,f,O,q.dataAccessorType,q.animationChannelTargetPath,j,d,g,h,q.useQuaternion,L,N)}}else if(t instanceof Oq.d||1===t.length&&t[0]instanceof Oq.d){if(Eq._DeduceAnimationInfo(i.animation)){const f=t instanceof Oq.d?t:t[0];if(f){const j=q.morphTargetManagers.find((q=>{for(let j=0;j<q.numTargets;++j)if(q.getTarget(j)===f)return!0;return!1}));if(j){const d=q.meshes.find((q=>q.morphTargetManager===j));var u;if(d)X.has(d)||X.set(d,new Map),null===(u=X.get(d))||void 0===u||u.set(f,O),D.add(d),B.set(d,O)}}}}}D.forEach((q=>{const f=q.morphTargetManager;let Q=null;const H=[],u=B.get(q).getKeys(),D=u.length;for(let j=0;j<D;++j)for(let d=0;d<f.numTargets;++d){const g=f.getTarget(d),h=X.get(q);if(h){const f=h.get(g);f?(Q||(Q=new tq.e(`${z.name}_${q.name}_MorphWeightAnimation`,"influence",f.framePerSecond,tq.e.ANIMATIONTYPE_FLOAT,f.loopMode,f.enableBlending)),H.push(f.getKeys()[j])):H.push({frame:z.from+i/D*j,value:g.influence,inTangent:u[0].inTangent?0:void 0,outTangent:u[0].outTangent?0:void 0})}}Q.setKeys(H);const t=Eq._DeduceAnimationInfo(Q);t&&Eq._AddAnimation(`${z.name}_${q.name}_MorphWeightAnimation`,r,q,Q,t.dataAccessorType,t.animationChannelTargetPath,j,d,g,h,t.useQuaternion,L,!1,null===f||void 0===f?void 0:f.numTargets)})),r.channels.length&&r.samplers.length&&f.push(r)}}}static _AddAnimation(q,f,j,g,h,L,Q,H,r,u,X,z,B,D){const i=Eq._CreateNodeAnimation(j,g,L,X,z);let t,O,N,w,E,s;if(i){if(D){let q=0,f=0;const j=[];for(;i.inputs.length>0;)f=i.inputs.shift(),q%D==0&&j.push(f),q++;i.inputs=j}const q=Q.get(j),g=new Float32Array(i.inputs);t=H.createBufferView(g),O=H.createAccessor(t,"SCALAR",5126,i.inputs.length,void 0,{min:[i.inputsMin],max:[i.inputsMax]}),u.push(O),N=u.length-1;const r=new d.e,X=new d.j,z=new d.j,S=j instanceof zq.d,e=P(h),Z=new Float32Array(i.outputs.length*e);i.outputs.forEach((function(q,f){let j=q;switch(L){case"translation":B&&(d.j.FromArrayToRef(q,0,z),m(z),z.toArray(j));break;case"rotation":4===q.length?d.e.FromArrayToRef(q,0,r):(j=new Array(4),d.j.FromArrayToRef(q,0,X),d.e.FromEulerVectorToRef(X,r)),B&&(K(r),S&&J(r)),r.toArray(j)}Z.set(j,f*e)})),t=H.createBufferView(Z),O=H.createAccessor(t,h,5126,i.outputs.length),u.push(O),w=u.length-1,E={interpolation:i.samplerInterpolation,input:N,output:w},f.samplers.push(E),s={sampler:f.samplers.length-1,target:{node:q,path:L}},f.channels.push(s)}}static _CreateBakedAnimation(q,f,j,h,L,Q,H,r,u,X,z){let B;const D=d.e.Identity();let i,t=null,O=null,N=null,w=null,E=null,s=null;X.min=g.h.FloatRound(h/Q);const S=f.getKeys();for(let d=0,e=S.length;d<e;++d){if(s=null,N=S[d],d+1<e)if(w=S[d+1],N.value.equals&&N.value.equals(w.value)||N.value===w.value){if(0!==d)continue;s=N.frame}else s=w.frame;else{if(E=S[d-1],N.value.equals&&N.value.equals(E.value)||N.value===E.value)continue;s=L}if(s)for(let d=N.frame;d<=s;d+=H){if(i=g.h.FloatRound(d/Q),i===t)continue;t=i,O=i;const h={key:0,repeatCount:0,loopMode:f.loopMode};B=f._interpolate(d,h),Eq._SetInterpolatedValue(q,B,i,f,j,D,r,u,z)}}O&&(X.max=O)}static _ConvertFactorToVector3OrQuaternion(q,f,j,h,L){const Q=Eq._GetBasePositionRotationOrScale(f,h,L),H=j.targetProperty.split("."),r=H?H[1]:"",u=L?d.e.Pf(Q).normalize():d.j.Pf(Q);switch(r){case"x":case"y":case"z":u[r]=q;break;case"w":u.w=q;break;default:g.h.Error(`glTFAnimation: Unsupported component name "${r}"!`)}return u}static _SetInterpolatedValue(q,f,j,g,h,L,Q,H,r){let u;Q.push(j),"weights"!==h?(g.dataType===tq.e.ANIMATIONTYPE_FLOAT&&(f=this._ConvertFactorToVector3OrQuaternion(f,q,g,h,r)),"rotation"===h?(r?L=f:(u=f,d.e.RotationYawPitchRollToRef(u.y,u.x,u.z,L)),H.push(L.Yf())):(u=f,H.push(u.Yf()))):H.push([f])}static _CreateLinearOrStepAnimation(q,f,j,d,g,h){for(const L of f.getKeys())d.push(L.frame/f.framePerSecond),Eq._AddKeyframeValue(L,f,g,j,q,h)}static _CreateCubicSplineAnimation(q,f,j,d,g,h){f.getKeys().forEach((function(L){d.push(L.frame/f.framePerSecond),Eq._AddSplineTangent(Xq.INTANGENT,g,j,"CUBICSPLINE",L,h),Eq._AddKeyframeValue(L,f,g,j,q,h),Eq._AddSplineTangent(Xq.OUTTANGENT,g,j,"CUBICSPLINE",L,h)}))}static _GetBasePositionRotationOrScale(q,f,j){let g;if("rotation"===f)if(j){g=(q.rotationQuaternion??d.e.Identity()).Yf()}else{g=(q.rotation??d.j.Zero()).Yf()}else if("translation"===f){g=(q.position??d.j.Zero()).Yf()}else{g=(q.Vf??d.j.One()).Yf()}return g}static _AddKeyframeValue(q,f,j,h,L,Q){let H;const r=f.dataType;if(r===tq.e.ANIMATIONTYPE_VECTOR3){let f=q.value.Yf();if("rotation"===h){const q=d.j.Pf(f);f=d.e.RotationYawPitchRoll(q.y,q.x,q.z).Yf()}j.push(f)}else if(r===tq.e.ANIMATIONTYPE_FLOAT){if("weights"===h)j.push([q.value]);else if(H=this._ConvertFactorToVector3OrQuaternion(q.value,L,f,h,Q),H){if("rotation"===h){const q=Q?H:d.e.RotationYawPitchRoll(H.y,H.x,H.z).normalize();j.push(q.Yf())}j.push(H.Yf())}}else r===tq.e.ANIMATIONTYPE_QUATERNION?j.push(q.value.normalize().Yf()):g.h.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(q,f,j){let d,g,h=!1;if("rotation"===f&&!j)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let L=0,Q=q.length;L<Q;++L)if(g=q[L],g.inTangent||g.outTangent)if(d){if("CUBICSPLINE"!==d){d="LINEAR",h=!0;break}}else d="CUBICSPLINE";else if(d){if("CUBICSPLINE"===d||g.interpolation&&1===g.interpolation&&"STEP"!==d){d="LINEAR",h=!0;break}}else d=g.interpolation&&1===g.interpolation?"STEP":"LINEAR";return d||(d="LINEAR"),{interpolationType:d,shouldBakeAnimation:h}}static _AddSplineTangent(q,f,j,g,h,L){let Q;const H=q===Xq.INTANGENT?h.inTangent:h.outTangent;if("CUBICSPLINE"===g){if("rotation"===j)if(H)if(L)Q=H.Yf();else{const q=H;Q=d.e.RotationYawPitchRoll(q.y,q.x,q.z).Yf()}else Q=[0,0,0,0];else Q="weights"===j?H?[H]:[0]:H?H.Yf():[0,0,0];f.push(Q)}}static _CalculateMinMaxKeyFrames(q){let f=1/0,j=-1/0;return q.forEach((function(q){f=Math.min(f,q.frame),j=Math.max(j,q.frame)})),{min:f,max:j}}}function sq(q,f,j,h,L,Q){const H={attributes:{},influence:q.influence,name:q.name},r=f.wf;if(!r)return g.h.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),H;const X=Q?-1:1,z=d.j.Zero();let B=0,D=0;if(q.hasPositions){const h=q.getPositions(),Q=r.getVerticesData(u.i.PositionKind);if(Q){const q=new Float32Array(Q.length),f=[1/0,1/0,1/0],g=[-1/0,-1/0,-1/0];D=Q.length/3,B=0;for(let j=B;j<D;++j){const L=d.j.Pf(Q,3*j);d.j.Pf(h,3*j).subtractToRef(L,z),z.x*=X,f[0]=Math.min(f[0],z.x),g[0]=Math.max(g[0],z.x),f[1]=Math.min(f[1],z.y),g[1]=Math.max(g[1],z.y),f[2]=Math.min(f[2],z.z),g[2]=Math.max(g[2],z.z),q[3*j]=z.x,q[3*j+1]=z.y,q[3*j+2]=z.z}const r=j.createBufferView(q,12),u=j.createAccessor(r,"VEC3",5126,h.length/3,0,{min:f,max:g});L.push(u),H.attributes.POSITION=L.length-1}else g.h.Warn(`Morph target positions for mesh ${f.name} were not exported. Mesh does not have position vertex data`)}if(q.hasNormals){const h=q.getNormals(),Q=r.getVerticesData(u.i.NormalKind);if(Q){const q=new Float32Array(Q.length);D=Q.length/3,B=0;for(let j=B;j<D;++j){const f=d.j.Pf(Q,3*j).normalize();d.j.Pf(h,3*j).normalize().subtractToRef(f,z),q[3*j]=z.x*X,q[3*j+1]=z.y,q[3*j+2]=z.z}const f=j.createBufferView(q,12),g=j.createAccessor(f,"VEC3",5126,h.length/3,0);L.push(g),H.attributes.NORMAL=L.length-1}else g.h.Warn(`Morph target normals for mesh ${f.name} were not exported. Mesh does not have normals vertex data`)}if(q.hasTangents){const h=q.getTangents(),Q=r.getVerticesData(u.i.TangentKind);if(Q){D=Q.length/4;const q=new Float32Array(3*D);B=0;for(let j=B;j<D;++j){const f=d.j.Pf(Q,4*j);G(f);const g=d.j.Pf(h,3*j);G(g),g.subtractToRef(f,z),q[3*j]=z.x*X,q[3*j+1]=z.y,q[3*j+2]=z.z}const f=j.createBufferView(q,12),g=j.createAccessor(f,"VEC3",5126,D,0);L.push(g),H.attributes.TANGENT=L.length-1}else g.h.Warn(`Morph target tangents for mesh ${f.name} were not exported. Mesh does not have tangents vertex data`)}if(q.hasColors){const h=q.getColors(),Q=r.getVerticesData(u.i.ColorKind),X=r.getVertexBuffer(u.i.ColorKind);if(Q&&X){const q=X.getSize();D=Q.length/q;const f=new Float32Array(D*q);B=0;for(let j=B;j<D;++j)if(3===q){const g=d.j.Pf(Q,j*q);d.j.Pf(h,j*q).subtractToRef(g,z),f[3*j]=z.x,f[3*j+1]=z.y,f[3*j+2]=z.z}else if(4===q){const g=new d.m,L=d.m.Pf(Q,j*q);d.m.Pf(h,j*q).subtractToRef(L,g),f[4*j]=g.x,f[4*j+1]=g.y,f[4*j+2]=g.z,f[4*j+3]=g.w}else g.h.Warn(`Unsupported number of components for color attribute: ${q}`);const r=j.createBufferView(f,4*q),u=j.createAccessor(r,3===q?"VEC3":"VEC4",5126,D,0);L.push(u),H.attributes.COLOR_0=L.length-1}else g.h.Warn(`Morph target colors for mesh ${f.name} were not exported. Mesh does not have colors vertex data`)}return H}var Sq=j(11634),eq=j(11551),Zq=j(11549),Iq=j(10965);class Tq{}Tq.DEFAULT_COLOR=t.c.White(),Tq.DEFAULT_WIDTH_ATTENUATED=1,Tq.DEFAULT_WIDTH=.1;var Wq=j(11402),nq=j(11649);class Uq{static ConvertPoints(q,f){if(q.length&&Array.isArray(q)&&"number"===typeof q[0])return[q];if(q.length&&Array.isArray(q[0])&&"number"===typeof q[0][0])return q;if(q.length&&!Array.isArray(q[0])&&q[0]instanceof d.j){const f=[];for(let j=0;j<q.length;j++){const d=q[j];f.push(d.x,d.y,d.z)}return[f]}if(q.length>0&&Array.isArray(q[0])&&q[0].length>0&&q[0][0]instanceof d.j){const f=[],j=q;for(const q of j)f.push(q.flatMap((q=>[q.x,q.y,q.z])));return f}if(q instanceof Float32Array){if(null!==f&&void 0!==f&&f.floatArrayStride){const j=[],d=3*f.floatArrayStride;for(let f=0;f<q.length;f+=d){const g=new Array(d);for(let j=0;j<d;j++)g[j]=q[f+j];j.push(g)}return j}return[Array.from(q)]}if(q.length&&q[0]instanceof Float32Array){const f=[];for(const j of q)f.push(Array.from(j));return f}return[]}static OmitZeroLengthPredicate(q,f,j){const d=[];return f.ej(q).lengthSquared()>0&&d.push([q,f]),j.ej(f).lengthSquared()>0&&d.push([f,j]),q.ej(j).lengthSquared()>0&&d.push([j,q]),0===d.length?null:d}static OmitDuplicatesPredicate(q,f,j,d){const g=[];return Uq._SearchInPoints(q,f,d)||g.push([q,f]),Uq._SearchInPoints(f,j,d)||g.push([f,j]),Uq._SearchInPoints(j,q,d)||g.push([j,q]),0===g.length?null:g}static _SearchInPoints(q,f,j){for(const L of j)for(let j=0;j<L.length;j++){var d,g,h;if(null!==(d=L[j])&&void 0!==d&&d.equals(q))if(null!==(g=L[j+1])&&void 0!==g&&g.equals(f)||null!==(h=L[j-1])&&void 0!==h&&h.equals(f))return!0}return!1}static MeshesToLines(q,f){const j=[];for(let g=0;g<q.length;g++){const h=q[g],L=h.getVerticesData(u.i.PositionKind),Q=h.sf();if(L&&Q)for(let q=0,H=0;q<Q.length;q++){const r=3*Q[H++],u=3*Q[H++],X=3*Q[H++],z=new d.j(L[r],L[r+1],L[r+2]),B=new d.j(L[u],L[u+1],L[u+2]),D=new d.j(L[X],L[X+1],L[X+2]);if(f){const d=f(z,B,D,j,q,r,h,g,L,Q);if(d)for(const q of d)j.push(q)}else j.push([z,B],[B,D],[D,z])}}return j}static ToVector3Array(q){if(Array.isArray(q[0])){const f=[],j=q;for(const q of j){const j=[];for(let f=0;f<q.length;f+=3)j.push(new d.j(q[f],q[f+1],q[f+2]));f.push(j)}return f}const f=q,j=[];for(let g=0;g<f.length;g+=3)j.push(new d.j(f[g],f[g+1],f[g+2]));return j}static ToNumberArray(q){return q.flatMap((q=>[q.x,q.y,q.z]))}static GetPointsCountInfo(q){const f=new Array(q.length);let j=0;for(let d=q.length;d--;)f[d]=q[d].length/3,j+=f[d];return{total:j,counts:f}}static GetLineLength(q){if(0===q.length)return 0;let f;f="number"===typeof q[0]?Uq.ToVector3Array(q):q;const j=d.f.kf[0];let g=0;for(let d=0;d<f.length-1;d++){const q=f[d];g+=f[d+1].subtractToRef(q,j).length()}return g}static GetLineLengthArray(q){const f=new Float32Array(q.length/3);let j=0;for(let d=0,g=q.length/3-1;d<g;d++){let g=q[3*d+0],h=q[3*d+1],L=q[3*d+2];g-=q[3*d+3],h-=q[3*d+4],L-=q[3*d+5];j+=Math.sqrt(g*g+h*h+L*L),f[d+1]=j}return f}static SegmentizeSegmentByCount(q,f,j){const g=[],h=f.ej(q),L=d.f.kf[0];L.cf(j);const Q=d.f.kf[1];h.divideToRef(L,Q);let H=q.clone();g.push(H);for(let d=0;d<j;d++)H=H.clone(),g.push(H.addInPlace(Q));return g}static SegmentizeLineBySegmentLength(q,f){const j=q[0]instanceof d.j?Uq.GetLineSegments(q):"number"===typeof q[0]?Uq.GetLineSegments(Uq.ToVector3Array(q)):q,g=[];for(const d of j)if(d.length>f){const q=Uq.SegmentizeSegmentByCount(d.point1,d.point2,Math.ceil(d.length/f));for(const f of q)g.push(f)}else g.push(d.point1),g.push(d.point2);return g}static SegmentizeLineBySegmentCount(q,f){const j="number"===typeof q[0]?Uq.ToVector3Array(q):q,d=Uq.GetLineLength(j)/f;return Uq.SegmentizeLineBySegmentLength(j,d)}static GetLineSegments(q){const f=[];for(let j=0;j<q.length-1;j++){const d=q[j],g=q[j+1],h=g.ej(d).length();f.push({point1:d,point2:g,length:h})}return f}static GetMinMaxSegmentLength(q){const f=Uq.GetLineSegments(q).sort((q=>q.length));return{min:f[0].length,max:f[f.length-1].length}}static GetPositionOnLineByVisibility(q,f,j){let g=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const h=f*j;let L=0,Q=0;const H=q.length;for(let d=0;d<H;d++){if(h<=L+q[d].length){Q=d;break}L+=q[d].length}const r=(h-L)/q[Q].length;return q[Q].point2.subtractToRef(q[Q].point1,d.f.kf[0]),d.f.kf[1]=d.f.kf[0].multiplyByFloats(r,r,r),g||d.f.kf[1].addInPlace(q[Q].point1),d.f.kf[1].clone()}static GetCircleLinePoints(q,f){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:q,h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/f;const L=[];for(let Q=0;Q<=f;Q++)L.push(new d.j(Math.cos(Q*h)*q,Math.sin(Q*h)*g,j));return L}static GetBezierLinePoints(q,f,j,d){return Wq.f.CreateQuadraticBezier(q,f,j,d).getPoints().flatMap((q=>[q.x,q.y,q.z]))}static GetArrowCap(q,f,j,d,g){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,L=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[q.clone(),q.add(f.multiplyByFloats(j,j,j))],widths:[d,g,h,L]}}static GetPointsFromText(q,f,j,d){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,h=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const L=[],Q=(0,nq.b)(q,f,j,d);for(const H of Q){for(const q of H.paths){const f=[],j=q.getPoints();for(const q of j)f.push(q.x,q.y,g);L.push(f)}if(h)for(const q of H.holes){const f=[],j=q.getPoints();for(const q of j)f.push(q.x,q.y,g);L.push(f)}}return L}static Color3toRGBAUint8(q){const f=new Uint8Array(4*q.length);for(let j=0,d=0;j<q.length;j++)f[d++]=255*q[j].r,f[d++]=255*q[j].g,f[d++]=255*q[j].b,f[d++]=255;return f}static CreateColorsTexture(q,f,j,d){const g=d.getEngine().getCaps().maxTextureSize??1,h=f.length>g?g:f.length,L=Math.ceil(f.length/g);L>1&&(f=[...f,...Array(h*L-f.length).fill(f[0])]);const Q=Uq.Color3toRGBAUint8(f),H=new S.c(Q,h,L,D.d.TEXTUREFORMAT_RGBA,d,!1,!0,j);return H.name=q,H}static PrepareEmptyColorsTexture(q){if(!Tq.EmptyColorsTexture){const f=new Uint8Array(4);Tq.EmptyColorsTexture=new S.c(f,1,1,D.d.TEXTUREFORMAT_RGBA,q,!1,!1,S.c.NEAREST_NEAREST),Tq.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Tq.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var q;null===(q=Tq.EmptyColorsTexture)||void 0===q||q.dispose(),Tq.EmptyColorsTexture=null}static BooleanToNumber(q){return q?1:0}}class Yq extends Zq.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class vq extends eq.e{isCompatible(q){return!0}constructor(q,f,j){var g;j=j||{color:Tq.DEFAULT_COLOR};const h=new Yq;h.GREASED_LINE_HAS_COLOR=!!j.color&&!j.useColors,h.GREASED_LINE_SIZE_ATTENUATION=j.sizeAttenuation??!1,h.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===j.colorDistributionType,h.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(f??q.eq()).useRightHandedSystem,h.GREASED_LINE_CAMERA_FACING=j.cameraFacing??!0,super(q,vq.GREASED_LINE_MATERIAL_NAME,200,h,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(g=j)||void 0===g?void 0:g.forceGLSL)||vq.ForceGLSL,this._scene=f??q.eq(),this._engine=this._scene.getEngine(),this._cameraFacing=j.cameraFacing??!0,this.visibility=j.visibility??1,this.useDash=j.useDash??!1,this.dashRatio=j.dashRatio??.5,this.dashOffset=j.dashOffset??0,this.width=j.width?j.width:j.sizeAttenuation?Tq.DEFAULT_WIDTH_ATTENUATED:Tq.DEFAULT_WIDTH,this._sizeAttenuation=j.sizeAttenuation??!1,this.colorMode=j.colorMode??0,this._color=j.color??null,this.useColors=j.useColors??!1,this._colorsDistributionType=j.colorDistributionType??0,this.colorsSampling=j.colorsSampling??S.c.NEAREST_NEAREST,this._colors=j.Wq??null,this.dashCount=j.dashCount??1,this.resolution=j.resolution??new d.i(this._engine.getRenderWidth(),this._engine.getRenderHeight()),j.colorsTexture?this.colorsTexture=j.colorsTexture:this._colors?this.colorsTexture=Uq.CreateColorsTexture(`${q.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Tq.DEFAULT_COLOR,Uq.PrepareEmptyColorsTexture(this._scene)),this._engine.qd.add((()=>{Uq.DisposeEmptyColorsTexture()}))}getAttributes(q){q.push("grl_offsets"),q.push("grl_widths"),q.push("grl_colorPointers"),q.push("grl_counters"),this._cameraFacing?(q.push("grl_previousAndSide"),q.push("grl_nextAndCounters")):q.push("grl_slopes")}getSamplers(q){q.push("grl_colors")}getActiveTextures(q){this.colorsTexture&&q.push(this.colorsTexture)}getUniforms(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const f=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&f.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===q&&f.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:f,vertex:this._cameraFacing&&this._isGLSL(q)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(q)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(q){if(this._cameraFacing){q.jd("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||q.jd("viewProjection",this._scene.getTransformMatrix());const f=d.f.Vector4[0];f.x=this._aspect,f.y=this._resolution.x,f.z=this._resolution.y,f.w=this.width,q.updateVector4("grl_aspect_resolution_lineWidth",f)}const f=d.f.Vector4[0];f.x=Uq.BooleanToNumber(this.useDash),f.y=this._dashArray,f.z=this.dashOffset,f.w=this.dashRatio,q.updateVector4("grl_dashOptions",f);const j=d.f.Vector4[1];j.x=this.colorMode,j.y=this.visibility,j.z=this.colorsTexture?this.colorsTexture.getSize().width:0,j.w=Uq.BooleanToNumber(this.useColors),q.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",j),this._color&&q.updateColor3("grl_singleColor",this._color);const g=this.colorsTexture??Tq.EmptyColorsTexture;q.setTexture("grl_colors",g),q.updateFloat2("grl_textureSize",(null===g||void 0===g?void 0:g.getSize().width)??1,(null===g||void 0===g?void 0:g.getSize().height)??1)}prepareDefines(q,f,j){q.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,q.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,q.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,q.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=f.useRightHandedSystem,q.GREASED_LINE_CAMERA_FACING=this._cameraFacing,q.GREASED_LINE_USE_OFFSETS=!!j.offsets}getClassName(){return vq.GREASED_LINE_MATERIAL_NAME}getCustomCode(q){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(f)?function(q,f){if("vertex"===q){const q={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return f&&(q["!gl_Position\\=viewProjection\\*worldPos;"]="//"),q}return"fragment"===q?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(q,this._cameraFacing):function(q,f){if("vertex"===q){const q={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return f&&(q["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),q}return"fragment"===q?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(q,this._cameraFacing)}dispose(){var q;null===(q=this.colorsTexture)||void 0===q||q.dispose(),super.dispose()}get Wq(){return this._colors}set Wq(q){this.setColors(q)}setColors(q){var f;let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1],d=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const g=(null===(f=this._colors)||void 0===f?void 0:f.length)??0;var h;if(this._colors=q,null!==q&&0!==q.length){if(!j||d)if(this.colorsTexture&&g===q.length&&!d){const f=Uq.Color3toRGBAUint8(q);this.colorsTexture.update(f)}else{var L;null===(L=this.colorsTexture)||void 0===L||L.dispose(),this.colorsTexture=Uq.CreateColorsTexture(`${this._material.name}-colors-texture`,q,this.colorsSampling,this._scene)}}else null===(h=this.colorsTexture)||void 0===h||h.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(q){this._dashCount=q,this._dashArray=1/q}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(q){this._sizeAttenuation=q,this.markAllDefinesAsDirty()}get color(){return this._color}set color(q){this.setColor(q)}setColor(q){let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==q||null!==this._color&&null===q?(this._color=q,f||this.markAllDefinesAsDirty()):this._color=q}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(q){this._colorsDistributionType=q,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(q){this._aspect=q.x/q.y,this._resolution=q}serialize(){const q=super.serialize(),f={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(f.Wq=this._colors),this._color&&(f.color=this._color),q.greasedLineMaterialOptions=f,q}parse(q,f,j){var d;super.parse(q,f,j);const g=q.greasedLineMaterialOptions;null===(d=this.colorsTexture)||void 0===d||d.dispose(),g.color&&this.setColor(g.color,!0),g.colorDistributionType&&(this.colorsDistributionType=g.colorDistributionType),g.Wq&&(this.Wq=g.Wq),g.colorsSampling&&(this.colorsSampling=g.colorsSampling),g.colorMode&&(this.colorMode=g.colorMode),g.useColors&&(this.useColors=g.useColors),g.visibility&&(this.visibility=g.visibility),g.useDash&&(this.useDash=g.useDash),g.dashCount&&(this.dashCount=g.dashCount),g.dashRatio&&(this.dashRatio=g.dashRatio),g.dashOffset&&(this.dashOffset=g.dashOffset),g.width&&(this.width=g.width),g.sizeAttenuation&&(this.sizeAttenuation=g.sizeAttenuation),g.resolution&&(this.resolution=g.resolution),this.Wq?this.colorsTexture=Uq.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Wq,this.colorsSampling,f):Uq.PrepareEmptyColorsTexture(f),this.markAllDefinesAsDirty()}copyTo(q){var f;const j=q;null===(f=j.colorsTexture)||void 0===f||f.dispose(),this._colors&&(j.colorsTexture=Uq.CreateColorsTexture(`${j._material.name}-colors-texture`,this._colors,j.colorsSampling,this._scene)),j.setColor(this.color,!0),j.colorsDistributionType=this.colorsDistributionType,j.colorsSampling=this.colorsSampling,j.colorMode=this.colorMode,j.useColors=this.useColors,j.visibility=this.visibility,j.useDash=this.useDash,j.dashCount=this.dashCount,j.dashRatio=this.dashRatio,j.dashOffset=this.dashOffset,j.width=this.width,j.sizeAttenuation=this.sizeAttenuation,j.resolution=this.resolution,j.markAllDefinesAsDirty()}_isGLSL(q){return 0===q||this._forceGLSL}}vq.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",vq.ForceGLSL=!1,(0,Iq.f)(`BABYLON.${vq.GREASED_LINE_MATERIAL_NAME}`,vq);var Fq=j(11257),Mq=j(11011),oq=j(11642),bq=j(11093);class xq extends oq.d{constructor(q,f,g){const h=f.getEngine(),L=h.isWebGPU&&!(g.forceGLSL||xq.ForceGLSL),Q=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];f.useRightHandedSystem&&Q.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const H=["position","grl_widths","grl_offsets","grl_colorPointers"];g.cameraFacing?(Q.push("GREASED_LINE_CAMERA_FACING"),H.push("grl_previousAndSide","grl_nextAndCounters")):(H.push("grl_slopes"),H.push("grl_counters"));const r=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(L||r.push("world","viewProjection","view","projection"),super(q,f,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:L?["Scene","Mesh"]:void 0,attributes:H,uniforms:r,samplers:L?[]:["grlColors"],defines:Q,extraInitializationsAsync:async()=>{L?await Promise.all([j.e(47).then(j.bind(j,14087)),j.e(55).then(j.bind(j,14093))]):await Promise.all([j.e(50).then(j.bind(j,14095)),j.e(56).then(j.bind(j,14101))])},shaderLanguage:L?1:0}),this._color=t.c.White(),this._colorsDistributionType=0,this._colorsTexture=null,g=g||{color:Tq.DEFAULT_COLOR},this.visibility=g.visibility??1,this.useDash=g.useDash??!1,this.dashRatio=g.dashRatio??.5,this.dashOffset=g.dashOffset??0,this.dashCount=g.dashCount??1,this.width=g.width?g.width:g.sizeAttenuation&&g.cameraFacing?Tq.DEFAULT_WIDTH_ATTENUATED:Tq.DEFAULT_WIDTH,this.sizeAttenuation=g.sizeAttenuation??!1,this.color=g.color??t.c.White(),this.useColors=g.useColors??!1,this.colorsDistributionType=g.colorDistributionType??0,this.colorsSampling=g.colorsSampling??S.c.NEAREST_NEAREST,this.colorMode=g.colorMode??0,this._colors=g.Wq??null,this._cameraFacing=g.cameraFacing??!0,this.resolution=g.resolution??new d.i(h.getRenderWidth(),h.getRenderHeight()),g.colorsTexture?this.colorsTexture=g.colorsTexture:this._colors?this.colorsTexture=Uq.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,f):(this._color=this._color??Tq.DEFAULT_COLOR,this.colorsTexture=Uq.PrepareEmptyColorsTexture(f)),L){const q=new bq.b;q.setParameters(),q.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",q)}h.qd.add((()=>{Uq.DisposeEmptyColorsTexture()}))}dispose(){var q;null===(q=this._colorsTexture)||void 0===q||q.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new d.i(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Wq(){return this._colors}set Wq(q){this.setColors(q)}setColors(q){var f;let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1],d=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const g=(null===(f=this._colors)||void 0===f?void 0:f.length)??0;var h;if(this._colors=q,null!==q&&0!==q.length){if(!j||d)if(this._colorsTexture&&g===q.length&&!d){const f=Uq.Color3toRGBAUint8(q);this._colorsTexture.update(f)}else{var L;null===(L=this._colorsTexture)||void 0===L||L.dispose(),this.colorsTexture=Uq.CreateColorsTexture(`${this.name}-colors-texture`,q,this.colorsSampling,this.eq())}}else null===(h=this._colorsTexture)||void 0===h||h.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(q){this._colorsTexture=q,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(q){this._width=q,this.setFloat("grlWidth",q)}get useColors(){return this._useColors}set useColors(q){this._useColors=q,this.setFloat("grlUseColors",Uq.BooleanToNumber(q))}get colorsSampling(){return this._colorsSampling}set colorsSampling(q){this._colorsSampling=q}get visibility(){return this._visibility}set visibility(q){this._visibility=q,this.setFloat("grlVisibility",q)}get useDash(){return this._useDash}set useDash(q){this._useDash=q,this.setFloat("grlUseDash",Uq.BooleanToNumber(q))}get dashOffset(){return this._dashOffset}set dashOffset(q){this._dashOffset=q,this.setFloat("grlDashOffset",q)}get dashRatio(){return this._dashRatio}set dashRatio(q){this._dashRatio=q,this.setFloat("grlDashRatio",q)}get dashCount(){return this._dashCount}set dashCount(q){this._dashCount=q,this._dashArray=1/q,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(q){this._sizeAttenuation=q,this.setFloat("grlSizeAttenuation",Uq.BooleanToNumber(q))}get color(){return this._color}set color(q){this.setColor(q)}setColor(q){q=q??Tq.DEFAULT_COLOR,this._color=q,this.setColor3("grlColor",q)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(q){this._colorsDistributionType=q,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(q){this._colorMode=q,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(q){this._resolution=q,this.setVector2("grlResolution",q),this.setFloat("grlAspect",q.x/q.y)}serialize(){const q=super.serialize(),f={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(f.Wq=this._colors),q.greasedLineMaterialOptions=f,q}parse(q,f,j){var d;const g=q.greasedLineMaterialOptions;null===(d=this._colorsTexture)||void 0===d||d.dispose(),g.color&&(this.color=g.color),g.colorDistributionType&&(this.colorsDistributionType=g.colorDistributionType),g.colorsSampling&&(this.colorsSampling=g.colorsSampling),g.colorMode&&(this.colorMode=g.colorMode),g.useColors&&(this.useColors=g.useColors),g.visibility&&(this.visibility=g.visibility),g.useDash&&(this.useDash=g.useDash),g.dashCount&&(this.dashCount=g.dashCount),g.dashRatio&&(this.dashRatio=g.dashRatio),g.dashOffset&&(this.dashOffset=g.dashOffset),g.width&&(this.width=g.width),g.sizeAttenuation&&(this.sizeAttenuation=g.sizeAttenuation),g.resolution&&(this.resolution=g.resolution),g.Wq?this.colorsTexture=Uq.CreateColorsTexture(`${this.name}-colors-texture`,g.Wq,this.colorsSampling,this.eq()):this.colorsTexture=Uq.PrepareEmptyColorsTexture(f),this._cameraFacing=g.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Rq,Aq,kq;xq.ForceGLSL=!1,function(q){q[q.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",q[q.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Rq||(Rq={})),function(q){q[q.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",q[q.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",q[q.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Aq||(Aq={})),function(q){q[q.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",q[q.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",q[q.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",q[q.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",q[q.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(kq||(kq={}));class yq extends Nq.e{constructor(q,f,j){super(q,f,null,null,!1,!1),this.name=q,this._options=j,this._lazy=!1,this._updatable=!1,this._engine=f.getEngine(),this._lazy=j.lazy??!1,this._updatable=j.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=j.colorPointers??[],this._widths=j.widths??new Array(j.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(q){let f=0;for(const d of this._points)f+=d.length;const j=f/3*2-this._widths.length;for(let d=0;d<j;d++)this._widths.push(q)}updateLazy(){var q,f;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(q=this._options.ribbonOptions)||void 0===q?void 0:q.smoothShading),!this.vq&&this.refreshBoundingInfo(),null===(f=this.greasedLineMaterial)||void 0===f||f.updateLazy()}addPoints(q,f){for(const j of q)this._points.push(j);this._lazy||this.setPoints(this._points,f)}dispose(q){let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(q,f)}isLazy(){return this._lazy}get nq(){return this._uvs}set nq(q){this._uvs=q instanceof Float32Array?q:new Float32Array(q),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(q){this.material instanceof xq&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===q||void 0===q?void 0:q.length)>0),this._offsets=q,this._offsetsBuffer?this._offsetsBuffer.update(q):this._createOffsetsBuffer(q)}get widths(){return this._widths}set widths(q){this._widths=q,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(q)}get colorPointers(){return this._colorPointers}set colorPointers(q){this._colorPointers=q,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(q)}get greasedLineMaterial(){var q,f;if(this.material&&this.material instanceof xq)return this.material;const j=null===(q=this.material)||void 0===q||null===(f=q.pluginManager)||void 0===f?void 0:f.getPlugin(vq.GREASED_LINE_MATERIAL_NAME);return j||void 0}get points(){const q=[];return Mq.e.DeepCopy(this._points,q),q}setPoints(q,f){this._points=Uq.ConvertPoints(q,(null===f||void 0===f?void 0:f.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==f&&void 0!==f&&f.colorPointers||this._updateColorPointers(),this._setPoints(this._points,f)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,nq:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(q){super.serialize(q),q.type=this.getClassName(),q.lineOptions=this._createLineOptions()}_createVertexBuffers(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const f=new Fq.e;return f.Iq=this._vertexPositions,f.indices=this._indices,f.nq=this._uvs,q&&(f.Tq=[],Fq.e.ComputeNormals(this._vertexPositions,this._indices,f.Tq)),f.Yq(this,this._options.updatable),f}_createOffsetsBuffer(q){const f=this._scene.getEngine(),j=new u.e(f,q,this._updatable,3);this.setVerticesBuffer(j.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=j}}class pq{constructor(q,f){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=q,this.wasAddedByNoopNode=f}getIndicesAccessor(q,f,j,d,g){var h,L,Q,H;return null===(h=this._indicesAccessorMap.get(q))||void 0===h||null===(L=h.get(f))||void 0===L||null===(Q=L.get(j))||void 0===Q||null===(H=Q.get(d))||void 0===H?void 0:H.get(g)}setIndicesAccessor(q,f,j,d,g,h){let L=this._indicesAccessorMap.get(q);L||(L=new Map,this._indicesAccessorMap.set(q,L));let Q=L.get(f);Q||(Q=new Map,L.set(f,Q));let H=Q.get(j);H||(H=new Map,Q.set(j,H));let r=H.get(d);r||(r=new Map,H.set(d,r)),r.set(g,h)}pushExportedNode(q){this._exportedNodes.has(q)||this._exportedNodes.add(q)}getNodesSet(){return this._exportedNodes}getVertexBufferView(q){return this._vertexBufferViewMap.get(q)}setVertexBufferView(q,f){this._vertexBufferViewMap.set(q,f)}setRemappedBufferView(q,f,j){this._remappedBufferView.set(q,new Map),this._remappedBufferView.get(q).set(f,j)}getRemappedBufferView(q,f){var j;return null===(j=this._remappedBufferView.get(q))||void 0===j?void 0:j.get(f)}getVertexAccessor(q,f,j){var d,g;return null===(d=this._vertexAccessorMap.get(q))||void 0===d||null===(g=d.get(f))||void 0===g?void 0:g.get(j)}setVertexAccessor(q,f,j,d){let g=this._vertexAccessorMap.get(q);g||(g=new Map,this._vertexAccessorMap.set(q,g));let h=g.get(f);h||(h=new Map,g.set(f,h)),h.set(j,d)}hasVertexColorAlpha(q){return this._vertexMapColorAlpha.get(q)||!1}setHasVertexColorAlpha(q,f){return this._vertexMapColorAlpha.set(q,f)}getMesh(q){return this._meshMap.get(q)}setMesh(q,f){this._meshMap.set(q,f)}bindMorphDataToMesh(q,f){const j=this._meshMorphTargetMap.get(q)||[];this._meshMorphTargetMap.set(q,j),-1===j.indexOf(f)&&j.push(f)}getMorphTargetsFromMesh(q){return this._meshMorphTargetMap.get(q)}}class lq{_ApplyExtension(q,f,j,d){if(j>=f.length)return Promise.resolve(q);const g=d(f[j],q);return g?g.then((async q=>q?await this._ApplyExtension(q,f,j+1,d):null)):this._ApplyExtension(q,f,j+1,d)}_ApplyExtensions(q,f){const j=[];for(const d of lq._ExtensionNames)j.push(this._extensions[d]);return this._ApplyExtension(q,j,0,f)}_extensionsPreExportTextureAsync(q,f,j){return this._ApplyExtensions(f,((f,d)=>f.preExportTextureAsync&&f.preExportTextureAsync(q,d,j)))}_extensionsPostExportNodeAsync(q,f,j,d,g){return this._ApplyExtensions(f,((f,h)=>f.postExportNodeAsync&&f.postExportNodeAsync(q,h,j,d,g,this._bufferManager)))}_extensionsPostExportMaterialAsync(q,f,j){return this._ApplyExtensions(f,((f,d)=>f.postExportMaterialAsync&&f.postExportMaterialAsync(q,d,j)))}_extensionsPostExportMaterialAdditionalTextures(q,f,j){const d=[];for(const g of lq._ExtensionNames){const h=this._extensions[g];h.postExportMaterialAdditionalTextures&&d.push(...h.postExportMaterialAdditionalTextures(q,f,j))}return d}_extensionsPostExportTextures(q,f,j){for(const d of lq._ExtensionNames){const g=this._extensions[d];g.postExportTexture&&g.postExportTexture(q,f,j)}}_extensionsPostExportMeshPrimitive(q){for(const f of lq._ExtensionNames){const j=this._extensions[f];j.postExportMeshPrimitive&&j.postExportMeshPrimitive(q,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const q of lq._ExtensionNames){const f=this._extensions[q];f.preGenerateBinaryAsync&&await f.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(q){for(const f of lq._ExtensionNames){const j=this._extensions[f];j.enabled&&q(j)}}_extensionsOnExporting(){this._forEachExtensions((q=>{var f,j,d;q.wasUsed&&((f=this._glTF).extensionsUsed||(f.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(q.name)&&this._glTF.extensionsUsed.push(q.name),q.required&&((j=this._glTF).extensionsRequired||(j.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(q.name)&&this._glTF.extensionsRequired.push(q.name)),(d=this._glTF).extensions||(d.extensions={}),q.onExporting&&q.onExporting())}))}_loadExtensions(){for(const q of lq._ExtensionNames){const f=lq._ExtensionFactories[q](this);this._extensions[q]=f}}constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:i.d.LastCreatedScene,f=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${D.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new b(this),this._extensions={},this._bufferManager=new uq,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!q)throw new Error("No scene available to export");this._babylonScene=q,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:q=>{var f;return null===q||void 0===q||null===(f=q.dd)||void 0===f?void 0:f.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...f},this._loadExtensions()}dispose(){for(const q in this._extensions){this._extensions[q].dispose()}}get options(){return this._options}static RegisterExtension(q,f){lq.UnregisterExtension(q)&&g.h.Warn(`Extension with the name ${q} already exists`),lq._ExtensionFactories[q]=f,lq._ExtensionNames.push(q)}static UnregisterExtension(q){if(!lq._ExtensionFactories[q])return!1;delete lq._ExtensionFactories[q];const f=lq._ExtensionNames.indexOf(q);return-1!==f&&lq._ExtensionNames.splice(f,1),!0}_generateJSON(q,f,j){const d={byteLength:q};return d.byteLength&&(this._glTF.buffers=[d]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Sf=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(d.uri=f+".bin"),j?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(q){const f=await this._generateBinaryAsync();this._extensionsOnExporting();const j=this._generateJSON(f.byteLength,q,!0),d=new Blob([f],{type:"application/octet-stream"}),g=q+".gltf",h=q+".bin",L=new r;if(L.files[g]=j,L.files[h]=d,this._imageData)for(const Q in this._imageData)L.files[Q]=new Blob([this._imageData[Q].data],{type:this._imageData[Q].mimeType});return L}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(q){const f=q%4;return 0===f?f:4-f}async generateGLBAsync(q){this._shouldUseGlb=!0;const f=await this._generateBinaryAsync();this._extensionsOnExporting();const j=this._generateJSON(f.byteLength),d=q+".glb";let g,h=j.length;if("undefined"!==typeof TextEncoder){g=(new TextEncoder).encode(j),h=g.length}const L=this._getPadding(h),Q=this._getPadding(f.byteLength),H=28+h+L+f.byteLength+Q,u=new Hq(H);if(u.writeUInt32(1179937895),u.writeUInt32(2),u.writeUInt32(H),u.writeUInt32(h+L),u.writeUInt32(1313821514),g)u.writeTypedArray(g);else{const q="_".charCodeAt(0);for(let f=0;f<h;++f){const d=j.charCodeAt(f);d!=j.codePointAt(f)?u.writeUInt8(q):u.writeUInt8(d)}}for(let r=0;r<L;++r)u.writeUInt8(32);u.writeUInt32(f.byteLength+Q),u.writeUInt32(5130562),u.writeTypedArray(f);for(let r=0;r<Q;++r)u.writeUInt8(0);const X=new r;return X.files[d]=new Blob([u.getOutputData()],{type:"application/octet-stream"}),X}_setNodeTransformation(q,f,j){if(f.getPivotPoint().equalsWithEpsilon(y,k.d)||g.h.Warn("Pivot points are not supported in the glTF serializer"),!f.position.equalsWithEpsilon(y,k.d)){const g=d.f.kf[0].H(f.position);j&&m(g),q.translation=g.Yf()}f.Vf.equalsWithEpsilon(l,k.d)||(q.scale=f.Vf.Yf());const h=f.rotationQuaternion||d.e.FromEulerAngles(f.rotation.x,f.rotation.y,f.rotation.z);h.equalsWithEpsilon(p,k.d)||(j&&K(h),q.rotation=h.normalize().Yf())}_setCameraTransformation(q,f,j){if(!f.position.equalsWithEpsilon(y,k.d)){const g=d.f.kf[0].H(f.position);j&&m(g),q.translation=g.Yf()}const g=f.rotationQuaternion||d.e.FromEulerAngles(f.rotation.x,f.rotation.y,f.rotation.z);j&&K(g),this._babylonScene.useRightHandedSystem||J(g),g.equalsWithEpsilon(p,k.d)||(q.rotation=g.Yf())}_listAvailableCameras(){for(const q of this._babylonScene.cameras){const f={type:q.mode===zq.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(q.name&&(f.name=q.name),"perspective"===f.type)f.perspective={aspectRatio:q.getEngine().getAspectRatio(q),yfov:q.fovMode===zq.d.FOVMODE_VERTICAL_FIXED?q.fov:q.fov*q.getEngine().getAspectRatio(q),znear:q.gd,zfar:q.maxZ};else if("orthographic"===f.type){const j=q.orthoLeft&&q.orthoRight?.5*(q.orthoRight-q.orthoLeft):.5*q.getEngine().getRenderWidth(),d=q.orthoBottom&&q.orthoTop?.5*(q.orthoTop-q.orthoBottom):.5*q.getEngine().getRenderHeight();f.orthographic={xmag:j,ymag:d,znear:q.gd,zfar:q.maxZ}}this._camerasMap.set(q,f)}}_exportAndAssignCameras(){const q=Array.from(this._camerasMap.values());for(const f of q){const q=this._nodesCameraMap.get(f);if(void 0!==q){this._cameras.push(f);for(const f of q)f.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const q of this._babylonScene.skeletons){if(q.bones.length<=0)continue;const f={joints:[]};this._skinMap.set(q,f)}}_exportAndAssignSkeletons(){for(const q of this._babylonScene.skeletons){if(q.bones.length<=0)continue;const f=this._skinMap.get(q);if(void 0==f)continue;const j={},d=[];let h=-1;for(let g=0;g<q.bones.length;++g){const f=q.bones[g],d=f.getIndex()??g;-1!==d&&(j[d]=f,d>h&&(h=d))}for(let q=0;q<=h;++q){const h=j[q];d.push(h.getAbsoluteInverseBindMatrix());const L=h.getTransformNode();if(null!==L){const q=this._nodeMap.get(L);L&&null!==q&&void 0!==q?f.joints.push(q):g.h.Warn("Exporting a bone without a linked transform node is currently unsupported")}else g.h.Warn("Exporting a bone without a linked transform node is currently unsupported")}const L=this._nodesSkinMap.get(f);if(f.joints.length>0&&void 0!==L){const q=64*d.length,j=new Float32Array(q/4);d.forEach(((q,f)=>{j.set(q.m,16*f)}));const g=this._bufferManager.createBufferView(j);this._accessors.push(this._bufferManager.createAccessor(g,"MAT4",5126,d.length)),f.inverseBindMatrices=this._accessors.length-1,this._skins.push(f);for(const f of L)f.skin=this._skins.length-1}}}async _exportSceneAsync(){const q={nodes:[]};if(this._babylonScene.metadata){const f=this._options.metadataSelector(this._babylonScene.metadata);f&&(q.extras=f)}const f=new Array,j=new Array,d=new Array;for(const Q of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Lq(Q,this._babylonScene.useRightHandedSystem)?d.push(...Q.getChildren()):this._babylonScene.useRightHandedSystem?f.push(Q):j.push(Q);this._listAvailableCameras(),this._listAvailableSkeletons();const g=new pq(!0,!1);q.nodes.push(...await this._exportNodesAsync(j,g));const h=new pq(!1,!1);q.nodes.push(...await this._exportNodesAsync(f,h));const L=new pq(!1,!0);q.nodes.push(...await this._exportNodesAsync(d,L)),q.nodes.length&&this._scenes.push(q),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Eq._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,g.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(q){let f=this._shouldExportNodeMap.get(q);return void 0===f&&(f=this._options.shouldExportNode(q),this._shouldExportNodeMap.set(q,f)),f}async _exportNodesAsync(q,f){const j=new Array;this._exportBuffers(q,f);for(const d of q)await this._exportNodeAsync(d,j,f);return j}_collectBuffers(q,f,j,d,g){if(this._shouldExportNode(q)&&q instanceof z.e&&q.wf){const h=q.wf.getVertexBuffers();if(h)for(const d in h){if(!C(d))continue;const L=h[d];g.setHasVertexColorAlpha(L,q.hasVertexAlpha);const Q=L._buffer,H=f.get(Q)||[];f.set(Q,H),-1===H.indexOf(L)&&H.push(L);const r=j.get(L)||[];j.set(L,r),-1===r.indexOf(q)&&r.push(q)}const L=q.morphTargetManager;if(L)for(let f=0;f<L.numTargets;f++){const j=L.getTarget(f),g=d.get(j)||[];d.set(j,g),-1===g.indexOf(q)&&g.push(q)}}for(const h of q.getChildren())this._collectBuffers(h,f,j,d,g)}_exportBuffers(q,f){const j=new Map,d=new Map,g=new Map;for(const Q of q)this._collectBuffers(Q,j,d,g,f);const h=Array.from(j.keys());for(const Q of h){const q=Q.getData();if(!q)throw new Error("Buffer data is not available");const g=j.get(Q);if(!g)continue;const h=g[0].byteStride;if(g.some((q=>q.byteStride!==h)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const L=jq(q).slice();for(const f of g){const q=d.get(f),{byteOffset:j,byteStride:g,componentCount:h,type:Q,count:H,normalized:r,kind:X}=a(f,q);switch(X){case u.i.NormalKind:case u.i.TangentKind:(0,x.k)(L,j,g,h,Q,H,r,(q=>{const f=Math.sqrt(q[0]*q[0]+q[1]*q[1]+q[2]*q[2]);if(f>0){const j=1/f;q[0]*=j,q[1]*=j,q[2]*=j}}));break;case u.i.ColorKind:{const f=q.filter((q=>q.material instanceof iq.b||null==q.material)).length;if(0==f)break;if(f!=q.length){R.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}Q==u.i.UNSIGNED_BYTE&&R.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const d=new t.c,X=new t.e,z=this._babylonScene.getEngine().useExactSrgbConversions;(0,x.k)(L,j,g,h,Q,H,r,(q=>{3===q.length?(d.Zj(q,0),d.toLinearSpaceToRef(d,z),d.toArray(q,0)):(X.Zj(q,0),X.toLinearSpaceToRef(X,z),X.toArray(q,0))}))}}}if(f.convertToRightHanded){for(const q of g){const f=d.get(q),{byteOffset:j,byteStride:g,componentCount:h,type:Q,count:H,normalized:r,kind:X}=a(q,f);switch(X){case u.i.PositionKind:case u.i.NormalKind:case u.i.TangentKind:(0,x.k)(L,j,g,h,Q,H,r,(q=>{q[0]=-q[0]}))}}f.convertedToRightHandedBuffers.set(Q,L)}const H=this._bufferManager.createBufferView(L,h);f.setVertexBufferView(Q,H);const r=new Map;for(const f of g){const q=d.get(f),{kind:j,totalVertices:g}=a(f,q);switch(j){case u.i.MatricesIndicesKind:case u.i.MatricesIndicesExtraKind:if(f.type==u.i.FLOAT){const q=f.getFloatData(g);null!==q&&r.set(f,q)}}}0!==r.size&&R.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const X=Array.from(r.keys());for(const j of X){const q=r.get(j);if(!q)continue;const d=q.some((q=>q>=256)),g=new(d?Uint16Array:Uint8Array)(q.length);for(let f=0;f<q.length;f++)g[f]=q[f];const h=this._bufferManager.createBufferView(g,4*(d?2:1));f.setRemappedBufferView(Q,j,h)}}const L=Array.from(g.keys());for(const Q of L){const q=g.get(Q);if(!q)continue;const j=sq(Q,q[0],this._bufferManager,this._bufferViews,this._accessors,f.convertToRightHanded);for(const d of q)f.bindMorphDataToMesh(d,j)}}async _exportNodeAsync(q,f,j){let d=this._nodeMap.get(q);if(void 0!==d)return void(f.includes(d)||f.push(d));const g=await this._createNodeAsync(q,j);if(g){d=this._nodes.length,this._nodes.push(g),this._nodeMap.set(q,d),j.pushExportedNode(q),f.push(d);const h={name:"runtime animations",channels:[],samplers:[]},L=[];this._babylonScene.animationGroups.length||(Eq._CreateMorphTargetAnimationFromMorphTargetAnimations(q,h,L,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,j.convertToRightHanded,this._options.shouldExportAnimation),q.animations.length&&Eq._CreateNodeAnimationFromNodeAnimations(q,h,L,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,j.convertToRightHanded,this._options.shouldExportAnimation)),h.channels.length&&h.samplers.length&&this._animations.push(h),L.forEach((q=>{q.channels.length&&q.samplers.length&&this._animations.push(q)}))}const h=g?[]:f;for(const L of q.getChildren())await this._exportNodeAsync(L,h,j);g&&h.length&&(g.children=h)}async _createNodeAsync(q,f){if(!this._shouldExportNode(q))return null;const j={};if(q.name&&(j.name=q.name),q.metadata){const f=this._options.metadataSelector(q.metadata);f&&(j.extras=f)}if(q instanceof X.b&&(this._setNodeTransformation(j,q,f.convertToRightHanded),q instanceof z.e)){const g=q instanceof B.d?q.sourceMesh:q;if(g.Qd&&g.Qd.length>0&&(j.mesh=await this._exportMeshAsync(g,f)),q.skeleton){const f=this._skinMap.get(q.skeleton);var d;if(void 0!==f)void 0===this._nodesSkinMap.get(f)&&this._nodesSkinMap.set(f,[]),null===(d=this._nodesSkinMap.get(f))||void 0===d||d.push(j)}}if(q instanceof A.b){const d=this._camerasMap.get(q);if(d){var g;void 0===this._nodesCameraMap.get(d)&&this._nodesCameraMap.set(d,[]),this._setCameraTransformation(j,q,f.convertToRightHanded);const L=q.parent;if(null!==L&&fq(q,L)){const q=this._nodeMap.get(L);if(void 0!==q){var h;const f=this._nodes[q];return qq(j,f),null===(h=this._nodesCameraMap.get(d))||void 0===h||h.push(f),null}}null===(g=this._nodesCameraMap.get(d))||void 0===g||g.push(j)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",j,q,this._nodeMap,f.convertToRightHanded)?j:(R.e.Warn(`Not exporting node ${q.name}`),null)}_exportIndices(q,f,j,d,g,L,Q,H,r){let u=q;r.mode=c(L);const X=Q!==h.b.CounterClockWiseSideOrientation,z=!H.wasAddedByNoopNode&&X,B=function(q){switch(q){case h.b.TriangleFillMode:case h.b.TriangleStripDrawMode:case h.b.TriangleFanDrawMode:return!0}return!1}(L)&&z;if(B){if(L===h.b.TriangleStripDrawMode||L===h.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");r.mode=c(L);const Q=f?new Uint32Array(d):new Uint16Array(d);if(q)for(let f=0;f+2<d;f+=3)Q[f]=q[j+f]+g,Q[f+1]=q[j+f+2]+g,Q[f+2]=q[j+f+1]+g;else for(let q=0;q+2<d;q+=3)Q[q]=q,Q[q+1]=q+2,Q[q+2]=q+1;u=Q}else if(q&&0!==g){const h=f?new Uint32Array(d):new Uint16Array(d);for(let f=0;f<d;f++)h[f]=q[j+f]+g;u=h}if(u){let h=H.getIndicesAccessor(q,j,d,g,B);if(void 0===h){const L=function(q,f,j,d){if(q instanceof Uint16Array||q instanceof Uint32Array)return q;if(q instanceof Int32Array)return new Uint32Array(q.buffer,q.byteOffset,q.length);const g=q.slice(f,f+j);return d?new Uint32Array(g):new Uint16Array(g)}(u,0,d,f),Q=this._bufferManager.createBufferView(L),r=f?5125:5123;this._accessors.push(this._bufferManager.createAccessor(Q,"SCALAR",r,d,0)),h=this._accessors.length-1,H.setIndicesAccessor(q,j,d,g,B,h)}r.indices=h}}_exportVertexBuffer(q,f,j,d,g,h){const L=q.getKind();if(!C(L))return;if(L.startsWith("uv")&&!this._options.exportUnusedUVs&&(!f||!this._materialNeedsUVsSet.has(f)))return;let Q=g.getVertexAccessor(q,j,d);if(void 0===Q){const f=g.convertedToRightHandedBuffers.get(q._buffer)||q._buffer.getData(),h=L===u.i.PositionKind?function(q,f,j,d){const{byteOffset:g,byteStride:h,type:L,normalized:Q}=f,H=f.getSize(),r=new Array(H).fill(1/0),u=new Array(H).fill(-1/0);return(0,x.k)(q,g+j*h,h,H,L,d*H,Q,(q=>{for(let f=0;f<H;f++)r[f]=Math.min(r[f],q[f]),u[f]=Math.max(u[f],q[f])})),{min:r,max:u}}(f,q,j,d):void 0,H=(L===u.i.MatricesIndicesKind||L===u.i.MatricesIndicesExtraKind)&&q.type===u.i.FLOAT,r=H?u.i.UNSIGNED_BYTE:q.type,X=H?void 0:q.normalized,z=H?g.getRemappedBufferView(q._buffer,q):g.getVertexBufferView(q._buffer),B=q.byteOffset+j*q.byteStride;this._accessors.push(this._bufferManager.createAccessor(z,function(q,f){if(q==u.i.ColorKind)return f?"VEC4":"VEC3";switch(q){case u.i.PositionKind:case u.i.NormalKind:return"VEC3";case u.i.TangentKind:case u.i.MatricesIndicesKind:case u.i.MatricesIndicesExtraKind:case u.i.MatricesWeightsKind:case u.i.MatricesWeightsExtraKind:return"VEC4";case u.i.UVKind:case u.i.UV2Kind:case u.i.UV3Kind:case u.i.UV4Kind:case u.i.UV5Kind:case u.i.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${q}`)}(L,g.hasVertexColorAlpha(q)),r,d,B,h,X)),Q=this._accessors.length-1,g.setVertexAccessor(q,j,d,Q)}h.attributes[function(q){switch(q){case u.i.PositionKind:return"POSITION";case u.i.NormalKind:return"NORMAL";case u.i.TangentKind:return"TANGENT";case u.i.ColorKind:return"COLOR_0";case u.i.UVKind:return"TEXCOORD_0";case u.i.UV2Kind:return"TEXCOORD_1";case u.i.UV3Kind:return"TEXCOORD_2";case u.i.UV4Kind:return"TEXCOORD_3";case u.i.UV5Kind:return"TEXCOORD_4";case u.i.UV6Kind:return"TEXCOORD_5";case u.i.MatricesIndicesKind:return"JOINTS_0";case u.i.MatricesIndicesExtraKind:return"JOINTS_1";case u.i.MatricesWeightsKind:return"WEIGHTS_0";case u.i.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${q}`)}(L)]=Q}async _exportMaterialAsync(q,f,j,d){let g=this._materialMap.get(q);if(void 0===g){const d=f&&Object.keys(f).some((q=>q.startsWith("uv")));if((q=q instanceof Bq.e?q.rd[j.materialIndex]:q)instanceof Dq.d)g=await this._materialExporter.exportPBRMaterialAsync(q,"image/png",d);else{if(!(q instanceof iq.b))return void R.e.Warn(`Unsupported material '${q.name}' with type ${q.getClassName()}`);g=await this._materialExporter.exportStandardMaterialAsync(q,"image/png",d)}this._materialMap.set(q,g)}d.material=g}async _exportMeshAsync(q,f){var j;let d=f.getMesh(q);if(void 0!==d)return d;const g={primitives:[]};d=this._meshes.length,this._meshes.push(g),f.setMesh(q,d);const L=q.isUnIndexed?null:q.sf(),Q=null===(j=q.wf)||void 0===j?void 0:j.getVertexBuffers(),H=f.getMorphTargetsFromMesh(q),r=q instanceof Sq.c,u=q instanceof yq,X=q.Qd;if(Q&&X&&X.length>0)for(const D of X){const j={attributes:{}},d=D.bq()||this._babylonScene.defaultMaterial;if(u){var z,B;const f={name:d.name},g=q,h=t.c.White(),L=(null===(z=g.material)||void 0===z?void 0:z.alpha)??1,Q=(null===(B=g.greasedLineMaterial)||void 0===B?void 0:B.color)??h;(!Q.equalsWithEpsilon(h,k.d)||L<1)&&(f.pbrMetallicRoughness={baseColorFactor:[...Q.Yf(),L]}),this._materials.push(f),j.material=this._materials.length-1}else if(r){const f={name:d.name},g=q;(!g.color.equalsWithEpsilon(t.c.White(),k.d)||g.alpha<1)&&(f.pbrMetallicRoughness={baseColorFactor:[...g.color.Yf(),g.alpha]}),this._materials.push(f),j.material=this._materials.length-1}else await this._exportMaterialAsync(d,Q,D,j);const X=r||u?h.b.LineListDrawMode:q.overrideRenderingFillMode??d.fillMode,i=d._getEffectiveOrientation(q);this._exportIndices(L,L?(0,x.d)(L,D.indexCount,D.indexStart,D.verticesStart):D.verticesCount>65535,L?D.indexStart:D.verticesStart,L?D.indexCount:D.verticesCount,-D.verticesStart,X,i,f,j);for(const q of Object.values(Q))this._exportVertexBuffer(q,d,D.verticesStart,D.verticesCount,f,j);if(H){j.targets=[];for(const q of H)j.targets.push(q.attributes)}g.primitives.push(j),this._extensionsPostExportMeshPrimitive(j)}if(H){g.weights=[],g.extras||(g.extras={}),g.extras.targetNames=[];for(const q of H)g.weights.push(q.influence),g.extras.targetNames.push(q.name)}return d}}lq._ExtensionNames=new Array,lq._ExtensionFactories={};class Vq{static async GLTFAsync(q,f,j){j&&j.exportWithoutWaitingForScene||await q.whenReadyAsync();const d=new lq(q,j),g=await d.generateGLTFAsync(f.replace(/\.[^/.]+$/,""));return d.dispose(),g}static async GLBAsync(q,f,j){j&&j.exportWithoutWaitingForScene||await q.whenReadyAsync();const d=new lq(q,j),g=await d.generateGLBAsync(f.replace(/\.[^/.]+$/,""));return d.dispose(),g}}j(11660);const aq="EXT_mesh_gpu_instancing";class Pq{constructor(q){this.name=aq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(q,f,j,g,h,L){return await new Promise((q=>{if(f&&j instanceof Nq.e&&j.hasThinInstances&&this._exporter){this._wasUsed=!0;const q=d.j.Zero(),g=d.e.Identity(),Q=d.j.One(),H=j.thinInstanceGetWorldMatrices(),r=d.f.kf[2],u=d.f.Quaternion[1],X=d.f.kf[3];let z=!1,B=!1,D=!1;const i=new Float32Array(3*j.ud),t=new Float32Array(4*j.ud),O=new Float32Array(3*j.ud);let N=0;for(const f of H)f.decompose(X,u,r),h&&(m(r),K(u)),i.set(r.Yf(),3*N),t.set(u.normalize().Yf(),4*N),O.set(X.Yf(),3*N),z=z||!r.equalsWithEpsilon(q),B=B||!u.equalsWithEpsilon(g),D=D||!X.equalsWithEpsilon(Q),N++;const w={attributes:{}};z&&(w.attributes.TRANSLATION=this._buildAccessor(i,"VEC3",j.ud,L)),B&&(w.attributes.ROTATION=this._buildAccessor(t,"VEC4",j.ud,L)),D&&(w.attributes.SCALE=this._buildAccessor(O,"VEC3",j.ud,L)),f.extensions=f.extensions||{},f.extensions[aq]=w}q(f)}))}_buildAccessor(q,f,j,d){const g=d.createBufferView(q),h=d.createAccessor(g,f,5126,j);return this._exporter._accessors.push(h),this._exporter._accessors.length-1}}lq.RegisterExtension(aq,(q=>new Pq(q)));var Cq=j(11669),cq=j(11684),Gq=j(11690),mq=j(11693);function Kq(q){return q===Gq.c.PositionKind?"POSITION":q===Gq.c.NormalKind?"NORMAL":q===Gq.c.ColorKind?"COLOR":q.startsWith(Gq.c.UVKind)?"TEX_COORD":"GENERIC"}const Jq={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class qf extends Cq.b{static get DefaultAvailable(){return(0,Cq.d)(qf.DefaultConfiguration)}static get Default(){return qf._Default??(qf._Default=new qf),qf._Default}static ResetDefault(q){qf._Default&&(q||qf._Default.dispose(),qf._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(q,f){return{module:await(f||DracoEncoderModule)({wasmBinary:q})}}_getWorkerContent(){return`${cq.g}(${cq.i})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:qf.DefaultConfiguration)}async _encodeAsync(q,f,j){const d=j?(0,mq.b)(Jq,j):Jq;if(this._workerPoolPromise){const j=await this._workerPoolPromise;return await new Promise(((g,h)=>{j.push(((j,L)=>{const Q=q=>{j.removeEventListener("error",Q),j.removeEventListener("message",H),h(q),L()},H=q=>{"encodeMeshDone"===q.data.id&&(j.removeEventListener("error",Q),j.removeEventListener("message",H),g(q.data.encodedMeshData),L())};j.addEventListener("error",Q),j.addEventListener("message",H);const r=[];for(const f of q)r.push(f.data.buffer);f&&r.push(f.buffer),j.postMessage({id:"encodeMesh",attributes:q,indices:f,options:d},r)}))}))}if(this._modulePromise){const j=await this._modulePromise;return(0,cq.g)(j.module,q,f,d)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(q,f){if(0==q.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");q instanceof Nq.e&&q.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===f||void 0===f?void 0:f.method)&&(R.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),f.method="MESH_SEQUENTIAL_ENCODING");const j=function(q){let f=q.sf(void 0,!0);return!f||f instanceof Uint32Array||f instanceof Uint16Array||(f=((0,x.d)(f,f.length)?Uint32Array:Uint16Array).from(f)),f}(q),d=function(q,f){const j=[];for(const d of q.getVerticesDataKinds()){if(null!==f&&void 0!==f&&f.includes(d)){if(d===Gq.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const g=q.getVertexBuffer(d),h=g.getSize(),L=(0,x.t)(g.getData(),h,g.type,g.byteOffset,g.byteStride,g.normalized,q.getTotalVertices(),!0);j.push({kind:d,dracoName:Kq(d),size:h,data:L})}return j}(q,null===f||void 0===f?void 0:f.excludedAttributes);return await this._encodeAsync(d,j,f)}}qf.DefaultConfiguration={wasmUrl:`${g.h._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${g.h._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${g.h._DefaultCdnUrl}/draco_encoder.js`},qf._Default=null;const ff="KHR_draco_mesh_compression";class jf{get wasUsed(){return this._wasUsed}constructor(q){this.name=ff,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===q.options.meshCompressionMethod&&qf.DefaultAvailable}dispose(){}postExportMeshPrimitive(q,f,j){if(!this.enabled)return;if(4!==q.mode&&5!==q.mode)return void R.e.Warn("Cannot compress primitive with mode "+q.mode+".");const d=[],g=[];let h=null;if(void 0!==q.indices){const L=j[q.indices],Q=f.getBufferView(L);h=f.getData(Q).slice(),d.push(Q),g.push(L)}const L=[];for(const[u,X]of Object.entries(q.attributes)){const q=j[X],h=f.getBufferView(q),H=P(q.type),r=(0,x.t)(f.getData(h),H,q.componentType,q.byteOffset||0,h.byteStride||(0,x.o)(q.componentType)*H,q.normalized||!1,q.count,!0);L.push({kind:u,dracoName:(Q=u,"POSITION"===Q?"POSITION":"NORMAL"===Q?"NORMAL":Q.startsWith("COLOR")?"COLOR":Q.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:P(q.type),data:r}),d.push(h),g.push(q)}var Q;const H={method:q.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},r=qf.Default._encodeAsync(L,h,H).then((j=>{if(!j)return void R.e.Error("Draco encoding failed for primitive.");const h={bufferView:-1,attributes:j.attributeIds},L=f.createBufferView(j.data);f.setBufferView(h,L);for(const q of d)this._bufferViewsUsed.add(q);for(const q of g)this._accessorsUsed.add(q);q.extensions||(q.extensions={}),q.extensions[ff]=h})).catch((q=>{R.e.Error("Draco encoding failed for primitive: "+q)}));this._encodePromises.push(r),this._wasUsed=!0}async preGenerateBinaryAsync(q){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((f=>{q.getPropertiesWithBufferView(f).every((q=>this._accessorsUsed.has(q)))&&q.removeBufferView(f)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}lq.RegisterExtension(ff,(q=>new jf(q)));var df=j(11698);const gf="KHR_lights_punctual",hf={name:"",color:[1,1,1],Xd:1,range:Number.MAX_VALUE},Lf={innerConeAngle:0,outerConeAngle:Math.PI/4},Qf=d.j.Backward();class Hf{constructor(q){this.name=gf,this.enabled=!0,this.required=!1,this._exporter=q}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[gf]=this._lights}async postExportNodeAsync(q,f,j,g,h){return await new Promise((L=>{if(!(j instanceof wq.e))return void L(f);const Q=j.getTypeID()==wq.e.LIGHTTYPEID_POINTLIGHT?"point":j.getTypeID()==wq.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":j.getTypeID()==wq.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!Q||!(j instanceof df.b))return R.e.Warn(`${q}: Light ${j.name} is not supported in ${gf}`),void L(f);if(j.falloffType!==wq.e.FALLOFF_GLTF&&R.e.Warn(`${q}: Light falloff for ${j.name} does not match the ${gf} specification!`),!j.position.equalsToFloats(0,0,0)){const q=d.f.kf[0].H(j.position);h&&m(q),f.translation=q.Yf()}if("point"!==Q){const q=j.direction.normalizeToRef(d.f.kf[0]);h&&m(q);const g=d.e.FromUnitVectorsToRef(Qf,q,d.f.Quaternion[0]);d.e.IsIdentity(g)||(f.rotation=g.Yf())}const H={type:Q,name:j.name,color:j.zd.Yf(),Xd:j.Xd,range:j.range};if(dq(H,hf),"spot"===Q){const q=j;H.spot={innerConeAngle:q.innerAngle/2,outerConeAngle:q.angle/2},dq(H.spot,Lf)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(H);const r={Df:this._lights.lights.length-1},u=j.parent;if(u&&fq(j,u)){const q=g.get(u);if(q){const j=this._exporter._nodes[q];return qq(f,j),j.extensions||(j.extensions={}),j.extensions[gf]=r,void L(null)}}f.extensions||(f.extensions={}),f.extensions[gf]=r,L(f)}))}}lq.RegisterExtension(gf,(q=>new Hf(q)));var rf=j(11502);const uf="KHR_materials_anisotropy";class Xf{constructor(q){this.name=uf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,f,j){const d=[];return j instanceof rf.c&&j.anisotropy.isEnabled&&!j.anisotropy.legacy?(j.anisotropy.texture&&d.push(j.anisotropy.texture),d):[]}postExportMaterialAsync(q,f,j){return new Promise((q=>{if(j instanceof rf.c){if(!j.anisotropy.isEnabled||j.anisotropy.legacy)return void q(f);this._wasUsed=!0,f.extensions=f.extensions||{};const d=this._exporter._materialExporter.getTextureInfo(j.anisotropy.texture),g={anisotropyStrength:j.anisotropy.Xd,anisotropyRotation:j.anisotropy.angle,anisotropyTexture:d??void 0};null!==g.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(j),f.extensions[uf]=g}q(f)}))}}lq.RegisterExtension(uf,(q=>new Xf(q)));const zf="KHR_materials_clearcoat";class Bf{constructor(q){this.name=zf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,f,j){const d=[];return j instanceof rf.c&&j.clearCoat.isEnabled?(j.clearCoat.texture&&d.push(j.clearCoat.texture),!j.clearCoat.useRoughnessFromMainTexture&&j.clearCoat.textureRoughness&&d.push(j.clearCoat.textureRoughness),j.clearCoat.bumpTexture&&d.push(j.clearCoat.bumpTexture),d):[]}postExportMaterialAsync(q,f,j){return new Promise((q=>{if(j instanceof rf.c){if(!j.clearCoat.isEnabled)return void q(f);this._wasUsed=!0,f.extensions=f.extensions||{};const d=this._exporter._materialExporter.getTextureInfo(j.clearCoat.texture);let h;h=j.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(j.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(j.clearCoat.textureRoughness),j.clearCoat.isTintEnabled&&g.h.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${j.name}`),j.clearCoat.remapF0OnInterfaceChange&&g.h.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${j.name}`);const L=this._exporter._materialExporter.getTextureInfo(j.clearCoat.bumpTexture),Q={clearcoatFactor:j.clearCoat.Xd,clearcoatTexture:d??void 0,clearcoatRoughnessFactor:j.clearCoat.roughness,clearcoatRoughnessTexture:h??void 0,clearcoatNormalTexture:L??void 0};null===Q.clearcoatTexture&&null===Q.clearcoatRoughnessTexture&&null===Q.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(j),f.extensions[zf]=Q}q(f)}))}}lq.RegisterExtension(zf,(q=>new Bf(q)));const Df="KHR_materials_diffuse_transmission";function tf(q,f){const j=f.subSurface;let d=null;return j.translucencyIntensityTexture?d=j.translucencyIntensityTexture:j.thicknessTexture&&j.useMaskFromThicknessTexture&&(d=j.thicknessTexture),d&&!j.useGltfStyleTextures?(R.e.Warn(`${q}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${f.name}`,1),null):d}class Of{constructor(q){this.name=Df,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,f,j){const d=[];if(j instanceof Dq.d&&this._isExtensionEnabled(j)){const f=tf(q,j);return f&&d.push(f),j.subSurface.translucencyColorTexture&&d.push(j.subSurface.translucencyColorTexture),d}return d}_isExtensionEnabled(q){if(q.unlit)return!1;const f=q.subSurface;return!!f.isTranslucencyEnabled&&(!q.unlit&&!f.useAlbedoToTintTranslucency&&f.useGltfStyleTextures&&1===f.volumeIndexOfRefraction&&0===f.minimumThickness&&0===f.maximumThickness)}postExportMaterialAsync(q,f,j){return new Promise((d=>{if(j instanceof Dq.d&&this._isExtensionEnabled(j)){this._wasUsed=!0;const d=j.subSurface,g=tf(q,j),h=0==d.translucencyIntensity?void 0:d.translucencyIntensity,L=this._exporter._materialExporter.getTextureInfo(g)??void 0,Q=!d.translucencyColor||d.translucencyColor.equalsFloats(1,1,1)?void 0:d.translucencyColor.Yf(),H=this._exporter._materialExporter.getTextureInfo(d.translucencyColorTexture)??void 0,r={diffuseTransmissionFactor:h,diffuseTransmissionTexture:L,diffuseTransmissionColorFactor:Q,diffuseTransmissionColorTexture:H};(L||H)&&this._exporter._materialNeedsUVsSet.add(j),f.extensions=f.extensions||{},f.extensions[Df]=r}d(f)}))}}lq.RegisterExtension(Df,(q=>new Of(q)));const Nf="KHR_materials_dispersion";class wf{constructor(){this.name=Nf,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(q){if(q.unlit)return!1;const f=q.subSurface;return!(!f.isRefractionEnabled&&!f.isDispersionEnabled)}postExportMaterialAsync(q,f,j){return new Promise((q=>{if(j instanceof Dq.d&&this._isExtensionEnabled(j)){this._wasUsed=!0;const q={dispersion:j.subSurface.dispersion};f.extensions=f.extensions||{},f.extensions[Nf]=q}q(f)}))}}lq.RegisterExtension(Nf,(()=>new wf));const Ef="KHR_materials_emissive_strength";class sf{constructor(){this.name=Ef,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(q,f,j){return await new Promise((q=>{if(!(j instanceof Dq.d))return q(f);const d=j.emissiveColor.Yf(),g=Math.max(...d);if(g>1){this._wasUsed=!0,f.extensions||(f.extensions={});const q={emissiveStrength:g},d=j.emissiveColor.scale(1/q.emissiveStrength);f.emissiveFactor=d.Yf(),f.extensions[Ef]=q}return q(f)}))}}lq.RegisterExtension(Ef,(q=>new sf));const Sf="KHR_materials_ior";class ef{constructor(){this.name=Sf,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(q){return!q.unlit&&(void 0!=q.indexOfRefraction&&1.5!=q.indexOfRefraction)}postExportMaterialAsync(q,f,j){return new Promise((q=>{if(j instanceof Dq.d&&this._isExtensionEnabled(j)){this._wasUsed=!0;const q={ior:j.indexOfRefraction};f.extensions=f.extensions||{},f.extensions[Sf]=q}q(f)}))}}lq.RegisterExtension(Sf,(q=>new ef));const Zf="KHR_materials_iridescence";class If{constructor(q){this.name=Zf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,f,j){const d=[];return j instanceof rf.c&&j.iridescence.isEnabled?(j.iridescence.texture&&d.push(j.iridescence.texture),j.iridescence.thicknessTexture&&j.iridescence.thicknessTexture!==j.iridescence.texture&&d.push(j.iridescence.thicknessTexture),d):[]}postExportMaterialAsync(q,f,j){return new Promise((q=>{if(j instanceof rf.c){if(!j.iridescence.isEnabled)return void q(f);this._wasUsed=!0,f.extensions=f.extensions||{};const d=this._exporter._materialExporter.getTextureInfo(j.iridescence.texture),g=this._exporter._materialExporter.getTextureInfo(j.iridescence.thicknessTexture),h={iridescenceFactor:j.iridescence.Xd,iridescenceIor:j.iridescence.indexOfRefraction,iridescenceThicknessMinimum:j.iridescence.minimumThickness,iridescenceThicknessMaximum:j.iridescence.maximumThickness,iridescenceTexture:d??void 0,iridescenceThicknessTexture:g??void 0};null===h.iridescenceTexture&&null===h.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(j),f.extensions[Zf]=h}q(f)}))}}lq.RegisterExtension(Zf,(q=>new If(q)));const Tf="KHR_materials_sheen";class Wf{constructor(q){this.name=Tf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,f,j){return j instanceof Dq.d&&j.sheen.isEnabled&&j.sheen.texture?[j.sheen.texture]:[]}async postExportMaterialAsync(q,f,j){return await new Promise((q=>{if(j instanceof Dq.d){if(!j.sheen.isEnabled)return void q(f);this._wasUsed=!0,null==f.extensions&&(f.extensions={});const d={sheenColorFactor:j.sheen.color.Yf(),sheenRoughnessFactor:j.sheen.roughness??0};null===d.sheenColorTexture&&null===d.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(j),j.sheen.texture&&(d.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(j.sheen.texture)??void 0),j.sheen.textureRoughness&&!j.sheen.useRoughnessFromMainTexture?d.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(j.sheen.textureRoughness)??void 0:j.sheen.texture&&j.sheen.useRoughnessFromMainTexture&&(d.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(j.sheen.texture)??void 0),f.extensions[Tf]=d}q(f)}))}}lq.RegisterExtension(Tf,(q=>new Wf(q)));const nf="KHR_materials_specular";class Uf{constructor(q){this.name=nf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,f,j){const d=[];return j instanceof Dq.d&&this._isExtensionEnabled(j)?(j.metallicReflectanceTexture&&d.push(j.metallicReflectanceTexture),j.reflectanceTexture&&d.push(j.reflectanceTexture),d):d}_isExtensionEnabled(q){return!q.unlit&&(void 0!=q.metallicF0Factor&&1!=q.metallicF0Factor||void 0!=q.metallicReflectanceColor&&!q.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(q))}_hasTexturesExtension(q){return null!=q.metallicReflectanceTexture||null!=q.reflectanceTexture}postExportMaterialAsync(q,f,j){return new Promise((q=>{if(j instanceof Dq.d&&this._isExtensionEnabled(j)){this._wasUsed=!0,f.extensions=f.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(j.metallicReflectanceTexture)??void 0,d=this._exporter._materialExporter.getTextureInfo(j.reflectanceTexture)??void 0,g={specularFactor:1==j.metallicF0Factor?void 0:j.metallicF0Factor,specularTexture:q,specularColorFactor:j.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:j.metallicReflectanceColor.Yf(),specularColorTexture:d};this._hasTexturesExtension(j)&&this._exporter._materialNeedsUVsSet.add(j),f.extensions[nf]=g}q(f)}))}}lq.RegisterExtension(nf,(q=>new Uf(q)));const Yf="KHR_materials_transmission";class vf{constructor(q){this.name=Yf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,f,j){const d=[];return j instanceof Dq.d&&this._isExtensionEnabled(j)?(j.subSurface.thicknessTexture&&d.push(j.subSurface.thicknessTexture),d):d}_isExtensionEnabled(q){if(q.unlit)return!1;const f=q.subSurface;return f.isRefractionEnabled&&void 0!=f.refractionIntensity&&0!=f.refractionIntensity||this._hasTexturesExtension(q)}_hasTexturesExtension(q){return null!=q.subSurface.refractionIntensityTexture}async postExportMaterialAsync(q,f,j){if(j instanceof Dq.d&&this._isExtensionEnabled(j)){this._wasUsed=!0;const d=j.subSurface,g={transmissionFactor:0===d.refractionIntensity?void 0:d.refractionIntensity};if(this._hasTexturesExtension(j)&&this._exporter._materialNeedsUVsSet.add(j),d.refractionIntensityTexture)if(d.useGltfStyleTextures){const q=await this._exporter._materialExporter.exportTextureAsync(d.refractionIntensityTexture,"image/png");q&&(g.transmissionTexture=q)}else R.e.Warn(`${q}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);f.extensions||(f.extensions={}),f.extensions[Yf]=g}return f}}lq.RegisterExtension(Yf,(q=>new vf(q)));const Ff="KHR_materials_unlit";class Mf{constructor(){this.name=Ff,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(q,f,j){return new Promise((q=>{let d=!1;j instanceof Dq.d?d=j.unlit:j instanceof iq.b&&(d=j.disableLighting),d&&(this._wasUsed=!0,null==f.extensions&&(f.extensions={}),f.extensions[Ff]={}),q(f)}))}}lq.RegisterExtension(Ff,(()=>new Mf));const of="KHR_materials_volume";class bf{constructor(q){this.name=of,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,f,j){const d=[];return j instanceof Dq.d&&this._isExtensionEnabled(j)?(j.subSurface.thicknessTexture&&d.push(j.subSurface.thicknessTexture),d):d}_isExtensionEnabled(q){if(q.unlit)return!1;const f=q.subSurface;return!(!f.isRefractionEnabled&&!f.isTranslucencyEnabled)&&(void 0!=f.maximumThickness&&0!=f.maximumThickness||void 0!=f.tintColorAtDistance&&f.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=f.tintColor&&f.tintColor!=t.c.White()||this._hasTexturesExtension(q))}_hasTexturesExtension(q){return null!=q.subSurface.thicknessTexture}postExportMaterialAsync(q,f,j){return new Promise((q=>{if(j instanceof Dq.d&&this._isExtensionEnabled(j)){this._wasUsed=!0;const q=j.subSurface,d={thicknessFactor:0==q.maximumThickness?void 0:q.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(q.thicknessTexture)??void 0,attenuationDistance:q.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:q.tintColorAtDistance,attenuationColor:q.tintColor.equalsFloats(1,1,1)?void 0:q.tintColor.Yf()};this._hasTexturesExtension(j)&&this._exporter._materialNeedsUVsSet.add(j),f.extensions=f.extensions||{},f.extensions[of]=d}q(f)}))}}lq.RegisterExtension(of,(q=>new bf(q)));const xf="EXT_materials_diffuse_roughness";class Rf{constructor(q){this.name=xf,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,f,j){const d=[];return j instanceof rf.c&&j._baseDiffuseRoughness?(j._baseDiffuseRoughnessTexture&&d.push(j._baseDiffuseRoughnessTexture),d):[]}postExportMaterialAsync(q,f,j){return new Promise((q=>{if(j instanceof rf.c){if(!j._baseDiffuseRoughness)return void q(f);this._wasUsed=!0,f.extensions=f.extensions||{};const d=this._exporter._materialExporter.getTextureInfo(j._baseDiffuseRoughnessTexture),g={diffuseRoughnessFactor:j._baseDiffuseRoughness,diffuseRoughnessTexture:d??void 0};null!==g.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(j),f.extensions[xf]=g}q(f)}))}}lq.RegisterExtension(xf,(q=>new Rf(q)));const Af="KHR_texture_transform";class kf{constructor(){this.name=Af,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(q,f,j){if(j.eq()||g.h.Warn(`${q}: /*@__KEY__*/"scene" is not defined for Babylon texture ${j.name}!`),(0!==j.uAng||0!==j.vAng)&&(g.h.Warn(`${q}: Texture ${j.name} with rotation in the u or v axis is not supported in glTF.`),0!==j.uRotationCenter||0!==j.vRotationCenter))return;const d={};let h=!1;if(0===j.uOffset&&0===j.vOffset||(d.offset=[j.uOffset,j.vOffset],h=!0),1===j.uScale&&1===j.vScale||(d.scale=[j.uScale,j.vScale],h=!0),0!==j.wAng){if(0!==j.uRotationCenter||0!==j.vRotationCenter){if(j.homogeneousRotationInUVTransform&&j.uScale!==j.vScale)return void g.h.Warn(`${q}: Texture ${j.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Af}.`);g.h.Warn(`${q}: Texture ${j.name} with non-origin rotation center will be exported using an adjusted offset with ${Af}.`),d.offset=function(q){const{uOffset:f,vOffset:j,uRotationCenter:d,vRotationCenter:g,uScale:h,vScale:L,wAng:Q}=q,H=Math.cos(Q),r=Math.sin(Q),u=d*h,X=g*L;return[f+(u*(1-H)+X*r),j+(X*(1-H)-u*r)]}(j)}d.rotation=-j.wAng,h=!0}0!==j.coordinatesIndex&&(d.texCoord=j.coordinatesIndex,h=!0),h&&(this._wasUsed=!0,f.extensions||(f.extensions={}),f.extensions[Af]=d)}}lq.RegisterExtension(Af,(()=>new kf));class yf{static CreateSTL(q){let f=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",g=arguments.length>3&&void 0!==arguments[3]&&arguments[3],h=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],L=arguments.length>5&&void 0!==arguments[5]&&arguments[5],Q=arguments.length>6&&void 0!==arguments[6]&&arguments[6],H=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const r=function(q,f,j){const g=[3*q[j],3*q[j+1],3*q[j+2]],h=[new d.j(f[g[0]],f[g[0]+2],f[g[0]+1]),new d.j(f[g[1]],f[g[1]+2],f[g[1]+1]),new d.j(f[g[2]],f[g[2]+2],f[g[2]+1])],L=h[0].ej(h[1]),Q=h[2].ej(h[1]);return{v:h,n:d.j.Cross(Q,L).normalize()}},X=function(q,f,j,d){return f=z(q,f,j.x,d),f=z(q,f,j.y,d),z(q,f,j.z,d)},z=function(q,f,j,d){return q.setFloat32(f,j,d),f+4},D=function(q){if(Q){let f=q;q instanceof B.d&&(f=q.sourceMesh);const j=f.getVerticesData(u.i.PositionKind,!0,!0);if(!j)return[];const g=d.j.Zero();let h;for(h=0;h<j.length;h+=3)d.j.TransformCoordinatesFromFloatsToRef(j[h],j[h+1],j[h+2],q.Nf(!0),g).toArray(j,h);return j}return q.getVerticesData(u.i.PositionKind)||[]};Q&&(L=!0);let i="",t=0,O=0;if(g){for(let j=0;j<q.length;j++){const f=q[j].sf();t+=f?f.length/3:0}const f=new ArrayBuffer(84+50*t);i=new DataView(f),O+=80,i.setUint32(O,t,h),O+=4}else H||(i="solid stlmesh\r\n");for(let d=0;d<q.length;d++){const f=q[d];!g&&H&&(i+="solid "+f.name+"\r\n"),!L&&f instanceof Nq.e&&f.bakeCurrentTransformIntoVertices();const j=D(f),Q=f.sf()||[];for(let q=0;q<Q.length;q+=3){const f=r(Q,j,q);g?(O=X(i,O,f.n,h),O=X(i,O,f.v[0],h),O=X(i,O,f.v[1],h),O=X(i,O,f.v[2],h),O+=2):(i+="\tfacet normal "+f.n.x+" "+f.n.y+" "+f.n.z+"\r\n",i+="\t\touter loop\r\n",i+="\t\t\tvertex "+f.v[0].x+" "+f.v[0].y+" "+f.v[0].z+"\r\n",i+="\t\t\tvertex "+f.v[1].x+" "+f.v[1].y+" "+f.v[1].z+"\r\n",i+="\t\t\tvertex "+f.v[2].x+" "+f.v[2].y+" "+f.v[2].z+"\r\n",i+="\t\tendloop\r\n",i+="\tendfacet\r\n")}!g&&H&&(i+="endsolid "+name+"\r\n")}if(g||H||(i+="endsolid stlmesh"),f){const q=document.createElement("a"),f=new Blob([i],{type:"application/octet-stream"});q.href=window.URL.createObjectURL(f),q.download=j+".stl",q.click()}return i}}function pf(q,f){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const d=[];for(let g=0;g<q.length/j;g++){const h=q[g*j],L=q[g*j+1],Q=q[g*j+2];d.push(`(${h.toPrecision(f.precision)}, ${L.toPrecision(f.precision)}, ${Q.toPrecision(f.precision)})`)}return d.join(", ")}function lf(q,f){const j=[];for(let d=0;d<q.length/2;d++){const g=q[2*d],h=q[2*d+1];j.push(`(${g.toPrecision(f.precision)}, ${(1-h).toPrecision(f.precision)})`)}return j.join(", ")}function Vf(q,f){const j=q.getVerticesData(u.i.PositionKind),d=q.getVerticesData(u.i.NormalKind);if(j&&d)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(q){var f;const j=null!==(f=q.sf())&&void 0!==f&&f.length?q.getTotalIndices():q.getTotalVertices();return Array(j/3).fill(3).join(", ")}(q)}]\n\t\tint[] faceVertexIndices = [${function(q){const f=q.sf(),j=[];if(null!==f)for(let d=0;d<f.length;d++)j.push(f[d]);else{const f=q.getTotalVertices();for(let q=0;q<f;q++)j.push(q)}return j.join(", ")}(q)}]\n\t\tnormal3f[] normals = [${pf(d,f)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${pf(j,f)}]\n        ${function(q,f){let j="";for(let g=0;g<4;g++){const d=g>0?g:"",h=q.getVerticesData(u.i.UVKind+(d?d+1:""));h&&(j+=`\n\t\ttexCoord2f[] primvars:st${d} = [${lf(h,f)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const d=q.getVerticesData(u.i.ColorKind);return d&&(j+=`\n\tcolor3f[] primvars:displayColor = [${pf(d,f,d.length/q.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),j}(q,f)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function af(q,f){return`\n        def "Geometry"\n        {\n        ${Vf(q,f)}\n        }\n        `}function Pf(q){let f='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return f+=q,fflate.strToU8(f)}function Cf(q){const f=q.m;return`( ${cf(f,0)}, ${cf(f,4)}, ${cf(f,8)}, ${cf(f,12)} )`}function cf(q,f){return`(${q[f+0]}, ${q[f+1]}, ${q[f+2]}, ${q[f+3]})`}function Gf(q){const f="Object_"+q.uniqueId,j=function(q){const f=q.getWorldMatrix().clone(),j=q.eq().useRightHandedSystem;if(!j){let d=q.parent;for(;d;){if(Lq(d,j)){f.multiplyToRef(d.getWorldMatrix().invert(),f);break}d=d.parent}}return f.determinant()<0&&g.h.Warn(`Exporting mesh ${q.name} with negative scale. Result may look incorrect in destination engine.`),f}(q),d=Cf(j);return`def Xform "${f}" (\n\tprepend references = @./geometries/Geometry_${q.wf.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${d}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${q.material.uniqueId}>\n}\n\n`}function mf(q){switch(q){case e.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case e.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case e.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Kf(q){return`(${q.x}, ${q.y})`}function Jf(q){return`(${q.r}, ${q.g}, ${q.b})`}function qj(q,f,j,g,h,L){const Q=q.getInternalTexture().uniqueId+"_"+q.invertY;h[Q]=q;const H=q.coordinatesIndex>0?"st"+q.coordinatesIndex:"st",r=new d.i(q.uScale,q.vScale),u=new d.i(q.uOffset,q.vOffset),X=q.wAng,z=Math.sin(X),B=Math.cos(X);return u.y=1-u.y-r.y,u.x+=z*r.x,u.y+=(1-B)*r.y,`\n    def Shader "PrimvarReader_${j}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${H}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${j}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${f.uniqueId}/PrimvarReader_${j}.outputs:result>\n        float inputs:rotation = ${(X*(180/Math.PI)).toFixed(L.precision)}\n        float2 inputs:scale = ${Kf(r)}\n        float2 inputs:translation = ${Kf(u)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${q.uniqueId}_${j}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${Q}.png@\n        float2 inputs:st.connect = </Materials/Material_${f.uniqueId}/Transform2d_${j}.outputs:result>\n        ${g?"float4 inputs:scale = "+function(q){return`(${q.r}, ${q.g}, ${q.b}, 1.0)`}(g):""}\n        token inputs:sourceColorSpace = "${q.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${mf(q.wrapU)}"\n        token inputs:wrapT = "${mf(q.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${f.needAlphaBlending()?"float outputs:a":""}\n    }`}function fj(q,f,j){const d="\t\t\t",g=[],h=[],{diffuseMap:L,zd:Q,alphaCutOff:H,emissiveMap:r,emissive:u,normalMap:X,roughnessMap:z,roughnessChannel:B,roughness:D,metalnessMap:i,metalnessChannel:O,metalness:N,aoMap:w,aoMapChannel:E,aoMapIntensity:s,alphaMap:S,ior:e,clearCoatEnabled:Z,clearCoat:I,clearCoatMap:T,clearCoatRoughness:W,clearCoatRoughnessMap:n}=function(q){const f={diffuseMap:null,zd:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return q instanceof iq.b?{...f,diffuseMap:q.diffuseTexture,zd:q.diffuseColor,alphaCutOff:q.alphaCutOff,emissiveMap:q.emissiveTexture,emissive:q.emissiveColor,roughness:1,alphaMap:q.opacityTexture}:q instanceof rf.c?{...f,diffuseMap:q._albedoTexture,zd:q._albedoColor,alphaCutOff:q._alphaCutOff,emissiveMap:q._emissiveTexture,emissive:q._emissiveColor,normalMap:q._bumpTexture,roughnessMap:q._metallicTexture,roughnessChannel:q._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:q._roughness??1,metalnessMap:q._metallicTexture,metalnessChannel:q._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:q._metallic??0,aoMap:q._ambientTexture,aoMapChannel:q._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:q._ambientTextureStrength,alphaMap:q._opacityTexture,ior:q.subSurface.indexOfRefraction,clearCoatEnabled:q.clearCoat.isEnabled,clearCoat:q.clearCoat.Xd,clearCoatMap:q.clearCoat.texture,clearCoatRoughness:q.clearCoat.roughness,clearCoatRoughnessMap:q.clearCoat.useRoughnessFromMainTexture?q.clearCoat.texture:q.clearCoat.textureRoughness}:f}(q);return null!==L?(g.push(`${d}color3f inputs:diffuseColor.connect = </Materials/Material_${q.uniqueId}/Texture_${L.uniqueId}_diffuse.outputs:rgb>`),q.needAlphaBlending()?g.push(`${d}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${L.uniqueId}_diffuse.outputs:a>`):q.needAlphaTesting()&&(g.push(`${d}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${L.uniqueId}_diffuse.outputs:a>`),g.push(`${d}float inputs:opacityThreshold = ${H}`)),h.push(qj(L,q,"diffuse",Q,f,j))):g.push(`${d}color3f inputs:diffuseColor = ${Jf(Q||t.c.White())}`),null!==r?(g.push(`${d}color3f inputs:emissiveColor.connect = </Materials/Material_${q.uniqueId}/Texture_${r.uniqueId}_emissive.outputs:rgb>`),h.push(qj(r,q,"emissive",u,f,j))):u&&u.toLuminance()>0&&g.push(`${d}color3f inputs:emissiveColor = ${Jf(u)}`),null!==X&&(g.push(`${d}normal3f inputs:normal.connect = </Materials/Material_${q.uniqueId}/Texture_${X.uniqueId}_normal.outputs:rgb>`),h.push(qj(X,q,"df",null,f,j))),null!==w&&(g.push(`${d}float inputs:occlusion.connect = </Materials/Material_${q.uniqueId}/Texture_${w.uniqueId}_occlusion.outputs:${E}>`),h.push(qj(w,q,"occlusion",new t.c(s,s,s),f,j))),null!==z?(g.push(`${d}float inputs:roughness.connect = </Materials/Material_${q.uniqueId}/Texture_${z.uniqueId}_roughness.outputs:${B}>`),h.push(qj(z,q,"roughness",new t.c(D,D,D),f,j))):g.push(`${d}float inputs:roughness = ${D}`),null!==i?(g.push(`${d}float inputs:metallic.connect = </Materials/Material_${q.uniqueId}/Texture_${i.uniqueId}_metallic.outputs:${O}>`),h.push(qj(i,q,"metallic",new t.c(N,N,N),f,j))):g.push(`${d}float inputs:metallic = ${N}`),null!==S?(g.push(`${d}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${S.uniqueId}_opacity.outputs:r>`),g.push(`${d}float inputs:opacityThreshold = 0.0001`),h.push(qj(S,q,"opacity",null,f,j))):g.push(`${d}float inputs:opacity = ${q.alpha}`),Z&&(null!==T?(g.push(`${d}float inputs:clearcoat.connect = </Materials/Material_${q.uniqueId}/Texture_${T.uniqueId}_clearcoat.outputs:r>`),h.push(qj(T,q,"clearcoat",new t.c(I,I,I),f,j))):g.push(`${d}float inputs:clearcoat = ${I}`),null!==n?(g.push(`${d}float inputs:clearcoatRoughness.connect = </Materials/Material_${q.uniqueId}/Texture_${n.uniqueId}_clearcoatRoughness.outputs:g>`),h.push(qj(n,q,"clearcoatRoughness",new t.c(W,W,W),f,j))):g.push(`${d}float inputs:clearcoatRoughness = ${W}`)),g.push(`${d}float inputs:ior = ${e}`),`\n\tdef Material "Material_${q.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${g.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${q.uniqueId}/PreviewSurface.outputs:surface>\n\n${h.join("\n")}\n\n\t}\n`}async function jj(q,f,j){const h={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...f};"undefined"===typeof fflate&&await g.h.LoadScriptAsync(h.fflateUrl);const L={};L[h.modelFileName]=null;let Q='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';Q+=function(q){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===q.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${q.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${q.planeAnchoringAlignment}"`:""}\n            `}(h);const H={};for(const d of q.meshes){if(0===d.getTotalVertices())continue;const q=d,f=q.wf,r=q.material;if(!r||!f||j&&!j(q))continue;if(-1!==["Od","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(r.getClassName())){const j="geometries/Geometry_"+f.uniqueId+".usda";if(!(j in L)){const q=af(f,h);L[j]=Pf(q)}r.uniqueId in H||(H[r.uniqueId]=r),Q+=Gf(q)}else g.h.Warn("USDZExportAsync does not support this material type: "+r.getClassName())}q.activeCamera&&h.exportCamera&&(Q+=function(q,f){const j="Camera_"+q.uniqueId,g=Cf(d.b.RotationY(Math.PI).multiply(q.getWorldMatrix()));if(q.mode===e.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${j}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${g}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${q.gd.toPrecision(f.precision)}, ${q.maxZ.toPrecision(f.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(q.orthoLeft||1)+Math.abs(q.orthoRight||1))).toPrecision(f.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(q.orthoTop||1)+Math.abs(q.orthoBottom||1))).toPrecision(f.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const d=q.getEngine().getAspectRatio(q),h=f.cameraSensorWidth||35;return`def Camera "${j}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${g}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${q.gd.toPrecision(f.precision)}, ${q.maxZ.toPrecision(f.precision)})\n\t\t\tfloat focalLength = ${(h/(2*Math.tan(.5*q.fov))).toPrecision(f.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(h*d).toPrecision(f.precision)}\n\t\t\tfloat verticalAperture = ${(h/d).toPrecision(f.precision)}            \n\t\t}\n\t\n\t`}}(q.activeCamera,h)),Q+="\n            }\n        }\n    }";const r={};Q+=function(q,f,j){const d=[];for(const g in q){const h=q[g];d.push(fj(h,f,j))}return`\n    def "Materials"\n{\n${d.join("")}\n}\n\n`}(H,r,h),L[h.modelFileName]=fflate.strToU8(Q);for(const d in r){const q=r[d],f=q.getSize(),j=await q.readPixels();if(!j)throw new Error("Texture data is not available");const g=await Z.DumpTools.DumpDataAsync(f.width,f.height,j,"image/png",void 0,!1,!0);L[`textures/Texture_${d}.png`]=new Uint8Array(g).slice()}let u=0;for(const d in L){const q=L[d];if(!q)continue;u+=34+d.length;const f=63&u;if(4!==f){const j=new Uint8Array(64-f);L[d]=[q,{extra:{12345:j}}]}u=q.length}return fflate.zipSync(L,{level:0})}}}]);