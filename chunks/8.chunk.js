"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{11017:(w,p,e)=>{e.r(p),e.d(p,{EXT_materials_diffuse_roughness:()=>Yp,EXT_mesh_gpu_instancing:()=>Gw,GLTF2Export:()=>Tw,GLTFData:()=>j,KHR_draco_mesh_compression:()=>ep,KHR_lights_punctual:()=>Ep,KHR_materials_anisotropy:()=>kp,KHR_materials_clearcoat:()=>Jp,KHR_materials_diffuse_transmission:()=>cp,KHR_materials_dispersion:()=>Op,KHR_materials_emissive_strength:()=>Ap,KHR_materials_ior:()=>Mp,KHR_materials_iridescence:()=>tp,KHR_materials_sheen:()=>lp,KHR_materials_specular:()=>Up,KHR_materials_transmission:()=>Rp,KHR_materials_unlit:()=>bp,KHR_materials_volume:()=>Pp,KHR_texture_transform:()=>Wp,OBJExport:()=>f,STLExport:()=>Fp,USDZExportAsync:()=>pe,_ConvertToGLTFPBRMetallicRoughness:()=>V,_SolveMetallic:()=>R,__IGLTFExporterExtension:()=>q});var r=e(11023),I=e(11071),d=e(11203);class f{static OBJ(w,p,e,f){const q=[];let E=1,j=1;p&&(e||(e="mat"),q.push("mtllib "+e+".mtl"));for(let X=0;X<w.length;X++){const e=w[X],k=e.name||`mesh${X}}`;q.push(`o ${k}`);let m=null;if(f){const w=e.ke(!0);m=new r.b,w.invertToRef(m),e.bakeTransformIntoVertices(w)}if(p){const w=e.material;w&&q.push("usemtl "+w.id)}const J=e.me;if(!J){I.g.Warn("No geometry is present on the mesh");continue}const K=J.getVerticesData("position"),y=J.getVerticesData("dp"),c=J.getVerticesData("uv"),s=J.Ke();let O=0,a=0;if(!K||!s){I.g.Warn("There are no position vertices or indices on the mesh!");continue}const A=w[0].iw().useRightHandedSystem?1:-1;for(let w=0;w<K.length;w+=3)q.push("v "+K[w]*A+" "+K[w+1]+" "+K[w+2]),O++;if(null!=y)for(let w=0;w<y.length;w+=3)q.push("vn "+y[w]*A+" "+y[w+1]+" "+y[w+2]);if(null!=c)for(let w=0;w<c.length;w+=2)q.push("vt "+c[w]+" "+c[w+1]),a++;const z=["","",""],M=(e.material||e.iw().defaultMaterial)._getEffectiveOrientation(e),[i,t]=M===d.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let w=0;w<s.length;w+=3){const p=[String(s[w]+E),String(s[w+i]+E),String(s[w+t]+E)],e=[String(s[w]+j),String(s[w+i]+j),String(s[w+t]+j)],r=p,I=null!=c?e:z,d=null!=y?p:z;q.push("f "+r[0]+"/"+I[0]+"/"+d[0]+" "+r[1]+"/"+I[1]+"/"+d[1]+" "+r[2]+"/"+I[2]+"/"+d[2])}f&&m&&e.bakeTransformIntoVertices(m),E+=O,j+=a}return q.join("\n")}static MTL(w){const p=[],e=w.material;p.push("newmtl mat1"),p.push("  Ns "+e.specularPower.toFixed(4)),p.push("  Ni 1.5000"),p.push("  d "+e.alpha.toFixed(4)),p.push("  Tr 0.0000"),p.push("  Tf 1.0000 1.0000 1.0000"),p.push("  illum 2"),p.push("  Ka "+e.ambientColor.r.toFixed(4)+" "+e.ambientColor.g.toFixed(4)+" "+e.ambientColor.b.toFixed(4)),p.push("  Kd "+e.diffuseColor.r.toFixed(4)+" "+e.diffuseColor.g.toFixed(4)+" "+e.diffuseColor.b.toFixed(4)),p.push("  Ks "+e.specularColor.r.toFixed(4)+" "+e.specularColor.g.toFixed(4)+" "+e.specularColor.b.toFixed(4)),p.push("  Ke "+e.emissiveColor.r.toFixed(4)+" "+e.emissiveColor.g.toFixed(4)+" "+e.emissiveColor.b.toFixed(4));e.ambientTexture&&p.push("  map_Ka "+e.ambientTexture.name),e.diffuseTexture&&p.push("  map_Kd "+e.diffuseTexture.name),e.specularTexture&&p.push("  map_Ks "+e.specularTexture.name),e.bumpTexture&&p.push("  map_bump -imfchan z "+e.bumpTexture.name),e.opacityTexture&&p.push("  map_d "+e.opacityTexture.name);return p.join("\n")}}var q=0,E=e(11107);class j{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const w in this.files){const p=this.files[w],e=new Blob([p],{type:(0,E.j)(w)});I.g.Download(e,w)}}}var X=e(11232),k=e(11325),m=e(11333),J=e(11365),K=e(11411),y=e(11051),c=e(11308),s=e(11063);const O=s.HighestCommonFactor,a={...s,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:O};var A=e(11502),z=e(11511),M=e(11546),i=e(11552),t=e(11555);const n=1e-6,l=new c.b(.04,.04,.04),N=1024,U=c.b.White(),v=c.b.Black();function R(w,p,e){if(p<l.r)return 0;const r=l.r,I=w*e/(1-l.r)+p-2*l.r,d=I*I-4*r*(l.r-p);return a.Clamp((-I+Math.sqrt(d))/(2*r),0,1)}function V(w){const p=w.diffuseColor.toLinearSpace(w.iw().getEngine().useExactSrgbConversions).scale(.5),e=w.alpha,I=function(w){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new r.g(0,1),e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new r.g(0,.1),I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new r.g(0,.1),d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new r.g(1300,.1);return function(w,p,e,r,I){return(1-w)*(1-w)*(1-w)*p+3*(1-w)*(1-w)*w*e+3*(1-w)*w*w*r+w*w*w*I}(Math.pow(w/d.x,.333333),p.y,e.y,I.y,d.y)}(a.Clamp(w.specularPower,0,N));return{baseColorFactor:[p.r,p.g,p.b,e],metallicFactor:0,roughnessFactor:I}}function b(w,p){p.needAlphaBlending()?w.alphaMode="BLEND":p.needAlphaTesting()&&(w.alphaMode="MASK",w.alphaCutoff=p.alphaCutOff)}function h(w,p,e){const r=new Uint8Array(w*p*4);for(let I=0;I<r.length;I+=4)r[I]=r[I+1]=r[I+2]=r[I+3]=255;return M.b.CreateRGBATexture(r,w,p,e)}function P(w){if(w instanceof Uint8Array){const p=w.length,e=new Float32Array(w.length);for(let r=0;r<p;++r)e[r]=w[r]/255;return e}if(w instanceof Float32Array)return w;throw new Error("Unsupported pixel format!")}class u{constructor(w){this._exporter=w,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(w){return w?this._textureMap.get(w)??null:null}async exportStandardMaterialAsync(w,p,e){const r=V(w),d={name:w.name};if(null==w.ce||w.ce||(w.twoSidedLighting||I.g.Warn(w.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),d.doubleSided=!0),e){const e=[],I=w.diffuseTexture;I&&e.push(this.exportTextureAsync(I,p).then((w=>{w&&(r.baseColorTexture=w)})));const f=w.bumpTexture;f&&e.push(this.exportTextureAsync(f,p).then((w=>{w&&(d.normalTexture=w,1!==f.level&&(d.normalTexture.scale=f.level))})));const q=w.emissiveTexture;q&&(d.emissiveFactor=[1,1,1],e.push(this.exportTextureAsync(q,p).then((w=>{w&&(d.emissiveTexture=w)}))));const E=w.ambientTexture;E&&e.push(this.exportTextureAsync(E,p).then((w=>{if(w){const p={index:w.index};d.occlusionTexture=p}}))),e.length>0&&(this._exporter._materialNeedsUVsSet.add(w),await Promise.all(e))}(w.alpha<1||w.opacityTexture)&&(w.alphaMode===i.c.ALPHA_COMBINE?d.alphaMode="BLEND":I.g.Warn(w.name+": glTF 2.0 does not support alpha mode: "+w.alphaMode.toString())),w.emissiveColor&&!w.emissiveColor.equalsWithEpsilon(v,n)&&(d.emissiveFactor=w.emissiveColor.ze()),d.pbrMetallicRoughness=r,b(d,w),await this._finishMaterialAsync(d,w,p);const f=this._exporter._materials;return f.push(d),f.length-1}async _finishMaterialAsync(w,p,e){const r=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",w,p),I=[];for(const d of r)I.push(this.exportTextureAsync(d,e));await Promise.all(I),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",w,p)}async _getImageDataAsync(w,p,r,I){const d=i.c.TEXTURETYPE_UNSIGNED_BYTE,f=this._exporter._babylonScene,q=f.getEngine(),E=q.createRawTexture(w,p,r,i.c.TEXTUREFORMAT_RGBA,!1,!0,z.e.NEAREST_SAMPLINGMODE,null,d);q.isWebGPU?await e.e(36).then(e.bind(e,13682)):await e.e(37).then(e.bind(e,13688)),await A.i.ApplyPostProcess("pass",E,f,d,i.c.TEXTURE_NEAREST_SAMPLINGMODE,i.c.TEXTUREFORMAT_RGBA);const j=await q._readTexturePixels(E,p,r);return await t.DumpTools.DumpDataAsync(p,r,j,I,void 0,!0,!0)}_resizeTexturesToSameDimensions(w,p,e){const r=w?w.getSize():{width:0,height:0},I=p?p.getSize():{width:0,height:0};let d,f;return r.width<I.width?(d=w&&w instanceof z.e?A.i.CreateResizedCopy(w,I.width,I.height,!0):h(I.width,I.height,e),f=p):r.width>I.width?(f=p&&p instanceof z.e?A.i.CreateResizedCopy(p,r.width,r.height,!0):h(r.width,r.height,e),d=w):(d=w,f=p),{texture1:d,texture2:f}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(w,p,e,r){const I=new Array;if(!w&&!p)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const d=w?w.iw():p?p.iw():null;if(d){var f;const q=this._resizeTexturesToSameDimensions(w,p,d),E=null===(f=q.texture1)||void 0===f?void 0:f.getSize();let j,X;const k=E.width,m=E.height,J=await q.texture1.readPixels(),K=await q.texture2.readPixels();if(!J)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(j=P(J),!K)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");X=P(K);const y=X.byteLength,s=new Uint8Array(y),O=new Uint8Array(y),a=4,A=v;let z=0,M=0;for(let w=0;w<m;++w)for(let p=0;p<k;++p){const r=(k*w+p)*a,I={diffuseColor:new c.b(j[r],j[r+1],j[r+2]).toLinearSpace(d.getEngine().useExactSrgbConversions).multiply(e.diffuseColor),specularColor:new c.b(X[r],X[r+1],X[r+2]).toLinearSpace(d.getEngine().useExactSrgbConversions).multiply(e.specularColor),glossiness:X[r+3]*e.glossiness},f=this._convertSpecularGlossinessToMetallicRoughness(I);A.r=Math.max(A.r,f.baseColor.r),A.g=Math.max(A.g,f.baseColor.g),A.b=Math.max(A.b,f.baseColor.b),z=Math.max(z,f.metallic),M=Math.max(M,f.roughness),O[r]=255*f.baseColor.r,O[r+1]=255*f.baseColor.g,O[r+2]=255*f.baseColor.b,O[r+3]=q.texture1.ie?255*j[r+3]:255,s[r]=0,s[r+1]=255*f.roughness,s[r+2]=255*f.metallic,s[r+3]=255}const i={baseColor:A,metallic:z,roughness:M};let t=!1,l=!1;for(let w=0;w<m;++w)for(let p=0;p<k;++p){const e=(k*w+p)*a;O[e]/=i.baseColor.r>n?i.baseColor.r:1,O[e+1]/=i.baseColor.g>n?i.baseColor.g:1,O[e+2]/=i.baseColor.b>n?i.baseColor.b:1;const r=c.b.FromInts(O[e],O[e+1],O[e+2]).toGammaSpace(d.getEngine().useExactSrgbConversions);O[e]=255*r.r,O[e+1]=255*r.g,O[e+2]=255*r.b,r.equalsWithEpsilon(U,n)||(l=!0),s[e+1]/=i.roughness>n?i.roughness:1,s[e+2]/=i.metallic>n?i.metallic:1;c.b.FromInts(255,s[e+1],s[e+2]).equalsWithEpsilon(U,n)||(t=!0)}return t&&I.push(this._getImageDataAsync(s,k,m,r).then((w=>{i.metallicRoughnessTextureData=w}))),l&&I.push(this._getImageDataAsync(O,k,m,r).then((w=>{i.baseColorTextureData=w}))),await Promise.all(I).then((()=>i))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(w){const p=this._getPerceivedBrightness(w.diffuseColor),e=this._getPerceivedBrightness(w.specularColor),r=1-this._getMaxComponent(w.specularColor),I=R(p,e,r),d=w.diffuseColor.scale(r/(1-l.r)/Math.max(1-I)),f=w.specularColor.Je(l.scale(1-I)).scale(1/Math.max(I));let q=c.b.Lerp(d,f,I*I);q=q.clampToRef(0,1,q);return{baseColor:q,metallic:I,roughness:1-w.glossiness}}_getPerceivedBrightness(w){return w?Math.sqrt(.299*w.r*w.r+.587*w.g*w.g+.114*w.b*w.b):0}_getMaxComponent(w){return w?Math.max(w.r,Math.max(w.g,w.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(w,p,e,r){const I=[],d={baseColor:w._albedoColor,metallic:w._metallic,roughness:w._roughness};if(r){w._albedoTexture&&I.push(this.exportTextureAsync(w._albedoTexture,p).then((w=>{w&&(e.baseColorTexture=w)})));const r=w._metallicTexture;r&&I.push(this.exportTextureAsync(r,p).then((w=>{w&&(e.metallicRoughnessTexture=w)})))}return I.length>0&&(this._exporter._materialNeedsUVsSet.add(w),await Promise.all(I)),d}_getTextureSampler(w){const p={};if(!w||!(w instanceof z.e))return p;const e=this._getGLTFTextureWrapMode(w.wrapU);10497!==e&&(p.wrapS=e);const r=this._getGLTFTextureWrapMode(w.wrapV);switch(10497!==r&&(p.wrapT=r),w.samplingMode){case z.e.LINEAR_LINEAR:p.magFilter=9729,p.minFilter=9729;break;case z.e.LINEAR_NEAREST:p.magFilter=9729,p.minFilter=9728;break;case z.e.NEAREST_LINEAR:p.magFilter=9728,p.minFilter=9729;break;case z.e.NEAREST_LINEAR_MIPLINEAR:p.magFilter=9728,p.minFilter=9987;break;case z.e.NEAREST_NEAREST:p.magFilter=9728,p.minFilter=9728;break;case z.e.NEAREST_LINEAR_MIPNEAREST:p.magFilter=9728,p.minFilter=9985;break;case z.e.LINEAR_NEAREST_MIPNEAREST:p.magFilter=9729,p.minFilter=9984;break;case z.e.LINEAR_NEAREST_MIPLINEAR:p.magFilter=9729,p.minFilter=9986;break;case z.e.NEAREST_NEAREST_MIPLINEAR:p.magFilter=9728,p.minFilter=9986;break;case z.e.LINEAR_LINEAR_MIPLINEAR:p.magFilter=9729,p.minFilter=9987;break;case z.e.LINEAR_LINEAR_MIPNEAREST:p.magFilter=9729,p.minFilter=9985;break;case z.e.NEAREST_NEAREST_MIPNEAREST:p.magFilter=9728,p.minFilter=9984}return p}_getGLTFTextureWrapMode(w){switch(w){case z.e.WRAP_ADDRESSMODE:return 10497;case z.e.CLAMP_ADDRESSMODE:return 33071;case z.e.MIRROR_ADDRESSMODE:return 33648;default:return I.g.Error(`Unsupported Texture Wrap Mode ${w}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(w,p,e,r){const I={diffuseColor:w._albedoColor,specularColor:w._reflectivityColor,glossiness:w._microSurface},d=w._albedoTexture,f=w._reflectivityTexture,q=w._useMicroSurfaceFromReflectivityMapAlpha;if(f&&!q)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((d||f)&&r){this._exporter._materialNeedsUVsSet.add(w);const r=this._exportTextureSampler(d||f),q=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(d,f,I,p),E=this._exporter._textures;if(q.baseColorTextureData){const w=this._exportImage(`baseColor${E.length}`,p,q.baseColorTextureData);e.baseColorTexture=this._exportTextureInfo(w,r,null===d||void 0===d?void 0:d.coordinatesIndex)}if(q.metallicRoughnessTextureData){const w=this._exportImage(`metallicRoughness${E.length}`,p,q.metallicRoughnessTextureData);e.metallicRoughnessTexture=this._exportTextureInfo(w,r,null===f||void 0===f?void 0:f.coordinatesIndex)}return q}return this._convertSpecularGlossinessToMetallicRoughness(I)}async exportPBRMaterialAsync(w,p,e){const r={},I={name:w.name},d=w.isMetallicWorkflow();if(d){const p=w._albedoColor,e=w.alpha;p&&(r.baseColorFactor=[p.r,p.g,p.b,e])}const f=d?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(w,p,r,e):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(w,p,r,e);await this._setMetallicRoughnessPbrMaterialAsync(f,w,I,r,p,e),await this._finishMaterialAsync(I,w,p);const q=this._exporter._materials;return q.push(I),q.length-1}async _setMetallicRoughnessPbrMaterialAsync(w,p,e,r,d,f){if(b(e,p),w.baseColor.equalsWithEpsilon(U,n)&&a.WithinEpsilon(p.alpha,1,n)||(r.baseColorFactor=[w.baseColor.r,w.baseColor.g,w.baseColor.b,p.alpha]),null!=w.metallic&&1!==w.metallic&&(r.metallicFactor=w.metallic),null!=w.roughness&&1!==w.roughness&&(r.roughnessFactor=w.roughness),null==p.ce||p.ce||(p._twoSidedLighting||I.g.Warn(p.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),e.doubleSided=!0),f){const w=[],r=p._bumpTexture;r&&w.push(this.exportTextureAsync(r,d).then((w=>{w&&(e.normalTexture=w,1!==r.level&&(e.normalTexture.scale=r.level))})));const I=p._ambientTexture;I&&w.push(this.exportTextureAsync(I,d).then((w=>{if(w){const r={index:w.index,texCoord:w.texCoord,extensions:w.extensions};e.occlusionTexture=r;const I=p._ambientTextureStrength;I&&(r.strength=I)}})));const f=p._emissiveTexture;f&&w.push(this.exportTextureAsync(f,d).then((w=>{w&&(e.emissiveTexture=w)}))),w.length>0&&(this._exporter._materialNeedsUVsSet.add(p),await Promise.all(w))}const q=p._emissiveColor;q.equalsWithEpsilon(v,n)||(e.emissiveFactor=q.ze()),e.pbrMetallicRoughness=r}_getPixelsFromTextureAsync(w){return function(w){switch(w){case i.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case i.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case i.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case i.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case i.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case i.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case i.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case i.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case i.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case i.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case i.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case i.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case i.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case i.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case i.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case i.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case i.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case i.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case i.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case i.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case i.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(w.textureFormat)?(0,A.g)(w,w._texture.width,w._texture.height):(w.textureType,i.c.TEXTURETYPE_UNSIGNED_BYTE,w.readPixels())}async exportTextureAsync(w,p){const e=this._exporter._extensionsPreExportTextureAsync("exporter",w,p);return e?await e.then((async e=>e?await this._exportTextureInfoAsync(e,p):await this._exportTextureInfoAsync(w,p))):await this._exportTextureInfoAsync(w,p)}async _exportTextureInfoAsync(w,p){let e=this._textureMap.get(w);if(!e){const r=await this._getPixelsFromTextureAsync(w);if(!r)return null;const d=this._exportTextureSampler(w),f=w.mimeType;if(f)switch(f){case"image/jpeg":case"image/png":case"image/webp":p=f;break;default:I.g.Warn(`Unsupported media type: ${f}. Exporting texture as PNG.`)}const q=this._internalTextureToImage,E=w.getInternalTexture().uniqueId;q[E]||(q[E]={});let j=q[E][p];if(void 0===j){const e=w.getSize();j=(async()=>{const I=await this._getImageDataAsync(r,e.width,e.height,p);return this._exportImage(w.name,p,I)})(),q[E][p]=j}e=this._exportTextureInfo(await j,d,w.coordinatesIndex),this._textureMap.set(w,e),this._exporter._extensionsPostExportTextures("exporter",e,w)}return e}_exportImage(w,p,e){const r=this._exporter._images;let d;if(this._exporter._shouldUseGlb){d={name:w,mimeType:p,bufferView:void 0};const r=this._exporter._bufferManager.createBufferView(new Uint8Array(e));this._exporter._bufferManager.setBufferView(d,r)}else{const f=w.replace(/\.\/|\/|\.\\|\\/g,"_"),q=function(w){switch(w){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(p);let E=f+q;r.some((w=>w.uri===E))&&(E=`${f}_${I.g.RandomId()}${q}`),d={name:w,uri:E},this._exporter._imageData[E]={data:e,mimeType:p}}return r.push(d),r.length-1}_exportTextureInfo(w,p,e){const r=this._exporter._textures;let I=r.findIndex((e=>e.sampler==p&&e.source===w));-1===I&&(I=r.length,r.push({source:w,sampler:p}));const d={index:I};return e&&(d.texCoord=e),d}_exportTextureSampler(w){const p=this._getTextureSampler(w),e=this._exporter._samplers,r=e.findIndex((w=>w.minFilter===p.minFilter&&w.magFilter===p.magFilter&&w.wrapS===p.wrapS&&w.wrapT===p.wrapT));return-1!==r?r:(e.push(p),e.length-1)}}var Y=e(11247),L=e(11081),W=e(11561),F=e(11027);const H=r.k.Zero(),B=r.c.Identity(),D=r.k.One(),T=new r.k(-1,1,1);function Z(w,p){const{byteOffset:e,byteStride:r,type:I,normalized:d}=w,f=w.getSize(),q=p.reduce(((w,p)=>p.getTotalVertices()>w?p.getTotalVertices():w),-Number.MAX_VALUE);return{byteOffset:e,byteStride:r,componentCount:f,type:I,count:q*f,normalized:d,totalVertices:q,kind:w.getKind()}}function G(w){switch(w){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function g(w){switch(w){case X.e.PositionKind:case X.e.NormalKind:case X.e.TangentKind:case X.e.ColorKind:case X.e.MatricesIndicesKind:case X.e.MatricesIndicesExtraKind:case X.e.MatricesWeightsKind:case X.e.MatricesWeightsExtraKind:case X.e.UVKind:case X.e.UV2Kind:case X.e.UV3Kind:case X.e.UV4Kind:case X.e.UV5Kind:case X.e.UV6Kind:return!0}return!1}function o(w){switch(w){case d.b.TriangleFillMode:return 4;case d.b.TriangleStripDrawMode:return 5;case d.b.TriangleFanDrawMode:return 6;case d.b.PointListDrawMode:case d.b.PointFillMode:return 0;case d.b.LineLoopDrawMode:return 2;case d.b.LineListDrawMode:return 1;case d.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${w}`)}function C(w){const p=Math.sqrt(w.x*w.x+w.y*w.y+w.z*w.z);p>0&&(w.x/=p,w.y/=p,w.z/=p)}function Q(w){return w.x*=-1,w}function x(w){if(w.x*w.x+w.y*w.y>.5){const p=Math.abs(w.x),e=Math.abs(w.y);if(p>e){const e=Math.sign(w.x);w.x=p,w.y*=-e,w.z*=-e,w.w*=e}else{const p=Math.sign(w.y);w.x*=-p,w.y=e,w.z*=p,w.w*=-p}}else{const p=Math.abs(w.z),e=Math.abs(w.w);if(p>e){const e=Math.sign(w.z);w.x*=-e,w.y*=e,w.z=p,w.w*=-e}else{const p=Math.sign(w.w);w.x*=p,w.y*=-p,w.z*=-p,w.w=e}}return w}function S(w){w.te(-w.z,w.w,w.x,-w.y)}function ww(w,p){const e=r.k.FromArrayToRef(p.translation||[0,0,0],0,r.d.ne[0]),I=r.c.FromArrayToRef(p.rotation||[0,0,0,1],0,r.d.Quaternion[0]),d=r.b.ComposeToRef(D,I,e,r.d.Matrix[0]),f=r.k.FromArrayToRef(w.translation||[0,0,0],0,r.d.ne[2]),q=r.c.FromArrayToRef(w.rotation||[0,0,0,1],0,r.d.Quaternion[1]),E=r.b.ComposeToRef(D,q,f,r.d.Matrix[1]);d.multiplyToRef(E,E),E.decompose(void 0,I,e),e.equalsWithEpsilon(H,F.c)?delete p.translation:p.translation=e.ze(),I.equalsWithEpsilon(B,F.c)?delete p.rotation:p.rotation=I.ze(),p.scale&&delete p.scale}function pw(w,p){if(!(p instanceof k.e))return!1;if(!(1===p.getChildren().length&&0===w.getChildren().length&&w.parent===p))return!1;const e=w.iw(),r=w instanceof W.d&&!e.useRightHandedSystem?T:D;return!!p.Ne.equalsWithEpsilon(r,F.c)||(L.c.Warn(`Cannot collapse node ${w.name} into parent node ${p.name} with modified scaling.`),!1)}function ew(w){if(w instanceof Array){const p=new Float32Array(w);return new Uint8Array(p.buffer,p.byteOffset,p.byteLength)}return ArrayBuffer.isView(w)?new Uint8Array(w.buffer,w.byteOffset,w.byteLength):new Uint8Array(w)}function rw(w,p){for(const[e,r]of Object.entries(w)){const I=p[e];(Array.isArray(r)&&Array.isArray(I)&&Iw(r,I)||r===I)&&delete w[e]}return w}function Iw(w,p){return w.length===p.length&&w.every(((w,e)=>w===p[e]))}const dw=r.b.Compose(new r.k(-1,1,1),r.c.Identity(),r.k.Zero());function fw(w,p){if(!(w instanceof k.e))return!1;if(p){if(!w.getWorldMatrix().equalsWithEpsilon(r.b.IdentityReadOnly,F.c))return!1}else{if(!w.getWorldMatrix().multiplyToRef(dw,r.d.Matrix[0]).equalsWithEpsilon(r.b.IdentityReadOnly,F.c))return!1}return!(w instanceof m.b&&w.me)}const qw=new Map([[Int8Array,(w,p,e)=>w.setInt8(p,e)],[Uint8Array,(w,p,e)=>w.setUint8(p,e)],[Uint8ClampedArray,(w,p,e)=>w.setUint8(p,e)],[Int16Array,(w,p,e)=>w.setInt16(p,e,!0)],[Uint16Array,(w,p,e)=>w.setUint16(p,e,!0)],[Int32Array,(w,p,e)=>w.setInt32(p,e,!0)],[Uint32Array,(w,p,e)=>w.setUint32(p,e,!0)],[Float32Array,(w,p,e)=>w.setFloat32(p,e,!0)],[Float64Array,(w,p,e)=>w.setFloat64(p,e,!0)]]);class Ew{writeTypedArray(w){this._checkGrowBuffer(w.byteLength);const p=qw.get(w.constructor);for(let e=0;e<w.length;e++)p(this._dataView,this._byteOffset,w[e]),this._byteOffset+=w.BYTES_PER_ELEMENT}constructor(w){this._data=new Uint8Array(w),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(w){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,w),this._byteOffset++}writeInt8(w){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,w),this._byteOffset++}writeInt16(w){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,w,!0),this._byteOffset+=2}writeUInt16(w){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,w,!0),this._byteOffset+=2}writeInt32(w){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,w,!0),this._byteOffset+=4}writeUInt32(w){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,w,!0),this._byteOffset+=4}writeFloat32(w){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,w,!0),this._byteOffset+=4}writeFloat64(w){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,w,!0),this._byteOffset+=8}_checkGrowBuffer(w){const p=this.byteOffset+w;if(p>this._data.byteLength){const w=new Uint8Array(2*p);w.set(this._data),this._data=w,this._dataView=new DataView(this._data.buffer)}}}function jw(w){return w%4===0?4:w%2===0?2:1}class Xw{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(w){let p=0;this._bufferViewToData.forEach((w=>{p+=w.byteLength}));const e=new Ew(p),r=Array.from(this._bufferViewToData.keys()).sort(((w,p)=>jw(p.byteLength)-jw(w.byteLength)));for(const I of r){I.byteOffset=e.byteOffset,w.push(I);const p=w.length-1,r=this.getPropertiesWithBufferView(I);for(const w of r)w.bufferView=p;e.writeTypedArray(this._bufferViewToData.get(I)),this._bufferViewToData.delete(I)}return e.getOutputData()}createBufferView(w,p){const e={buffer:0,byteOffset:void 0,byteLength:w.byteLength,byteStride:p};return this._bufferViewToData.set(e,w),e}createAccessor(w,p,e,r,I,d,f){this._verifyBufferView(w);const q={bufferView:void 0,componentType:e,count:r,type:p,min:null===d||void 0===d?void 0:d.min,max:null===d||void 0===d?void 0:d.max,normalized:f,byteOffset:I};return this.setBufferView(q,w),this._accessorToBufferView.set(q,w),q}setBufferView(w,p){this._verifyBufferView(p);this.getPropertiesWithBufferView(p).push(w)}removeBufferView(w){const p=this.getPropertiesWithBufferView(w);for(const e of p)void 0!==e.bufferView&&delete e.bufferView;this._bufferViewToData.delete(w),this._bufferViewToProperties.delete(w),this._accessorToBufferView.forEach(((p,e)=>{p===w&&(void 0!==e.byteOffset&&delete e.byteOffset,this._accessorToBufferView.delete(e))}))}getBufferView(w){const p=this._accessorToBufferView.get(w);return this._verifyBufferView(p),p}getPropertiesWithBufferView(w){return this._verifyBufferView(w),this._bufferViewToProperties.set(w,this._bufferViewToProperties.get(w)??[]),this._bufferViewToProperties.get(w)}getData(w){return this._verifyBufferView(w),this._bufferViewToData.get(w)}_verifyBufferView(w){if(void 0===w||!this._bufferViewToData.has(w))throw new Error(`BufferView ${w} not found in BufferManager.`)}}var kw,mw=e(11374),Jw=e(11404),Kw=e(11564),yw=e(11710),cw=e(11713),sw=e(11723),Ow=e(11370),aw=e(11729);!function(w){w[w.INTANGENT=0]="INTANGENT",w[w.OUTTANGENT=1]="OUTTANGENT"}(kw||(kw={}));class Aw{static _IsTransformable(w){return w&&(w instanceof k.e||w instanceof mw.d||w instanceof aw.b)}static _CreateNodeAnimation(w,p,e,r,d){if(this._IsTransformable(w)){const f=[],q=[],E=p.getKeys(),j=Aw._CalculateMinMaxKeyFrames(E),X=Aw._DeduceInterpolation(E,e,r),k=X.interpolationType,m=X.shouldBakeAnimation;if(m?Aw._CreateBakedAnimation(w,p,e,j.min,j.max,p.framePerSecond,d,f,q,j,r):"LINEAR"===k||"STEP"===k?Aw._CreateLinearOrStepAnimation(w,p,e,f,q,r):"CUBICSPLINE"===k?Aw._CreateCubicSplineAnimation(w,p,e,f,q,r):Aw._CreateBakedAnimation(w,p,e,j.min,j.max,p.framePerSecond,d,f,q,j,r),f.length&&q.length){return{inputs:f,outputs:q,samplerInterpolation:k,inputsMin:m?j.min:I.g.FloatRound(j.min/p.framePerSecond),inputsMax:m?j.max:I.g.FloatRound(j.max/p.framePerSecond)}}}return null}static _DeduceAnimationInfo(w){let p=null,e="VEC3",r=!1;const d=w.targetProperty.split(".");switch(d[0]){case"Ne":p="scale";break;case"position":p="translation";break;case"rotation":e="VEC4",p="rotation";break;case"rotationQuaternion":e="VEC4",r=!0,p="rotation";break;case"influence":e="SCALAR",p="weights";break;default:I.g.Error(`Unsupported animatable property ${d[0]}`)}return p?{animationChannelTargetPath:p,dataAccessorType:e,useQuaternion:r}:(I.g.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(w,p,e,r,I,d,f,q,E,j,X){let k;if(Aw._IsTransformable(w)&&w.animations)for(const m of w.animations){if(X&&!X(m))continue;const I=Aw._DeduceAnimationInfo(m);I&&(k={name:m.name,samplers:[],channels:[]},Aw._AddAnimation(`${m.name}`,m.hasRunningRuntimeAnimations?p:k,w,m,I.dataAccessorType,I.animationChannelTargetPath,r,d,f,q,I.useQuaternion,E,j),k.samplers.length&&k.channels.length&&e.push(k))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(w,p,e,r,I,d,f,q,E,j,X){let k;if(w instanceof Ow.c){const I=w.morphTargetManager;if(I)for(let m=0;m<I.numTargets;++m){const J=I.getTarget(m);for(const K of J.animations){if(X&&!X(K))continue;const J=new cw.c(`${K.name}`,"influence",K.framePerSecond,K.dataType,K.loopMode,K.enableBlending),y=[],c=K.getKeys();for(let w=0;w<c.length;++w){const p=c[w];for(let w=0;w<I.numTargets;++w)w==m?y.push(p):y.push({frame:p.frame,value:0})}J.setKeys(y);const s=Aw._DeduceAnimationInfo(J);s&&(k={name:J.name,samplers:[],channels:[]},Aw._AddAnimation(K.name,K.hasRunningRuntimeAnimations?p:k,w,J,s.dataAccessorType,s.animationChannelTargetPath,r,d,f,q,s.useQuaternion,E,j,I.numTargets),k.samplers.length&&k.channels.length&&e.push(k))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(w,p,e,r,I,d,f,q,E){let j;if(w.animationGroups){const k=w.animationGroups;for(const m of k){const k=new Map,J=new Map,K=new Set,y=m.to-m.from;j={name:m.name,channels:[],samplers:[]};for(let p=0;p<m.targetedAnimations.length;++p){const y=m.targetedAnimations[p],c=y.target,s=y.animation;if(E&&!E(s))continue;const O=q.has(c);if(this._IsTransformable(c)||1===c.length&&this._IsTransformable(c[0])){const w=Aw._DeduceAnimationInfo(y.animation);if(w){const p=this._IsTransformable(c)?c:this._IsTransformable(c[0])?c[0]:null;p&&Aw._AddAnimation(`${s.name}`,j,p,s,w.dataAccessorType,w.animationChannelTargetPath,e,r,I,d,w.useQuaternion,f,O)}}else if(c instanceof sw.e||1===c.length&&c[0]instanceof sw.e){if(Aw._DeduceAnimationInfo(y.animation)){const p=c instanceof sw.e?c:c[0];if(p){const e=w.morphTargetManagers.find((w=>{for(let e=0;e<w.numTargets;++e)if(w.getTarget(e)===p)return!0;return!1}));if(e){const r=w.meshes.find((w=>w.morphTargetManager===e));var X;if(r)k.has(r)||k.set(r,new Map),null===(X=k.get(r))||void 0===X||X.set(p,s),K.add(r),J.set(r,s)}}}}}K.forEach((w=>{const p=w.morphTargetManager;let q=null;const E=[],X=J.get(w).getKeys(),K=X.length;for(let e=0;e<K;++e)for(let r=0;r<p.numTargets;++r){const I=p.getTarget(r),d=k.get(w);if(d){const p=d.get(I);p?(q||(q=new cw.c(`${m.name}_${w.name}_MorphWeightAnimation`,"influence",p.framePerSecond,cw.c.ANIMATIONTYPE_FLOAT,p.loopMode,p.enableBlending)),E.push(p.getKeys()[e])):E.push({frame:m.from+y/K*e,value:I.influence,inTangent:X[0].inTangent?0:void 0,outTangent:X[0].outTangent?0:void 0})}}q.setKeys(E);const c=Aw._DeduceAnimationInfo(q);c&&Aw._AddAnimation(`${m.name}_${w.name}_MorphWeightAnimation`,j,w,q,c.dataAccessorType,c.animationChannelTargetPath,e,r,I,d,c.useQuaternion,f,!1,null===p||void 0===p?void 0:p.numTargets)})),j.channels.length&&j.samplers.length&&p.push(j)}}}static _AddAnimation(w,p,e,I,d,f,q,E,j,X,k,m,J,K){const y=Aw._CreateNodeAnimation(e,I,f,k,m);let c,s,O,a,A,z;if(y){if(K){let w=0,p=0;const e=[];for(;y.inputs.length>0;)p=y.inputs.shift(),w%K==0&&e.push(p),w++;y.inputs=e}const w=q.get(e),I=new Float32Array(y.inputs);c=E.createBufferView(I),s=E.createAccessor(c,"SCALAR",5126,y.inputs.length,void 0,{min:[y.inputsMin],max:[y.inputsMax]}),X.push(s),O=X.length-1;const j=new r.c,k=new r.k,m=new r.k,M=e instanceof mw.d,i=G(d),t=new Float32Array(y.outputs.length*i);y.outputs.forEach((function(w,p){let e=w;switch(f){case"translation":J&&(r.k.FromArrayToRef(w,0,m),Q(m),m.toArray(e));break;case"rotation":4===w.length?r.c.FromArrayToRef(w,0,j):(e=new Array(4),r.k.FromArrayToRef(w,0,k),r.c.FromEulerVectorToRef(k,j)),J&&(x(j),M&&S(j)),j.toArray(e)}t.set(e,p*i)})),c=E.createBufferView(t),s=E.createAccessor(c,d,5126,y.outputs.length),X.push(s),a=X.length-1,A={interpolation:y.samplerInterpolation,input:O,output:a},p.samplers.push(A),z={sampler:p.samplers.length-1,target:{node:w,path:f}},p.channels.push(z)}}static _CreateBakedAnimation(w,p,e,d,f,q,E,j,X,k,m){let J;const K=r.c.Identity();let y,c=null,s=null,O=null,a=null,A=null,z=null;k.min=I.g.FloatRound(d/q);const M=p.getKeys();for(let r=0,i=M.length;r<i;++r){if(z=null,O=M[r],r+1<i)if(a=M[r+1],O.value.equals&&O.value.equals(a.value)||O.value===a.value){if(0!==r)continue;z=O.frame}else z=a.frame;else{if(A=M[r-1],O.value.equals&&O.value.equals(A.value)||O.value===A.value)continue;z=f}if(z)for(let r=O.frame;r<=z;r+=E){if(y=I.g.FloatRound(r/q),y===c)continue;c=y,s=y;const d={key:0,repeatCount:0,loopMode:p.loopMode};J=p._interpolate(r,d),Aw._SetInterpolatedValue(w,J,y,p,e,K,j,X,m)}}s&&(k.max=s)}static _ConvertFactorToVector3OrQuaternion(w,p,e,d,f){const q=Aw._GetBasePositionRotationOrScale(p,d,f),E=e.targetProperty.split("."),j=E?E[1]:"",X=f?r.c.Ve(q).normalize():r.k.Ve(q);switch(j){case"x":case"y":case"z":X[j]=w;break;case"w":X.w=w;break;default:I.g.Error(`glTFAnimation: Unsupported component name "${j}"!`)}return X}static _SetInterpolatedValue(w,p,e,I,d,f,q,E,j){let X;q.push(e),"weights"!==d?(I.dataType===cw.c.ANIMATIONTYPE_FLOAT&&(p=this._ConvertFactorToVector3OrQuaternion(p,w,I,d,j)),"rotation"===d?(j?f=p:(X=p,r.c.RotationYawPitchRollToRef(X.y,X.x,X.z,f)),E.push(f.ze())):(X=p,E.push(X.ze()))):E.push([p])}static _CreateLinearOrStepAnimation(w,p,e,r,I,d){for(const f of p.getKeys())r.push(f.frame/p.framePerSecond),Aw._AddKeyframeValue(f,p,I,e,w,d)}static _CreateCubicSplineAnimation(w,p,e,r,I,d){p.getKeys().forEach((function(f){r.push(f.frame/p.framePerSecond),Aw._AddSplineTangent(kw.INTANGENT,I,e,"CUBICSPLINE",f,d),Aw._AddKeyframeValue(f,p,I,e,w,d),Aw._AddSplineTangent(kw.OUTTANGENT,I,e,"CUBICSPLINE",f,d)}))}static _GetBasePositionRotationOrScale(w,p,e){let I;if("rotation"===p)if(e){I=(w.rotationQuaternion??r.c.Identity()).ze()}else{I=(w.rotation??r.k.Zero()).ze()}else if("translation"===p){I=(w.position??r.k.Zero()).ze()}else{I=(w.Ne??r.k.One()).ze()}return I}static _AddKeyframeValue(w,p,e,d,f,q){let E;const j=p.dataType;if(j===cw.c.ANIMATIONTYPE_VECTOR3){let p=w.value.ze();if("rotation"===d){const w=r.k.Ve(p);p=r.c.RotationYawPitchRoll(w.y,w.x,w.z).ze()}e.push(p)}else if(j===cw.c.ANIMATIONTYPE_FLOAT){if("weights"===d)e.push([w.value]);else if(E=this._ConvertFactorToVector3OrQuaternion(w.value,f,p,d,q),E){if("rotation"===d){const w=q?E:r.c.RotationYawPitchRoll(E.y,E.x,E.z).normalize();e.push(w.ze())}e.push(E.ze())}}else j===cw.c.ANIMATIONTYPE_QUATERNION?e.push(w.value.normalize().ze()):I.g.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(w,p,e){let r,I,d=!1;if("rotation"===p&&!e)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let f=0,q=w.length;f<q;++f)if(I=w[f],I.inTangent||I.outTangent)if(r){if("CUBICSPLINE"!==r){r="LINEAR",d=!0;break}}else r="CUBICSPLINE";else if(r){if("CUBICSPLINE"===r||I.interpolation&&1===I.interpolation&&"STEP"!==r){r="LINEAR",d=!0;break}}else r=I.interpolation&&1===I.interpolation?"STEP":"LINEAR";return r||(r="LINEAR"),{interpolationType:r,shouldBakeAnimation:d}}static _AddSplineTangent(w,p,e,I,d,f){let q;const E=w===kw.INTANGENT?d.inTangent:d.outTangent;if("CUBICSPLINE"===I){if("rotation"===e)if(E)if(f)q=E.ze();else{const w=E;q=r.c.RotationYawPitchRoll(w.y,w.x,w.z).ze()}else q=[0,0,0,0];else q="weights"===e?E?[E]:[0]:E?E.ze():[0,0,0];p.push(q)}}static _CalculateMinMaxKeyFrames(w){let p=1/0,e=-1/0;return w.forEach((function(w){p=Math.min(p,w.frame),e=Math.max(e,w.frame)})),{min:p,max:e}}}function zw(w,p,e,d,f,q){const E={attributes:{},influence:w.influence,name:w.name},j=p.me;if(!j)return I.g.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),E;const k=q?-1:1,m=r.k.Zero();let J=0,K=0;if(w.hasPositions){const d=w.getPositions(),q=j.getVerticesData(X.e.PositionKind);if(q){const w=new Float32Array(q.length),p=[1/0,1/0,1/0],I=[-1/0,-1/0,-1/0];K=q.length/3,J=0;for(let e=J;e<K;++e){const f=r.k.Ve(q,3*e);r.k.Ve(d,3*e).subtractToRef(f,m),m.x*=k,p[0]=Math.min(p[0],m.x),I[0]=Math.max(I[0],m.x),p[1]=Math.min(p[1],m.y),I[1]=Math.max(I[1],m.y),p[2]=Math.min(p[2],m.z),I[2]=Math.max(I[2],m.z),w[3*e]=m.x,w[3*e+1]=m.y,w[3*e+2]=m.z}const j=e.createBufferView(w,12),X=e.createAccessor(j,"VEC3",5126,d.length/3,0,{min:p,max:I});f.push(X),E.attributes.POSITION=f.length-1}else I.g.Warn(`Morph target positions for mesh ${p.name} were not exported. Mesh does not have position vertex data`)}if(w.hasNormals){const d=w.getNormals(),q=j.getVerticesData(X.e.NormalKind);if(q){const w=new Float32Array(q.length);K=q.length/3,J=0;for(let e=J;e<K;++e){const p=r.k.Ve(q,3*e).normalize();r.k.Ve(d,3*e).normalize().subtractToRef(p,m),w[3*e]=m.x*k,w[3*e+1]=m.y,w[3*e+2]=m.z}const p=e.createBufferView(w,12),I=e.createAccessor(p,"VEC3",5126,d.length/3,0);f.push(I),E.attributes.NORMAL=f.length-1}else I.g.Warn(`Morph target normals for mesh ${p.name} were not exported. Mesh does not have normals vertex data`)}if(w.hasTangents){const d=w.getTangents(),q=j.getVerticesData(X.e.TangentKind);if(q){K=q.length/4;const w=new Float32Array(3*K);J=0;for(let e=J;e<K;++e){const p=r.k.Ve(q,4*e);C(p);const I=r.k.Ve(d,3*e);C(I),I.subtractToRef(p,m),w[3*e]=m.x*k,w[3*e+1]=m.y,w[3*e+2]=m.z}const p=e.createBufferView(w,12),I=e.createAccessor(p,"VEC3",5126,K,0);f.push(I),E.attributes.TANGENT=f.length-1}else I.g.Warn(`Morph target tangents for mesh ${p.name} were not exported. Mesh does not have tangents vertex data`)}if(w.hasColors){const d=w.getColors(),q=j.getVerticesData(X.e.ColorKind),k=j.getVertexBuffer(X.e.ColorKind);if(q&&k){const w=k.getSize();K=q.length/w;const p=new Float32Array(K*w);J=0;for(let e=J;e<K;++e)if(3===w){const I=r.k.Ve(q,e*w);r.k.Ve(d,e*w).subtractToRef(I,m),p[3*e]=m.x,p[3*e+1]=m.y,p[3*e+2]=m.z}else if(4===w){const I=new r.o,f=r.o.Ve(q,e*w);r.o.Ve(d,e*w).subtractToRef(f,I),p[4*e]=I.x,p[4*e+1]=I.y,p[4*e+2]=I.z,p[4*e+3]=I.w}else I.g.Warn(`Unsupported number of components for color attribute: ${w}`);const j=e.createBufferView(p,4*w),X=e.createAccessor(j,3===w?"VEC3":"VEC4",5126,K,0);f.push(X),E.attributes.COLOR_0=f.length-1}else I.g.Warn(`Morph target colors for mesh ${p.name} were not exported. Mesh does not have colors vertex data`)}return E}var Mw=e(11735),iw=e(11657),tw=e(11648),nw=e(11038);class lw{}lw.DEFAULT_COLOR=c.b.White(),lw.DEFAULT_WIDTH_ATTENUATED=1,lw.DEFAULT_WIDTH=.1;var Nw=e(11482),Uw=e(11744);class vw{static ConvertPoints(w,p){if(w.length&&Array.isArray(w)&&"number"===typeof w[0])return[w];if(w.length&&Array.isArray(w[0])&&"number"===typeof w[0][0])return w;if(w.length&&!Array.isArray(w[0])&&w[0]instanceof r.k){const p=[];for(let e=0;e<w.length;e++){const r=w[e];p.push(r.x,r.y,r.z)}return[p]}if(w.length>0&&Array.isArray(w[0])&&w[0].length>0&&w[0][0]instanceof r.k){const p=[],e=w;for(const w of e)p.push(w.flatMap((w=>[w.x,w.y,w.z])));return p}if(w instanceof Float32Array){if(null!==p&&void 0!==p&&p.floatArrayStride){const e=[],r=3*p.floatArrayStride;for(let p=0;p<w.length;p+=r){const I=new Array(r);for(let e=0;e<r;e++)I[e]=w[p+e];e.push(I)}return e}return[Array.from(w)]}if(w.length&&w[0]instanceof Float32Array){const p=[];for(const e of w)p.push(Array.from(e));return p}return[]}static OmitZeroLengthPredicate(w,p,e){const r=[];return p.Je(w).lengthSquared()>0&&r.push([w,p]),e.Je(p).lengthSquared()>0&&r.push([p,e]),w.Je(e).lengthSquared()>0&&r.push([e,w]),0===r.length?null:r}static OmitDuplicatesPredicate(w,p,e,r){const I=[];return vw._SearchInPoints(w,p,r)||I.push([w,p]),vw._SearchInPoints(p,e,r)||I.push([p,e]),vw._SearchInPoints(e,w,r)||I.push([e,w]),0===I.length?null:I}static _SearchInPoints(w,p,e){for(const f of e)for(let e=0;e<f.length;e++){var r,I,d;if(null!==(r=f[e])&&void 0!==r&&r.equals(w))if(null!==(I=f[e+1])&&void 0!==I&&I.equals(p)||null!==(d=f[e-1])&&void 0!==d&&d.equals(p))return!0}return!1}static MeshesToLines(w,p){const e=[];for(let I=0;I<w.length;I++){const d=w[I],f=d.getVerticesData(X.e.PositionKind),q=d.Ke();if(f&&q)for(let w=0,E=0;w<q.length;w++){const j=3*q[E++],X=3*q[E++],k=3*q[E++],m=new r.k(f[j],f[j+1],f[j+2]),J=new r.k(f[X],f[X+1],f[X+2]),K=new r.k(f[k],f[k+1],f[k+2]);if(p){const r=p(m,J,K,e,w,j,d,I,f,q);if(r)for(const w of r)e.push(w)}else e.push([m,J],[J,K],[K,m])}}return e}static ToVector3Array(w){if(Array.isArray(w[0])){const p=[],e=w;for(const w of e){const e=[];for(let p=0;p<w.length;p+=3)e.push(new r.k(w[p],w[p+1],w[p+2]));p.push(e)}return p}const p=w,e=[];for(let I=0;I<p.length;I+=3)e.push(new r.k(p[I],p[I+1],p[I+2]));return e}static ToNumberArray(w){return w.flatMap((w=>[w.x,w.y,w.z]))}static GetPointsCountInfo(w){const p=new Array(w.length);let e=0;for(let r=w.length;r--;)p[r]=w[r].length/3,e+=p[r];return{total:e,counts:p}}static GetLineLength(w){if(0===w.length)return 0;let p;p="number"===typeof w[0]?vw.ToVector3Array(w):w;const e=r.d.ne[0];let I=0;for(let r=0;r<p.length-1;r++){const w=p[r];I+=p[r+1].subtractToRef(w,e).length()}return I}static GetLineLengthArray(w){const p=new Float32Array(w.length/3);let e=0;for(let r=0,I=w.length/3-1;r<I;r++){let I=w[3*r+0],d=w[3*r+1],f=w[3*r+2];I-=w[3*r+3],d-=w[3*r+4],f-=w[3*r+5];e+=Math.sqrt(I*I+d*d+f*f),p[r+1]=e}return p}static SegmentizeSegmentByCount(w,p,e){const I=[],d=p.Je(w),f=r.d.ne[0];f.Pe(e);const q=r.d.ne[1];d.divideToRef(f,q);let E=w.clone();I.push(E);for(let r=0;r<e;r++)E=E.clone(),I.push(E.addInPlace(q));return I}static SegmentizeLineBySegmentLength(w,p){const e=w[0]instanceof r.k?vw.GetLineSegments(w):"number"===typeof w[0]?vw.GetLineSegments(vw.ToVector3Array(w)):w,I=[];for(const r of e)if(r.length>p){const w=vw.SegmentizeSegmentByCount(r.point1,r.point2,Math.ceil(r.length/p));for(const p of w)I.push(p)}else I.push(r.point1),I.push(r.point2);return I}static SegmentizeLineBySegmentCount(w,p){const e="number"===typeof w[0]?vw.ToVector3Array(w):w,r=vw.GetLineLength(e)/p;return vw.SegmentizeLineBySegmentLength(e,r)}static GetLineSegments(w){const p=[];for(let e=0;e<w.length-1;e++){const r=w[e],I=w[e+1],d=I.Je(r).length();p.push({point1:r,point2:I,length:d})}return p}static GetMinMaxSegmentLength(w){const p=vw.GetLineSegments(w).sort((w=>w.length));return{min:p[0].length,max:p[p.length-1].length}}static GetPositionOnLineByVisibility(w,p,e){let I=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const d=p*e;let f=0,q=0;const E=w.length;for(let r=0;r<E;r++){if(d<=f+w[r].length){q=r;break}f+=w[r].length}const j=(d-f)/w[q].length;return w[q].point2.subtractToRef(w[q].point1,r.d.ne[0]),r.d.ne[1]=r.d.ne[0].multiplyByFloats(j,j,j),I||r.d.ne[1].addInPlace(w[q].point1),r.d.ne[1].clone()}static GetCircleLinePoints(w,p){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:w,d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/p;const f=[];for(let q=0;q<=p;q++)f.push(new r.k(Math.cos(q*d)*w,Math.sin(q*d)*I,e));return f}static GetBezierLinePoints(w,p,e,r){return Nw.h.CreateQuadraticBezier(w,p,e,r).getPoints().flatMap((w=>[w.x,w.y,w.z]))}static GetArrowCap(w,p,e,r,I){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,f=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[w.clone(),w.add(p.multiplyByFloats(e,e,e))],widths:[r,I,d,f]}}static GetPointsFromText(w,p,e,r){let I=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,d=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const f=[],q=(0,Uw.d)(w,p,e,r);for(const E of q){for(const w of E.paths){const p=[],e=w.getPoints();for(const w of e)p.push(w.x,w.y,I);f.push(p)}if(d)for(const w of E.holes){const p=[],e=w.getPoints();for(const w of e)p.push(w.x,w.y,I);f.push(p)}}return f}static Color3toRGBAUint8(w){const p=new Uint8Array(4*w.length);for(let e=0,r=0;e<w.length;e++)p[r++]=255*w[e].r,p[r++]=255*w[e].g,p[r++]=255*w[e].b,p[r++]=255;return p}static CreateColorsTexture(w,p,e,r){const I=r.getEngine().getCaps().maxTextureSize??1,d=p.length>I?I:p.length,f=Math.ceil(p.length/I);f>1&&(p=[...p,...Array(d*f-p.length).fill(p[0])]);const q=vw.Color3toRGBAUint8(p),E=new M.b(q,d,f,K.e.TEXTUREFORMAT_RGBA,r,!1,!0,e);return E.name=w,E}static PrepareEmptyColorsTexture(w){if(!lw.EmptyColorsTexture){const p=new Uint8Array(4);lw.EmptyColorsTexture=new M.b(p,1,1,K.e.TEXTUREFORMAT_RGBA,w,!1,!1,M.b.NEAREST_NEAREST),lw.EmptyColorsTexture.name="grlEmptyColorsTexture"}return lw.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var w;null===(w=lw.EmptyColorsTexture)||void 0===w||w.dispose(),lw.EmptyColorsTexture=null}static BooleanToNumber(w){return w?1:0}}class Rw extends tw.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Vw extends iw.c{isCompatible(w){return!0}constructor(w,p,e){var I;e=e||{color:lw.DEFAULT_COLOR};const d=new Rw;d.GREASED_LINE_HAS_COLOR=!!e.color&&!e.useColors,d.GREASED_LINE_SIZE_ATTENUATION=e.sizeAttenuation??!1,d.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===e.colorDistributionType,d.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(p??w.iw()).useRightHandedSystem,d.GREASED_LINE_CAMERA_FACING=e.cameraFacing??!0,super(w,Vw.GREASED_LINE_MATERIAL_NAME,200,d,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(I=e)||void 0===I?void 0:I.forceGLSL)||Vw.ForceGLSL,this._scene=p??w.iw(),this._engine=this._scene.getEngine(),this._cameraFacing=e.cameraFacing??!0,this.visibility=e.visibility??1,this.useDash=e.useDash??!1,this.dashRatio=e.dashRatio??.5,this.dashOffset=e.dashOffset??0,this.width=e.width?e.width:e.sizeAttenuation?lw.DEFAULT_WIDTH_ATTENUATED:lw.DEFAULT_WIDTH,this._sizeAttenuation=e.sizeAttenuation??!1,this.colorMode=e.colorMode??0,this._color=e.color??null,this.useColors=e.useColors??!1,this._colorsDistributionType=e.colorDistributionType??0,this.colorsSampling=e.colorsSampling??M.b.NEAREST_NEAREST,this._colors=e.Nw??null,this.dashCount=e.dashCount??1,this.resolution=e.resolution??new r.g(this._engine.getRenderWidth(),this._engine.getRenderHeight()),e.colorsTexture?this.colorsTexture=e.colorsTexture:this._colors?this.colorsTexture=vw.CreateColorsTexture(`${w.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??lw.DEFAULT_COLOR,vw.PrepareEmptyColorsTexture(this._scene)),this._engine.ue.add((()=>{vw.DisposeEmptyColorsTexture()}))}getAttributes(w){w.push("grl_offsets"),w.push("grl_widths"),w.push("grl_colorPointers"),w.push("grl_counters"),this._cameraFacing?(w.push("grl_previousAndSide"),w.push("grl_nextAndCounters")):w.push("grl_slopes")}getSamplers(w){w.push("grl_colors")}getActiveTextures(w){this.colorsTexture&&w.push(this.colorsTexture)}getUniforms(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const p=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&p.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===w&&p.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:p,vertex:this._cameraFacing&&this._isGLSL(w)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(w)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(w){if(this._cameraFacing){w.Ze("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||w.Ze("viewProjection",this._scene.getTransformMatrix());const p=r.d.Vector4[0];p.x=this._aspect,p.y=this._resolution.x,p.z=this._resolution.y,p.w=this.width,w.updateVector4("grl_aspect_resolution_lineWidth",p)}const p=r.d.Vector4[0];p.x=vw.BooleanToNumber(this.useDash),p.y=this._dashArray,p.z=this.dashOffset,p.w=this.dashRatio,w.updateVector4("grl_dashOptions",p);const e=r.d.Vector4[1];e.x=this.colorMode,e.y=this.visibility,e.z=this.colorsTexture?this.colorsTexture.getSize().width:0,e.w=vw.BooleanToNumber(this.useColors),w.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",e),this._color&&w.updateColor3("grl_singleColor",this._color);const I=this.colorsTexture??lw.EmptyColorsTexture;w.setTexture("grl_colors",I),w.updateFloat2("grl_textureSize",(null===I||void 0===I?void 0:I.getSize().width)??1,(null===I||void 0===I?void 0:I.getSize().height)??1)}prepareDefines(w,p,e){w.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,w.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,w.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,w.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=p.useRightHandedSystem,w.GREASED_LINE_CAMERA_FACING=this._cameraFacing,w.GREASED_LINE_USE_OFFSETS=!!e.offsets}getClassName(){return Vw.GREASED_LINE_MATERIAL_NAME}getCustomCode(w){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(p)?function(w,p){if("vertex"===w){const w={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return p&&(w["!gl_Position\\=viewProjection\\*worldPos;"]="//"),w}return"fragment"===w?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(w,this._cameraFacing):function(w,p){if("vertex"===w){const w={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return p&&(w["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),w}return"fragment"===w?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(w,this._cameraFacing)}dispose(){var w;null===(w=this.colorsTexture)||void 0===w||w.dispose(),super.dispose()}get Nw(){return this._colors}set Nw(w){this.setColors(w)}setColors(w){var p;let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const I=(null===(p=this._colors)||void 0===p?void 0:p.length)??0;var d;if(this._colors=w,null!==w&&0!==w.length){if(!e||r)if(this.colorsTexture&&I===w.length&&!r){const p=vw.Color3toRGBAUint8(w);this.colorsTexture.update(p)}else{var f;null===(f=this.colorsTexture)||void 0===f||f.dispose(),this.colorsTexture=vw.CreateColorsTexture(`${this._material.name}-colors-texture`,w,this.colorsSampling,this._scene)}}else null===(d=this.colorsTexture)||void 0===d||d.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(w){this._dashCount=w,this._dashArray=1/w}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(w){this._sizeAttenuation=w,this.markAllDefinesAsDirty()}get color(){return this._color}set color(w){this.setColor(w)}setColor(w){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==w||null!==this._color&&null===w?(this._color=w,p||this.markAllDefinesAsDirty()):this._color=w}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(w){this._colorsDistributionType=w,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(w){this._aspect=w.x/w.y,this._resolution=w}serialize(){const w=super.serialize(),p={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(p.Nw=this._colors),this._color&&(p.color=this._color),w.greasedLineMaterialOptions=p,w}parse(w,p,e){var r;super.parse(w,p,e);const I=w.greasedLineMaterialOptions;null===(r=this.colorsTexture)||void 0===r||r.dispose(),I.color&&this.setColor(I.color,!0),I.colorDistributionType&&(this.colorsDistributionType=I.colorDistributionType),I.Nw&&(this.Nw=I.Nw),I.colorsSampling&&(this.colorsSampling=I.colorsSampling),I.colorMode&&(this.colorMode=I.colorMode),I.useColors&&(this.useColors=I.useColors),I.visibility&&(this.visibility=I.visibility),I.useDash&&(this.useDash=I.useDash),I.dashCount&&(this.dashCount=I.dashCount),I.dashRatio&&(this.dashRatio=I.dashRatio),I.dashOffset&&(this.dashOffset=I.dashOffset),I.width&&(this.width=I.width),I.sizeAttenuation&&(this.sizeAttenuation=I.sizeAttenuation),I.resolution&&(this.resolution=I.resolution),this.Nw?this.colorsTexture=vw.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Nw,this.colorsSampling,p):vw.PrepareEmptyColorsTexture(p),this.markAllDefinesAsDirty()}copyTo(w){var p;const e=w;null===(p=e.colorsTexture)||void 0===p||p.dispose(),this._colors&&(e.colorsTexture=vw.CreateColorsTexture(`${e._material.name}-colors-texture`,this._colors,e.colorsSampling,this._scene)),e.setColor(this.color,!0),e.colorsDistributionType=this.colorsDistributionType,e.colorsSampling=this.colorsSampling,e.colorMode=this.colorMode,e.useColors=this.useColors,e.visibility=this.visibility,e.useDash=this.useDash,e.dashCount=this.dashCount,e.dashRatio=this.dashRatio,e.dashOffset=this.dashOffset,e.width=this.width,e.sizeAttenuation=this.sizeAttenuation,e.resolution=this.resolution,e.markAllDefinesAsDirty()}_isGLSL(w){return 0===w||this._forceGLSL}}Vw.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Vw.ForceGLSL=!1,(0,nw.d)(`BABYLON.${Vw.GREASED_LINE_MATERIAL_NAME}`,Vw);var bw=e(11337),hw=e(11086),Pw=e(11739),uw=e(11164);class Yw extends Pw.c{constructor(w,p,I){const d=p.getEngine(),f=d.isWebGPU&&!(I.forceGLSL||Yw.ForceGLSL),q=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];p.useRightHandedSystem&&q.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const E=["position","grl_widths","grl_offsets","grl_colorPointers"];I.cameraFacing?(q.push("GREASED_LINE_CAMERA_FACING"),E.push("grl_previousAndSide","grl_nextAndCounters")):(E.push("grl_slopes"),E.push("grl_counters"));const j=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(f||j.push("world","viewProjection","view","projection"),super(w,p,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:f?["Scene","Mesh"]:void 0,attributes:E,uniforms:j,samplers:f?[]:["grlColors"],defines:q,extraInitializationsAsync:async()=>{f?await Promise.all([e.e(47).then(e.bind(e,14320)),e.e(55).then(e.bind(e,14327))]):await Promise.all([e.e(50).then(e.bind(e,14329)),e.e(56).then(e.bind(e,14337))])},shaderLanguage:f?1:0}),this._color=c.b.White(),this._colorsDistributionType=0,this._colorsTexture=null,I=I||{color:lw.DEFAULT_COLOR},this.visibility=I.visibility??1,this.useDash=I.useDash??!1,this.dashRatio=I.dashRatio??.5,this.dashOffset=I.dashOffset??0,this.dashCount=I.dashCount??1,this.width=I.width?I.width:I.sizeAttenuation&&I.cameraFacing?lw.DEFAULT_WIDTH_ATTENUATED:lw.DEFAULT_WIDTH,this.sizeAttenuation=I.sizeAttenuation??!1,this.color=I.color??c.b.White(),this.useColors=I.useColors??!1,this.colorsDistributionType=I.colorDistributionType??0,this.colorsSampling=I.colorsSampling??M.b.NEAREST_NEAREST,this.colorMode=I.colorMode??0,this._colors=I.Nw??null,this._cameraFacing=I.cameraFacing??!0,this.resolution=I.resolution??new r.g(d.getRenderWidth(),d.getRenderHeight()),I.colorsTexture?this.colorsTexture=I.colorsTexture:this._colors?this.colorsTexture=vw.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,p):(this._color=this._color??lw.DEFAULT_COLOR,this.colorsTexture=vw.PrepareEmptyColorsTexture(p)),f){const w=new uw.e;w.setParameters(),w.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",w)}d.ue.add((()=>{vw.DisposeEmptyColorsTexture()}))}dispose(){var w;null===(w=this._colorsTexture)||void 0===w||w.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new r.g(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Nw(){return this._colors}set Nw(w){this.setColors(w)}setColors(w){var p;let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const I=(null===(p=this._colors)||void 0===p?void 0:p.length)??0;var d;if(this._colors=w,null!==w&&0!==w.length){if(!e||r)if(this._colorsTexture&&I===w.length&&!r){const p=vw.Color3toRGBAUint8(w);this._colorsTexture.update(p)}else{var f;null===(f=this._colorsTexture)||void 0===f||f.dispose(),this.colorsTexture=vw.CreateColorsTexture(`${this.name}-colors-texture`,w,this.colorsSampling,this.iw())}}else null===(d=this._colorsTexture)||void 0===d||d.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(w){this._colorsTexture=w,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(w){this._width=w,this.setFloat("grlWidth",w)}get useColors(){return this._useColors}set useColors(w){this._useColors=w,this.setFloat("grlUseColors",vw.BooleanToNumber(w))}get colorsSampling(){return this._colorsSampling}set colorsSampling(w){this._colorsSampling=w}get visibility(){return this._visibility}set visibility(w){this._visibility=w,this.setFloat("grlVisibility",w)}get useDash(){return this._useDash}set useDash(w){this._useDash=w,this.setFloat("grlUseDash",vw.BooleanToNumber(w))}get dashOffset(){return this._dashOffset}set dashOffset(w){this._dashOffset=w,this.setFloat("grlDashOffset",w)}get dashRatio(){return this._dashRatio}set dashRatio(w){this._dashRatio=w,this.setFloat("grlDashRatio",w)}get dashCount(){return this._dashCount}set dashCount(w){this._dashCount=w,this._dashArray=1/w,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(w){this._sizeAttenuation=w,this.setFloat("grlSizeAttenuation",vw.BooleanToNumber(w))}get color(){return this._color}set color(w){this.setColor(w)}setColor(w){w=w??lw.DEFAULT_COLOR,this._color=w,this.setColor3("grlColor",w)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(w){this._colorsDistributionType=w,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(w){this._colorMode=w,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(w){this._resolution=w,this.setVector2("grlResolution",w),this.setFloat("grlAspect",w.x/w.y)}serialize(){const w=super.serialize(),p={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(p.Nw=this._colors),w.greasedLineMaterialOptions=p,w}parse(w,p,e){var r;const I=w.greasedLineMaterialOptions;null===(r=this._colorsTexture)||void 0===r||r.dispose(),I.color&&(this.color=I.color),I.colorDistributionType&&(this.colorsDistributionType=I.colorDistributionType),I.colorsSampling&&(this.colorsSampling=I.colorsSampling),I.colorMode&&(this.colorMode=I.colorMode),I.useColors&&(this.useColors=I.useColors),I.visibility&&(this.visibility=I.visibility),I.useDash&&(this.useDash=I.useDash),I.dashCount&&(this.dashCount=I.dashCount),I.dashRatio&&(this.dashRatio=I.dashRatio),I.dashOffset&&(this.dashOffset=I.dashOffset),I.width&&(this.width=I.width),I.sizeAttenuation&&(this.sizeAttenuation=I.sizeAttenuation),I.resolution&&(this.resolution=I.resolution),I.Nw?this.colorsTexture=vw.CreateColorsTexture(`${this.name}-colors-texture`,I.Nw,this.colorsSampling,this.iw()):this.colorsTexture=vw.PrepareEmptyColorsTexture(p),this._cameraFacing=I.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Lw,Ww,Fw;Yw.ForceGLSL=!1,function(w){w[w.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",w[w.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Lw||(Lw={})),function(w){w[w.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",w[w.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",w[w.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Ww||(Ww={})),function(w){w[w.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",w[w.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",w[w.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",w[w.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",w[w.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Fw||(Fw={}));class Hw extends Ow.c{constructor(w,p,e){super(w,p,null,null,!1,!1),this.name=w,this._options=e,this._lazy=!1,this._updatable=!1,this._engine=p.getEngine(),this._lazy=e.lazy??!1,this._updatable=e.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=e.colorPointers??[],this._widths=e.widths??new Array(e.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(w){let p=0;for(const r of this._points)p+=r.length;const e=p/3*2-this._widths.length;for(let r=0;r<e;r++)this._widths.push(w)}updateLazy(){var w,p;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(w=this._options.ribbonOptions)||void 0===w?void 0:w.smoothShading),!this.bw&&this.refreshBoundingInfo(),null===(p=this.greasedLineMaterial)||void 0===p||p.updateLazy()}addPoints(w,p){for(const e of w)this._points.push(e);this._lazy||this.setPoints(this._points,p)}dispose(w){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(w,p)}isLazy(){return this._lazy}get Uw(){return this._uvs}set Uw(w){this._uvs=w instanceof Float32Array?w:new Float32Array(w),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(w){this.material instanceof Yw&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===w||void 0===w?void 0:w.length)>0),this._offsets=w,this._offsetsBuffer?this._offsetsBuffer.update(w):this._createOffsetsBuffer(w)}get widths(){return this._widths}set widths(w){this._widths=w,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(w)}get colorPointers(){return this._colorPointers}set colorPointers(w){this._colorPointers=w,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(w)}get greasedLineMaterial(){var w,p;if(this.material&&this.material instanceof Yw)return this.material;const e=null===(w=this.material)||void 0===w||null===(p=w.pluginManager)||void 0===p?void 0:p.getPlugin(Vw.GREASED_LINE_MATERIAL_NAME);return e||void 0}get points(){const w=[];return hw.d.DeepCopy(this._points,w),w}setPoints(w,p){this._points=vw.ConvertPoints(w,(null===p||void 0===p?void 0:p.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==p&&void 0!==p&&p.colorPointers||this._updateColorPointers(),this._setPoints(this._points,p)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Uw:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(w){super.serialize(w),w.type=this.getClassName(),w.lineOptions=this._createLineOptions()}_createVertexBuffers(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=new bw.b;return p.nw=this._vertexPositions,p.indices=this._indices,p.Uw=this._uvs,w&&(p.lw=[],bw.b.ComputeNormals(this._vertexPositions,this._indices,p.lw)),p.Vw(this,this._options.updatable),p}_createOffsetsBuffer(w){const p=this._scene.getEngine(),e=new X.b(p,w,this._updatable,3);this.setVerticesBuffer(e.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=e}}class Bw{constructor(w,p){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=w,this.wasAddedByNoopNode=p}getIndicesAccessor(w,p,e,r,I){var d,f,q,E;return null===(d=this._indicesAccessorMap.get(w))||void 0===d||null===(f=d.get(p))||void 0===f||null===(q=f.get(e))||void 0===q||null===(E=q.get(r))||void 0===E?void 0:E.get(I)}setIndicesAccessor(w,p,e,r,I,d){let f=this._indicesAccessorMap.get(w);f||(f=new Map,this._indicesAccessorMap.set(w,f));let q=f.get(p);q||(q=new Map,f.set(p,q));let E=q.get(e);E||(E=new Map,q.set(e,E));let j=E.get(r);j||(j=new Map,E.set(r,j)),j.set(I,d)}pushExportedNode(w){this._exportedNodes.has(w)||this._exportedNodes.add(w)}getNodesSet(){return this._exportedNodes}getVertexBufferView(w){return this._vertexBufferViewMap.get(w)}setVertexBufferView(w,p){this._vertexBufferViewMap.set(w,p)}setRemappedBufferView(w,p,e){this._remappedBufferView.set(w,new Map),this._remappedBufferView.get(w).set(p,e)}getRemappedBufferView(w,p){var e;return null===(e=this._remappedBufferView.get(w))||void 0===e?void 0:e.get(p)}getVertexAccessor(w,p,e){var r,I;return null===(r=this._vertexAccessorMap.get(w))||void 0===r||null===(I=r.get(p))||void 0===I?void 0:I.get(e)}setVertexAccessor(w,p,e,r){let I=this._vertexAccessorMap.get(w);I||(I=new Map,this._vertexAccessorMap.set(w,I));let d=I.get(p);d||(d=new Map,I.set(p,d)),d.set(e,r)}hasVertexColorAlpha(w){return this._vertexMapColorAlpha.get(w)||!1}setHasVertexColorAlpha(w,p){return this._vertexMapColorAlpha.set(w,p)}getMesh(w){return this._meshMap.get(w)}setMesh(w,p){this._meshMap.set(w,p)}bindMorphDataToMesh(w,p){const e=this._meshMorphTargetMap.get(w)||[];this._meshMorphTargetMap.set(w,e),-1===e.indexOf(p)&&e.push(p)}getMorphTargetsFromMesh(w){return this._meshMorphTargetMap.get(w)}}class Dw{_ApplyExtension(w,p,e,r){if(e>=p.length)return Promise.resolve(w);const I=r(p[e],w);return I?I.then((async w=>w?await this._ApplyExtension(w,p,e+1,r):null)):this._ApplyExtension(w,p,e+1,r)}_ApplyExtensions(w,p){const e=[];for(const r of Dw._ExtensionNames)e.push(this._extensions[r]);return this._ApplyExtension(w,e,0,p)}_extensionsPreExportTextureAsync(w,p,e){return this._ApplyExtensions(p,((p,r)=>p.preExportTextureAsync&&p.preExportTextureAsync(w,r,e)))}_extensionsPostExportNodeAsync(w,p,e,r,I){return this._ApplyExtensions(p,((p,d)=>p.postExportNodeAsync&&p.postExportNodeAsync(w,d,e,r,I,this._bufferManager)))}_extensionsPostExportMaterialAsync(w,p,e){return this._ApplyExtensions(p,((p,r)=>p.postExportMaterialAsync&&p.postExportMaterialAsync(w,r,e)))}_extensionsPostExportMaterialAdditionalTextures(w,p,e){const r=[];for(const I of Dw._ExtensionNames){const d=this._extensions[I];d.postExportMaterialAdditionalTextures&&r.push(...d.postExportMaterialAdditionalTextures(w,p,e))}return r}_extensionsPostExportTextures(w,p,e){for(const r of Dw._ExtensionNames){const I=this._extensions[r];I.postExportTexture&&I.postExportTexture(w,p,e)}}_extensionsPostExportMeshPrimitive(w){for(const p of Dw._ExtensionNames){const e=this._extensions[p];e.postExportMeshPrimitive&&e.postExportMeshPrimitive(w,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const w of Dw._ExtensionNames){const p=this._extensions[w];p.preGenerateBinaryAsync&&await p.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(w){for(const p of Dw._ExtensionNames){const e=this._extensions[p];e.enabled&&w(e)}}_extensionsOnExporting(){this._forEachExtensions((w=>{var p,e,r;w.wasUsed&&((p=this._glTF).extensionsUsed||(p.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(w.name)&&this._glTF.extensionsUsed.push(w.name),w.required&&((e=this._glTF).extensionsRequired||(e.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(w.name)&&this._glTF.extensionsRequired.push(w.name)),(r=this._glTF).extensions||(r.extensions={}),w.onExporting&&w.onExporting())}))}_loadExtensions(){for(const w of Dw._ExtensionNames){const p=Dw._ExtensionFactories[w](this);this._extensions[w]=p}}constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:y.d.LastCreatedScene,p=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${K.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new u(this),this._extensions={},this._bufferManager=new Xw,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!w)throw new Error("No scene available to export");this._babylonScene=w,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:w=>{var p;return null===w||void 0===w||null===(p=w.Ge)||void 0===p?void 0:p.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...p},this._loadExtensions()}dispose(){for(const w in this._extensions){this._extensions[w].dispose()}}get options(){return this._options}static RegisterExtension(w,p){Dw.UnregisterExtension(w)&&I.g.Warn(`Extension with the name ${w} already exists`),Dw._ExtensionFactories[w]=p,Dw._ExtensionNames.push(w)}static UnregisterExtension(w){if(!Dw._ExtensionFactories[w])return!1;delete Dw._ExtensionFactories[w];const p=Dw._ExtensionNames.indexOf(w);return-1!==p&&Dw._ExtensionNames.splice(p,1),!0}_generateJSON(w,p,e){const r={byteLength:w};return r.byteLength&&(this._glTF.buffers=[r]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.yp=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(r.uri=p+".bin"),e?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(w){const p=await this._generateBinaryAsync();this._extensionsOnExporting();const e=this._generateJSON(p.byteLength,w,!0),r=new Blob([p],{type:"application/octet-stream"}),I=w+".gltf",d=w+".bin",f=new j;if(f.files[I]=e,f.files[d]=r,this._imageData)for(const q in this._imageData)f.files[q]=new Blob([this._imageData[q].data],{type:this._imageData[q].mimeType});return f}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(w){const p=w%4;return 0===p?p:4-p}async generateGLBAsync(w){this._shouldUseGlb=!0;const p=await this._generateBinaryAsync();this._extensionsOnExporting();const e=this._generateJSON(p.byteLength),r=w+".glb";let I,d=e.length;if("undefined"!==typeof TextEncoder){I=(new TextEncoder).encode(e),d=I.length}const f=this._getPadding(d),q=this._getPadding(p.byteLength),E=28+d+f+p.byteLength+q,X=new Ew(E);if(X.writeUInt32(1179937895),X.writeUInt32(2),X.writeUInt32(E),X.writeUInt32(d+f),X.writeUInt32(1313821514),I)X.writeTypedArray(I);else{const w="_".charCodeAt(0);for(let p=0;p<d;++p){const r=e.charCodeAt(p);r!=e.codePointAt(p)?X.writeUInt8(w):X.writeUInt8(r)}}for(let j=0;j<f;++j)X.writeUInt8(32);X.writeUInt32(p.byteLength+q),X.writeUInt32(5130562),X.writeTypedArray(p);for(let j=0;j<q;++j)X.writeUInt8(0);const k=new j;return k.files[r]=new Blob([X.getOutputData()],{type:"application/octet-stream"}),k}_setNodeTransformation(w,p,e){if(p.getPivotPoint().equalsWithEpsilon(H,F.c)||I.g.Warn("Pivot points are not supported in the glTF serializer"),!p.position.equalsWithEpsilon(H,F.c)){const I=r.d.ne[0].X(p.position);e&&Q(I),w.translation=I.ze()}p.Ne.equalsWithEpsilon(D,F.c)||(w.scale=p.Ne.ze());const d=p.rotationQuaternion||r.c.FromEulerAngles(p.rotation.x,p.rotation.y,p.rotation.z);d.equalsWithEpsilon(B,F.c)||(e&&x(d),w.rotation=d.normalize().ze())}_setCameraTransformation(w,p,e){if(!p.position.equalsWithEpsilon(H,F.c)){const I=r.d.ne[0].X(p.position);e&&Q(I),w.translation=I.ze()}const I=p.rotationQuaternion||r.c.FromEulerAngles(p.rotation.x,p.rotation.y,p.rotation.z);e&&x(I),this._babylonScene.useRightHandedSystem||S(I),I.equalsWithEpsilon(B,F.c)||(w.rotation=I.ze())}_listAvailableCameras(){for(const w of this._babylonScene.cameras){const p={type:w.mode===mw.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(w.name&&(p.name=w.name),"perspective"===p.type)p.perspective={aspectRatio:w.getEngine().getAspectRatio(w),yfov:w.fovMode===mw.d.FOVMODE_VERTICAL_FIXED?w.fov:w.fov*w.getEngine().getAspectRatio(w),znear:w.ge,zfar:w.maxZ};else if("orthographic"===p.type){const e=w.orthoLeft&&w.orthoRight?.5*(w.orthoRight-w.orthoLeft):.5*w.getEngine().getRenderWidth(),r=w.orthoBottom&&w.orthoTop?.5*(w.orthoTop-w.orthoBottom):.5*w.getEngine().getRenderHeight();p.orthographic={xmag:e,ymag:r,znear:w.ge,zfar:w.maxZ}}this._camerasMap.set(w,p)}}_exportAndAssignCameras(){const w=Array.from(this._camerasMap.values());for(const p of w){const w=this._nodesCameraMap.get(p);if(void 0!==w){this._cameras.push(p);for(const p of w)p.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const w of this._babylonScene.skeletons){if(w.bones.length<=0)continue;const p={joints:[]};this._skinMap.set(w,p)}}_exportAndAssignSkeletons(){for(const w of this._babylonScene.skeletons){if(w.bones.length<=0)continue;const p=this._skinMap.get(w);if(void 0==p)continue;const e={},r=[];let d=-1;for(let I=0;I<w.bones.length;++I){const p=w.bones[I],r=p.getIndex()??I;-1!==r&&(e[r]=p,r>d&&(d=r))}for(let w=0;w<=d;++w){const d=e[w];r.push(d.getAbsoluteInverseBindMatrix());const f=d.getTransformNode();if(null!==f){const w=this._nodeMap.get(f);f&&null!==w&&void 0!==w?p.joints.push(w):I.g.Warn("Exporting a bone without a linked transform node is currently unsupported")}else I.g.Warn("Exporting a bone without a linked transform node is currently unsupported")}const f=this._nodesSkinMap.get(p);if(p.joints.length>0&&void 0!==f){const w=64*r.length,e=new Float32Array(w/4);r.forEach(((w,p)=>{e.set(w.m,16*p)}));const I=this._bufferManager.createBufferView(e);this._accessors.push(this._bufferManager.createAccessor(I,"MAT4",5126,r.length)),p.inverseBindMatrices=this._accessors.length-1,this._skins.push(p);for(const p of f)p.skin=this._skins.length-1}}}async _exportSceneAsync(){const w={nodes:[]};if(this._babylonScene.metadata){const p=this._options.metadataSelector(this._babylonScene.metadata);p&&(w.extras=p)}const p=new Array,e=new Array,r=new Array;for(const q of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&fw(q,this._babylonScene.useRightHandedSystem)?r.push(...q.getChildren()):this._babylonScene.useRightHandedSystem?p.push(q):e.push(q);this._listAvailableCameras(),this._listAvailableSkeletons();const I=new Bw(!0,!1);w.nodes.push(...await this._exportNodesAsync(e,I));const d=new Bw(!1,!1);w.nodes.push(...await this._exportNodesAsync(p,d));const f=new Bw(!1,!0);w.nodes.push(...await this._exportNodesAsync(r,f)),w.nodes.length&&this._scenes.push(w),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Aw._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,I.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(w){let p=this._shouldExportNodeMap.get(w);return void 0===p&&(p=this._options.shouldExportNode(w),this._shouldExportNodeMap.set(w,p)),p}async _exportNodesAsync(w,p){const e=new Array;this._exportBuffers(w,p);for(const r of w)await this._exportNodeAsync(r,e,p);return e}_collectBuffers(w,p,e,r,I){if(this._shouldExportNode(w)&&w instanceof m.b&&w.me){const d=w.me.getVertexBuffers();if(d)for(const r in d){if(!g(r))continue;const f=d[r];I.setHasVertexColorAlpha(f,w.hasVertexAlpha);const q=f._buffer,E=p.get(q)||[];p.set(q,E),-1===E.indexOf(f)&&E.push(f);const j=e.get(f)||[];e.set(f,j),-1===j.indexOf(w)&&j.push(w)}const f=w.morphTargetManager;if(f)for(let p=0;p<f.numTargets;p++){const e=f.getTarget(p),I=r.get(e)||[];r.set(e,I),-1===I.indexOf(w)&&I.push(w)}}for(const d of w.getChildren())this._collectBuffers(d,p,e,r,I)}_exportBuffers(w,p){const e=new Map,r=new Map,I=new Map;for(const q of w)this._collectBuffers(q,e,r,I,p);const d=Array.from(e.keys());for(const q of d){const w=q.getData();if(!w)throw new Error("Buffer data is not available");const I=e.get(q);if(!I)continue;const d=I[0].byteStride;if(I.some((w=>w.byteStride!==d)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const f=ew(w).slice();for(const p of I){const w=r.get(p),{byteOffset:e,byteStride:I,componentCount:d,type:q,count:E,normalized:j,kind:k}=Z(p,w);switch(k){case X.e.NormalKind:case X.e.TangentKind:(0,Y.e)(f,e,I,d,q,E,j,(w=>{const p=Math.sqrt(w[0]*w[0]+w[1]*w[1]+w[2]*w[2]);if(p>0){const e=1/p;w[0]*=e,w[1]*=e,w[2]*=e}}));break;case X.e.ColorKind:{const p=w.filter((w=>w.material instanceof yw.c||null==w.material)).length;if(0==p)break;if(p!=w.length){L.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}q==X.e.UNSIGNED_BYTE&&L.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const r=new c.b,k=new c.e,m=this._babylonScene.getEngine().useExactSrgbConversions;(0,Y.e)(f,e,I,d,q,E,j,(w=>{3===w.length?(r.ye(w,0),r.toLinearSpaceToRef(r,m),r.toArray(w,0)):(k.ye(w,0),k.toLinearSpaceToRef(k,m),k.toArray(w,0))}))}}}if(p.convertToRightHanded){for(const w of I){const p=r.get(w),{byteOffset:e,byteStride:I,componentCount:d,type:q,count:E,normalized:j,kind:k}=Z(w,p);switch(k){case X.e.PositionKind:case X.e.NormalKind:case X.e.TangentKind:(0,Y.e)(f,e,I,d,q,E,j,(w=>{w[0]=-w[0]}))}}p.convertedToRightHandedBuffers.set(q,f)}const E=this._bufferManager.createBufferView(f,d);p.setVertexBufferView(q,E);const j=new Map;for(const p of I){const w=r.get(p),{kind:e,totalVertices:I}=Z(p,w);switch(e){case X.e.MatricesIndicesKind:case X.e.MatricesIndicesExtraKind:if(p.type==X.e.FLOAT){const w=p.getFloatData(I);null!==w&&j.set(p,w)}}}0!==j.size&&L.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const k=Array.from(j.keys());for(const e of k){const w=j.get(e);if(!w)continue;const r=w.some((w=>w>=256)),I=new(r?Uint16Array:Uint8Array)(w.length);for(let p=0;p<w.length;p++)I[p]=w[p];const d=this._bufferManager.createBufferView(I,4*(r?2:1));p.setRemappedBufferView(q,e,d)}}const f=Array.from(I.keys());for(const q of f){const w=I.get(q);if(!w)continue;const e=zw(q,w[0],this._bufferManager,this._bufferViews,this._accessors,p.convertToRightHanded);for(const r of w)p.bindMorphDataToMesh(r,e)}}async _exportNodeAsync(w,p,e){let r=this._nodeMap.get(w);if(void 0!==r)return void(p.includes(r)||p.push(r));const I=await this._createNodeAsync(w,e);if(I){r=this._nodes.length,this._nodes.push(I),this._nodeMap.set(w,r),e.pushExportedNode(w),p.push(r);const d={name:"runtime animations",channels:[],samplers:[]},f=[];this._babylonScene.animationGroups.length||(Aw._CreateMorphTargetAnimationFromMorphTargetAnimations(w,d,f,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,e.convertToRightHanded,this._options.shouldExportAnimation),w.animations.length&&Aw._CreateNodeAnimationFromNodeAnimations(w,d,f,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,e.convertToRightHanded,this._options.shouldExportAnimation)),d.channels.length&&d.samplers.length&&this._animations.push(d),f.forEach((w=>{w.channels.length&&w.samplers.length&&this._animations.push(w)}))}const d=I?[]:p;for(const f of w.getChildren())await this._exportNodeAsync(f,d,e);I&&d.length&&(I.children=d)}async _createNodeAsync(w,p){if(!this._shouldExportNode(w))return null;const e={};if(w.name&&(e.name=w.name),w.metadata){const p=this._options.metadataSelector(w.metadata);p&&(e.extras=p)}if(w instanceof k.e&&(this._setNodeTransformation(e,w,p.convertToRightHanded),w instanceof m.b)){const I=w instanceof J.b?w.sourceMesh:w;if(I.oe&&I.oe.length>0&&(e.mesh=await this._exportMeshAsync(I,p)),w.skeleton){const p=this._skinMap.get(w.skeleton);var r;if(void 0!==p)void 0===this._nodesSkinMap.get(p)&&this._nodesSkinMap.set(p,[]),null===(r=this._nodesSkinMap.get(p))||void 0===r||r.push(e)}}if(w instanceof W.d){const r=this._camerasMap.get(w);if(r){var I;void 0===this._nodesCameraMap.get(r)&&this._nodesCameraMap.set(r,[]),this._setCameraTransformation(e,w,p.convertToRightHanded);const f=w.parent;if(null!==f&&pw(w,f)){const w=this._nodeMap.get(f);if(void 0!==w){var d;const p=this._nodes[w];return ww(e,p),null===(d=this._nodesCameraMap.get(r))||void 0===d||d.push(p),null}}null===(I=this._nodesCameraMap.get(r))||void 0===I||I.push(e)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",e,w,this._nodeMap,p.convertToRightHanded)?e:(L.c.Warn(`Not exporting node ${w.name}`),null)}_exportIndices(w,p,e,r,I,f,q,E,j){let X=w;j.mode=o(f);const k=q!==d.b.CounterClockWiseSideOrientation,m=!E.wasAddedByNoopNode&&k,J=function(w){switch(w){case d.b.TriangleFillMode:case d.b.TriangleStripDrawMode:case d.b.TriangleFanDrawMode:return!0}return!1}(f)&&m;if(J){if(f===d.b.TriangleStripDrawMode||f===d.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");j.mode=o(f);const q=p?new Uint32Array(r):new Uint16Array(r);if(w)for(let p=0;p+2<r;p+=3)q[p]=w[e+p]+I,q[p+1]=w[e+p+2]+I,q[p+2]=w[e+p+1]+I;else for(let w=0;w+2<r;w+=3)q[w]=w,q[w+1]=w+2,q[w+2]=w+1;X=q}else if(w&&0!==I){const d=p?new Uint32Array(r):new Uint16Array(r);for(let p=0;p<r;p++)d[p]=w[e+p]+I;X=d}if(X){let d=E.getIndicesAccessor(w,e,r,I,J);if(void 0===d){const f=function(w,p,e,r){if(w instanceof Uint16Array||w instanceof Uint32Array)return w;if(w instanceof Int32Array)return new Uint32Array(w.buffer,w.byteOffset,w.length);const I=w.slice(p,p+e);return r?new Uint32Array(I):new Uint16Array(I)}(X,0,r,p),q=this._bufferManager.createBufferView(f),j=p?5125:5123;this._accessors.push(this._bufferManager.createAccessor(q,"SCALAR",j,r,0)),d=this._accessors.length-1,E.setIndicesAccessor(w,e,r,I,J,d)}j.indices=d}}_exportVertexBuffer(w,p,e,r,I,d){const f=w.getKind();if(!g(f))return;if(f.startsWith("uv")&&!this._options.exportUnusedUVs&&(!p||!this._materialNeedsUVsSet.has(p)))return;let q=I.getVertexAccessor(w,e,r);if(void 0===q){const p=I.convertedToRightHandedBuffers.get(w._buffer)||w._buffer.getData(),d=f===X.e.PositionKind?function(w,p,e,r){const{byteOffset:I,byteStride:d,type:f,normalized:q}=p,E=p.getSize(),j=new Array(E).fill(1/0),X=new Array(E).fill(-1/0);return(0,Y.e)(w,I+e*d,d,E,f,r*E,q,(w=>{for(let p=0;p<E;p++)j[p]=Math.min(j[p],w[p]),X[p]=Math.max(X[p],w[p])})),{min:j,max:X}}(p,w,e,r):void 0,E=(f===X.e.MatricesIndicesKind||f===X.e.MatricesIndicesExtraKind)&&w.type===X.e.FLOAT,j=E?X.e.UNSIGNED_BYTE:w.type,k=E?void 0:w.normalized,m=E?I.getRemappedBufferView(w._buffer,w):I.getVertexBufferView(w._buffer),J=w.byteOffset+e*w.byteStride;this._accessors.push(this._bufferManager.createAccessor(m,function(w,p){if(w==X.e.ColorKind)return p?"VEC4":"VEC3";switch(w){case X.e.PositionKind:case X.e.NormalKind:return"VEC3";case X.e.TangentKind:case X.e.MatricesIndicesKind:case X.e.MatricesIndicesExtraKind:case X.e.MatricesWeightsKind:case X.e.MatricesWeightsExtraKind:return"VEC4";case X.e.UVKind:case X.e.UV2Kind:case X.e.UV3Kind:case X.e.UV4Kind:case X.e.UV5Kind:case X.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${w}`)}(f,I.hasVertexColorAlpha(w)),j,r,J,d,k)),q=this._accessors.length-1,I.setVertexAccessor(w,e,r,q)}d.attributes[function(w){switch(w){case X.e.PositionKind:return"POSITION";case X.e.NormalKind:return"NORMAL";case X.e.TangentKind:return"TANGENT";case X.e.ColorKind:return"COLOR_0";case X.e.UVKind:return"TEXCOORD_0";case X.e.UV2Kind:return"TEXCOORD_1";case X.e.UV3Kind:return"TEXCOORD_2";case X.e.UV4Kind:return"TEXCOORD_3";case X.e.UV5Kind:return"TEXCOORD_4";case X.e.UV6Kind:return"TEXCOORD_5";case X.e.MatricesIndicesKind:return"JOINTS_0";case X.e.MatricesIndicesExtraKind:return"JOINTS_1";case X.e.MatricesWeightsKind:return"WEIGHTS_0";case X.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${w}`)}(f)]=q}async _exportMaterialAsync(w,p,e,r){let I=this._materialMap.get(w);if(void 0===I){const r=p&&Object.keys(p).some((w=>w.startsWith("uv")));if((w=w instanceof Jw.b?w.Ce[e.materialIndex]:w)instanceof Kw.d)I=await this._materialExporter.exportPBRMaterialAsync(w,"image/png",r);else{if(!(w instanceof yw.c))return void L.c.Warn(`Unsupported material '${w.name}' with type ${w.getClassName()}`);I=await this._materialExporter.exportStandardMaterialAsync(w,"image/png",r)}this._materialMap.set(w,I)}r.material=I}async _exportMeshAsync(w,p){var e;let r=p.getMesh(w);if(void 0!==r)return r;const I={primitives:[]};r=this._meshes.length,this._meshes.push(I),p.setMesh(w,r);const f=w.isUnIndexed?null:w.Ke(),q=null===(e=w.me)||void 0===e?void 0:e.getVertexBuffers(),E=p.getMorphTargetsFromMesh(w),j=w instanceof Mw.d,X=w instanceof Hw,k=w.oe;if(q&&k&&k.length>0)for(const K of k){const e={attributes:{}},r=K.Yw()||this._babylonScene.defaultMaterial;if(X){var m,J;const p={name:r.name},I=w,d=c.b.White(),f=(null===(m=I.material)||void 0===m?void 0:m.alpha)??1,q=(null===(J=I.greasedLineMaterial)||void 0===J?void 0:J.color)??d;(!q.equalsWithEpsilon(d,F.c)||f<1)&&(p.pbrMetallicRoughness={baseColorFactor:[...q.ze(),f]}),this._materials.push(p),e.material=this._materials.length-1}else if(j){const p={name:r.name},I=w;(!I.color.equalsWithEpsilon(c.b.White(),F.c)||I.alpha<1)&&(p.pbrMetallicRoughness={baseColorFactor:[...I.color.ze(),I.alpha]}),this._materials.push(p),e.material=this._materials.length-1}else await this._exportMaterialAsync(r,q,K,e);const k=j||X?d.b.LineListDrawMode:w.overrideRenderingFillMode??r.fillMode,y=r._getEffectiveOrientation(w);this._exportIndices(f,f?(0,Y.c)(f,K.indexCount,K.indexStart,K.verticesStart):K.verticesCount>65535,f?K.indexStart:K.verticesStart,f?K.indexCount:K.verticesCount,-K.verticesStart,k,y,p,e);for(const w of Object.values(q))this._exportVertexBuffer(w,r,K.verticesStart,K.verticesCount,p,e);if(E){e.targets=[];for(const w of E)e.targets.push(w.attributes)}I.primitives.push(e),this._extensionsPostExportMeshPrimitive(e)}if(E){I.weights=[],I.extras||(I.extras={}),I.extras.targetNames=[];for(const w of E)I.weights.push(w.influence),I.extras.targetNames.push(w.name)}return r}}Dw._ExtensionNames=new Array,Dw._ExtensionFactories={};class Tw{static async GLTFAsync(w,p,e){e&&e.exportWithoutWaitingForScene||await w.whenReadyAsync();const r=new Dw(w,e),I=await r.generateGLTFAsync(p.replace(/\.[^/.]+$/,""));return r.dispose(),I}static async GLBAsync(w,p,e){e&&e.exportWithoutWaitingForScene||await w.whenReadyAsync();const r=new Dw(w,e),I=await r.generateGLBAsync(p.replace(/\.[^/.]+$/,""));return r.dispose(),I}}e(11752);const Zw="EXT_mesh_gpu_instancing";class Gw{constructor(w){this.name=Zw,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(w,p,e,I,d,f){return await new Promise((w=>{if(p&&e instanceof Ow.c&&e.hasThinInstances&&this._exporter){this._wasUsed=!0;const w=r.k.Zero(),I=r.c.Identity(),q=r.k.One(),E=e.thinInstanceGetWorldMatrices(),j=r.d.ne[2],X=r.d.Quaternion[1],k=r.d.ne[3];let m=!1,J=!1,K=!1;const y=new Float32Array(3*e.xe),c=new Float32Array(4*e.xe),s=new Float32Array(3*e.xe);let O=0;for(const p of E)p.decompose(k,X,j),d&&(Q(j),x(X)),y.set(j.ze(),3*O),c.set(X.normalize().ze(),4*O),s.set(k.ze(),3*O),m=m||!j.equalsWithEpsilon(w),J=J||!X.equalsWithEpsilon(I),K=K||!k.equalsWithEpsilon(q),O++;const a={attributes:{}};m&&(a.attributes.TRANSLATION=this._buildAccessor(y,"VEC3",e.xe,f)),J&&(a.attributes.ROTATION=this._buildAccessor(c,"VEC4",e.xe,f)),K&&(a.attributes.SCALE=this._buildAccessor(s,"VEC3",e.xe,f)),p.extensions=p.extensions||{},p.extensions[Zw]=a}w(p)}))}_buildAccessor(w,p,e,r){const I=r.createBufferView(w),d=r.createAccessor(I,p,5126,e);return this._exporter._accessors.push(d),this._exporter._accessors.length-1}}Dw.RegisterExtension(Zw,(w=>new Gw(w)));var gw=e(11755),ow=e(11765),Cw=e(11772),Qw=e(11778);function xw(w){return w===Cw.e.PositionKind?"POSITION":w===Cw.e.NormalKind?"NORMAL":w===Cw.e.ColorKind?"COLOR":w.startsWith(Cw.e.UVKind)?"TEX_COORD":"GENERIC"}const Sw={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class wp extends gw.b{static get DefaultAvailable(){return(0,gw.h)(wp.DefaultConfiguration)}static get Default(){return wp._Default??(wp._Default=new wp),wp._Default}static ResetDefault(w){wp._Default&&(w||wp._Default.dispose(),wp._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(w,p){return{module:await(p||DracoEncoderModule)({wasmBinary:w})}}_getWorkerContent(){return`${ow.k}(${ow.n})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:wp.DefaultConfiguration)}async _encodeAsync(w,p,e){const r=e?(0,Qw.c)(Sw,e):Sw;if(this._workerPoolPromise){const e=await this._workerPoolPromise;return await new Promise(((I,d)=>{e.push(((e,f)=>{const q=w=>{e.removeEventListener("error",q),e.removeEventListener("message",E),d(w),f()},E=w=>{"encodeMeshDone"===w.data.id&&(e.removeEventListener("error",q),e.removeEventListener("message",E),I(w.data.encodedMeshData),f())};e.addEventListener("error",q),e.addEventListener("message",E);const j=[];for(const p of w)j.push(p.data.buffer);p&&j.push(p.buffer),e.postMessage({id:"encodeMesh",attributes:w,indices:p,options:r},j)}))}))}if(this._modulePromise){const e=await this._modulePromise;return(0,ow.k)(e.module,w,p,r)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(w,p){if(0==w.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");w instanceof Ow.c&&w.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===p||void 0===p?void 0:p.method)&&(L.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),p.method="MESH_SEQUENTIAL_ENCODING");const e=function(w){let p=w.Ke(void 0,!0);return!p||p instanceof Uint32Array||p instanceof Uint16Array||(p=((0,Y.c)(p,p.length)?Uint32Array:Uint16Array).from(p)),p}(w),r=function(w,p){const e=[];for(const r of w.getVerticesDataKinds()){if(null!==p&&void 0!==p&&p.includes(r)){if(r===Cw.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const I=w.getVertexBuffer(r),d=I.getSize(),f=(0,Y.q)(I.getData(),d,I.type,I.byteOffset,I.byteStride,I.normalized,w.getTotalVertices(),!0);e.push({kind:r,dracoName:xw(r),size:d,data:f})}return e}(w,null===p||void 0===p?void 0:p.excludedAttributes);return await this._encodeAsync(r,e,p)}}wp.DefaultConfiguration={wasmUrl:`${I.g._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${I.g._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${I.g._DefaultCdnUrl}/draco_encoder.js`},wp._Default=null;const pp="KHR_draco_mesh_compression";class ep{get wasUsed(){return this._wasUsed}constructor(w){this.name=pp,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===w.options.meshCompressionMethod&&wp.DefaultAvailable}dispose(){}postExportMeshPrimitive(w,p,e){if(!this.enabled)return;if(4!==w.mode&&5!==w.mode)return void L.c.Warn("Cannot compress primitive with mode "+w.mode+".");const r=[],I=[];let d=null;if(void 0!==w.indices){const f=e[w.indices],q=p.getBufferView(f);d=p.getData(q).slice(),r.push(q),I.push(f)}const f=[];for(const[X,k]of Object.entries(w.attributes)){const w=e[k],d=p.getBufferView(w),E=G(w.type),j=(0,Y.q)(p.getData(d),E,w.componentType,w.byteOffset||0,d.byteStride||(0,Y.i)(w.componentType)*E,w.normalized||!1,w.count,!0);f.push({kind:X,dracoName:(q=X,"POSITION"===q?"POSITION":"NORMAL"===q?"NORMAL":q.startsWith("COLOR")?"COLOR":q.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:G(w.type),data:j}),r.push(d),I.push(w)}var q;const E={method:w.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},j=wp.Default._encodeAsync(f,d,E).then((e=>{if(!e)return void L.c.Error("Draco encoding failed for primitive.");const d={bufferView:-1,attributes:e.attributeIds},f=p.createBufferView(e.data);p.setBufferView(d,f);for(const w of r)this._bufferViewsUsed.add(w);for(const w of I)this._accessorsUsed.add(w);w.extensions||(w.extensions={}),w.extensions[pp]=d})).catch((w=>{L.c.Error("Draco encoding failed for primitive: "+w)}));this._encodePromises.push(j),this._wasUsed=!0}async preGenerateBinaryAsync(w){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((p=>{w.getPropertiesWithBufferView(p).every((w=>this._accessorsUsed.has(w)))&&w.removeBufferView(p)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Dw.RegisterExtension(pp,(w=>new ep(w)));var rp=e(11786);const Ip="KHR_lights_punctual",dp={name:"",color:[1,1,1],Se:1,range:Number.MAX_VALUE},fp={innerConeAngle:0,outerConeAngle:Math.PI/4},qp=r.k.Backward();class Ep{constructor(w){this.name=Ip,this.enabled=!0,this.required=!1,this._exporter=w}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Ip]=this._lights}async postExportNodeAsync(w,p,e,I,d){return await new Promise((f=>{if(!(e instanceof aw.b))return void f(p);const q=e.getTypeID()==aw.b.LIGHTTYPEID_POINTLIGHT?"point":e.getTypeID()==aw.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":e.getTypeID()==aw.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!q||!(e instanceof rp.b))return L.c.Warn(`${w}: Light ${e.name} is not supported in ${Ip}`),void f(p);if(e.falloffType!==aw.b.FALLOFF_GLTF&&L.c.Warn(`${w}: Light falloff for ${e.name} does not match the ${Ip} specification!`),!e.position.equalsToFloats(0,0,0)){const w=r.d.ne[0].X(e.position);d&&Q(w),p.translation=w.ze()}if("point"!==q){const w=e.direction.normalizeToRef(r.d.ne[0]);d&&Q(w);const I=r.c.FromUnitVectorsToRef(qp,w,r.d.Quaternion[0]);r.c.IsIdentity(I)||(p.rotation=I.ze())}const E={type:q,name:e.name,color:e.br.ze(),Se:e.Se,range:e.range};if(rw(E,dp),"spot"===q){const w=e;E.spot={innerConeAngle:w.innerAngle/2,outerConeAngle:w.angle/2},rw(E.spot,fp)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(E);const j={pe:this._lights.lights.length-1},X=e.parent;if(X&&pw(e,X)){const w=I.get(X);if(w){const e=this._exporter._nodes[w];return ww(p,e),e.extensions||(e.extensions={}),e.extensions[Ip]=j,void f(null)}}p.extensions||(p.extensions={}),p.extensions[Ip]=j,f(p)}))}}Dw.RegisterExtension(Ip,(w=>new Ep(w)));var jp=e(11586);const Xp="KHR_materials_anisotropy";class kp{constructor(w){this.name=Xp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,p,e){const r=[];return e instanceof jp.d&&e.anisotropy.isEnabled&&!e.anisotropy.legacy?(e.anisotropy.texture&&r.push(e.anisotropy.texture),r):[]}postExportMaterialAsync(w,p,e){return new Promise((w=>{if(e instanceof jp.d){if(!e.anisotropy.isEnabled||e.anisotropy.legacy)return void w(p);this._wasUsed=!0,p.extensions=p.extensions||{};const r=this._exporter._materialExporter.getTextureInfo(e.anisotropy.texture),I={anisotropyStrength:e.anisotropy.Se,anisotropyRotation:e.anisotropy.angle,anisotropyTexture:r??void 0};null!==I.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(e),p.extensions[Xp]=I}w(p)}))}}Dw.RegisterExtension(Xp,(w=>new kp(w)));const mp="KHR_materials_clearcoat";class Jp{constructor(w){this.name=mp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,p,e){const r=[];return e instanceof jp.d&&e.clearCoat.isEnabled?(e.clearCoat.texture&&r.push(e.clearCoat.texture),!e.clearCoat.useRoughnessFromMainTexture&&e.clearCoat.textureRoughness&&r.push(e.clearCoat.textureRoughness),e.clearCoat.bumpTexture&&r.push(e.clearCoat.bumpTexture),r):[]}postExportMaterialAsync(w,p,e){return new Promise((w=>{if(e instanceof jp.d){if(!e.clearCoat.isEnabled)return void w(p);this._wasUsed=!0,p.extensions=p.extensions||{};const r=this._exporter._materialExporter.getTextureInfo(e.clearCoat.texture);let d;d=e.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(e.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(e.clearCoat.textureRoughness),e.clearCoat.isTintEnabled&&I.g.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${e.name}`),e.clearCoat.remapF0OnInterfaceChange&&I.g.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${e.name}`);const f=this._exporter._materialExporter.getTextureInfo(e.clearCoat.bumpTexture),q={clearcoatFactor:e.clearCoat.Se,clearcoatTexture:r??void 0,clearcoatRoughnessFactor:e.clearCoat.roughness,clearcoatRoughnessTexture:d??void 0,clearcoatNormalTexture:f??void 0};null===q.clearcoatTexture&&null===q.clearcoatRoughnessTexture&&null===q.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(e),p.extensions[mp]=q}w(p)}))}}Dw.RegisterExtension(mp,(w=>new Jp(w)));const Kp="KHR_materials_diffuse_transmission";function yp(w,p){const e=p.subSurface;let r=null;return e.translucencyIntensityTexture?r=e.translucencyIntensityTexture:e.thicknessTexture&&e.useMaskFromThicknessTexture&&(r=e.thicknessTexture),r&&!e.useGltfStyleTextures?(L.c.Warn(`${w}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${p.name}`,1),null):r}class cp{constructor(w){this.name=Kp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,p,e){const r=[];if(e instanceof Kw.d&&this._isExtensionEnabled(e)){const p=yp(w,e);return p&&r.push(p),e.subSurface.translucencyColorTexture&&r.push(e.subSurface.translucencyColorTexture),r}return r}_isExtensionEnabled(w){if(w.unlit)return!1;const p=w.subSurface;return!!p.isTranslucencyEnabled&&(!w.unlit&&!p.useAlbedoToTintTranslucency&&p.useGltfStyleTextures&&1===p.volumeIndexOfRefraction&&0===p.minimumThickness&&0===p.maximumThickness)}postExportMaterialAsync(w,p,e){return new Promise((r=>{if(e instanceof Kw.d&&this._isExtensionEnabled(e)){this._wasUsed=!0;const r=e.subSurface,I=yp(w,e),d=0==r.translucencyIntensity?void 0:r.translucencyIntensity,f=this._exporter._materialExporter.getTextureInfo(I)??void 0,q=!r.translucencyColor||r.translucencyColor.equalsFloats(1,1,1)?void 0:r.translucencyColor.ze(),E=this._exporter._materialExporter.getTextureInfo(r.translucencyColorTexture)??void 0,j={diffuseTransmissionFactor:d,diffuseTransmissionTexture:f,diffuseTransmissionColorFactor:q,diffuseTransmissionColorTexture:E};(f||E)&&this._exporter._materialNeedsUVsSet.add(e),p.extensions=p.extensions||{},p.extensions[Kp]=j}r(p)}))}}Dw.RegisterExtension(Kp,(w=>new cp(w)));const sp="KHR_materials_dispersion";class Op{constructor(){this.name=sp,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(w){if(w.unlit)return!1;const p=w.subSurface;return!(!p.isRefractionEnabled&&!p.isDispersionEnabled)}postExportMaterialAsync(w,p,e){return new Promise((w=>{if(e instanceof Kw.d&&this._isExtensionEnabled(e)){this._wasUsed=!0;const w={dispersion:e.subSurface.dispersion};p.extensions=p.extensions||{},p.extensions[sp]=w}w(p)}))}}Dw.RegisterExtension(sp,(()=>new Op));const ap="KHR_materials_emissive_strength";class Ap{constructor(){this.name=ap,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(w,p,e){return await new Promise((w=>{if(!(e instanceof Kw.d))return w(p);const r=e.emissiveColor.ze(),I=Math.max(...r);if(I>1){this._wasUsed=!0,p.extensions||(p.extensions={});const w={emissiveStrength:I},r=e.emissiveColor.scale(1/w.emissiveStrength);p.emissiveFactor=r.ze(),p.extensions[ap]=w}return w(p)}))}}Dw.RegisterExtension(ap,(w=>new Ap));const zp="KHR_materials_ior";class Mp{constructor(){this.name=zp,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(w){return!w.unlit&&(void 0!=w.indexOfRefraction&&1.5!=w.indexOfRefraction)}postExportMaterialAsync(w,p,e){return new Promise((w=>{if(e instanceof Kw.d&&this._isExtensionEnabled(e)){this._wasUsed=!0;const w={ior:e.indexOfRefraction};p.extensions=p.extensions||{},p.extensions[zp]=w}w(p)}))}}Dw.RegisterExtension(zp,(w=>new Mp));const ip="KHR_materials_iridescence";class tp{constructor(w){this.name=ip,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,p,e){const r=[];return e instanceof jp.d&&e.iridescence.isEnabled?(e.iridescence.texture&&r.push(e.iridescence.texture),e.iridescence.thicknessTexture&&e.iridescence.thicknessTexture!==e.iridescence.texture&&r.push(e.iridescence.thicknessTexture),r):[]}postExportMaterialAsync(w,p,e){return new Promise((w=>{if(e instanceof jp.d){if(!e.iridescence.isEnabled)return void w(p);this._wasUsed=!0,p.extensions=p.extensions||{};const r=this._exporter._materialExporter.getTextureInfo(e.iridescence.texture),I=this._exporter._materialExporter.getTextureInfo(e.iridescence.thicknessTexture),d={iridescenceFactor:e.iridescence.Se,iridescenceIor:e.iridescence.indexOfRefraction,iridescenceThicknessMinimum:e.iridescence.minimumThickness,iridescenceThicknessMaximum:e.iridescence.maximumThickness,iridescenceTexture:r??void 0,iridescenceThicknessTexture:I??void 0};null===d.iridescenceTexture&&null===d.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(e),p.extensions[ip]=d}w(p)}))}}Dw.RegisterExtension(ip,(w=>new tp(w)));const np="KHR_materials_sheen";class lp{constructor(w){this.name=np,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,p,e){return e instanceof Kw.d&&e.sheen.isEnabled&&e.sheen.texture?[e.sheen.texture]:[]}async postExportMaterialAsync(w,p,e){return await new Promise((w=>{if(e instanceof Kw.d){if(!e.sheen.isEnabled)return void w(p);this._wasUsed=!0,null==p.extensions&&(p.extensions={});const r={sheenColorFactor:e.sheen.color.ze(),sheenRoughnessFactor:e.sheen.roughness??0};null===r.sheenColorTexture&&null===r.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(e),e.sheen.texture&&(r.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(e.sheen.texture)??void 0),e.sheen.textureRoughness&&!e.sheen.useRoughnessFromMainTexture?r.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(e.sheen.textureRoughness)??void 0:e.sheen.texture&&e.sheen.useRoughnessFromMainTexture&&(r.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(e.sheen.texture)??void 0),p.extensions[np]=r}w(p)}))}}Dw.RegisterExtension(np,(w=>new lp(w)));const Np="KHR_materials_specular";class Up{constructor(w){this.name=Np,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,p,e){const r=[];return e instanceof Kw.d&&this._isExtensionEnabled(e)?(e.metallicReflectanceTexture&&r.push(e.metallicReflectanceTexture),e.reflectanceTexture&&r.push(e.reflectanceTexture),r):r}_isExtensionEnabled(w){return!w.unlit&&(void 0!=w.metallicF0Factor&&1!=w.metallicF0Factor||void 0!=w.metallicReflectanceColor&&!w.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(w))}_hasTexturesExtension(w){return null!=w.metallicReflectanceTexture||null!=w.reflectanceTexture}postExportMaterialAsync(w,p,e){return new Promise((w=>{if(e instanceof Kw.d&&this._isExtensionEnabled(e)){this._wasUsed=!0,p.extensions=p.extensions||{};const w=this._exporter._materialExporter.getTextureInfo(e.metallicReflectanceTexture)??void 0,r=this._exporter._materialExporter.getTextureInfo(e.reflectanceTexture)??void 0,I={specularFactor:1==e.metallicF0Factor?void 0:e.metallicF0Factor,specularTexture:w,specularColorFactor:e.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:e.metallicReflectanceColor.ze(),specularColorTexture:r};this._hasTexturesExtension(e)&&this._exporter._materialNeedsUVsSet.add(e),p.extensions[Np]=I}w(p)}))}}Dw.RegisterExtension(Np,(w=>new Up(w)));const vp="KHR_materials_transmission";class Rp{constructor(w){this.name=vp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,p,e){const r=[];return e instanceof Kw.d&&this._isExtensionEnabled(e)?(e.subSurface.thicknessTexture&&r.push(e.subSurface.thicknessTexture),r):r}_isExtensionEnabled(w){if(w.unlit)return!1;const p=w.subSurface;return p.isRefractionEnabled&&void 0!=p.refractionIntensity&&0!=p.refractionIntensity||this._hasTexturesExtension(w)}_hasTexturesExtension(w){return null!=w.subSurface.refractionIntensityTexture}async postExportMaterialAsync(w,p,e){if(e instanceof Kw.d&&this._isExtensionEnabled(e)){this._wasUsed=!0;const r=e.subSurface,I={transmissionFactor:0===r.refractionIntensity?void 0:r.refractionIntensity};if(this._hasTexturesExtension(e)&&this._exporter._materialNeedsUVsSet.add(e),r.refractionIntensityTexture)if(r.useGltfStyleTextures){const w=await this._exporter._materialExporter.exportTextureAsync(r.refractionIntensityTexture,"image/png");w&&(I.transmissionTexture=w)}else L.c.Warn(`${w}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);p.extensions||(p.extensions={}),p.extensions[vp]=I}return p}}Dw.RegisterExtension(vp,(w=>new Rp(w)));const Vp="KHR_materials_unlit";class bp{constructor(){this.name=Vp,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(w,p,e){return new Promise((w=>{let r=!1;e instanceof Kw.d?r=e.unlit:e instanceof yw.c&&(r=e.disableLighting),r&&(this._wasUsed=!0,null==p.extensions&&(p.extensions={}),p.extensions[Vp]={}),w(p)}))}}Dw.RegisterExtension(Vp,(()=>new bp));const hp="KHR_materials_volume";class Pp{constructor(w){this.name=hp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,p,e){const r=[];return e instanceof Kw.d&&this._isExtensionEnabled(e)?(e.subSurface.thicknessTexture&&r.push(e.subSurface.thicknessTexture),r):r}_isExtensionEnabled(w){if(w.unlit)return!1;const p=w.subSurface;return!(!p.isRefractionEnabled&&!p.isTranslucencyEnabled)&&(void 0!=p.maximumThickness&&0!=p.maximumThickness||void 0!=p.tintColorAtDistance&&p.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=p.tintColor&&p.tintColor!=c.b.White()||this._hasTexturesExtension(w))}_hasTexturesExtension(w){return null!=w.subSurface.thicknessTexture}postExportMaterialAsync(w,p,e){return new Promise((w=>{if(e instanceof Kw.d&&this._isExtensionEnabled(e)){this._wasUsed=!0;const w=e.subSurface,r={thicknessFactor:0==w.maximumThickness?void 0:w.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(w.thicknessTexture)??void 0,attenuationDistance:w.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:w.tintColorAtDistance,attenuationColor:w.tintColor.equalsFloats(1,1,1)?void 0:w.tintColor.ze()};this._hasTexturesExtension(e)&&this._exporter._materialNeedsUVsSet.add(e),p.extensions=p.extensions||{},p.extensions[hp]=r}w(p)}))}}Dw.RegisterExtension(hp,(w=>new Pp(w)));const up="EXT_materials_diffuse_roughness";class Yp{constructor(w){this.name=up,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,p,e){const r=[];return e instanceof jp.d&&e._baseDiffuseRoughness?(e._baseDiffuseRoughnessTexture&&r.push(e._baseDiffuseRoughnessTexture),r):[]}postExportMaterialAsync(w,p,e){return new Promise((w=>{if(e instanceof jp.d){if(!e._baseDiffuseRoughness)return void w(p);this._wasUsed=!0,p.extensions=p.extensions||{};const r=this._exporter._materialExporter.getTextureInfo(e._baseDiffuseRoughnessTexture),I={diffuseRoughnessFactor:e._baseDiffuseRoughness,diffuseRoughnessTexture:r??void 0};null!==I.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(e),p.extensions[up]=I}w(p)}))}}Dw.RegisterExtension(up,(w=>new Yp(w)));const Lp="KHR_texture_transform";class Wp{constructor(){this.name=Lp,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(w,p,e){if(e.iw()||I.g.Warn(`${w}: /*@__KEY__*/"scene" is not defined for Babylon texture ${e.name}!`),(0!==e.uAng||0!==e.vAng)&&(I.g.Warn(`${w}: Texture ${e.name} with rotation in the u or v axis is not supported in glTF.`),0!==e.uRotationCenter||0!==e.vRotationCenter))return;const r={};let d=!1;if(0===e.uOffset&&0===e.vOffset||(r.offset=[e.uOffset,e.vOffset],d=!0),1===e.uScale&&1===e.vScale||(r.scale=[e.uScale,e.vScale],d=!0),0!==e.wAng){if(0!==e.uRotationCenter||0!==e.vRotationCenter){if(e.homogeneousRotationInUVTransform&&e.uScale!==e.vScale)return void I.g.Warn(`${w}: Texture ${e.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Lp}.`);I.g.Warn(`${w}: Texture ${e.name} with non-origin rotation center will be exported using an adjusted offset with ${Lp}.`),r.offset=function(w){const{uOffset:p,vOffset:e,uRotationCenter:r,vRotationCenter:I,uScale:d,vScale:f,wAng:q}=w,E=Math.cos(q),j=Math.sin(q),X=r*d,k=I*f;return[p+(X*(1-E)+k*j),e+(k*(1-E)-X*j)]}(e)}r.rotation=-e.wAng,d=!0}0!==e.coordinatesIndex&&(r.texCoord=e.coordinatesIndex,d=!0),d&&(this._wasUsed=!0,p.extensions||(p.extensions={}),p.extensions[Lp]=r)}}Dw.RegisterExtension(Lp,(()=>new Wp));class Fp{static CreateSTL(w){let p=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",I=arguments.length>3&&void 0!==arguments[3]&&arguments[3],d=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],f=arguments.length>5&&void 0!==arguments[5]&&arguments[5],q=arguments.length>6&&void 0!==arguments[6]&&arguments[6],E=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const j=function(w,p,e){const I=[3*w[e],3*w[e+1],3*w[e+2]],d=[new r.k(p[I[0]],p[I[0]+2],p[I[0]+1]),new r.k(p[I[1]],p[I[1]+2],p[I[1]+1]),new r.k(p[I[2]],p[I[2]+2],p[I[2]+1])],f=d[0].Je(d[1]),q=d[2].Je(d[1]);return{v:d,n:r.k.Cross(q,f).normalize()}},k=function(w,p,e,r){return p=m(w,p,e.x,r),p=m(w,p,e.y,r),m(w,p,e.z,r)},m=function(w,p,e,r){return w.setFloat32(p,e,r),p+4},K=function(w){if(q){let p=w;w instanceof J.b&&(p=w.sourceMesh);const e=p.getVerticesData(X.e.PositionKind,!0,!0);if(!e)return[];const I=r.k.Zero();let d;for(d=0;d<e.length;d+=3)r.k.TransformCoordinatesFromFloatsToRef(e[d],e[d+1],e[d+2],w.ke(!0),I).toArray(e,d);return e}return w.getVerticesData(X.e.PositionKind)||[]};q&&(f=!0);let y="",c=0,s=0;if(I){for(let e=0;e<w.length;e++){const p=w[e].Ke();c+=p?p.length/3:0}const p=new ArrayBuffer(84+50*c);y=new DataView(p),s+=80,y.setUint32(s,c,d),s+=4}else E||(y="solid stlmesh\r\n");for(let r=0;r<w.length;r++){const p=w[r];!I&&E&&(y+="solid "+p.name+"\r\n"),!f&&p instanceof Ow.c&&p.bakeCurrentTransformIntoVertices();const e=K(p),q=p.Ke()||[];for(let w=0;w<q.length;w+=3){const p=j(q,e,w);I?(s=k(y,s,p.n,d),s=k(y,s,p.v[0],d),s=k(y,s,p.v[1],d),s=k(y,s,p.v[2],d),s+=2):(y+="\tfacet normal "+p.n.x+" "+p.n.y+" "+p.n.z+"\r\n",y+="\t\touter loop\r\n",y+="\t\t\tvertex "+p.v[0].x+" "+p.v[0].y+" "+p.v[0].z+"\r\n",y+="\t\t\tvertex "+p.v[1].x+" "+p.v[1].y+" "+p.v[1].z+"\r\n",y+="\t\t\tvertex "+p.v[2].x+" "+p.v[2].y+" "+p.v[2].z+"\r\n",y+="\t\tendloop\r\n",y+="\tendfacet\r\n")}!I&&E&&(y+="endsolid "+name+"\r\n")}if(I||E||(y+="endsolid stlmesh"),p){const w=document.createElement("a"),p=new Blob([y],{type:"application/octet-stream"});w.href=window.URL.createObjectURL(p),w.download=e+".stl",w.click()}return y}}function Hp(w,p){let e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const r=[];for(let I=0;I<w.length/e;I++){const d=w[I*e],f=w[I*e+1],q=w[I*e+2];r.push(`(${d.toPrecision(p.precision)}, ${f.toPrecision(p.precision)}, ${q.toPrecision(p.precision)})`)}return r.join(", ")}function Bp(w,p){const e=[];for(let r=0;r<w.length/2;r++){const I=w[2*r],d=w[2*r+1];e.push(`(${I.toPrecision(p.precision)}, ${(1-d).toPrecision(p.precision)})`)}return e.join(", ")}function Dp(w,p){const e=w.getVerticesData(X.e.PositionKind),r=w.getVerticesData(X.e.NormalKind);if(e&&r)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(w){var p;const e=null!==(p=w.Ke())&&void 0!==p&&p.length?w.getTotalIndices():w.getTotalVertices();return Array(e/3).fill(3).join(", ")}(w)}]\n\t\tint[] faceVertexIndices = [${function(w){const p=w.Ke(),e=[];if(null!==p)for(let r=0;r<p.length;r++)e.push(p[r]);else{const p=w.getTotalVertices();for(let w=0;w<p;w++)e.push(w)}return e.join(", ")}(w)}]\n\t\tnormal3f[] normals = [${Hp(r,p)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Hp(e,p)}]\n        ${function(w,p){let e="";for(let I=0;I<4;I++){const r=I>0?I:"",d=w.getVerticesData(X.e.UVKind+(r?r+1:""));d&&(e+=`\n\t\ttexCoord2f[] primvars:st${r} = [${Bp(d,p)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const r=w.getVerticesData(X.e.ColorKind);return r&&(e+=`\n\tcolor3f[] primvars:displayColor = [${Hp(r,p,r.length/w.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),e}(w,p)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Tp(w,p){return`\n        def "Geometry"\n        {\n        ${Dp(w,p)}\n        }\n        `}function Zp(w){let p='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return p+=w,fflate.strToU8(p)}function Gp(w){const p=w.m;return`( ${gp(p,0)}, ${gp(p,4)}, ${gp(p,8)}, ${gp(p,12)} )`}function gp(w,p){return`(${w[p+0]}, ${w[p+1]}, ${w[p+2]}, ${w[p+3]})`}function op(w){const p="Object_"+w.uniqueId,e=function(w){const p=w.getWorldMatrix().clone(),e=w.iw().useRightHandedSystem;if(!e){let r=w.parent;for(;r;){if(fw(r,e)){p.multiplyToRef(r.getWorldMatrix().invert(),p);break}r=r.parent}}return p.determinant()<0&&I.g.Warn(`Exporting mesh ${w.name} with negative scale. Result may look incorrect in destination engine.`),p}(w),r=Gp(e);return`def Xform "${p}" (\n\tprepend references = @./geometries/Geometry_${w.me.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${r}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${w.material.uniqueId}>\n}\n\n`}function Cp(w){switch(w){case i.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case i.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case i.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Qp(w){return`(${w.x}, ${w.y})`}function xp(w){return`(${w.r}, ${w.g}, ${w.b})`}function Sp(w,p,e,I,d,f){const q=w.getInternalTexture().uniqueId+"_"+w.invertY;d[q]=w;const E=w.coordinatesIndex>0?"st"+w.coordinatesIndex:"st",j=new r.g(w.uScale,w.vScale),X=new r.g(w.uOffset,w.vOffset),k=w.wAng,m=Math.sin(k),J=Math.cos(k);return X.y=1-X.y-j.y,X.x+=m*j.x,X.y+=(1-J)*j.y,`\n    def Shader "PrimvarReader_${e}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${E}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${e}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${p.uniqueId}/PrimvarReader_${e}.outputs:result>\n        float inputs:rotation = ${(k*(180/Math.PI)).toFixed(f.precision)}\n        float2 inputs:scale = ${Qp(j)}\n        float2 inputs:translation = ${Qp(X)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${w.uniqueId}_${e}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${q}.png@\n        float2 inputs:st.connect = </Materials/Material_${p.uniqueId}/Transform2d_${e}.outputs:result>\n        ${I?"float4 inputs:scale = "+function(w){return`(${w.r}, ${w.g}, ${w.b}, 1.0)`}(I):""}\n        token inputs:sourceColorSpace = "${w.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Cp(w.wrapU)}"\n        token inputs:wrapT = "${Cp(w.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${p.needAlphaBlending()?"float outputs:a":""}\n    }`}function we(w,p,e){const r="\t\t\t",I=[],d=[],{diffuseMap:f,br:q,alphaCutOff:E,emissiveMap:j,emissive:X,normalMap:k,roughnessMap:m,roughnessChannel:J,roughness:K,metalnessMap:y,metalnessChannel:s,metalness:O,aoMap:a,aoMapChannel:A,aoMapIntensity:z,alphaMap:M,ior:i,clearCoatEnabled:t,clearCoat:n,clearCoatMap:l,clearCoatRoughness:N,clearCoatRoughnessMap:U}=function(w){const p={diffuseMap:null,br:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return w instanceof yw.c?{...p,diffuseMap:w.diffuseTexture,br:w.diffuseColor,alphaCutOff:w.alphaCutOff,emissiveMap:w.emissiveTexture,emissive:w.emissiveColor,roughness:1,alphaMap:w.opacityTexture}:w instanceof jp.d?{...p,diffuseMap:w._albedoTexture,br:w._albedoColor,alphaCutOff:w._alphaCutOff,emissiveMap:w._emissiveTexture,emissive:w._emissiveColor,normalMap:w._bumpTexture,roughnessMap:w._metallicTexture,roughnessChannel:w._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:w._roughness??1,metalnessMap:w._metallicTexture,metalnessChannel:w._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:w._metallic??0,aoMap:w._ambientTexture,aoMapChannel:w._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:w._ambientTextureStrength,alphaMap:w._opacityTexture,ior:w.subSurface.indexOfRefraction,clearCoatEnabled:w.clearCoat.isEnabled,clearCoat:w.clearCoat.Se,clearCoatMap:w.clearCoat.texture,clearCoatRoughness:w.clearCoat.roughness,clearCoatRoughnessMap:w.clearCoat.useRoughnessFromMainTexture?w.clearCoat.texture:w.clearCoat.textureRoughness}:p}(w);return null!==f?(I.push(`${r}color3f inputs:diffuseColor.connect = </Materials/Material_${w.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:rgb>`),w.needAlphaBlending()?I.push(`${r}float inputs:opacity.connect = </Materials/Material_${w.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:a>`):w.needAlphaTesting()&&(I.push(`${r}float inputs:opacity.connect = </Materials/Material_${w.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:a>`),I.push(`${r}float inputs:opacityThreshold = ${E}`)),d.push(Sp(f,w,"diffuse",q,p,e))):I.push(`${r}color3f inputs:diffuseColor = ${xp(q||c.b.White())}`),null!==j?(I.push(`${r}color3f inputs:emissiveColor.connect = </Materials/Material_${w.uniqueId}/Texture_${j.uniqueId}_emissive.outputs:rgb>`),d.push(Sp(j,w,"emissive",X,p,e))):X&&X.toLuminance()>0&&I.push(`${r}color3f inputs:emissiveColor = ${xp(X)}`),null!==k&&(I.push(`${r}normal3f inputs:normal.connect = </Materials/Material_${w.uniqueId}/Texture_${k.uniqueId}_normal.outputs:rgb>`),d.push(Sp(k,w,"dp",null,p,e))),null!==a&&(I.push(`${r}float inputs:occlusion.connect = </Materials/Material_${w.uniqueId}/Texture_${a.uniqueId}_occlusion.outputs:${A}>`),d.push(Sp(a,w,"occlusion",new c.b(z,z,z),p,e))),null!==m?(I.push(`${r}float inputs:roughness.connect = </Materials/Material_${w.uniqueId}/Texture_${m.uniqueId}_roughness.outputs:${J}>`),d.push(Sp(m,w,"roughness",new c.b(K,K,K),p,e))):I.push(`${r}float inputs:roughness = ${K}`),null!==y?(I.push(`${r}float inputs:metallic.connect = </Materials/Material_${w.uniqueId}/Texture_${y.uniqueId}_metallic.outputs:${s}>`),d.push(Sp(y,w,"metallic",new c.b(O,O,O),p,e))):I.push(`${r}float inputs:metallic = ${O}`),null!==M?(I.push(`${r}float inputs:opacity.connect = </Materials/Material_${w.uniqueId}/Texture_${M.uniqueId}_opacity.outputs:r>`),I.push(`${r}float inputs:opacityThreshold = 0.0001`),d.push(Sp(M,w,"opacity",null,p,e))):I.push(`${r}float inputs:opacity = ${w.alpha}`),t&&(null!==l?(I.push(`${r}float inputs:clearcoat.connect = </Materials/Material_${w.uniqueId}/Texture_${l.uniqueId}_clearcoat.outputs:r>`),d.push(Sp(l,w,"clearcoat",new c.b(n,n,n),p,e))):I.push(`${r}float inputs:clearcoat = ${n}`),null!==U?(I.push(`${r}float inputs:clearcoatRoughness.connect = </Materials/Material_${w.uniqueId}/Texture_${U.uniqueId}_clearcoatRoughness.outputs:g>`),d.push(Sp(U,w,"clearcoatRoughness",new c.b(N,N,N),p,e))):I.push(`${r}float inputs:clearcoatRoughness = ${N}`)),I.push(`${r}float inputs:ior = ${i}`),`\n\tdef Material "Material_${w.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${I.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${w.uniqueId}/PreviewSurface.outputs:surface>\n\n${d.join("\n")}\n\n\t}\n`}async function pe(w,p,e){const d={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...p};"undefined"===typeof fflate&&await I.g.LoadScriptAsync(d.fflateUrl);const f={};f[d.modelFileName]=null;let q='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';q+=function(w){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===w.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${w.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${w.planeAnchoringAlignment}"`:""}\n            `}(d);const E={};for(const r of w.meshes){if(0===r.getTotalVertices())continue;const w=r,p=w.me,j=w.material;if(!j||!p||e&&!e(w))continue;if(-1!==["hr","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(j.getClassName())){const e="geometries/Geometry_"+p.uniqueId+".usda";if(!(e in f)){const w=Tp(p,d);f[e]=Zp(w)}j.uniqueId in E||(E[j.uniqueId]=j),q+=op(w)}else I.g.Warn("USDZExportAsync does not support this material type: "+j.getClassName())}w.activeCamera&&d.exportCamera&&(q+=function(w,p){const e="Camera_"+w.uniqueId,I=Gp(r.b.RotationY(Math.PI).multiply(w.getWorldMatrix()));if(w.mode===i.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${I}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${w.ge.toPrecision(p.precision)}, ${w.maxZ.toPrecision(p.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(w.orthoLeft||1)+Math.abs(w.orthoRight||1))).toPrecision(p.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(w.orthoTop||1)+Math.abs(w.orthoBottom||1))).toPrecision(p.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const r=w.getEngine().getAspectRatio(w),d=p.cameraSensorWidth||35;return`def Camera "${e}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${I}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${w.ge.toPrecision(p.precision)}, ${w.maxZ.toPrecision(p.precision)})\n\t\t\tfloat focalLength = ${(d/(2*Math.tan(.5*w.fov))).toPrecision(p.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(d*r).toPrecision(p.precision)}\n\t\t\tfloat verticalAperture = ${(d/r).toPrecision(p.precision)}            \n\t\t}\n\t\n\t`}}(w.activeCamera,d)),q+="\n            }\n        }\n    }";const j={};q+=function(w,p,e){const r=[];for(const I in w){const d=w[I];r.push(we(d,p,e))}return`\n    def "Materials"\n{\n${r.join("")}\n}\n\n`}(E,j,d),f[d.modelFileName]=fflate.strToU8(q);for(const r in j){const w=j[r],p=w.getSize(),e=await w.readPixels();if(!e)throw new Error("Texture data is not available");const I=await t.DumpTools.DumpDataAsync(p.width,p.height,e,"image/png",void 0,!1,!0);f[`textures/Texture_${r}.png`]=new Uint8Array(I).slice()}let X=0;for(const r in f){const w=f[r];if(!w)continue;X+=34+r.length;const p=63&X;if(4!==p){const e=new Uint8Array(64-p);f[r]=[w,{extra:{12345:e}}]}X=w.length}return fflate.zipSync(f,{level:0})}}}]);