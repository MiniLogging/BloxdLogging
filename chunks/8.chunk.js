"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10429:(A,I,y)=>{y.r(I),y.d(I,{_HDRTextureLoader:()=>U});var X=y(1021);class F{static ConvertPanoramaToCubemap(A,I,y,X){let F=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!A)throw"ConvertPanoramaToCubemap: input cannot be null";if(A.length!=I*y*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(X,this.FACE_FRONT,A,I,y,F),back:this.CreateCubemapTexture(X,this.FACE_BACK,A,I,y,F),left:this.CreateCubemapTexture(X,this.FACE_LEFT,A,I,y,F),right:this.CreateCubemapTexture(X,this.FACE_RIGHT,A,I,y,F),up:this.CreateCubemapTexture(X,this.FACE_UP,A,I,y,F),down:this.CreateCubemapTexture(X,this.FACE_DOWN,A,I,y,F),size:X,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(A,I,y,X,F){let M=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const g=new ArrayBuffer(A*A*4*3),d=new Float32Array(g),V=M?Math.max(1,Math.round(X/4/A)):1,k=1/V,U=k*k,P=I[1].Qc(I[0]).scale(k/A),f=I[3].Qc(I[2]).scale(k/A),z=1/A;let l=0;for(let u=0;u<A;u++)for(let M=0;M<V;M++){let M=I[0],g=I[2];for(let I=0;I<A;I++)for(let k=0;k<V;k++){const V=g.Qc(M).scale(l).add(M);V.normalize();const k=this.CalcProjectionSpherical(V,y,X,F);d[u*A*3+3*I+0]+=k.r*U,d[u*A*3+3*I+1]+=k.g*U,d[u*A*3+3*I+2]+=k.b*U,M=M.add(P),g=g.add(f)}l+=z*k}return d}static CalcProjectionSpherical(A,I,y,X){let F=Math.atan2(A.z,A.x);const M=Math.acos(A.y);for(;F<-Math.PI;)F+=2*Math.PI;for(;F>Math.PI;)F-=2*Math.PI;let g=F/Math.PI;const d=M/Math.PI;g=.5*g+.5;let V=Math.round(g*y);V<0?V=0:V>=y&&(V=y-1);let k=Math.round(d*X);k<0?k=0:k>=X&&(k=X-1);const U=X-k-1;return{r:I[U*y*3+3*V+0],g:I[U*y*3+3*V+1],b:I[U*y*3+3*V+2]}}}function M(A,I,y,X,F,M){F>0?(F=function(A,I){return I>1023?A*Math.pow(2,1023)*Math.pow(2,I-1023):I<-1074?A*Math.pow(2,-1074)*Math.pow(2,I+1074):A*Math.pow(2,I)}(1,F-136),A[M+0]=I*F,A[M+1]=y*F,A[M+2]=X*F):(A[M+0]=0,A[M+1]=0,A[M+2]=0)}function g(A,I){let y="",X="";for(let F=I;F<A.length-I&&(X=String.fromCharCode(A[F]),"\n"!=X);F++)y+=X;return y}function d(A){let I=0,y=0,X=g(A,0);if("#"!=X[0]||"?"!=X[1])throw"Bad HDR Format.";let F=!1,M=!1,d=0;do{d+=X.length+1,X=g(A,d),"FORMAT=32-bit_rle_rgbe"==X?M=!0:0==X.length&&(F=!0)}while(!F);if(!M)throw"HDR Bad header format, unsupported FORMAT";d+=X.length+1,X=g(A,d);const V=/^-Y (.*) \+X (.*)$/g.exec(X);if(!V||V.length<3)throw"HDR Bad header format, no size";if(y=parseInt(V[2]),I=parseInt(V[1]),y<8||y>32767)throw"HDR Bad header format, unsupported size";return d+=X.length+1,{height:I,width:y,dataPosition:d}}function V(A,I){return function(A,I){let y=I.height;const X=I.width;let F,g,d,V,U,P=I.dataPosition,f=0,z=0,l=0;const u=new ArrayBuffer(4*X),K=new Uint8Array(u),x=new ArrayBuffer(I.width*I.height*4*3),t=new Float32Array(x);for(;y>0;){if(F=A[P++],g=A[P++],d=A[P++],V=A[P++],2!=F||2!=g||128&d||I.width<8||I.width>32767)return k(A,I);if((d<<8|V)!=X)throw"HDR Bad header format, wrong scan line width";for(f=0,l=0;l<4;l++)for(z=(l+1)*X;f<z;)if(F=A[P++],g=A[P++],F>128){if(U=F-128,0==U||U>z-f)throw"HDR Bad Format, bad scanline data (run)";for(;U-- >0;)K[f++]=g}else{if(U=F,0==U||U>z-f)throw"HDR Bad Format, bad scanline data (non-run)";if(K[f++]=g,--U>0)for(let I=0;I<U;I++)K[f++]=A[P++]}for(l=0;l<X;l++)F=K[l],g=K[l+X],d=K[l+2*X],V=K[l+3*X],M(t,F,g,d,V,(I.height-y)*X*3+3*l);y--}return t}(A,I)}function k(A,I){let y=I.height;const X=I.width;let F,g,d,V,k,U=I.dataPosition;const P=new ArrayBuffer(I.width*I.height*4*3),f=new Float32Array(P);for(;y>0;){for(k=0;k<I.width;k++)F=A[U++],g=A[U++],d=A[U++],V=A[U++],M(f,F,g,d,V,(I.height-y)*X*3+3*k);y--}return f}F.FACE_LEFT=[new X.j(-1,-1,-1),new X.j(1,-1,-1),new X.j(-1,1,-1),new X.j(1,1,-1)],F.FACE_RIGHT=[new X.j(1,-1,1),new X.j(-1,-1,1),new X.j(1,1,1),new X.j(-1,1,1)],F.FACE_FRONT=[new X.j(1,-1,-1),new X.j(1,-1,1),new X.j(1,1,-1),new X.j(1,1,1)],F.FACE_BACK=[new X.j(-1,-1,1),new X.j(-1,-1,-1),new X.j(-1,1,1),new X.j(-1,1,-1)],F.FACE_DOWN=[new X.j(1,1,-1),new X.j(1,1,1),new X.j(-1,1,-1),new X.j(-1,1,1)],F.FACE_UP=[new X.j(-1,-1,-1),new X.j(-1,-1,1),new X.j(1,-1,-1),new X.j(1,-1,1)];class U{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(A,I,y){const X=new Uint8Array(A.buffer,A.byteOffset,A.byteLength),F=d(X),M=V(X,F),g=F.width*F.height,k=new Float32Array(4*g);for(let d=0;d<g;d+=1)k[4*d]=M[3*d],k[4*d+1]=M[3*d+1],k[4*d+2]=M[3*d+2],k[4*d+3]=1;y(F.width,F.height,I.generateMipMaps,!1,(()=>{const A=I.getEngine();I.type=1,I.format=5,I._gammaSpace=!1,A._uploadDataToTextureDirectly(I,k)}))}}}}]);