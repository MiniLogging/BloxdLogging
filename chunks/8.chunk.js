"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{2154:(v,d,Q)=>{Q.r(d),Q.d(d,{_BasisTextureLoader:()=>h});var n,T=Q(475),L=Q(2041),e=Q(573);function F(){const v=0,d=1,Q=2,n=3,T=6,L=8,e=9,F=10,r=14;let C=null;function u(v,d,Q,n,T){const L=v.getImageTranscodedSizeInBytes(d,Q,n);let e=new Uint8Array(L);if(!v.transcodeImage(e,d,Q,n,1,0))return null;if(T){e=function(v,d,Q,n){const T=new Uint16Array(4),L=new Uint16Array(Q*n),e=Q/4,F=n/4;for(let r=0;r<F;r++)for(let n=0;n<e;n++){const F=d+8*(r*e+n);T[0]=v[F]|v[F+1]<<8,T[1]=v[F+2]|v[F+3]<<8,T[2]=(2*(31&T[0])+1*(31&T[1]))/3|(2*(2016&T[0])+1*(2016&T[1]))/3&2016|(2*(63488&T[0])+1*(63488&T[1]))/3&63488,T[3]=(2*(31&T[1])+1*(31&T[0]))/3|(2*(2016&T[1])+1*(2016&T[0]))/3&2016|(2*(63488&T[1])+1*(63488&T[0]))/3&63488;for(let d=0;d<4;d++){const e=v[F+4+d];let C=(4*r+d)*Q+4*n;L[C++]=T[3&e],L[C++]=T[e>>2&3],L[C++]=T[e>>4&3],L[C++]=T[e>>6&3]}}return L}(e,0,v.getImageWidth(d,Q)+3&-4,v.getImageHeight(d,Q)+3&-4)}return e}onmessage=y=>{if("init"===y.data.action){if(y.data.url)try{importScripts(y.data.url)}catch(z){postMessage({action:"error",error:z})}C||(C=BASIS({wasmBinary:y.data.wasmBinary})),null!==C&&C.then((v=>{BASIS=v,v.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===y.data.action){const C=y.data.config,z=y.data.imageData,B=new BASIS.BasisFile(z),X=function(v){const d=v.getHasAlpha(),Q=v.getNumImages(),n=[];for(let T=0;T<Q;T++){const d={levels:[]},Q=v.getNumLevels(T);for(let n=0;n<Q;n++){const Q={width:v.getImageWidth(T,n),height:v.getImageHeight(T,n)};d.levels.push(Q)}n.push(d)}return{ui:d,images:n}}(B);let m=y.data.ignoreSupportedFormats?null:function(C,u){let y=null;C.supportedCompressionFormats&&(y=C.supportedCompressionFormats.astc?F:C.supportedCompressionFormats.bc7?T:C.supportedCompressionFormats.s3tc?u.ui?n:Q:C.supportedCompressionFormats.pvrtc?u.ui?e:L:C.supportedCompressionFormats.etc2?d:C.supportedCompressionFormats.etc1?v:r);return y}(y.data.config,X),V=!1;null===m&&(V=!0,m=X.ui?n:Q);let h=!0;B.startTranscoding()||(h=!1);const S=[];for(let v=0;v<X.images.length&&h;v++){const d=X.images[v];if(void 0===C.loadSingleImage||C.loadSingleImage===v){let Q=d.levels.length;!1===C.loadMipmapLevels&&(Q=1);for(let n=0;n<Q;n++){const Q=d.levels[n],T=u(B,v,n,m,V);if(!T){h=!1;break}Q.transcodedPixels=T,S.push(Q.transcodedPixels.buffer)}}}B.close(),B.delete(),V&&(m=-1),h?postMessage({action:"transcode",success:h,id:y.data.id,fileInfo:X,format:m},S):postMessage({action:"transcode",success:h,id:y.data.id})}}}!function(v){v[v.cTFETC1=0]="cTFETC1",v[v.cTFETC2=1]="cTFETC2",v[v.cTFBC1=2]="cTFBC1",v[v.cTFBC3=3]="cTFBC3",v[v.cTFBC4=4]="cTFBC4",v[v.cTFBC5=5]="cTFBC5",v[v.cTFBC7=6]="cTFBC7",v[v.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",v[v.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",v[v.cTFASTC_4x4=10]="cTFASTC_4x4",v[v.cTFATC_RGB=11]="cTFATC_RGB",v[v.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",v[v.cTFRGBA32=13]="cTFRGBA32",v[v.cTFRGB565=14]="cTFRGB565",v[v.cTFBGR565=15]="cTFBGR565",v[v.cTFRGBA4444=16]="cTFRGBA4444",v[v.cTFFXT1_RGB=17]="cTFFXT1_RGB",v[v.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",v[v.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",v[v.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",v[v.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(n||(n={}));const r={JSModuleURL:`${T.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${T.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let C=null,u=null,y=0;const z=async()=>(C||(C=new Promise(((v,d)=>{u?v(u):T.e.LoadFileAsync(T.e.GetBabylonScriptURL(r.WasmModuleURL)).then((Q=>{if("function"!==typeof URL)return d("Basis transcoder requires an environment with a URL constructor");const n=URL.createObjectURL(new Blob([`(${F})()`],{type:"application/javascript"}));u=new Worker(n),async function(v,d,Q){return await new Promise(((n,L)=>{const e=d=>{"init"===d.data.action?(v.removeEventListener("message",e),n(v)):"error"===d.data.action&&L(d.data.error||"error initializing worker")};v.addEventListener("message",e),v.postMessage({action:"init",url:Q?T.e.GetBabylonScriptURL(Q):void 0,wasmBinary:d},[d])}))}(u,Q,r.JSModuleURL).then(v,d)})).catch(d)}))),await C),B=async(v,d)=>{const Q=v instanceof ArrayBuffer?new Uint8Array(v):v;return await new Promise(((v,n)=>{z().then((()=>{const T=y++,L=d=>{"transcode"===d.data.action&&d.data.id===T&&(u.removeEventListener("message",L),d.data.success?v(d.data):n("Transcode is not supported on this device"))};u.addEventListener("message",L);const e=new Uint8Array(Q.byteLength);e.set(new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength)),u.postMessage({action:"transcode",id:T,imageData:e,config:d,ignoreSupportedFormats:false},[e.buffer])}),(v=>{n(v)}))}))},X=(v,d)=>{var Q;let n=null===(Q=d._gl)||void 0===Q?void 0:Q.TEXTURE_2D;var T;v.isCube&&(n=null===(T=d._gl)||void 0===T?void 0:T.TEXTURE_CUBE_MAP);d._bindTextureDirectly(n,v,!0)},m=(v,d)=>{const Q=v.getEngine();for(let F=0;F<d.fileInfo.images.length;F++){const r=d.fileInfo.images[F].levels[0];if(v._invertVScale=v.invertY,-1===d.format||d.format===n.cTFRGB565)if(v.type=10,v.format=4,!Q._features.basisNeedsPOT||Math.log2(r.width)%1===0&&Math.log2(r.height)%1===0)v._invertVScale=!v.invertY,v.width=r.width+3&-4,v.height=r.height+3&-4,v.samplingMode=2,X(v,Q),Q._uploadDataToTextureDirectly(v,new Uint16Array(r.transcodedPixels.buffer),F,0,4,!0);else{const d=new e.b(Q,2);v._invertVScale=v.invertY,d.type=10,d.format=4,d.width=r.width+3&-4,d.height=r.height+3&-4,X(d,Q),Q._uploadDataToTextureDirectly(d,new Uint16Array(r.transcodedPixels.buffer),F,0,4,!0),Q._rescaleTexture(d,v,Q.scenes[0],Q._getInternalFormat(4),(()=>{Q._releaseTexture(d),X(v,Q)}))}else{v.width=r.width,v.height=r.height,v.generateMipMaps=d.fileInfo.images[F].levels.length>1;const n=V.GetInternalFormatFromBasisFormat(d.format,Q);v.format=n,X(v,Q);const e=d.fileInfo.images[F].levels;for(let d=0;d<e.length;d++){const T=e[d];Q._uploadCompressedDataToTextureDirectly(v,n,T.width,T.height,T.transcodedPixels,F,d)}!Q._features.basisNeedsPOT||Math.log2(v.width)%1===0&&Math.log2(v.height)%1===0||(T.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),v._cachedWrapU=L.e.CLAMP_ADDRESSMODE,v._cachedWrapV=L.e.CLAMP_ADDRESSMODE)}}},V={JSModuleURL:r.JSModuleURL,WasmModuleURL:r.WasmModuleURL,GetInternalFormatFromBasisFormat:(v,d)=>{let Q;switch(v){case n.cTFETC1:Q=36196;break;case n.cTFBC1:Q=33776;break;case n.cTFBC4:Q=33779;break;case n.cTFASTC_4x4:Q=37808;break;case n.cTFETC2:Q=37496;break;case n.cTFBC7:Q=36492}if(void 0===Q)throw"The chosen Basis transcoder format is not currently supported";return Q},TranscodeAsync:B,LoadTextureFromTranscodeResult:m};Object.defineProperty(V,"JSModuleURL",{get:function(){return r.JSModuleURL},set:function(v){r.JSModuleURL=v}}),Object.defineProperty(V,"WasmModuleURL",{get:function(){return r.WasmModuleURL},set:function(v){r.WasmModuleURL=v}});class h{constructor(){this.supportCascades=!1}loadCubeData(v,d,Q,n,L){if(Array.isArray(v))return;const e=d.getEngine().getCaps(),F={supportedCompressionFormats:{etc1:!!e.etc1,s3tc:!!e.s3tc,pvrtc:!!e.pvrtc,etc2:!!e.etc2,astc:!!e.astc,bc7:!!e.bptc}};B(v,F).then((v=>{const Q=v.fileInfo.images[0].levels.length>1&&d.generateMipMaps;m(d,v),d.getEngine()._setCubeMapTextureParams(d,Q),d.isReady=!0,d.onLoadedObservable.notifyObservers(d),d.onLoadedObservable.clear(),n&&n()})).catch((v=>{T.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),d.isReady=!0,L&&L(v)}))}loadData(v,d,Q){const n=d.getEngine().getCaps(),L={supportedCompressionFormats:{etc1:!!n.etc1,s3tc:!!n.s3tc,pvrtc:!!n.pvrtc,etc2:!!n.etc2,astc:!!n.astc,bc7:!!n.bptc}};B(v,L).then((v=>{const n=v.fileInfo.images[0].levels[0],T=v.fileInfo.images[0].levels.length>1&&d.generateMipMaps;Q(n.width,n.height,T,-1!==v.format,(()=>{m(d,v)}))})).catch((v=>{T.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),T.e.Warn(`Failed to transcode Basis file: ${v}`),Q(0,0,!1,!1,(()=>{}),!0)}))}}}}]);