"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10634:(p,O,E)=>{E.r(O),E.d(O,{_HDRTextureLoader:()=>s});var e=E(995);class x{static ConvertPanoramaToCubemap(p,O,E,e){let x=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!p)throw"ConvertPanoramaToCubemap: input cannot be null";if(p.length!=O*E*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(e,this.FACE_FRONT,p,O,E,x),back:this.CreateCubemapTexture(e,this.FACE_BACK,p,O,E,x),left:this.CreateCubemapTexture(e,this.FACE_LEFT,p,O,E,x),right:this.CreateCubemapTexture(e,this.FACE_RIGHT,p,O,E,x),up:this.CreateCubemapTexture(e,this.FACE_UP,p,O,E,x),down:this.CreateCubemapTexture(e,this.FACE_DOWN,p,O,E,x),size:e,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(p,O,E,e,x){let F=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const q=new ArrayBuffer(p*p*4*3),a=new Float32Array(q),Y=F?Math.max(1,Math.round(e/4/p)):1,B=1/Y,s=B*B,D=O[1].Qc(O[0]).scale(B/p),Z=O[3].Qc(O[2]).scale(B/p),m=1/p;let h=0;for(let T=0;T<p;T++)for(let F=0;F<Y;F++){let F=O[0],q=O[2];for(let O=0;O<p;O++)for(let B=0;B<Y;B++){const Y=q.Qc(F).scale(h).add(F);Y.normalize();const B=this.CalcProjectionSpherical(Y,E,e,x);a[T*p*3+3*O+0]+=B.r*s,a[T*p*3+3*O+1]+=B.g*s,a[T*p*3+3*O+2]+=B.b*s,F=F.add(D),q=q.add(Z)}h+=m*B}return a}static CalcProjectionSpherical(p,O,E,e){let x=Math.atan2(p.z,p.x);const F=Math.acos(p.y);for(;x<-Math.PI;)x+=2*Math.PI;for(;x>Math.PI;)x-=2*Math.PI;let q=x/Math.PI;const a=F/Math.PI;q=.5*q+.5;let Y=Math.round(q*E);Y<0?Y=0:Y>=E&&(Y=E-1);let B=Math.round(a*e);B<0?B=0:B>=e&&(B=e-1);const s=e-B-1;return{r:O[s*E*3+3*Y+0],g:O[s*E*3+3*Y+1],b:O[s*E*3+3*Y+2]}}}function F(p,O,E,e,x,F){x>0?(x=function(p,O){return O>1023?p*Math.pow(2,1023)*Math.pow(2,O-1023):O<-1074?p*Math.pow(2,-1074)*Math.pow(2,O+1074):p*Math.pow(2,O)}(1,x-136),p[F+0]=O*x,p[F+1]=E*x,p[F+2]=e*x):(p[F+0]=0,p[F+1]=0,p[F+2]=0)}function q(p,O){let E="",e="";for(let x=O;x<p.length-O&&(e=String.fromCharCode(p[x]),"\n"!=e);x++)E+=e;return E}function a(p){let O=0,E=0,e=q(p,0);if("#"!=e[0]||"?"!=e[1])throw"Bad HDR Format.";let x=!1,F=!1,a=0;do{a+=e.length+1,e=q(p,a),"FORMAT=32-bit_rle_rgbe"==e?F=!0:0==e.length&&(x=!0)}while(!x);if(!F)throw"HDR Bad header format, unsupported FORMAT";a+=e.length+1,e=q(p,a);const Y=/^-Y (.*) \+X (.*)$/g.exec(e);if(!Y||Y.length<3)throw"HDR Bad header format, no size";if(E=parseInt(Y[2]),O=parseInt(Y[1]),E<8||E>32767)throw"HDR Bad header format, unsupported size";return a+=e.length+1,{height:O,width:E,dataPosition:a}}function Y(p,O){return function(p,O){let E=O.height;const e=O.width;let x,q,a,Y,s,D=O.dataPosition,Z=0,m=0,h=0;const T=new ArrayBuffer(4*e),A=new Uint8Array(T),H=new ArrayBuffer(O.width*O.height*4*3),t=new Float32Array(H);for(;E>0;){if(x=p[D++],q=p[D++],a=p[D++],Y=p[D++],2!=x||2!=q||128&a||O.width<8||O.width>32767)return B(p,O);if((a<<8|Y)!=e)throw"HDR Bad header format, wrong scan line width";for(Z=0,h=0;h<4;h++)for(m=(h+1)*e;Z<m;)if(x=p[D++],q=p[D++],x>128){if(s=x-128,0==s||s>m-Z)throw"HDR Bad Format, bad scanline data (run)";for(;s-- >0;)A[Z++]=q}else{if(s=x,0==s||s>m-Z)throw"HDR Bad Format, bad scanline data (non-run)";if(A[Z++]=q,--s>0)for(let O=0;O<s;O++)A[Z++]=p[D++]}for(h=0;h<e;h++)x=A[h],q=A[h+e],a=A[h+2*e],Y=A[h+3*e],F(t,x,q,a,Y,(O.height-E)*e*3+3*h);E--}return t}(p,O)}function B(p,O){let E=O.height;const e=O.width;let x,q,a,Y,B,s=O.dataPosition;const D=new ArrayBuffer(O.width*O.height*4*3),Z=new Float32Array(D);for(;E>0;){for(B=0;B<O.width;B++)x=p[s++],q=p[s++],a=p[s++],Y=p[s++],F(Z,x,q,a,Y,(O.height-E)*e*3+3*B);E--}return Z}x.FACE_LEFT=[new e.n(-1,-1,-1),new e.n(1,-1,-1),new e.n(-1,1,-1),new e.n(1,1,-1)],x.FACE_RIGHT=[new e.n(1,-1,1),new e.n(-1,-1,1),new e.n(1,1,1),new e.n(-1,1,1)],x.FACE_FRONT=[new e.n(1,-1,-1),new e.n(1,-1,1),new e.n(1,1,-1),new e.n(1,1,1)],x.FACE_BACK=[new e.n(-1,-1,1),new e.n(-1,-1,-1),new e.n(-1,1,1),new e.n(-1,1,-1)],x.FACE_DOWN=[new e.n(1,1,-1),new e.n(1,1,1),new e.n(-1,1,-1),new e.n(-1,1,1)],x.FACE_UP=[new e.n(-1,-1,-1),new e.n(-1,-1,1),new e.n(1,-1,-1),new e.n(1,-1,1)];class s{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(p,O,E){const e=new Uint8Array(p.buffer,p.byteOffset,p.byteLength),x=a(e),F=Y(e,x),q=x.width*x.height,B=new Float32Array(4*q);for(let a=0;a<q;a+=1)B[4*a]=F[3*a],B[4*a+1]=F[3*a+1],B[4*a+2]=F[3*a+2],B[4*a+3]=1;E(x.width,x.height,O.generateMipMaps,!1,(()=>{const p=O.getEngine();O.type=1,O.format=5,O._gammaSpace=!1,p._uploadDataToTextureDirectly(O,B)}))}}}}]);