"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10871:(Q,z,I)=>{I.r(z),I.d(z,{_HDRTextureLoader:()=>j});var P=I(984);class w{static ConvertPanoramaToCubemap(Q,z,I,P){let w=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Q)throw"ConvertPanoramaToCubemap: input cannot be null";if(Q.length!=z*I*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(P,this.FACE_FRONT,Q,z,I,w),back:this.CreateCubemapTexture(P,this.FACE_BACK,Q,z,I,w),left:this.CreateCubemapTexture(P,this.FACE_LEFT,Q,z,I,w),right:this.CreateCubemapTexture(P,this.FACE_RIGHT,Q,z,I,w),up:this.CreateCubemapTexture(P,this.FACE_UP,Q,z,I,w),down:this.CreateCubemapTexture(P,this.FACE_DOWN,Q,z,I,w),size:P,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(Q,z,I,P,w){let T=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const A=new ArrayBuffer(Q*Q*4*3),e=new Float32Array(A),m=T?Math.max(1,Math.round(P/4/Q)):1,f=1/m,j=f*f,D=z[1].Dc(z[0]).scale(f/Q),k=z[3].Dc(z[2]).scale(f/Q),s=1/Q;let J=0;for(let l=0;l<Q;l++)for(let T=0;T<m;T++){let T=z[0],A=z[2];for(let z=0;z<Q;z++)for(let f=0;f<m;f++){const m=A.Dc(T).scale(J).add(T);m.normalize();const f=this.CalcProjectionSpherical(m,I,P,w);e[l*Q*3+3*z+0]+=f.r*j,e[l*Q*3+3*z+1]+=f.g*j,e[l*Q*3+3*z+2]+=f.b*j,T=T.add(D),A=A.add(k)}J+=s*f}return e}static CalcProjectionSpherical(Q,z,I,P){let w=Math.atan2(Q.z,Q.x);const T=Math.acos(Q.y);for(;w<-Math.PI;)w+=2*Math.PI;for(;w>Math.PI;)w-=2*Math.PI;let A=w/Math.PI;const e=T/Math.PI;A=.5*A+.5;let m=Math.round(A*I);m<0?m=0:m>=I&&(m=I-1);let f=Math.round(e*P);f<0?f=0:f>=P&&(f=P-1);const j=P-f-1;return{r:z[j*I*3+3*m+0],g:z[j*I*3+3*m+1],b:z[j*I*3+3*m+2]}}}function T(Q,z,I,P,w,T){w>0?(w=function(Q,z){return z>1023?Q*Math.pow(2,1023)*Math.pow(2,z-1023):z<-1074?Q*Math.pow(2,-1074)*Math.pow(2,z+1074):Q*Math.pow(2,z)}(1,w-136),Q[T+0]=z*w,Q[T+1]=I*w,Q[T+2]=P*w):(Q[T+0]=0,Q[T+1]=0,Q[T+2]=0)}function A(Q,z){let I="",P="";for(let w=z;w<Q.length-z&&(P=String.fromCharCode(Q[w]),"\n"!=P);w++)I+=P;return I}function e(Q){let z=0,I=0,P=A(Q,0);if("#"!=P[0]||"?"!=P[1])throw"Bad HDR Format.";let w=!1,T=!1,e=0;do{e+=P.length+1,P=A(Q,e),"FORMAT=32-bit_rle_rgbe"==P?T=!0:0==P.length&&(w=!0)}while(!w);if(!T)throw"HDR Bad header format, unsupported FORMAT";e+=P.length+1,P=A(Q,e);const m=/^-Y (.*) \+X (.*)$/g.exec(P);if(!m||m.length<3)throw"HDR Bad header format, no size";if(I=parseInt(m[2]),z=parseInt(m[1]),I<8||I>32767)throw"HDR Bad header format, unsupported size";return e+=P.length+1,{height:z,width:I,dataPosition:e}}function m(Q,z){return function(Q,z){let I=z.height;const P=z.width;let w,A,e,m,j,D=z.dataPosition,k=0,s=0,J=0;const l=new ArrayBuffer(4*P),X=new Uint8Array(l),n=new ArrayBuffer(z.width*z.height*4*3),d=new Float32Array(n);for(;I>0;){if(w=Q[D++],A=Q[D++],e=Q[D++],m=Q[D++],2!=w||2!=A||128&e||z.width<8||z.width>32767)return f(Q,z);if((e<<8|m)!=P)throw"HDR Bad header format, wrong scan line width";for(k=0,J=0;J<4;J++)for(s=(J+1)*P;k<s;)if(w=Q[D++],A=Q[D++],w>128){if(j=w-128,0==j||j>s-k)throw"HDR Bad Format, bad scanline data (run)";for(;j-- >0;)X[k++]=A}else{if(j=w,0==j||j>s-k)throw"HDR Bad Format, bad scanline data (non-run)";if(X[k++]=A,--j>0)for(let z=0;z<j;z++)X[k++]=Q[D++]}for(J=0;J<P;J++)w=X[J],A=X[J+P],e=X[J+2*P],m=X[J+3*P],T(d,w,A,e,m,(z.height-I)*P*3+3*J);I--}return d}(Q,z)}function f(Q,z){let I=z.height;const P=z.width;let w,A,e,m,f,j=z.dataPosition;const D=new ArrayBuffer(z.width*z.height*4*3),k=new Float32Array(D);for(;I>0;){for(f=0;f<z.width;f++)w=Q[j++],A=Q[j++],e=Q[j++],m=Q[j++],T(k,w,A,e,m,(z.height-I)*P*3+3*f);I--}return k}w.FACE_LEFT=[new P.o(-1,-1,-1),new P.o(1,-1,-1),new P.o(-1,1,-1),new P.o(1,1,-1)],w.FACE_RIGHT=[new P.o(1,-1,1),new P.o(-1,-1,1),new P.o(1,1,1),new P.o(-1,1,1)],w.FACE_FRONT=[new P.o(1,-1,-1),new P.o(1,-1,1),new P.o(1,1,-1),new P.o(1,1,1)],w.FACE_BACK=[new P.o(-1,-1,1),new P.o(-1,-1,-1),new P.o(-1,1,1),new P.o(-1,1,-1)],w.FACE_DOWN=[new P.o(1,1,-1),new P.o(1,1,1),new P.o(-1,1,-1),new P.o(-1,1,1)],w.FACE_UP=[new P.o(-1,-1,-1),new P.o(-1,-1,1),new P.o(1,-1,-1),new P.o(1,-1,1)];class j{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(Q,z,I){const P=new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength),w=e(P),T=m(P,w),A=w.width*w.height,f=new Float32Array(4*A);for(let e=0;e<A;e+=1)f[4*e]=T[3*e],f[4*e+1]=T[3*e+1],f[4*e+2]=T[3*e+2],f[4*e+3]=1;I(w.width,w.height,z.generateMipMaps,!1,(()=>{const Q=z.getEngine();z.type=1,z.format=5,z._gammaSpace=!1,Q._uploadDataToTextureDirectly(z,f)}))}}}}]);