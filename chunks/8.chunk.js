"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10270:(f,Q,H)=>{H.r(Q),H.d(Q,{_HDRTextureLoader:()=>N});var X=H(1003);class i{static ConvertPanoramaToCubemap(f,Q,H,X){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!f)throw"ConvertPanoramaToCubemap: input cannot be null";if(f.length!=Q*H*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(X,this.FACE_FRONT,f,Q,H,i),back:this.CreateCubemapTexture(X,this.FACE_BACK,f,Q,H,i),left:this.CreateCubemapTexture(X,this.FACE_LEFT,f,Q,H,i),right:this.CreateCubemapTexture(X,this.FACE_RIGHT,f,Q,H,i),up:this.CreateCubemapTexture(X,this.FACE_UP,f,Q,H,i),down:this.CreateCubemapTexture(X,this.FACE_DOWN,f,Q,H,i),size:X,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(f,Q,H,X,i){let S=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const x=new ArrayBuffer(f*f*4*3),K=new Float32Array(x),Z=S?Math.max(1,Math.round(X/4/f)):1,B=1/Z,N=B*B,J=Q[1].hd(Q[0]).scale(B/f),g=Q[3].hd(Q[2]).scale(B/f),z=1/f;let v=0;for(let Y=0;Y<f;Y++)for(let S=0;S<Z;S++){let S=Q[0],x=Q[2];for(let Q=0;Q<f;Q++)for(let B=0;B<Z;B++){const Z=x.hd(S).scale(v).add(S);Z.normalize();const B=this.CalcProjectionSpherical(Z,H,X,i);K[Y*f*3+3*Q+0]+=B.r*N,K[Y*f*3+3*Q+1]+=B.g*N,K[Y*f*3+3*Q+2]+=B.b*N,S=S.add(J),x=x.add(g)}v+=z*B}return K}static CalcProjectionSpherical(f,Q,H,X){let i=Math.atan2(f.z,f.x);const S=Math.acos(f.y);for(;i<-Math.PI;)i+=2*Math.PI;for(;i>Math.PI;)i-=2*Math.PI;let x=i/Math.PI;const K=S/Math.PI;x=.5*x+.5;let Z=Math.round(x*H);Z<0?Z=0:Z>=H&&(Z=H-1);let B=Math.round(K*X);B<0?B=0:B>=X&&(B=X-1);const N=X-B-1;return{r:Q[N*H*3+3*Z+0],g:Q[N*H*3+3*Z+1],b:Q[N*H*3+3*Z+2]}}}function S(f,Q,H,X,i,S){i>0?(i=function(f,Q){return Q>1023?f*Math.pow(2,1023)*Math.pow(2,Q-1023):Q<-1074?f*Math.pow(2,-1074)*Math.pow(2,Q+1074):f*Math.pow(2,Q)}(1,i-136),f[S+0]=Q*i,f[S+1]=H*i,f[S+2]=X*i):(f[S+0]=0,f[S+1]=0,f[S+2]=0)}function x(f,Q){let H="",X="";for(let i=Q;i<f.length-Q&&(X=String.fromCharCode(f[i]),"\n"!=X);i++)H+=X;return H}function K(f){let Q=0,H=0,X=x(f,0);if("#"!=X[0]||"?"!=X[1])throw"Bad HDR Format.";let i=!1,S=!1,K=0;do{K+=X.length+1,X=x(f,K),"FORMAT=32-bit_rle_rgbe"==X?S=!0:0==X.length&&(i=!0)}while(!i);if(!S)throw"HDR Bad header format, unsupported FORMAT";K+=X.length+1,X=x(f,K);const Z=/^-Y (.*) \+X (.*)$/g.exec(X);if(!Z||Z.length<3)throw"HDR Bad header format, no size";if(H=parseInt(Z[2]),Q=parseInt(Z[1]),H<8||H>32767)throw"HDR Bad header format, unsupported size";return K+=X.length+1,{height:Q,width:H,dataPosition:K}}function Z(f,Q){return function(f,Q){let H=Q.height;const X=Q.width;let i,x,K,Z,N,J=Q.dataPosition,g=0,z=0,v=0;const Y=new ArrayBuffer(4*X),O=new Uint8Array(Y),n=new ArrayBuffer(Q.width*Q.height*4*3),e=new Float32Array(n);for(;H>0;){if(i=f[J++],x=f[J++],K=f[J++],Z=f[J++],2!=i||2!=x||128&K||Q.width<8||Q.width>32767)return B(f,Q);if((K<<8|Z)!=X)throw"HDR Bad header format, wrong scan line width";for(g=0,v=0;v<4;v++)for(z=(v+1)*X;g<z;)if(i=f[J++],x=f[J++],i>128){if(N=i-128,0==N||N>z-g)throw"HDR Bad Format, bad scanline data (run)";for(;N-- >0;)O[g++]=x}else{if(N=i,0==N||N>z-g)throw"HDR Bad Format, bad scanline data (non-run)";if(O[g++]=x,--N>0)for(let Q=0;Q<N;Q++)O[g++]=f[J++]}for(v=0;v<X;v++)i=O[v],x=O[v+X],K=O[v+2*X],Z=O[v+3*X],S(e,i,x,K,Z,(Q.height-H)*X*3+3*v);H--}return e}(f,Q)}function B(f,Q){let H=Q.height;const X=Q.width;let i,x,K,Z,B,N=Q.dataPosition;const J=new ArrayBuffer(Q.width*Q.height*4*3),g=new Float32Array(J);for(;H>0;){for(B=0;B<Q.width;B++)i=f[N++],x=f[N++],K=f[N++],Z=f[N++],S(g,i,x,K,Z,(Q.height-H)*X*3+3*B);H--}return g}i.FACE_LEFT=[new X.p(-1,-1,-1),new X.p(1,-1,-1),new X.p(-1,1,-1),new X.p(1,1,-1)],i.FACE_RIGHT=[new X.p(1,-1,1),new X.p(-1,-1,1),new X.p(1,1,1),new X.p(-1,1,1)],i.FACE_FRONT=[new X.p(1,-1,-1),new X.p(1,-1,1),new X.p(1,1,-1),new X.p(1,1,1)],i.FACE_BACK=[new X.p(-1,-1,1),new X.p(-1,-1,-1),new X.p(-1,1,1),new X.p(-1,1,-1)],i.FACE_DOWN=[new X.p(1,1,-1),new X.p(1,1,1),new X.p(-1,1,-1),new X.p(-1,1,1)],i.FACE_UP=[new X.p(-1,-1,-1),new X.p(-1,-1,1),new X.p(1,-1,-1),new X.p(1,-1,1)];class N{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(f,Q,H){const X=new Uint8Array(f.buffer,f.byteOffset,f.byteLength),i=K(X),S=Z(X,i),x=i.width*i.height,B=new Float32Array(4*x);for(let K=0;K<x;K+=1)B[4*K]=S[3*K],B[4*K+1]=S[3*K+1],B[4*K+2]=S[3*K+2],B[4*K+3]=1;H(i.width,i.height,Q.generateMipMaps,!1,(()=>{const f=Q.getEngine();Q.type=1,Q.format=5,Q._gammaSpace=!1,f._uploadDataToTextureDirectly(Q,B)}))}}}}]);