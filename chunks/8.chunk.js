"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10684:(C,M,x)=>{x.r(M),x.d(M,{_HDRTextureLoader:()=>V});var f=x(978);class T{static ConvertPanoramaToCubemap(C,M,x,f){let T=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!C)throw"ConvertPanoramaToCubemap: input cannot be null";if(C.length!=M*x*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(f,this.FACE_FRONT,C,M,x,T),back:this.CreateCubemapTexture(f,this.FACE_BACK,C,M,x,T),left:this.CreateCubemapTexture(f,this.FACE_LEFT,C,M,x,T),right:this.CreateCubemapTexture(f,this.FACE_RIGHT,C,M,x,T),up:this.CreateCubemapTexture(f,this.FACE_UP,C,M,x,T),down:this.CreateCubemapTexture(f,this.FACE_DOWN,C,M,x,T),size:f,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(C,M,x,f,T){let z=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const s=new ArrayBuffer(C*C*4*3),S=new Float32Array(s),m=z?Math.max(1,Math.round(f/4/C)):1,Q=1/m,V=Q*Q,y=M[1].rc(M[0]).scale(Q/C),U=M[3].rc(M[2]).scale(Q/C),O=1/C;let d=0;for(let D=0;D<C;D++)for(let z=0;z<m;z++){let z=M[0],s=M[2];for(let M=0;M<C;M++)for(let Q=0;Q<m;Q++){const m=s.rc(z).scale(d).add(z);m.normalize();const Q=this.CalcProjectionSpherical(m,x,f,T);S[D*C*3+3*M+0]+=Q.r*V,S[D*C*3+3*M+1]+=Q.g*V,S[D*C*3+3*M+2]+=Q.b*V,z=z.add(y),s=s.add(U)}d+=O*Q}return S}static CalcProjectionSpherical(C,M,x,f){let T=Math.atan2(C.z,C.x);const z=Math.acos(C.y);for(;T<-Math.PI;)T+=2*Math.PI;for(;T>Math.PI;)T-=2*Math.PI;let s=T/Math.PI;const S=z/Math.PI;s=.5*s+.5;let m=Math.round(s*x);m<0?m=0:m>=x&&(m=x-1);let Q=Math.round(S*f);Q<0?Q=0:Q>=f&&(Q=f-1);const V=f-Q-1;return{r:M[V*x*3+3*m+0],g:M[V*x*3+3*m+1],b:M[V*x*3+3*m+2]}}}function z(C,M,x,f,T,z){T>0?(T=function(C,M){return M>1023?C*Math.pow(2,1023)*Math.pow(2,M-1023):M<-1074?C*Math.pow(2,-1074)*Math.pow(2,M+1074):C*Math.pow(2,M)}(1,T-136),C[z+0]=M*T,C[z+1]=x*T,C[z+2]=f*T):(C[z+0]=0,C[z+1]=0,C[z+2]=0)}function s(C,M){let x="",f="";for(let T=M;T<C.length-M&&(f=String.fromCharCode(C[T]),"\n"!=f);T++)x+=f;return x}function S(C){let M=0,x=0,f=s(C,0);if("#"!=f[0]||"?"!=f[1])throw"Bad HDR Format.";let T=!1,z=!1,S=0;do{S+=f.length+1,f=s(C,S),"FORMAT=32-bit_rle_rgbe"==f?z=!0:0==f.length&&(T=!0)}while(!T);if(!z)throw"HDR Bad header format, unsupported FORMAT";S+=f.length+1,f=s(C,S);const m=/^-Y (.*) \+X (.*)$/g.exec(f);if(!m||m.length<3)throw"HDR Bad header format, no size";if(x=parseInt(m[2]),M=parseInt(m[1]),x<8||x>32767)throw"HDR Bad header format, unsupported size";return S+=f.length+1,{height:M,width:x,dataPosition:S}}function m(C,M){return function(C,M){let x=M.height;const f=M.width;let T,s,S,m,V,y=M.dataPosition,U=0,O=0,d=0;const D=new ArrayBuffer(4*f),o=new Uint8Array(D),L=new ArrayBuffer(M.width*M.height*4*3),t=new Float32Array(L);for(;x>0;){if(T=C[y++],s=C[y++],S=C[y++],m=C[y++],2!=T||2!=s||128&S||M.width<8||M.width>32767)return Q(C,M);if((S<<8|m)!=f)throw"HDR Bad header format, wrong scan line width";for(U=0,d=0;d<4;d++)for(O=(d+1)*f;U<O;)if(T=C[y++],s=C[y++],T>128){if(V=T-128,0==V||V>O-U)throw"HDR Bad Format, bad scanline data (run)";for(;V-- >0;)o[U++]=s}else{if(V=T,0==V||V>O-U)throw"HDR Bad Format, bad scanline data (non-run)";if(o[U++]=s,--V>0)for(let M=0;M<V;M++)o[U++]=C[y++]}for(d=0;d<f;d++)T=o[d],s=o[d+f],S=o[d+2*f],m=o[d+3*f],z(t,T,s,S,m,(M.height-x)*f*3+3*d);x--}return t}(C,M)}function Q(C,M){let x=M.height;const f=M.width;let T,s,S,m,Q,V=M.dataPosition;const y=new ArrayBuffer(M.width*M.height*4*3),U=new Float32Array(y);for(;x>0;){for(Q=0;Q<M.width;Q++)T=C[V++],s=C[V++],S=C[V++],m=C[V++],z(U,T,s,S,m,(M.height-x)*f*3+3*Q);x--}return U}T.FACE_LEFT=[new f.m(-1,-1,-1),new f.m(1,-1,-1),new f.m(-1,1,-1),new f.m(1,1,-1)],T.FACE_RIGHT=[new f.m(1,-1,1),new f.m(-1,-1,1),new f.m(1,1,1),new f.m(-1,1,1)],T.FACE_FRONT=[new f.m(1,-1,-1),new f.m(1,-1,1),new f.m(1,1,-1),new f.m(1,1,1)],T.FACE_BACK=[new f.m(-1,-1,1),new f.m(-1,-1,-1),new f.m(-1,1,1),new f.m(-1,1,-1)],T.FACE_DOWN=[new f.m(1,1,-1),new f.m(1,1,1),new f.m(-1,1,-1),new f.m(-1,1,1)],T.FACE_UP=[new f.m(-1,-1,-1),new f.m(-1,-1,1),new f.m(1,-1,-1),new f.m(1,-1,1)];class V{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(C,M,x){const f=new Uint8Array(C.buffer,C.byteOffset,C.byteLength),T=S(f),z=m(f,T),s=T.width*T.height,Q=new Float32Array(4*s);for(let S=0;S<s;S+=1)Q[4*S]=z[3*S],Q[4*S+1]=z[3*S+1],Q[4*S+2]=z[3*S+2],Q[4*S+3]=1;x(T.width,T.height,M.generateMipMaps,!1,(()=>{const C=M.getEngine();M.type=1,M.format=5,M._gammaSpace=!1,C._uploadDataToTextureDirectly(M,Q)}))}}}}]);