"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10987:(Z,c,L)=>{L.r(c),L.d(c,{EXT_materials_diffuse_roughness:()=>fc,EXT_mesh_gpu_instancing:()=>nZ,GLTF2Export:()=>UZ,GLTFData:()=>J,KHR_draco_mesh_compression:()=>Lc,KHR_lights_punctual:()=>pc,KHR_materials_anisotropy:()=>ic,KHR_materials_clearcoat:()=>Ec,KHR_materials_diffuse_transmission:()=>Oc,KHR_materials_dispersion:()=>Mc,KHR_materials_emissive_strength:()=>jc,KHR_materials_ior:()=>uc,KHR_materials_iridescence:()=>hc,KHR_materials_sheen:()=>Dc,KHR_materials_specular:()=>Hc,KHR_materials_transmission:()=>Wc,KHR_materials_unlit:()=>Ic,KHR_materials_volume:()=>Qc,KHR_texture_transform:()=>sc,OBJExport:()=>G,STLExport:()=>mc,USDZExportAsync:()=>cL,_ConvertToGLTFPBRMetallicRoughness:()=>T,_SolveMetallic:()=>W,__IGLTFExporterExtension:()=>V});var k=L(10993),N=L(11038),R=L(11163);class G{static OBJ(Z,c,L,G){const V=[];let p=1,J=1;c&&(L||(L="mat"),V.push("mtllib "+L+".mtl"));for(let z=0;z<Z.length;z++){const L=Z[z],i=L.name||`mesh${z}}`;V.push(`o ${i}`);let t=null;if(G){const Z=L.Jc(!0);t=new k.b,Z.invertToRef(t),L.bakeTransformIntoVertices(Z)}if(c){const Z=L.material;Z&&V.push("usemtl "+Z.id)}const E=L.zc;if(!E){N.c.Warn("No geometry is present on the mesh");continue}const x=E.getVerticesData("position"),q=E.getVerticesData("kc"),O=E.getVerticesData("uv"),w=E.tc();let M=0,P=0;if(!x||!w){N.c.Warn("There are no position vertices or indices on the mesh!");continue}const j=Z[0].XZ().useRightHandedSystem?1:-1;for(let Z=0;Z<x.length;Z+=3)V.push("v "+x[Z]*j+" "+x[Z+1]+" "+x[Z+2]),M++;if(null!=q)for(let Z=0;Z<q.length;Z+=3)V.push("vn "+q[Z]*j+" "+q[Z+1]+" "+q[Z+2]);if(null!=O)for(let Z=0;Z<O.length;Z+=2)V.push("vt "+O[Z]+" "+O[Z+1]),P++;const o=["","",""],u=(L.material||L.XZ().defaultMaterial)._getEffectiveOrientation(L),[X,h]=u===R.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let Z=0;Z<w.length;Z+=3){const c=[String(w[Z]+p),String(w[Z+X]+p),String(w[Z+h]+p)],L=[String(w[Z]+J),String(w[Z+X]+J),String(w[Z+h]+J)],k=c,N=null!=O?L:o,R=null!=q?c:o;V.push("f "+k[0]+"/"+N[0]+"/"+R[0]+" "+k[1]+"/"+N[1]+"/"+R[1]+" "+k[2]+"/"+N[2]+"/"+R[2])}G&&t&&L.bakeTransformIntoVertices(t),p+=M,J+=P}return V.join("\n")}static MTL(Z){const c=[],L=Z.material;c.push("newmtl mat1"),c.push("  Ns "+L.specularPower.toFixed(4)),c.push("  Ni 1.5000"),c.push("  d "+L.alpha.toFixed(4)),c.push("  Tr 0.0000"),c.push("  Tf 1.0000 1.0000 1.0000"),c.push("  illum 2"),c.push("  Ka "+L.ambientColor.r.toFixed(4)+" "+L.ambientColor.g.toFixed(4)+" "+L.ambientColor.b.toFixed(4)),c.push("  Kd "+L.diffuseColor.r.toFixed(4)+" "+L.diffuseColor.g.toFixed(4)+" "+L.diffuseColor.b.toFixed(4)),c.push("  Ks "+L.specularColor.r.toFixed(4)+" "+L.specularColor.g.toFixed(4)+" "+L.specularColor.b.toFixed(4)),c.push("  Ke "+L.emissiveColor.r.toFixed(4)+" "+L.emissiveColor.g.toFixed(4)+" "+L.emissiveColor.b.toFixed(4));L.ambientTexture&&c.push("  map_Ka "+L.ambientTexture.name),L.diffuseTexture&&c.push("  map_Kd "+L.diffuseTexture.name),L.specularTexture&&c.push("  map_Ks "+L.specularTexture.name),L.bumpTexture&&c.push("  map_bump -imfchan z "+L.bumpTexture.name),L.opacityTexture&&c.push("  map_d "+L.opacityTexture.name);return c.join("\n")}}var V=0,p=L(11081);class J{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const Z in this.files){const c=this.files[Z],L=new Blob([c],{type:(0,p.g)(Z)});N.c.Download(L,Z)}}}var z=L(11190),i=L(11274),t=L(11282),E=L(11321),x=L(11395),q=L(11023),O=L(11255),w=L(11032);const M=w.HighestCommonFactor,P={...w,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:M};var j=L(11503),o=L(11508),u=L(11544),X=L(11549),h=L(11556);const B=1e-6,D=new O.d(.04,.04,.04),e=1024,H=O.d.White(),l=O.d.Black();function W(Z,c,L){if(c<D.r)return 0;const k=D.r,N=Z*L/(1-D.r)+c-2*D.r,R=N*N-4*k*(D.r-c);return P.Clamp((-N+Math.sqrt(R))/(2*k),0,1)}function T(Z){const c=Z.diffuseColor.toLinearSpace(Z.XZ().getEngine().useExactSrgbConversions).scale(.5),L=Z.alpha,N=function(Z){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new k.f(0,1),L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new k.f(0,.1),N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new k.f(0,.1),R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new k.f(1300,.1);return function(Z,c,L,k,N){return(1-Z)*(1-Z)*(1-Z)*c+3*(1-Z)*(1-Z)*Z*L+3*(1-Z)*Z*Z*k+Z*Z*Z*N}(Math.pow(Z/R.x,.333333),c.y,L.y,N.y,R.y)}(P.Clamp(Z.specularPower,0,e));return{baseColorFactor:[c.r,c.g,c.b,L],metallicFactor:0,roughnessFactor:N}}function I(Z,c){c.needAlphaBlending()?Z.alphaMode="BLEND":c.needAlphaTesting()&&(Z.alphaMode="MASK",Z.alphaCutoff=c.alphaCutOff)}function d(Z,c,L){const k=new Uint8Array(Z*c*4);for(let N=0;N<k.length;N+=4)k[N]=k[N+1]=k[N+2]=k[N+3]=255;return u.e.CreateRGBATexture(k,Z,c,L)}function Q(Z){if(Z instanceof Uint8Array){const c=Z.length,L=new Float32Array(Z.length);for(let k=0;k<c;++k)L[k]=Z[k]/255;return L}if(Z instanceof Float32Array)return Z;throw new Error("Unsupported pixel format!")}class r{constructor(Z){this._exporter=Z,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(Z){return Z?this._textureMap.get(Z)??null:null}async exportStandardMaterialAsync(Z,c,L){const k=T(Z),R={name:Z.name};if(null==Z.Ec||Z.Ec||(Z.twoSidedLighting||N.c.Warn(Z.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),R.doubleSided=!0),L){const L=[],N=Z.diffuseTexture;N&&L.push(this.exportTextureAsync(N,c).then((Z=>{Z&&(k.baseColorTexture=Z)})));const G=Z.bumpTexture;G&&L.push(this.exportTextureAsync(G,c).then((Z=>{Z&&(R.normalTexture=Z,1!==G.level&&(R.normalTexture.scale=G.level))})));const V=Z.emissiveTexture;V&&(R.emissiveFactor=[1,1,1],L.push(this.exportTextureAsync(V,c).then((Z=>{Z&&(R.emissiveTexture=Z)}))));const p=Z.ambientTexture;p&&L.push(this.exportTextureAsync(p,c).then((Z=>{if(Z){const c={index:Z.index};R.occlusionTexture=c}}))),L.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(L))}(Z.alpha<1||Z.opacityTexture)&&(Z.alphaMode===X.b.ALPHA_COMBINE?R.alphaMode="BLEND":N.c.Warn(Z.name+": glTF 2.0 does not support alpha mode: "+Z.alphaMode.toString())),Z.emissiveColor&&!Z.emissiveColor.equalsWithEpsilon(l,B)&&(R.emissiveFactor=Z.emissiveColor.xc()),R.pbrMetallicRoughness=k,I(R,Z),await this._finishMaterialAsync(R,Z,c);const G=this._exporter._materials;return G.push(R),G.length-1}async _finishMaterialAsync(Z,c,L){const k=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",Z,c),N=[];for(const R of k)N.push(this.exportTextureAsync(R,L));await Promise.all(N),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",Z,c)}async _getImageDataAsync(Z,c,k,N){const R=X.b.TEXTURETYPE_UNSIGNED_BYTE,G=this._exporter._babylonScene,V=G.getEngine(),p=V.createRawTexture(Z,c,k,X.b.TEXTUREFORMAT_RGBA,!1,!0,o.c.NEAREST_SAMPLINGMODE,null,R);V.isWebGPU?await L.e(36).then(L.bind(L,13623)):await L.e(37).then(L.bind(L,13627)),await j.n.ApplyPostProcess("pass",p,G,R,X.b.TEXTURE_NEAREST_SAMPLINGMODE,X.b.TEXTUREFORMAT_RGBA);const J=await V._readTexturePixels(p,c,k);return await h.DumpTools.DumpDataAsync(c,k,J,N,void 0,!0,!0)}_resizeTexturesToSameDimensions(Z,c,L){const k=Z?Z.getSize():{width:0,height:0},N=c?c.getSize():{width:0,height:0};let R,G;return k.width<N.width?(R=Z&&Z instanceof o.c?j.n.CreateResizedCopy(Z,N.width,N.height,!0):d(N.width,N.height,L),G=c):k.width>N.width?(G=c&&c instanceof o.c?j.n.CreateResizedCopy(c,k.width,k.height,!0):d(k.width,k.height,L),R=Z):(R=Z,G=c),{texture1:R,texture2:G}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Z,c,L,k){const N=new Array;if(!Z&&!c)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const R=Z?Z.XZ():c?c.XZ():null;if(R){var G;const V=this._resizeTexturesToSameDimensions(Z,c,R),p=null===(G=V.texture1)||void 0===G?void 0:G.getSize();let J,z;const i=p.width,t=p.height,E=await V.texture1.readPixels(),x=await V.texture2.readPixels();if(!E)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(J=Q(E),!x)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");z=Q(x);const q=z.byteLength,w=new Uint8Array(q),M=new Uint8Array(q),P=4,j=l;let o=0,u=0;for(let Z=0;Z<t;++Z)for(let c=0;c<i;++c){const k=(i*Z+c)*P,N={diffuseColor:new O.d(J[k],J[k+1],J[k+2]).toLinearSpace(R.getEngine().useExactSrgbConversions).multiply(L.diffuseColor),specularColor:new O.d(z[k],z[k+1],z[k+2]).toLinearSpace(R.getEngine().useExactSrgbConversions).multiply(L.specularColor),glossiness:z[k+3]*L.glossiness},G=this._convertSpecularGlossinessToMetallicRoughness(N);j.r=Math.max(j.r,G.baseColor.r),j.g=Math.max(j.g,G.baseColor.g),j.b=Math.max(j.b,G.baseColor.b),o=Math.max(o,G.metallic),u=Math.max(u,G.roughness),M[k]=255*G.baseColor.r,M[k+1]=255*G.baseColor.g,M[k+2]=255*G.baseColor.b,M[k+3]=V.texture1.Oc?255*J[k+3]:255,w[k]=0,w[k+1]=255*G.roughness,w[k+2]=255*G.metallic,w[k+3]=255}const X={baseColor:j,metallic:o,roughness:u};let h=!1,D=!1;for(let Z=0;Z<t;++Z)for(let c=0;c<i;++c){const L=(i*Z+c)*P;M[L]/=X.baseColor.r>B?X.baseColor.r:1,M[L+1]/=X.baseColor.g>B?X.baseColor.g:1,M[L+2]/=X.baseColor.b>B?X.baseColor.b:1;const k=O.d.FromInts(M[L],M[L+1],M[L+2]).toGammaSpace(R.getEngine().useExactSrgbConversions);M[L]=255*k.r,M[L+1]=255*k.g,M[L+2]=255*k.b,k.equalsWithEpsilon(H,B)||(D=!0),w[L+1]/=X.roughness>B?X.roughness:1,w[L+2]/=X.metallic>B?X.metallic:1;O.d.FromInts(255,w[L+1],w[L+2]).equalsWithEpsilon(H,B)||(h=!0)}return h&&N.push(this._getImageDataAsync(w,i,t,k).then((Z=>{X.metallicRoughnessTextureData=Z}))),D&&N.push(this._getImageDataAsync(M,i,t,k).then((Z=>{X.baseColorTextureData=Z}))),await Promise.all(N).then((()=>X))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(Z){const c=this._getPerceivedBrightness(Z.diffuseColor),L=this._getPerceivedBrightness(Z.specularColor),k=1-this._getMaxComponent(Z.specularColor),N=W(c,L,k),R=Z.diffuseColor.scale(k/(1-D.r)/Math.max(1-N)),G=Z.specularColor.yL(D.scale(1-N)).scale(1/Math.max(N));let V=O.d.Lerp(R,G,N*N);V=V.clampToRef(0,1,V);return{baseColor:V,metallic:N,roughness:1-Z.glossiness}}_getPerceivedBrightness(Z){return Z?Math.sqrt(.299*Z.r*Z.r+.587*Z.g*Z.g+.114*Z.b*Z.b):0}_getMaxComponent(Z){return Z?Math.max(Z.r,Math.max(Z.g,Z.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(Z,c,L,k){const N=[],R={baseColor:Z._albedoColor,metallic:Z._metallic,roughness:Z._roughness};if(k){Z._albedoTexture&&N.push(this.exportTextureAsync(Z._albedoTexture,c).then((Z=>{Z&&(L.baseColorTexture=Z)})));const k=Z._metallicTexture;k&&N.push(this.exportTextureAsync(k,c).then((Z=>{Z&&(L.metallicRoughnessTexture=Z)})))}return N.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(N)),R}_getTextureSampler(Z){const c={};if(!Z||!(Z instanceof o.c))return c;const L=this._getGLTFTextureWrapMode(Z.wrapU);10497!==L&&(c.wrapS=L);const k=this._getGLTFTextureWrapMode(Z.wrapV);switch(10497!==k&&(c.wrapT=k),Z.samplingMode){case o.c.LINEAR_LINEAR:c.magFilter=9729,c.minFilter=9729;break;case o.c.LINEAR_NEAREST:c.magFilter=9729,c.minFilter=9728;break;case o.c.NEAREST_LINEAR:c.magFilter=9728,c.minFilter=9729;break;case o.c.NEAREST_LINEAR_MIPLINEAR:c.magFilter=9728,c.minFilter=9987;break;case o.c.NEAREST_NEAREST:c.magFilter=9728,c.minFilter=9728;break;case o.c.NEAREST_LINEAR_MIPNEAREST:c.magFilter=9728,c.minFilter=9985;break;case o.c.LINEAR_NEAREST_MIPNEAREST:c.magFilter=9729,c.minFilter=9984;break;case o.c.LINEAR_NEAREST_MIPLINEAR:c.magFilter=9729,c.minFilter=9986;break;case o.c.NEAREST_NEAREST_MIPLINEAR:c.magFilter=9728,c.minFilter=9986;break;case o.c.LINEAR_LINEAR_MIPLINEAR:c.magFilter=9729,c.minFilter=9987;break;case o.c.LINEAR_LINEAR_MIPNEAREST:c.magFilter=9729,c.minFilter=9985;break;case o.c.NEAREST_NEAREST_MIPNEAREST:c.magFilter=9728,c.minFilter=9984}return c}_getGLTFTextureWrapMode(Z){switch(Z){case o.c.WRAP_ADDRESSMODE:return 10497;case o.c.CLAMP_ADDRESSMODE:return 33071;case o.c.MIRROR_ADDRESSMODE:return 33648;default:return N.c.Error(`Unsupported Texture Wrap Mode ${Z}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(Z,c,L,k){const N={diffuseColor:Z._albedoColor,specularColor:Z._reflectivityColor,glossiness:Z._microSurface},R=Z._albedoTexture,G=Z._reflectivityTexture,V=Z._useMicroSurfaceFromReflectivityMapAlpha;if(G&&!V)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((R||G)&&k){this._exporter._materialNeedsUVsSet.add(Z);const k=this._exportTextureSampler(R||G),V=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(R,G,N,c),p=this._exporter._textures;if(V.baseColorTextureData){const Z=this._exportImage(`baseColor${p.length}`,c,V.baseColorTextureData);L.baseColorTexture=this._exportTextureInfo(Z,k,null===R||void 0===R?void 0:R.coordinatesIndex)}if(V.metallicRoughnessTextureData){const Z=this._exportImage(`metallicRoughness${p.length}`,c,V.metallicRoughnessTextureData);L.metallicRoughnessTexture=this._exportTextureInfo(Z,k,null===G||void 0===G?void 0:G.coordinatesIndex)}return V}return this._convertSpecularGlossinessToMetallicRoughness(N)}async exportPBRMaterialAsync(Z,c,L){const k={},N={name:Z.name},R=Z.isMetallicWorkflow();if(R){const c=Z._albedoColor,L=Z.alpha;c&&(k.baseColorFactor=[c.r,c.g,c.b,L])}const G=R?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(Z,c,k,L):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(Z,c,k,L);await this._setMetallicRoughnessPbrMaterialAsync(G,Z,N,k,c,L),await this._finishMaterialAsync(N,Z,c);const V=this._exporter._materials;return V.push(N),V.length-1}async _setMetallicRoughnessPbrMaterialAsync(Z,c,L,k,R,G){if(I(L,c),Z.baseColor.equalsWithEpsilon(H,B)&&P.WithinEpsilon(c.alpha,1,B)||(k.baseColorFactor=[Z.baseColor.r,Z.baseColor.g,Z.baseColor.b,c.alpha]),null!=Z.metallic&&1!==Z.metallic&&(k.metallicFactor=Z.metallic),null!=Z.roughness&&1!==Z.roughness&&(k.roughnessFactor=Z.roughness),null==c.Ec||c.Ec||(c._twoSidedLighting||N.c.Warn(c.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),L.doubleSided=!0),G){const Z=[],k=c._bumpTexture;k&&Z.push(this.exportTextureAsync(k,R).then((Z=>{Z&&(L.normalTexture=Z,1!==k.level&&(L.normalTexture.scale=k.level))})));const N=c._ambientTexture;N&&Z.push(this.exportTextureAsync(N,R).then((Z=>{if(Z){const k={index:Z.index,texCoord:Z.texCoord,extensions:Z.extensions};L.occlusionTexture=k;const N=c._ambientTextureStrength;N&&(k.strength=N)}})));const G=c._emissiveTexture;G&&Z.push(this.exportTextureAsync(G,R).then((Z=>{Z&&(L.emissiveTexture=Z)}))),Z.length>0&&(this._exporter._materialNeedsUVsSet.add(c),await Promise.all(Z))}const V=c._emissiveColor;V.equalsWithEpsilon(l,B)||(L.emissiveFactor=V.xc()),L.pbrMetallicRoughness=k}_getPixelsFromTextureAsync(Z){return function(Z){switch(Z){case X.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case X.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case X.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case X.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case X.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case X.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case X.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case X.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case X.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case X.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case X.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case X.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case X.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case X.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case X.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case X.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case X.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case X.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case X.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case X.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case X.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(Z.textureFormat)?(0,j.j)(Z,Z._texture.width,Z._texture.height):(Z.textureType,X.b.TEXTURETYPE_UNSIGNED_BYTE,Z.readPixels())}async exportTextureAsync(Z,c){const L=this._exporter._extensionsPreExportTextureAsync("exporter",Z,c);return L?await L.then((async L=>L?await this._exportTextureInfoAsync(L,c):await this._exportTextureInfoAsync(Z,c))):await this._exportTextureInfoAsync(Z,c)}async _exportTextureInfoAsync(Z,c){let L=this._textureMap.get(Z);if(!L){const k=await this._getPixelsFromTextureAsync(Z);if(!k)return null;const R=this._exportTextureSampler(Z),G=Z.mimeType;if(G)switch(G){case"image/jpeg":case"image/png":case"image/webp":c=G;break;default:N.c.Warn(`Unsupported media type: ${G}. Exporting texture as PNG.`)}const V=this._internalTextureToImage,p=Z.getInternalTexture().uniqueId;V[p]||(V[p]={});let J=V[p][c];if(void 0===J){const L=Z.getSize();J=(async()=>{const N=await this._getImageDataAsync(k,L.width,L.height,c);return this._exportImage(Z.name,c,N)})(),V[p][c]=J}L=this._exportTextureInfo(await J,R,Z.coordinatesIndex),this._textureMap.set(Z,L),this._exporter._extensionsPostExportTextures("exporter",L,Z)}return L}_exportImage(Z,c,L){const k=this._exporter._images;let R;if(this._exporter._shouldUseGlb){R={name:Z,mimeType:c,bufferView:void 0};const k=this._exporter._bufferManager.createBufferView(new Uint8Array(L));this._exporter._bufferManager.setBufferView(R,k)}else{const G=Z.replace(/\.\/|\/|\.\\|\\/g,"_"),V=function(Z){switch(Z){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(c);let p=G+V;k.some((Z=>Z.uri===p))&&(p=`${G}_${N.c.RandomId()}${V}`),R={name:Z,uri:p},this._exporter._imageData[p]={data:L,mimeType:c}}return k.push(R),k.length-1}_exportTextureInfo(Z,c,L){const k=this._exporter._textures;let N=k.findIndex((L=>L.sampler==c&&L.source===Z));-1===N&&(N=k.length,k.push({source:Z,sampler:c}));const R={index:N};return L&&(R.texCoord=L),R}_exportTextureSampler(Z){const c=this._getTextureSampler(Z),L=this._exporter._samplers,k=L.findIndex((Z=>Z.minFilter===c.minFilter&&Z.magFilter===c.magFilter&&Z.wrapS===c.wrapS&&Z.wrapT===c.wrapT));return-1!==k?k:(L.push(c),L.length-1)}}var f=L(11197),S=L(11052),s=L(11558),m=L(10999);const A=k.h.Zero(),b=k.c.Identity(),F=k.h.One(),U=new k.h(-1,1,1);function K(Z,c){const{byteOffset:L,byteStride:k,type:N,normalized:R}=Z,G=Z.getSize(),V=c.reduce(((Z,c)=>c.getTotalVertices()>Z?c.getTotalVertices():Z),-Number.MAX_VALUE);return{byteOffset:L,byteStride:k,componentCount:G,type:N,count:V*G,normalized:R,totalVertices:V,kind:Z.getKind()}}function n(Z){switch(Z){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function g(Z){switch(Z){case z.g.PositionKind:case z.g.NormalKind:case z.g.TangentKind:case z.g.ColorKind:case z.g.MatricesIndicesKind:case z.g.MatricesIndicesExtraKind:case z.g.MatricesWeightsKind:case z.g.MatricesWeightsExtraKind:case z.g.UVKind:case z.g.UV2Kind:case z.g.UV3Kind:case z.g.UV4Kind:case z.g.UV5Kind:case z.g.UV6Kind:return!0}return!1}function y(Z){switch(Z){case R.e.TriangleFillMode:return 4;case R.e.TriangleStripDrawMode:return 5;case R.e.TriangleFanDrawMode:return 6;case R.e.PointListDrawMode:case R.e.PointFillMode:return 0;case R.e.LineLoopDrawMode:return 2;case R.e.LineListDrawMode:return 1;case R.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${Z}`)}function v(Z){const c=Math.sqrt(Z.x*Z.x+Z.y*Z.y+Z.z*Z.z);c>0&&(Z.x/=c,Z.y/=c,Z.z/=c)}function Y(Z){return Z.x*=-1,Z}function a(Z){if(Z.x*Z.x+Z.y*Z.y>.5){const c=Math.abs(Z.x),L=Math.abs(Z.y);if(c>L){const L=Math.sign(Z.x);Z.x=c,Z.y*=-L,Z.z*=-L,Z.w*=L}else{const c=Math.sign(Z.y);Z.x*=-c,Z.y=L,Z.z*=c,Z.w*=-c}}else{const c=Math.abs(Z.z),L=Math.abs(Z.w);if(c>L){const L=Math.sign(Z.z);Z.x*=-L,Z.y*=L,Z.z=c,Z.w*=-L}else{const c=Math.sign(Z.w);Z.x*=c,Z.y*=-c,Z.z*=-c,Z.w=L}}return Z}function C(Z){Z.wc(-Z.z,Z.w,Z.x,-Z.y)}function ZZ(Z,c){const L=k.h.FromArrayToRef(c.translation||[0,0,0],0,k.d.Mc[0]),N=k.c.FromArrayToRef(c.rotation||[0,0,0,1],0,k.d.Quaternion[0]),R=k.b.ComposeToRef(F,N,L,k.d.Matrix[0]),G=k.h.FromArrayToRef(Z.translation||[0,0,0],0,k.d.Mc[2]),V=k.c.FromArrayToRef(Z.rotation||[0,0,0,1],0,k.d.Quaternion[1]),p=k.b.ComposeToRef(F,V,G,k.d.Matrix[1]);R.multiplyToRef(p,p),p.decompose(void 0,N,L),L.equalsWithEpsilon(A,m.e)?delete c.translation:c.translation=L.xc(),N.equalsWithEpsilon(b,m.e)?delete c.rotation:c.rotation=N.xc(),c.scale&&delete c.scale}function cZ(Z,c){if(!(c instanceof i.e))return!1;if(!(1===c.getChildren().length&&0===Z.getChildren().length&&Z.parent===c))return!1;const L=Z.XZ(),k=Z instanceof s.e&&!L.useRightHandedSystem?U:F;return!!c.Pc.equalsWithEpsilon(k,m.e)||(S.e.Warn(`Cannot collapse node ${Z.name} into parent node ${c.name} with modified scaling.`),!1)}function LZ(Z){if(Z instanceof Array){const c=new Float32Array(Z);return new Uint8Array(c.buffer,c.byteOffset,c.byteLength)}return ArrayBuffer.isView(Z)?new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength):new Uint8Array(Z)}function kZ(Z,c){for(const[L,k]of Object.entries(Z)){const N=c[L];(Array.isArray(k)&&Array.isArray(N)&&NZ(k,N)||k===N)&&delete Z[L]}return Z}function NZ(Z,c){return Z.length===c.length&&Z.every(((Z,L)=>Z===c[L]))}const RZ=k.b.Compose(new k.h(-1,1,1),k.c.Identity(),k.h.Zero());function GZ(Z,c){if(!(Z instanceof i.e))return!1;if(c){if(!Z.getWorldMatrix().equalsWithEpsilon(k.b.IdentityReadOnly,m.e))return!1}else{if(!Z.getWorldMatrix().multiplyToRef(RZ,k.d.Matrix[0]).equalsWithEpsilon(k.b.IdentityReadOnly,m.e))return!1}return!(Z instanceof t.d&&Z.zc)}const VZ=new Map([[Int8Array,(Z,c,L)=>Z.setInt8(c,L)],[Uint8Array,(Z,c,L)=>Z.setUint8(c,L)],[Uint8ClampedArray,(Z,c,L)=>Z.setUint8(c,L)],[Int16Array,(Z,c,L)=>Z.setInt16(c,L,!0)],[Uint16Array,(Z,c,L)=>Z.setUint16(c,L,!0)],[Int32Array,(Z,c,L)=>Z.setInt32(c,L,!0)],[Uint32Array,(Z,c,L)=>Z.setUint32(c,L,!0)],[Float32Array,(Z,c,L)=>Z.setFloat32(c,L,!0)],[Float64Array,(Z,c,L)=>Z.setFloat64(c,L,!0)]]);class pZ{writeTypedArray(Z){this._checkGrowBuffer(Z.byteLength);const c=VZ.get(Z.constructor);for(let L=0;L<Z.length;L++)c(this._dataView,this._byteOffset,Z[L]),this._byteOffset+=Z.BYTES_PER_ELEMENT}constructor(Z){this._data=new Uint8Array(Z),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(Z){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,Z),this._byteOffset++}writeInt8(Z){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,Z),this._byteOffset++}writeInt16(Z){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,Z,!0),this._byteOffset+=2}writeUInt16(Z){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,Z,!0),this._byteOffset+=2}writeInt32(Z){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,Z,!0),this._byteOffset+=4}writeUInt32(Z){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,Z,!0),this._byteOffset+=4}writeFloat32(Z){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,Z,!0),this._byteOffset+=4}writeFloat64(Z){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,Z,!0),this._byteOffset+=8}_checkGrowBuffer(Z){const c=this.byteOffset+Z;if(c>this._data.byteLength){const Z=new Uint8Array(2*c);Z.set(this._data),this._data=Z,this._dataView=new DataView(this._data.buffer)}}}function JZ(Z){return Z%4===0?4:Z%2===0?2:1}class zZ{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(Z){let c=0;this._bufferViewToData.forEach((Z=>{c+=Z.byteLength}));const L=new pZ(c),k=Array.from(this._bufferViewToData.keys()).sort(((Z,c)=>JZ(c.byteLength)-JZ(Z.byteLength)));for(const N of k){N.byteOffset=L.byteOffset,Z.push(N);const c=Z.length-1,k=this.getPropertiesWithBufferView(N);for(const Z of k)Z.bufferView=c;L.writeTypedArray(this._bufferViewToData.get(N)),this._bufferViewToData.delete(N)}return L.getOutputData()}createBufferView(Z,c){const L={buffer:0,byteOffset:void 0,byteLength:Z.byteLength,byteStride:c};return this._bufferViewToData.set(L,Z),L}createAccessor(Z,c,L,k,N,R,G){this._verifyBufferView(Z);const V={bufferView:void 0,componentType:L,count:k,type:c,min:null===R||void 0===R?void 0:R.min,max:null===R||void 0===R?void 0:R.max,normalized:G,byteOffset:N};return this.setBufferView(V,Z),this._accessorToBufferView.set(V,Z),V}setBufferView(Z,c){this._verifyBufferView(c);this.getPropertiesWithBufferView(c).push(Z)}removeBufferView(Z){const c=this.getPropertiesWithBufferView(Z);for(const L of c)void 0!==L.bufferView&&delete L.bufferView;this._bufferViewToData.delete(Z),this._bufferViewToProperties.delete(Z),this._accessorToBufferView.forEach(((c,L)=>{c===Z&&(void 0!==L.byteOffset&&delete L.byteOffset,this._accessorToBufferView.delete(L))}))}getBufferView(Z){const c=this._accessorToBufferView.get(Z);return this._verifyBufferView(c),c}getPropertiesWithBufferView(Z){return this._verifyBufferView(Z),this._bufferViewToProperties.set(Z,this._bufferViewToProperties.get(Z)??[]),this._bufferViewToProperties.get(Z)}getData(Z){return this._verifyBufferView(Z),this._bufferViewToData.get(Z)}_verifyBufferView(Z){if(void 0===Z||!this._bufferViewToData.has(Z))throw new Error(`BufferView ${Z} not found in BufferManager.`)}}var iZ,tZ=L(11329),EZ=L(11380),xZ=L(11563),qZ=L(11708),OZ=L(11716),wZ=L(11725),MZ=L(11325),PZ=L(11732);!function(Z){Z[Z.INTANGENT=0]="INTANGENT",Z[Z.OUTTANGENT=1]="OUTTANGENT"}(iZ||(iZ={}));class jZ{static _IsTransformable(Z){return Z&&(Z instanceof i.e||Z instanceof tZ.d||Z instanceof PZ.e)}static _CreateNodeAnimation(Z,c,L,k,R){if(this._IsTransformable(Z)){const G=[],V=[],p=c.getKeys(),J=jZ._CalculateMinMaxKeyFrames(p),z=jZ._DeduceInterpolation(p,L,k),i=z.interpolationType,t=z.shouldBakeAnimation;if(t?jZ._CreateBakedAnimation(Z,c,L,J.min,J.max,c.framePerSecond,R,G,V,J,k):"LINEAR"===i||"STEP"===i?jZ._CreateLinearOrStepAnimation(Z,c,L,G,V,k):"CUBICSPLINE"===i?jZ._CreateCubicSplineAnimation(Z,c,L,G,V,k):jZ._CreateBakedAnimation(Z,c,L,J.min,J.max,c.framePerSecond,R,G,V,J,k),G.length&&V.length){return{inputs:G,outputs:V,samplerInterpolation:i,inputsMin:t?J.min:N.c.FloatRound(J.min/c.framePerSecond),inputsMax:t?J.max:N.c.FloatRound(J.max/c.framePerSecond)}}}return null}static _DeduceAnimationInfo(Z){let c=null,L="VEC3",k=!1;const R=Z.targetProperty.split(".");switch(R[0]){case"Pc":c="scale";break;case"position":c="translation";break;case"rotation":L="VEC4",c="rotation";break;case"rotationQuaternion":L="VEC4",k=!0,c="rotation";break;case"influence":L="SCALAR",c="weights";break;default:N.c.Error(`Unsupported animatable property ${R[0]}`)}return c?{animationChannelTargetPath:c,dataAccessorType:L,useQuaternion:k}:(N.c.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(Z,c,L,k,N,R,G,V,p,J,z){let i;if(jZ._IsTransformable(Z)&&Z.animations)for(const t of Z.animations){if(z&&!z(t))continue;const N=jZ._DeduceAnimationInfo(t);N&&(i={name:t.name,samplers:[],channels:[]},jZ._AddAnimation(`${t.name}`,t.hasRunningRuntimeAnimations?c:i,Z,t,N.dataAccessorType,N.animationChannelTargetPath,k,R,G,V,N.useQuaternion,p,J),i.samplers.length&&i.channels.length&&L.push(i))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(Z,c,L,k,N,R,G,V,p,J,z){let i;if(Z instanceof MZ.c){const N=Z.morphTargetManager;if(N)for(let t=0;t<N.numTargets;++t){const E=N.getTarget(t);for(const x of E.animations){if(z&&!z(x))continue;const E=new OZ.c(`${x.name}`,"influence",x.framePerSecond,x.dataType,x.loopMode,x.enableBlending),q=[],O=x.getKeys();for(let Z=0;Z<O.length;++Z){const c=O[Z];for(let Z=0;Z<N.numTargets;++Z)Z==t?q.push(c):q.push({frame:c.frame,value:0})}E.setKeys(q);const w=jZ._DeduceAnimationInfo(E);w&&(i={name:E.name,samplers:[],channels:[]},jZ._AddAnimation(x.name,x.hasRunningRuntimeAnimations?c:i,Z,E,w.dataAccessorType,w.animationChannelTargetPath,k,R,G,V,w.useQuaternion,p,J,N.numTargets),i.samplers.length&&i.channels.length&&L.push(i))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(Z,c,L,k,N,R,G,V,p){let J;if(Z.animationGroups){const i=Z.animationGroups;for(const t of i){const i=new Map,E=new Map,x=new Set,q=t.to-t.from;J={name:t.name,channels:[],samplers:[]};for(let c=0;c<t.targetedAnimations.length;++c){const q=t.targetedAnimations[c],O=q.target,w=q.animation;if(p&&!p(w))continue;const M=V.has(O);if(this._IsTransformable(O)||1===O.length&&this._IsTransformable(O[0])){const Z=jZ._DeduceAnimationInfo(q.animation);if(Z){const c=this._IsTransformable(O)?O:this._IsTransformable(O[0])?O[0]:null;c&&jZ._AddAnimation(`${w.name}`,J,c,w,Z.dataAccessorType,Z.animationChannelTargetPath,L,k,N,R,Z.useQuaternion,G,M)}}else if(O instanceof wZ.e||1===O.length&&O[0]instanceof wZ.e){if(jZ._DeduceAnimationInfo(q.animation)){const c=O instanceof wZ.e?O:O[0];if(c){const L=Z.morphTargetManagers.find((Z=>{for(let L=0;L<Z.numTargets;++L)if(Z.getTarget(L)===c)return!0;return!1}));if(L){const k=Z.meshes.find((Z=>Z.morphTargetManager===L));var z;if(k)i.has(k)||i.set(k,new Map),null===(z=i.get(k))||void 0===z||z.set(c,w),x.add(k),E.set(k,w)}}}}}x.forEach((Z=>{const c=Z.morphTargetManager;let V=null;const p=[],z=E.get(Z).getKeys(),x=z.length;for(let L=0;L<x;++L)for(let k=0;k<c.numTargets;++k){const N=c.getTarget(k),R=i.get(Z);if(R){const c=R.get(N);c?(V||(V=new OZ.c(`${t.name}_${Z.name}_MorphWeightAnimation`,"influence",c.framePerSecond,OZ.c.ANIMATIONTYPE_FLOAT,c.loopMode,c.enableBlending)),p.push(c.getKeys()[L])):p.push({frame:t.from+q/x*L,value:N.influence,inTangent:z[0].inTangent?0:void 0,outTangent:z[0].outTangent?0:void 0})}}V.setKeys(p);const O=jZ._DeduceAnimationInfo(V);O&&jZ._AddAnimation(`${t.name}_${Z.name}_MorphWeightAnimation`,J,Z,V,O.dataAccessorType,O.animationChannelTargetPath,L,k,N,R,O.useQuaternion,G,!1,null===c||void 0===c?void 0:c.numTargets)})),J.channels.length&&J.samplers.length&&c.push(J)}}}static _AddAnimation(Z,c,L,N,R,G,V,p,J,z,i,t,E,x){const q=jZ._CreateNodeAnimation(L,N,G,i,t);let O,w,M,P,j,o;if(q){if(x){let Z=0,c=0;const L=[];for(;q.inputs.length>0;)c=q.inputs.shift(),Z%x==0&&L.push(c),Z++;q.inputs=L}const Z=V.get(L),N=new Float32Array(q.inputs);O=p.createBufferView(N),w=p.createAccessor(O,"SCALAR",5126,q.inputs.length,void 0,{min:[q.inputsMin],max:[q.inputsMax]}),z.push(w),M=z.length-1;const J=new k.c,i=new k.h,t=new k.h,u=L instanceof tZ.d,X=n(R),h=new Float32Array(q.outputs.length*X);q.outputs.forEach((function(Z,c){let L=Z;switch(G){case"translation":E&&(k.h.FromArrayToRef(Z,0,t),Y(t),t.toArray(L));break;case"rotation":4===Z.length?k.c.FromArrayToRef(Z,0,J):(L=new Array(4),k.h.FromArrayToRef(Z,0,i),k.c.FromEulerVectorToRef(i,J)),E&&(a(J),u&&C(J)),J.toArray(L)}h.set(L,c*X)})),O=p.createBufferView(h),w=p.createAccessor(O,R,5126,q.outputs.length),z.push(w),P=z.length-1,j={interpolation:q.samplerInterpolation,input:M,output:P},c.samplers.push(j),o={sampler:c.samplers.length-1,target:{node:Z,path:G}},c.channels.push(o)}}static _CreateBakedAnimation(Z,c,L,R,G,V,p,J,z,i,t){let E;const x=k.c.Identity();let q,O=null,w=null,M=null,P=null,j=null,o=null;i.min=N.c.FloatRound(R/V);const u=c.getKeys();for(let k=0,X=u.length;k<X;++k){if(o=null,M=u[k],k+1<X)if(P=u[k+1],M.value.equals&&M.value.equals(P.value)||M.value===P.value){if(0!==k)continue;o=M.frame}else o=P.frame;else{if(j=u[k-1],M.value.equals&&M.value.equals(j.value)||M.value===j.value)continue;o=G}if(o)for(let k=M.frame;k<=o;k+=p){if(q=N.c.FloatRound(k/V),q===O)continue;O=q,w=q;const R={key:0,repeatCount:0,loopMode:c.loopMode};E=c._interpolate(k,R),jZ._SetInterpolatedValue(Z,E,q,c,L,x,J,z,t)}}w&&(i.max=w)}static _ConvertFactorToVector3OrQuaternion(Z,c,L,R,G){const V=jZ._GetBasePositionRotationOrScale(c,R,G),p=L.targetProperty.split("."),J=p?p[1]:"",z=G?k.c.oc(V).normalize():k.h.oc(V);switch(J){case"x":case"y":case"z":z[J]=Z;break;case"w":z.w=Z;break;default:N.c.Error(`glTFAnimation: Unsupported component name "${J}"!`)}return z}static _SetInterpolatedValue(Z,c,L,N,R,G,V,p,J){let z;V.push(L),"weights"!==R?(N.dataType===OZ.c.ANIMATIONTYPE_FLOAT&&(c=this._ConvertFactorToVector3OrQuaternion(c,Z,N,R,J)),"rotation"===R?(J?G=c:(z=c,k.c.RotationYawPitchRollToRef(z.y,z.x,z.z,G)),p.push(G.xc())):(z=c,p.push(z.xc()))):p.push([c])}static _CreateLinearOrStepAnimation(Z,c,L,k,N,R){for(const G of c.getKeys())k.push(G.frame/c.framePerSecond),jZ._AddKeyframeValue(G,c,N,L,Z,R)}static _CreateCubicSplineAnimation(Z,c,L,k,N,R){c.getKeys().forEach((function(G){k.push(G.frame/c.framePerSecond),jZ._AddSplineTangent(iZ.INTANGENT,N,L,"CUBICSPLINE",G,R),jZ._AddKeyframeValue(G,c,N,L,Z,R),jZ._AddSplineTangent(iZ.OUTTANGENT,N,L,"CUBICSPLINE",G,R)}))}static _GetBasePositionRotationOrScale(Z,c,L){let N;if("rotation"===c)if(L){N=(Z.rotationQuaternion??k.c.Identity()).xc()}else{N=(Z.rotation??k.h.Zero()).xc()}else if("translation"===c){N=(Z.position??k.h.Zero()).xc()}else{N=(Z.Pc??k.h.One()).xc()}return N}static _AddKeyframeValue(Z,c,L,R,G,V){let p;const J=c.dataType;if(J===OZ.c.ANIMATIONTYPE_VECTOR3){let c=Z.value.xc();if("rotation"===R){const Z=k.h.oc(c);c=k.c.RotationYawPitchRoll(Z.y,Z.x,Z.z).xc()}L.push(c)}else if(J===OZ.c.ANIMATIONTYPE_FLOAT){if("weights"===R)L.push([Z.value]);else if(p=this._ConvertFactorToVector3OrQuaternion(Z.value,G,c,R,V),p){if("rotation"===R){const Z=V?p:k.c.RotationYawPitchRoll(p.y,p.x,p.z).normalize();L.push(Z.xc())}L.push(p.xc())}}else J===OZ.c.ANIMATIONTYPE_QUATERNION?L.push(Z.value.normalize().xc()):N.c.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(Z,c,L){let k,N,R=!1;if("rotation"===c&&!L)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let G=0,V=Z.length;G<V;++G)if(N=Z[G],N.inTangent||N.outTangent)if(k){if("CUBICSPLINE"!==k){k="LINEAR",R=!0;break}}else k="CUBICSPLINE";else if(k){if("CUBICSPLINE"===k||N.interpolation&&1===N.interpolation&&"STEP"!==k){k="LINEAR",R=!0;break}}else k=N.interpolation&&1===N.interpolation?"STEP":"LINEAR";return k||(k="LINEAR"),{interpolationType:k,shouldBakeAnimation:R}}static _AddSplineTangent(Z,c,L,N,R,G){let V;const p=Z===iZ.INTANGENT?R.inTangent:R.outTangent;if("CUBICSPLINE"===N){if("rotation"===L)if(p)if(G)V=p.xc();else{const Z=p;V=k.c.RotationYawPitchRoll(Z.y,Z.x,Z.z).xc()}else V=[0,0,0,0];else V="weights"===L?p?[p]:[0]:p?p.xc():[0,0,0];c.push(V)}}static _CalculateMinMaxKeyFrames(Z){let c=1/0,L=-1/0;return Z.forEach((function(Z){c=Math.min(c,Z.frame),L=Math.max(L,Z.frame)})),{min:c,max:L}}}function oZ(Z,c,L,R,G,V){const p={attributes:{},influence:Z.influence,name:Z.name},J=c.zc;if(!J)return N.c.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),p;const i=V?-1:1,t=k.h.Zero();let E=0,x=0;if(Z.hasPositions){const R=Z.getPositions(),V=J.getVerticesData(z.g.PositionKind);if(V){const Z=new Float32Array(V.length),c=[1/0,1/0,1/0],N=[-1/0,-1/0,-1/0];x=V.length/3,E=0;for(let L=E;L<x;++L){const G=k.h.oc(V,3*L);k.h.oc(R,3*L).subtractToRef(G,t),t.x*=i,c[0]=Math.min(c[0],t.x),N[0]=Math.max(N[0],t.x),c[1]=Math.min(c[1],t.y),N[1]=Math.max(N[1],t.y),c[2]=Math.min(c[2],t.z),N[2]=Math.max(N[2],t.z),Z[3*L]=t.x,Z[3*L+1]=t.y,Z[3*L+2]=t.z}const J=L.createBufferView(Z,12),z=L.createAccessor(J,"VEC3",5126,R.length/3,0,{min:c,max:N});G.push(z),p.attributes.POSITION=G.length-1}else N.c.Warn(`Morph target positions for mesh ${c.name} were not exported. Mesh does not have position vertex data`)}if(Z.hasNormals){const R=Z.getNormals(),V=J.getVerticesData(z.g.NormalKind);if(V){const Z=new Float32Array(V.length);x=V.length/3,E=0;for(let L=E;L<x;++L){const c=k.h.oc(V,3*L).normalize();k.h.oc(R,3*L).normalize().subtractToRef(c,t),Z[3*L]=t.x*i,Z[3*L+1]=t.y,Z[3*L+2]=t.z}const c=L.createBufferView(Z,12),N=L.createAccessor(c,"VEC3",5126,R.length/3,0);G.push(N),p.attributes.NORMAL=G.length-1}else N.c.Warn(`Morph target normals for mesh ${c.name} were not exported. Mesh does not have normals vertex data`)}if(Z.hasTangents){const R=Z.getTangents(),V=J.getVerticesData(z.g.TangentKind);if(V){x=V.length/4;const Z=new Float32Array(3*x);E=0;for(let L=E;L<x;++L){const c=k.h.oc(V,4*L);v(c);const N=k.h.oc(R,3*L);v(N),N.subtractToRef(c,t),Z[3*L]=t.x*i,Z[3*L+1]=t.y,Z[3*L+2]=t.z}const c=L.createBufferView(Z,12),N=L.createAccessor(c,"VEC3",5126,x,0);G.push(N),p.attributes.TANGENT=G.length-1}else N.c.Warn(`Morph target tangents for mesh ${c.name} were not exported. Mesh does not have tangents vertex data`)}if(Z.hasColors){const R=Z.getColors(),V=J.getVerticesData(z.g.ColorKind),i=J.getVertexBuffer(z.g.ColorKind);if(V&&i){const Z=i.getSize();x=V.length/Z;const c=new Float32Array(x*Z);E=0;for(let L=E;L<x;++L)if(3===Z){const N=k.h.oc(V,L*Z);k.h.oc(R,L*Z).subtractToRef(N,t),c[3*L]=t.x,c[3*L+1]=t.y,c[3*L+2]=t.z}else if(4===Z){const N=new k.j,G=k.j.oc(V,L*Z);k.j.oc(R,L*Z).subtractToRef(G,N),c[4*L]=N.x,c[4*L+1]=N.y,c[4*L+2]=N.z,c[4*L+3]=N.w}else N.c.Warn(`Unsupported number of components for color attribute: ${Z}`);const J=L.createBufferView(c,4*Z),z=L.createAccessor(J,3===Z?"VEC3":"VEC4",5126,x,0);G.push(z),p.attributes.COLOR_0=G.length-1}else N.c.Warn(`Morph target colors for mesh ${c.name} were not exported. Mesh does not have colors vertex data`)}return p}var uZ=L(11736),XZ=L(11652),hZ=L(11650),BZ=L(11012);class DZ{}DZ.DEFAULT_COLOR=O.d.White(),DZ.DEFAULT_WIDTH_ATTENUATED=1,DZ.DEFAULT_WIDTH=.1;var eZ=L(11471),HZ=L(11748);class lZ{static ConvertPoints(Z,c){if(Z.length&&Array.isArray(Z)&&"number"===typeof Z[0])return[Z];if(Z.length&&Array.isArray(Z[0])&&"number"===typeof Z[0][0])return Z;if(Z.length&&!Array.isArray(Z[0])&&Z[0]instanceof k.h){const c=[];for(let L=0;L<Z.length;L++){const k=Z[L];c.push(k.x,k.y,k.z)}return[c]}if(Z.length>0&&Array.isArray(Z[0])&&Z[0].length>0&&Z[0][0]instanceof k.h){const c=[],L=Z;for(const Z of L)c.push(Z.flatMap((Z=>[Z.x,Z.y,Z.z])));return c}if(Z instanceof Float32Array){if(null!==c&&void 0!==c&&c.floatArrayStride){const L=[],k=3*c.floatArrayStride;for(let c=0;c<Z.length;c+=k){const N=new Array(k);for(let L=0;L<k;L++)N[L]=Z[c+L];L.push(N)}return L}return[Array.from(Z)]}if(Z.length&&Z[0]instanceof Float32Array){const c=[];for(const L of Z)c.push(Array.from(L));return c}return[]}static OmitZeroLengthPredicate(Z,c,L){const k=[];return c.yL(Z).lengthSquared()>0&&k.push([Z,c]),L.yL(c).lengthSquared()>0&&k.push([c,L]),Z.yL(L).lengthSquared()>0&&k.push([L,Z]),0===k.length?null:k}static OmitDuplicatesPredicate(Z,c,L,k){const N=[];return lZ._SearchInPoints(Z,c,k)||N.push([Z,c]),lZ._SearchInPoints(c,L,k)||N.push([c,L]),lZ._SearchInPoints(L,Z,k)||N.push([L,Z]),0===N.length?null:N}static _SearchInPoints(Z,c,L){for(const G of L)for(let L=0;L<G.length;L++){var k,N,R;if(null!==(k=G[L])&&void 0!==k&&k.equals(Z))if(null!==(N=G[L+1])&&void 0!==N&&N.equals(c)||null!==(R=G[L-1])&&void 0!==R&&R.equals(c))return!0}return!1}static MeshesToLines(Z,c){const L=[];for(let N=0;N<Z.length;N++){const R=Z[N],G=R.getVerticesData(z.g.PositionKind),V=R.tc();if(G&&V)for(let Z=0,p=0;Z<V.length;Z++){const J=3*V[p++],z=3*V[p++],i=3*V[p++],t=new k.h(G[J],G[J+1],G[J+2]),E=new k.h(G[z],G[z+1],G[z+2]),x=new k.h(G[i],G[i+1],G[i+2]);if(c){const k=c(t,E,x,L,Z,J,R,N,G,V);if(k)for(const Z of k)L.push(Z)}else L.push([t,E],[E,x],[x,t])}}return L}static ToVector3Array(Z){if(Array.isArray(Z[0])){const c=[],L=Z;for(const Z of L){const L=[];for(let c=0;c<Z.length;c+=3)L.push(new k.h(Z[c],Z[c+1],Z[c+2]));c.push(L)}return c}const c=Z,L=[];for(let N=0;N<c.length;N+=3)L.push(new k.h(c[N],c[N+1],c[N+2]));return L}static ToNumberArray(Z){return Z.flatMap((Z=>[Z.x,Z.y,Z.z]))}static GetPointsCountInfo(Z){const c=new Array(Z.length);let L=0;for(let k=Z.length;k--;)c[k]=Z[k].length/3,L+=c[k];return{total:L,counts:c}}static GetLineLength(Z){if(0===Z.length)return 0;let c;c="number"===typeof Z[0]?lZ.ToVector3Array(Z):Z;const L=k.d.Mc[0];let N=0;for(let k=0;k<c.length-1;k++){const Z=c[k];N+=c[k+1].subtractToRef(Z,L).length()}return N}static GetLineLengthArray(Z){const c=new Float32Array(Z.length/3);let L=0;for(let k=0,N=Z.length/3-1;k<N;k++){let N=Z[3*k+0],R=Z[3*k+1],G=Z[3*k+2];N-=Z[3*k+3],R-=Z[3*k+4],G-=Z[3*k+5];L+=Math.sqrt(N*N+R*R+G*G),c[k+1]=L}return c}static SegmentizeSegmentByCount(Z,c,L){const N=[],R=c.yL(Z),G=k.d.Mc[0];G.uc(L);const V=k.d.Mc[1];R.divideToRef(G,V);let p=Z.clone();N.push(p);for(let k=0;k<L;k++)p=p.clone(),N.push(p.addInPlace(V));return N}static SegmentizeLineBySegmentLength(Z,c){const L=Z[0]instanceof k.h?lZ.GetLineSegments(Z):"number"===typeof Z[0]?lZ.GetLineSegments(lZ.ToVector3Array(Z)):Z,N=[];for(const k of L)if(k.length>c){const Z=lZ.SegmentizeSegmentByCount(k.point1,k.point2,Math.ceil(k.length/c));for(const c of Z)N.push(c)}else N.push(k.point1),N.push(k.point2);return N}static SegmentizeLineBySegmentCount(Z,c){const L="number"===typeof Z[0]?lZ.ToVector3Array(Z):Z,k=lZ.GetLineLength(L)/c;return lZ.SegmentizeLineBySegmentLength(L,k)}static GetLineSegments(Z){const c=[];for(let L=0;L<Z.length-1;L++){const k=Z[L],N=Z[L+1],R=N.yL(k).length();c.push({point1:k,point2:N,length:R})}return c}static GetMinMaxSegmentLength(Z){const c=lZ.GetLineSegments(Z).sort((Z=>Z.length));return{min:c[0].length,max:c[c.length-1].length}}static GetPositionOnLineByVisibility(Z,c,L){let N=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const R=c*L;let G=0,V=0;const p=Z.length;for(let k=0;k<p;k++){if(R<=G+Z[k].length){V=k;break}G+=Z[k].length}const J=(R-G)/Z[V].length;return Z[V].point2.subtractToRef(Z[V].point1,k.d.Mc[0]),k.d.Mc[1]=k.d.Mc[0].multiplyByFloats(J,J,J),N||k.d.Mc[1].addInPlace(Z[V].point1),k.d.Mc[1].clone()}static GetCircleLinePoints(Z,c){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Z,R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/c;const G=[];for(let V=0;V<=c;V++)G.push(new k.h(Math.cos(V*R)*Z,Math.sin(V*R)*N,L));return G}static GetBezierLinePoints(Z,c,L,k){return eZ.h.CreateQuadraticBezier(Z,c,L,k).getPoints().flatMap((Z=>[Z.x,Z.y,Z.z]))}static GetArrowCap(Z,c,L,k,N){let R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,G=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[Z.clone(),Z.add(c.multiplyByFloats(L,L,L))],widths:[k,N,R,G]}}static GetPointsFromText(Z,c,L,k){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,R=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const G=[],V=(0,HZ.d)(Z,c,L,k);for(const p of V){for(const Z of p.paths){const c=[],L=Z.getPoints();for(const Z of L)c.push(Z.x,Z.y,N);G.push(c)}if(R)for(const Z of p.holes){const c=[],L=Z.getPoints();for(const Z of L)c.push(Z.x,Z.y,N);G.push(c)}}return G}static Color3toRGBAUint8(Z){const c=new Uint8Array(4*Z.length);for(let L=0,k=0;L<Z.length;L++)c[k++]=255*Z[L].r,c[k++]=255*Z[L].g,c[k++]=255*Z[L].b,c[k++]=255;return c}static CreateColorsTexture(Z,c,L,k){const N=k.getEngine().getCaps().maxTextureSize??1,R=c.length>N?N:c.length,G=Math.ceil(c.length/N);G>1&&(c=[...c,...Array(R*G-c.length).fill(c[0])]);const V=lZ.Color3toRGBAUint8(c),p=new u.e(V,R,G,x.c.TEXTUREFORMAT_RGBA,k,!1,!0,L);return p.name=Z,p}static PrepareEmptyColorsTexture(Z){if(!DZ.EmptyColorsTexture){const c=new Uint8Array(4);DZ.EmptyColorsTexture=new u.e(c,1,1,x.c.TEXTUREFORMAT_RGBA,Z,!1,!1,u.e.NEAREST_NEAREST),DZ.EmptyColorsTexture.name="grlEmptyColorsTexture"}return DZ.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var Z;null===(Z=DZ.EmptyColorsTexture)||void 0===Z||Z.dispose(),DZ.EmptyColorsTexture=null}static BooleanToNumber(Z){return Z?1:0}}class WZ extends hZ.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class TZ extends XZ.c{isCompatible(Z){return!0}constructor(Z,c,L){var N;L=L||{color:DZ.DEFAULT_COLOR};const R=new WZ;R.GREASED_LINE_HAS_COLOR=!!L.color&&!L.useColors,R.GREASED_LINE_SIZE_ATTENUATION=L.sizeAttenuation??!1,R.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===L.colorDistributionType,R.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(c??Z.XZ()).useRightHandedSystem,R.GREASED_LINE_CAMERA_FACING=L.cameraFacing??!0,super(Z,TZ.GREASED_LINE_MATERIAL_NAME,200,R,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(N=L)||void 0===N?void 0:N.forceGLSL)||TZ.ForceGLSL,this._scene=c??Z.XZ(),this._engine=this._scene.getEngine(),this._cameraFacing=L.cameraFacing??!0,this.visibility=L.visibility??1,this.useDash=L.useDash??!1,this.dashRatio=L.dashRatio??.5,this.dashOffset=L.dashOffset??0,this.width=L.width?L.width:L.sizeAttenuation?DZ.DEFAULT_WIDTH_ATTENUATED:DZ.DEFAULT_WIDTH,this._sizeAttenuation=L.sizeAttenuation??!1,this.colorMode=L.colorMode??0,this._color=L.color??null,this.useColors=L.useColors??!1,this._colorsDistributionType=L.colorDistributionType??0,this.colorsSampling=L.colorsSampling??u.e.NEAREST_NEAREST,this._colors=L.eZ??null,this.dashCount=L.dashCount??1,this.resolution=L.resolution??new k.f(this._engine.getRenderWidth(),this._engine.getRenderHeight()),L.colorsTexture?this.colorsTexture=L.colorsTexture:this._colors?this.colorsTexture=lZ.CreateColorsTexture(`${Z.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??DZ.DEFAULT_COLOR,lZ.PrepareEmptyColorsTexture(this._scene)),this._engine.Xc.add((()=>{lZ.DisposeEmptyColorsTexture()}))}getAttributes(Z){Z.push("grl_offsets"),Z.push("grl_widths"),Z.push("grl_colorPointers"),Z.push("grl_counters"),this._cameraFacing?(Z.push("grl_previousAndSide"),Z.push("grl_nextAndCounters")):Z.push("grl_slopes")}getSamplers(Z){Z.push("grl_colors")}getActiveTextures(Z){this.colorsTexture&&Z.push(this.colorsTexture)}getUniforms(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const c=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&c.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===Z&&c.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:c,vertex:this._cameraFacing&&this._isGLSL(Z)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(Z)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(Z){if(this._cameraFacing){Z.hc("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||Z.hc("viewProjection",this._scene.getTransformMatrix());const c=k.d.Vector4[0];c.x=this._aspect,c.y=this._resolution.x,c.z=this._resolution.y,c.w=this.width,Z.updateVector4("grl_aspect_resolution_lineWidth",c)}const c=k.d.Vector4[0];c.x=lZ.BooleanToNumber(this.useDash),c.y=this._dashArray,c.z=this.dashOffset,c.w=this.dashRatio,Z.updateVector4("grl_dashOptions",c);const L=k.d.Vector4[1];L.x=this.colorMode,L.y=this.visibility,L.z=this.colorsTexture?this.colorsTexture.getSize().width:0,L.w=lZ.BooleanToNumber(this.useColors),Z.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",L),this._color&&Z.updateColor3("grl_singleColor",this._color);const N=this.colorsTexture??DZ.EmptyColorsTexture;Z.setTexture("grl_colors",N),Z.updateFloat2("grl_textureSize",(null===N||void 0===N?void 0:N.getSize().width)??1,(null===N||void 0===N?void 0:N.getSize().height)??1)}prepareDefines(Z,c,L){Z.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,Z.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,Z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,Z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=c.useRightHandedSystem,Z.GREASED_LINE_CAMERA_FACING=this._cameraFacing,Z.GREASED_LINE_USE_OFFSETS=!!L.offsets}getClassName(){return TZ.GREASED_LINE_MATERIAL_NAME}getCustomCode(Z){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(c)?function(Z,c){if("vertex"===Z){const Z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return c&&(Z["!gl_Position\\=viewProjection\\*worldPos;"]="//"),Z}return"fragment"===Z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(Z,this._cameraFacing):function(Z,c){if("vertex"===Z){const Z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return c&&(Z["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),Z}return"fragment"===Z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(Z,this._cameraFacing)}dispose(){var Z;null===(Z=this.colorsTexture)||void 0===Z||Z.dispose(),super.dispose()}get eZ(){return this._colors}set eZ(Z){this.setColors(Z)}setColors(Z){var c;let L=arguments.length>1&&void 0!==arguments[1]&&arguments[1],k=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const N=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var R;if(this._colors=Z,null!==Z&&0!==Z.length){if(!L||k)if(this.colorsTexture&&N===Z.length&&!k){const c=lZ.Color3toRGBAUint8(Z);this.colorsTexture.update(c)}else{var G;null===(G=this.colorsTexture)||void 0===G||G.dispose(),this.colorsTexture=lZ.CreateColorsTexture(`${this._material.name}-colors-texture`,Z,this.colorsSampling,this._scene)}}else null===(R=this.colorsTexture)||void 0===R||R.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(Z){this._dashCount=Z,this._dashArray=1/Z}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Z){this._sizeAttenuation=Z,this.markAllDefinesAsDirty()}get color(){return this._color}set color(Z){this.setColor(Z)}setColor(Z){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==Z||null!==this._color&&null===Z?(this._color=Z,c||this.markAllDefinesAsDirty()):this._color=Z}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Z){this._colorsDistributionType=Z,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(Z){this._aspect=Z.x/Z.y,this._resolution=Z}serialize(){const Z=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(c.eZ=this._colors),this._color&&(c.color=this._color),Z.greasedLineMaterialOptions=c,Z}parse(Z,c,L){var k;super.parse(Z,c,L);const N=Z.greasedLineMaterialOptions;null===(k=this.colorsTexture)||void 0===k||k.dispose(),N.color&&this.setColor(N.color,!0),N.colorDistributionType&&(this.colorsDistributionType=N.colorDistributionType),N.eZ&&(this.eZ=N.eZ),N.colorsSampling&&(this.colorsSampling=N.colorsSampling),N.colorMode&&(this.colorMode=N.colorMode),N.useColors&&(this.useColors=N.useColors),N.visibility&&(this.visibility=N.visibility),N.useDash&&(this.useDash=N.useDash),N.dashCount&&(this.dashCount=N.dashCount),N.dashRatio&&(this.dashRatio=N.dashRatio),N.dashOffset&&(this.dashOffset=N.dashOffset),N.width&&(this.width=N.width),N.sizeAttenuation&&(this.sizeAttenuation=N.sizeAttenuation),N.resolution&&(this.resolution=N.resolution),this.eZ?this.colorsTexture=lZ.CreateColorsTexture(`${this._material.name}-colors-texture`,this.eZ,this.colorsSampling,c):lZ.PrepareEmptyColorsTexture(c),this.markAllDefinesAsDirty()}copyTo(Z){var c;const L=Z;null===(c=L.colorsTexture)||void 0===c||c.dispose(),this._colors&&(L.colorsTexture=lZ.CreateColorsTexture(`${L._material.name}-colors-texture`,this._colors,L.colorsSampling,this._scene)),L.setColor(this.color,!0),L.colorsDistributionType=this.colorsDistributionType,L.colorsSampling=this.colorsSampling,L.colorMode=this.colorMode,L.useColors=this.useColors,L.visibility=this.visibility,L.useDash=this.useDash,L.dashCount=this.dashCount,L.dashRatio=this.dashRatio,L.dashOffset=this.dashOffset,L.width=this.width,L.sizeAttenuation=this.sizeAttenuation,L.resolution=this.resolution,L.markAllDefinesAsDirty()}_isGLSL(Z){return 0===Z||this._forceGLSL}}TZ.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",TZ.ForceGLSL=!1,(0,BZ.g)(`BABYLON.${TZ.GREASED_LINE_MATERIAL_NAME}`,TZ);var IZ=L(11289),dZ=L(11058),QZ=L(11741),rZ=L(11142);class fZ extends QZ.b{constructor(Z,c,N){const R=c.getEngine(),G=R.isWebGPU&&!(N.forceGLSL||fZ.ForceGLSL),V=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];c.useRightHandedSystem&&V.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const p=["position","grl_widths","grl_offsets","grl_colorPointers"];N.cameraFacing?(V.push("GREASED_LINE_CAMERA_FACING"),p.push("grl_previousAndSide","grl_nextAndCounters")):(p.push("grl_slopes"),p.push("grl_counters"));const J=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(G||J.push("world","viewProjection","view","projection"),super(Z,c,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:G?["Scene","Mesh"]:void 0,attributes:p,uniforms:J,samplers:G?[]:["grlColors"],defines:V,extraInitializationsAsync:async()=>{G?await Promise.all([L.e(47).then(L.bind(L,14276)),L.e(55).then(L.bind(L,14285))]):await Promise.all([L.e(50).then(L.bind(L,14287)),L.e(56).then(L.bind(L,14289))])},shaderLanguage:G?1:0}),this._color=O.d.White(),this._colorsDistributionType=0,this._colorsTexture=null,N=N||{color:DZ.DEFAULT_COLOR},this.visibility=N.visibility??1,this.useDash=N.useDash??!1,this.dashRatio=N.dashRatio??.5,this.dashOffset=N.dashOffset??0,this.dashCount=N.dashCount??1,this.width=N.width?N.width:N.sizeAttenuation&&N.cameraFacing?DZ.DEFAULT_WIDTH_ATTENUATED:DZ.DEFAULT_WIDTH,this.sizeAttenuation=N.sizeAttenuation??!1,this.color=N.color??O.d.White(),this.useColors=N.useColors??!1,this.colorsDistributionType=N.colorDistributionType??0,this.colorsSampling=N.colorsSampling??u.e.NEAREST_NEAREST,this.colorMode=N.colorMode??0,this._colors=N.eZ??null,this._cameraFacing=N.cameraFacing??!0,this.resolution=N.resolution??new k.f(R.getRenderWidth(),R.getRenderHeight()),N.colorsTexture?this.colorsTexture=N.colorsTexture:this._colors?this.colorsTexture=lZ.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,c):(this._color=this._color??DZ.DEFAULT_COLOR,this.colorsTexture=lZ.PrepareEmptyColorsTexture(c)),G){const Z=new rZ.d;Z.setParameters(),Z.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",Z)}R.Xc.add((()=>{lZ.DisposeEmptyColorsTexture()}))}dispose(){var Z;null===(Z=this._colorsTexture)||void 0===Z||Z.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new k.f(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get eZ(){return this._colors}set eZ(Z){this.setColors(Z)}setColors(Z){var c;let L=arguments.length>1&&void 0!==arguments[1]&&arguments[1],k=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const N=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var R;if(this._colors=Z,null!==Z&&0!==Z.length){if(!L||k)if(this._colorsTexture&&N===Z.length&&!k){const c=lZ.Color3toRGBAUint8(Z);this._colorsTexture.update(c)}else{var G;null===(G=this._colorsTexture)||void 0===G||G.dispose(),this.colorsTexture=lZ.CreateColorsTexture(`${this.name}-colors-texture`,Z,this.colorsSampling,this.XZ())}}else null===(R=this._colorsTexture)||void 0===R||R.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(Z){this._colorsTexture=Z,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(Z){this._width=Z,this.setFloat("grlWidth",Z)}get useColors(){return this._useColors}set useColors(Z){this._useColors=Z,this.setFloat("grlUseColors",lZ.BooleanToNumber(Z))}get colorsSampling(){return this._colorsSampling}set colorsSampling(Z){this._colorsSampling=Z}get visibility(){return this._visibility}set visibility(Z){this._visibility=Z,this.setFloat("grlVisibility",Z)}get useDash(){return this._useDash}set useDash(Z){this._useDash=Z,this.setFloat("grlUseDash",lZ.BooleanToNumber(Z))}get dashOffset(){return this._dashOffset}set dashOffset(Z){this._dashOffset=Z,this.setFloat("grlDashOffset",Z)}get dashRatio(){return this._dashRatio}set dashRatio(Z){this._dashRatio=Z,this.setFloat("grlDashRatio",Z)}get dashCount(){return this._dashCount}set dashCount(Z){this._dashCount=Z,this._dashArray=1/Z,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Z){this._sizeAttenuation=Z,this.setFloat("grlSizeAttenuation",lZ.BooleanToNumber(Z))}get color(){return this._color}set color(Z){this.setColor(Z)}setColor(Z){Z=Z??DZ.DEFAULT_COLOR,this._color=Z,this.setColor3("grlColor",Z)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Z){this._colorsDistributionType=Z,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(Z){this._colorMode=Z,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(Z){this._resolution=Z,this.setVector2("grlResolution",Z),this.setFloat("grlAspect",Z.x/Z.y)}serialize(){const Z=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(c.eZ=this._colors),Z.greasedLineMaterialOptions=c,Z}parse(Z,c,L){var k;const N=Z.greasedLineMaterialOptions;null===(k=this._colorsTexture)||void 0===k||k.dispose(),N.color&&(this.color=N.color),N.colorDistributionType&&(this.colorsDistributionType=N.colorDistributionType),N.colorsSampling&&(this.colorsSampling=N.colorsSampling),N.colorMode&&(this.colorMode=N.colorMode),N.useColors&&(this.useColors=N.useColors),N.visibility&&(this.visibility=N.visibility),N.useDash&&(this.useDash=N.useDash),N.dashCount&&(this.dashCount=N.dashCount),N.dashRatio&&(this.dashRatio=N.dashRatio),N.dashOffset&&(this.dashOffset=N.dashOffset),N.width&&(this.width=N.width),N.sizeAttenuation&&(this.sizeAttenuation=N.sizeAttenuation),N.resolution&&(this.resolution=N.resolution),N.eZ?this.colorsTexture=lZ.CreateColorsTexture(`${this.name}-colors-texture`,N.eZ,this.colorsSampling,this.XZ()):this.colorsTexture=lZ.PrepareEmptyColorsTexture(c),this._cameraFacing=N.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var SZ,sZ,mZ;fZ.ForceGLSL=!1,function(Z){Z[Z.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",Z[Z.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(SZ||(SZ={})),function(Z){Z[Z.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",Z[Z.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",Z[Z.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(sZ||(sZ={})),function(Z){Z[Z.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",Z[Z.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",Z[Z.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",Z[Z.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",Z[Z.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(mZ||(mZ={}));class AZ extends MZ.c{constructor(Z,c,L){super(Z,c,null,null,!1,!1),this.name=Z,this._options=L,this._lazy=!1,this._updatable=!1,this._engine=c.getEngine(),this._lazy=L.lazy??!1,this._updatable=L.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=L.colorPointers??[],this._widths=L.widths??new Array(L.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(Z){let c=0;for(const k of this._points)c+=k.length;const L=c/3*2-this._widths.length;for(let k=0;k<L;k++)this._widths.push(Z)}updateLazy(){var Z,c;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(Z=this._options.ribbonOptions)||void 0===Z?void 0:Z.smoothShading),!this.TZ&&this.refreshBoundingInfo(),null===(c=this.greasedLineMaterial)||void 0===c||c.updateLazy()}addPoints(Z,c){for(const L of Z)this._points.push(L);this._lazy||this.setPoints(this._points,c)}dispose(Z){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(Z,c)}isLazy(){return this._lazy}get HZ(){return this._uvs}set HZ(Z){this._uvs=Z instanceof Float32Array?Z:new Float32Array(Z),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(Z){this.material instanceof fZ&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===Z||void 0===Z?void 0:Z.length)>0),this._offsets=Z,this._offsetsBuffer?this._offsetsBuffer.update(Z):this._createOffsetsBuffer(Z)}get widths(){return this._widths}set widths(Z){this._widths=Z,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(Z)}get colorPointers(){return this._colorPointers}set colorPointers(Z){this._colorPointers=Z,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(Z)}get greasedLineMaterial(){var Z,c;if(this.material&&this.material instanceof fZ)return this.material;const L=null===(Z=this.material)||void 0===Z||null===(c=Z.pluginManager)||void 0===c?void 0:c.getPlugin(TZ.GREASED_LINE_MATERIAL_NAME);return L||void 0}get points(){const Z=[];return dZ.d.DeepCopy(this._points,Z),Z}setPoints(Z,c){this._points=lZ.ConvertPoints(Z,(null===c||void 0===c?void 0:c.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==c&&void 0!==c&&c.colorPointers||this._updateColorPointers(),this._setPoints(this._points,c)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,HZ:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(Z){super.serialize(Z),Z.type=this.getClassName(),Z.lineOptions=this._createLineOptions()}_createVertexBuffers(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new IZ.e;return c.BZ=this._vertexPositions,c.indices=this._indices,c.HZ=this._uvs,Z&&(c.DZ=[],IZ.e.ComputeNormals(this._vertexPositions,this._indices,c.DZ)),c.WZ(this,this._options.updatable),c}_createOffsetsBuffer(Z){const c=this._scene.getEngine(),L=new z.e(c,Z,this._updatable,3);this.setVerticesBuffer(L.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=L}}class bZ{constructor(Z,c){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=Z,this.wasAddedByNoopNode=c}getIndicesAccessor(Z,c,L,k,N){var R,G,V,p;return null===(R=this._indicesAccessorMap.get(Z))||void 0===R||null===(G=R.get(c))||void 0===G||null===(V=G.get(L))||void 0===V||null===(p=V.get(k))||void 0===p?void 0:p.get(N)}setIndicesAccessor(Z,c,L,k,N,R){let G=this._indicesAccessorMap.get(Z);G||(G=new Map,this._indicesAccessorMap.set(Z,G));let V=G.get(c);V||(V=new Map,G.set(c,V));let p=V.get(L);p||(p=new Map,V.set(L,p));let J=p.get(k);J||(J=new Map,p.set(k,J)),J.set(N,R)}pushExportedNode(Z){this._exportedNodes.has(Z)||this._exportedNodes.add(Z)}getNodesSet(){return this._exportedNodes}getVertexBufferView(Z){return this._vertexBufferViewMap.get(Z)}setVertexBufferView(Z,c){this._vertexBufferViewMap.set(Z,c)}setRemappedBufferView(Z,c,L){this._remappedBufferView.set(Z,new Map),this._remappedBufferView.get(Z).set(c,L)}getRemappedBufferView(Z,c){var L;return null===(L=this._remappedBufferView.get(Z))||void 0===L?void 0:L.get(c)}getVertexAccessor(Z,c,L){var k,N;return null===(k=this._vertexAccessorMap.get(Z))||void 0===k||null===(N=k.get(c))||void 0===N?void 0:N.get(L)}setVertexAccessor(Z,c,L,k){let N=this._vertexAccessorMap.get(Z);N||(N=new Map,this._vertexAccessorMap.set(Z,N));let R=N.get(c);R||(R=new Map,N.set(c,R)),R.set(L,k)}hasVertexColorAlpha(Z){return this._vertexMapColorAlpha.get(Z)||!1}setHasVertexColorAlpha(Z,c){return this._vertexMapColorAlpha.set(Z,c)}getMesh(Z){return this._meshMap.get(Z)}setMesh(Z,c){this._meshMap.set(Z,c)}bindMorphDataToMesh(Z,c){const L=this._meshMorphTargetMap.get(Z)||[];this._meshMorphTargetMap.set(Z,L),-1===L.indexOf(c)&&L.push(c)}getMorphTargetsFromMesh(Z){return this._meshMorphTargetMap.get(Z)}}class FZ{_ApplyExtension(Z,c,L,k){if(L>=c.length)return Promise.resolve(Z);const N=k(c[L],Z);return N?N.then((async Z=>Z?await this._ApplyExtension(Z,c,L+1,k):null)):this._ApplyExtension(Z,c,L+1,k)}_ApplyExtensions(Z,c){const L=[];for(const k of FZ._ExtensionNames)L.push(this._extensions[k]);return this._ApplyExtension(Z,L,0,c)}_extensionsPreExportTextureAsync(Z,c,L){return this._ApplyExtensions(c,((c,k)=>c.preExportTextureAsync&&c.preExportTextureAsync(Z,k,L)))}_extensionsPostExportNodeAsync(Z,c,L,k,N){return this._ApplyExtensions(c,((c,R)=>c.postExportNodeAsync&&c.postExportNodeAsync(Z,R,L,k,N,this._bufferManager)))}_extensionsPostExportMaterialAsync(Z,c,L){return this._ApplyExtensions(c,((c,k)=>c.postExportMaterialAsync&&c.postExportMaterialAsync(Z,k,L)))}_extensionsPostExportMaterialAdditionalTextures(Z,c,L){const k=[];for(const N of FZ._ExtensionNames){const R=this._extensions[N];R.postExportMaterialAdditionalTextures&&k.push(...R.postExportMaterialAdditionalTextures(Z,c,L))}return k}_extensionsPostExportTextures(Z,c,L){for(const k of FZ._ExtensionNames){const N=this._extensions[k];N.postExportTexture&&N.postExportTexture(Z,c,L)}}_extensionsPostExportMeshPrimitive(Z){for(const c of FZ._ExtensionNames){const L=this._extensions[c];L.postExportMeshPrimitive&&L.postExportMeshPrimitive(Z,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const Z of FZ._ExtensionNames){const c=this._extensions[Z];c.preGenerateBinaryAsync&&await c.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(Z){for(const c of FZ._ExtensionNames){const L=this._extensions[c];L.enabled&&Z(L)}}_extensionsOnExporting(){this._forEachExtensions((Z=>{var c,L,k;Z.wasUsed&&((c=this._glTF).extensionsUsed||(c.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(Z.name)&&this._glTF.extensionsUsed.push(Z.name),Z.required&&((L=this._glTF).extensionsRequired||(L.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(Z.name)&&this._glTF.extensionsRequired.push(Z.name)),(k=this._glTF).extensions||(k.extensions={}),Z.onExporting&&Z.onExporting())}))}_loadExtensions(){for(const Z of FZ._ExtensionNames){const c=FZ._ExtensionFactories[Z](this);this._extensions[Z]=c}}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:q.d.LastCreatedScene,c=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${x.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new r(this),this._extensions={},this._bufferManager=new zZ,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!Z)throw new Error("No scene available to export");this._babylonScene=Z,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:Z=>{var c;return null===Z||void 0===Z||null===(c=Z.Bc)||void 0===c?void 0:c.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...c},this._loadExtensions()}dispose(){for(const Z in this._extensions){this._extensions[Z].dispose()}}get options(){return this._options}static RegisterExtension(Z,c){FZ.UnregisterExtension(Z)&&N.c.Warn(`Extension with the name ${Z} already exists`),FZ._ExtensionFactories[Z]=c,FZ._ExtensionNames.push(Z)}static UnregisterExtension(Z){if(!FZ._ExtensionFactories[Z])return!1;delete FZ._ExtensionFactories[Z];const c=FZ._ExtensionNames.indexOf(Z);return-1!==c&&FZ._ExtensionNames.splice(c,1),!0}_generateJSON(Z,c,L){const k={byteLength:Z};return k.byteLength&&(this._glTF.buffers=[k]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.LL=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(k.uri=c+".bin"),L?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(Z){const c=await this._generateBinaryAsync();this._extensionsOnExporting();const L=this._generateJSON(c.byteLength,Z,!0),k=new Blob([c],{type:"application/octet-stream"}),N=Z+".gltf",R=Z+".bin",G=new J;if(G.files[N]=L,G.files[R]=k,this._imageData)for(const V in this._imageData)G.files[V]=new Blob([this._imageData[V].data],{type:this._imageData[V].mimeType});return G}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(Z){const c=Z%4;return 0===c?c:4-c}async generateGLBAsync(Z){this._shouldUseGlb=!0;const c=await this._generateBinaryAsync();this._extensionsOnExporting();const L=this._generateJSON(c.byteLength),k=Z+".glb";let N,R=L.length;if("undefined"!==typeof TextEncoder){N=(new TextEncoder).encode(L),R=N.length}const G=this._getPadding(R),V=this._getPadding(c.byteLength),p=28+R+G+c.byteLength+V,z=new pZ(p);if(z.writeUInt32(1179937895),z.writeUInt32(2),z.writeUInt32(p),z.writeUInt32(R+G),z.writeUInt32(1313821514),N)z.writeTypedArray(N);else{const Z="_".charCodeAt(0);for(let c=0;c<R;++c){const k=L.charCodeAt(c);k!=L.codePointAt(c)?z.writeUInt8(Z):z.writeUInt8(k)}}for(let J=0;J<G;++J)z.writeUInt8(32);z.writeUInt32(c.byteLength+V),z.writeUInt32(5130562),z.writeTypedArray(c);for(let J=0;J<V;++J)z.writeUInt8(0);const i=new J;return i.files[k]=new Blob([z.getOutputData()],{type:"application/octet-stream"}),i}_setNodeTransformation(Z,c,L){if(c.getPivotPoint().equalsWithEpsilon(A,m.e)||N.c.Warn("Pivot points are not supported in the glTF serializer"),!c.position.equalsWithEpsilon(A,m.e)){const N=k.d.Mc[0].R(c.position);L&&Y(N),Z.translation=N.xc()}c.Pc.equalsWithEpsilon(F,m.e)||(Z.scale=c.Pc.xc());const R=c.rotationQuaternion||k.c.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);R.equalsWithEpsilon(b,m.e)||(L&&a(R),Z.rotation=R.normalize().xc())}_setCameraTransformation(Z,c,L){if(!c.position.equalsWithEpsilon(A,m.e)){const N=k.d.Mc[0].R(c.position);L&&Y(N),Z.translation=N.xc()}const N=c.rotationQuaternion||k.c.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);L&&a(N),this._babylonScene.useRightHandedSystem||C(N),N.equalsWithEpsilon(b,m.e)||(Z.rotation=N.xc())}_listAvailableCameras(){for(const Z of this._babylonScene.cameras){const c={type:Z.mode===tZ.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(Z.name&&(c.name=Z.name),"perspective"===c.type)c.perspective={aspectRatio:Z.getEngine().getAspectRatio(Z),yfov:Z.fovMode===tZ.d.FOVMODE_VERTICAL_FIXED?Z.fov:Z.fov*Z.getEngine().getAspectRatio(Z),znear:Z.Dc,zfar:Z.maxZ};else if("orthographic"===c.type){const L=Z.orthoLeft&&Z.orthoRight?.5*(Z.orthoRight-Z.orthoLeft):.5*Z.getEngine().getRenderWidth(),k=Z.orthoBottom&&Z.orthoTop?.5*(Z.orthoTop-Z.orthoBottom):.5*Z.getEngine().getRenderHeight();c.orthographic={xmag:L,ymag:k,znear:Z.Dc,zfar:Z.maxZ}}this._camerasMap.set(Z,c)}}_exportAndAssignCameras(){const Z=Array.from(this._camerasMap.values());for(const c of Z){const Z=this._nodesCameraMap.get(c);if(void 0!==Z){this._cameras.push(c);for(const c of Z)c.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const Z of this._babylonScene.skeletons){if(Z.bones.length<=0)continue;const c={joints:[]};this._skinMap.set(Z,c)}}_exportAndAssignSkeletons(){for(const Z of this._babylonScene.skeletons){if(Z.bones.length<=0)continue;const c=this._skinMap.get(Z);if(void 0==c)continue;const L={},k=[];let R=-1;for(let N=0;N<Z.bones.length;++N){const c=Z.bones[N],k=c.getIndex()??N;-1!==k&&(L[k]=c,k>R&&(R=k))}for(let Z=0;Z<=R;++Z){const R=L[Z];k.push(R.getAbsoluteInverseBindMatrix());const G=R.getTransformNode();if(null!==G){const Z=this._nodeMap.get(G);G&&null!==Z&&void 0!==Z?c.joints.push(Z):N.c.Warn("Exporting a bone without a linked transform node is currently unsupported")}else N.c.Warn("Exporting a bone without a linked transform node is currently unsupported")}const G=this._nodesSkinMap.get(c);if(c.joints.length>0&&void 0!==G){const Z=64*k.length,L=new Float32Array(Z/4);k.forEach(((Z,c)=>{L.set(Z.m,16*c)}));const N=this._bufferManager.createBufferView(L);this._accessors.push(this._bufferManager.createAccessor(N,"MAT4",5126,k.length)),c.inverseBindMatrices=this._accessors.length-1,this._skins.push(c);for(const c of G)c.skin=this._skins.length-1}}}async _exportSceneAsync(){const Z={nodes:[]};if(this._babylonScene.metadata){const c=this._options.metadataSelector(this._babylonScene.metadata);c&&(Z.extras=c)}const c=new Array,L=new Array,k=new Array;for(const V of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&GZ(V,this._babylonScene.useRightHandedSystem)?k.push(...V.getChildren()):this._babylonScene.useRightHandedSystem?c.push(V):L.push(V);this._listAvailableCameras(),this._listAvailableSkeletons();const N=new bZ(!0,!1);Z.nodes.push(...await this._exportNodesAsync(L,N));const R=new bZ(!1,!1);Z.nodes.push(...await this._exportNodesAsync(c,R));const G=new bZ(!1,!0);Z.nodes.push(...await this._exportNodesAsync(k,G)),Z.nodes.length&&this._scenes.push(Z),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&jZ._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,N.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(Z){let c=this._shouldExportNodeMap.get(Z);return void 0===c&&(c=this._options.shouldExportNode(Z),this._shouldExportNodeMap.set(Z,c)),c}async _exportNodesAsync(Z,c){const L=new Array;this._exportBuffers(Z,c);for(const k of Z)await this._exportNodeAsync(k,L,c);return L}_collectBuffers(Z,c,L,k,N){if(this._shouldExportNode(Z)&&Z instanceof t.d&&Z.zc){const R=Z.zc.getVertexBuffers();if(R)for(const k in R){if(!g(k))continue;const G=R[k];N.setHasVertexColorAlpha(G,Z.hasVertexAlpha);const V=G._buffer,p=c.get(V)||[];c.set(V,p),-1===p.indexOf(G)&&p.push(G);const J=L.get(G)||[];L.set(G,J),-1===J.indexOf(Z)&&J.push(Z)}const G=Z.morphTargetManager;if(G)for(let c=0;c<G.numTargets;c++){const L=G.getTarget(c),N=k.get(L)||[];k.set(L,N),-1===N.indexOf(Z)&&N.push(Z)}}for(const R of Z.getChildren())this._collectBuffers(R,c,L,k,N)}_exportBuffers(Z,c){const L=new Map,k=new Map,N=new Map;for(const V of Z)this._collectBuffers(V,L,k,N,c);const R=Array.from(L.keys());for(const V of R){const Z=V.getData();if(!Z)throw new Error("Buffer data is not available");const N=L.get(V);if(!N)continue;const R=N[0].byteStride;if(N.some((Z=>Z.byteStride!==R)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const G=LZ(Z).slice();for(const c of N){const Z=k.get(c),{byteOffset:L,byteStride:N,componentCount:R,type:V,count:p,normalized:J,kind:i}=K(c,Z);switch(i){case z.g.NormalKind:case z.g.TangentKind:(0,f.i)(G,L,N,R,V,p,J,(Z=>{const c=Math.sqrt(Z[0]*Z[0]+Z[1]*Z[1]+Z[2]*Z[2]);if(c>0){const L=1/c;Z[0]*=L,Z[1]*=L,Z[2]*=L}}));break;case z.g.ColorKind:{const c=Z.filter((Z=>Z.material instanceof qZ.c||null==Z.material)).length;if(0==c)break;if(c!=Z.length){S.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}V==z.g.UNSIGNED_BYTE&&S.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const k=new O.d,i=new O.h,t=this._babylonScene.getEngine().useExactSrgbConversions;(0,f.i)(G,L,N,R,V,p,J,(Z=>{3===Z.length?(k.vL(Z,0),k.toLinearSpaceToRef(k,t),k.toArray(Z,0)):(i.vL(Z,0),i.toLinearSpaceToRef(i,t),i.toArray(Z,0))}))}}}if(c.convertToRightHanded){for(const Z of N){const c=k.get(Z),{byteOffset:L,byteStride:N,componentCount:R,type:V,count:p,normalized:J,kind:i}=K(Z,c);switch(i){case z.g.PositionKind:case z.g.NormalKind:case z.g.TangentKind:(0,f.i)(G,L,N,R,V,p,J,(Z=>{Z[0]=-Z[0]}))}}c.convertedToRightHandedBuffers.set(V,G)}const p=this._bufferManager.createBufferView(G,R);c.setVertexBufferView(V,p);const J=new Map;for(const c of N){const Z=k.get(c),{kind:L,totalVertices:N}=K(c,Z);switch(L){case z.g.MatricesIndicesKind:case z.g.MatricesIndicesExtraKind:if(c.type==z.g.FLOAT){const Z=c.getFloatData(N);null!==Z&&J.set(c,Z)}}}0!==J.size&&S.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const i=Array.from(J.keys());for(const L of i){const Z=J.get(L);if(!Z)continue;const k=Z.some((Z=>Z>=256)),N=new(k?Uint16Array:Uint8Array)(Z.length);for(let c=0;c<Z.length;c++)N[c]=Z[c];const R=this._bufferManager.createBufferView(N,4*(k?2:1));c.setRemappedBufferView(V,L,R)}}const G=Array.from(N.keys());for(const V of G){const Z=N.get(V);if(!Z)continue;const L=oZ(V,Z[0],this._bufferManager,this._bufferViews,this._accessors,c.convertToRightHanded);for(const k of Z)c.bindMorphDataToMesh(k,L)}}async _exportNodeAsync(Z,c,L){let k=this._nodeMap.get(Z);if(void 0!==k)return void(c.includes(k)||c.push(k));const N=await this._createNodeAsync(Z,L);if(N){k=this._nodes.length,this._nodes.push(N),this._nodeMap.set(Z,k),L.pushExportedNode(Z),c.push(k);const R={name:"runtime animations",channels:[],samplers:[]},G=[];this._babylonScene.animationGroups.length||(jZ._CreateMorphTargetAnimationFromMorphTargetAnimations(Z,R,G,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,L.convertToRightHanded,this._options.shouldExportAnimation),Z.animations.length&&jZ._CreateNodeAnimationFromNodeAnimations(Z,R,G,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,L.convertToRightHanded,this._options.shouldExportAnimation)),R.channels.length&&R.samplers.length&&this._animations.push(R),G.forEach((Z=>{Z.channels.length&&Z.samplers.length&&this._animations.push(Z)}))}const R=N?[]:c;for(const G of Z.getChildren())await this._exportNodeAsync(G,R,L);N&&R.length&&(N.children=R)}async _createNodeAsync(Z,c){if(!this._shouldExportNode(Z))return null;const L={};if(Z.name&&(L.name=Z.name),Z.metadata){const c=this._options.metadataSelector(Z.metadata);c&&(L.extras=c)}if(Z instanceof i.e&&(this._setNodeTransformation(L,Z,c.convertToRightHanded),Z instanceof t.d)){const N=Z instanceof E.e?Z.sourceMesh:Z;if(N.ec&&N.ec.length>0&&(L.mesh=await this._exportMeshAsync(N,c)),Z.skeleton){const c=this._skinMap.get(Z.skeleton);var k;if(void 0!==c)void 0===this._nodesSkinMap.get(c)&&this._nodesSkinMap.set(c,[]),null===(k=this._nodesSkinMap.get(c))||void 0===k||k.push(L)}}if(Z instanceof s.e){const k=this._camerasMap.get(Z);if(k){var N;void 0===this._nodesCameraMap.get(k)&&this._nodesCameraMap.set(k,[]),this._setCameraTransformation(L,Z,c.convertToRightHanded);const G=Z.parent;if(null!==G&&cZ(Z,G)){const Z=this._nodeMap.get(G);if(void 0!==Z){var R;const c=this._nodes[Z];return ZZ(L,c),null===(R=this._nodesCameraMap.get(k))||void 0===R||R.push(c),null}}null===(N=this._nodesCameraMap.get(k))||void 0===N||N.push(L)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",L,Z,this._nodeMap,c.convertToRightHanded)?L:(S.e.Warn(`Not exporting node ${Z.name}`),null)}_exportIndices(Z,c,L,k,N,G,V,p,J){let z=Z;J.mode=y(G);const i=V!==R.e.CounterClockWiseSideOrientation,t=!p.wasAddedByNoopNode&&i,E=function(Z){switch(Z){case R.e.TriangleFillMode:case R.e.TriangleStripDrawMode:case R.e.TriangleFanDrawMode:return!0}return!1}(G)&&t;if(E){if(G===R.e.TriangleStripDrawMode||G===R.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");J.mode=y(G);const V=c?new Uint32Array(k):new Uint16Array(k);if(Z)for(let c=0;c+2<k;c+=3)V[c]=Z[L+c]+N,V[c+1]=Z[L+c+2]+N,V[c+2]=Z[L+c+1]+N;else for(let Z=0;Z+2<k;Z+=3)V[Z]=Z,V[Z+1]=Z+2,V[Z+2]=Z+1;z=V}else if(Z&&0!==N){const R=c?new Uint32Array(k):new Uint16Array(k);for(let c=0;c<k;c++)R[c]=Z[L+c]+N;z=R}if(z){let R=p.getIndicesAccessor(Z,L,k,N,E);if(void 0===R){const G=function(Z,c,L,k){if(Z instanceof Uint16Array||Z instanceof Uint32Array)return Z;if(Z instanceof Int32Array)return new Uint32Array(Z.buffer,Z.byteOffset,Z.length);const N=Z.slice(c,c+L);return k?new Uint32Array(N):new Uint16Array(N)}(z,0,k,c),V=this._bufferManager.createBufferView(G),J=c?5125:5123;this._accessors.push(this._bufferManager.createAccessor(V,"SCALAR",J,k,0)),R=this._accessors.length-1,p.setIndicesAccessor(Z,L,k,N,E,R)}J.indices=R}}_exportVertexBuffer(Z,c,L,k,N,R){const G=Z.getKind();if(!g(G))return;if(G.startsWith("uv")&&!this._options.exportUnusedUVs&&(!c||!this._materialNeedsUVsSet.has(c)))return;let V=N.getVertexAccessor(Z,L,k);if(void 0===V){const c=N.convertedToRightHandedBuffers.get(Z._buffer)||Z._buffer.getData(),R=G===z.g.PositionKind?function(Z,c,L,k){const{byteOffset:N,byteStride:R,type:G,normalized:V}=c,p=c.getSize(),J=new Array(p).fill(1/0),z=new Array(p).fill(-1/0);return(0,f.i)(Z,N+L*R,R,p,G,k*p,V,(Z=>{for(let c=0;c<p;c++)J[c]=Math.min(J[c],Z[c]),z[c]=Math.max(z[c],Z[c])})),{min:J,max:z}}(c,Z,L,k):void 0,p=(G===z.g.MatricesIndicesKind||G===z.g.MatricesIndicesExtraKind)&&Z.type===z.g.FLOAT,J=p?z.g.UNSIGNED_BYTE:Z.type,i=p?void 0:Z.normalized,t=p?N.getRemappedBufferView(Z._buffer,Z):N.getVertexBufferView(Z._buffer),E=Z.byteOffset+L*Z.byteStride;this._accessors.push(this._bufferManager.createAccessor(t,function(Z,c){if(Z==z.g.ColorKind)return c?"VEC4":"VEC3";switch(Z){case z.g.PositionKind:case z.g.NormalKind:return"VEC3";case z.g.TangentKind:case z.g.MatricesIndicesKind:case z.g.MatricesIndicesExtraKind:case z.g.MatricesWeightsKind:case z.g.MatricesWeightsExtraKind:return"VEC4";case z.g.UVKind:case z.g.UV2Kind:case z.g.UV3Kind:case z.g.UV4Kind:case z.g.UV5Kind:case z.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${Z}`)}(G,N.hasVertexColorAlpha(Z)),J,k,E,R,i)),V=this._accessors.length-1,N.setVertexAccessor(Z,L,k,V)}R.attributes[function(Z){switch(Z){case z.g.PositionKind:return"POSITION";case z.g.NormalKind:return"NORMAL";case z.g.TangentKind:return"TANGENT";case z.g.ColorKind:return"COLOR_0";case z.g.UVKind:return"TEXCOORD_0";case z.g.UV2Kind:return"TEXCOORD_1";case z.g.UV3Kind:return"TEXCOORD_2";case z.g.UV4Kind:return"TEXCOORD_3";case z.g.UV5Kind:return"TEXCOORD_4";case z.g.UV6Kind:return"TEXCOORD_5";case z.g.MatricesIndicesKind:return"JOINTS_0";case z.g.MatricesIndicesExtraKind:return"JOINTS_1";case z.g.MatricesWeightsKind:return"WEIGHTS_0";case z.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${Z}`)}(G)]=V}async _exportMaterialAsync(Z,c,L,k){let N=this._materialMap.get(Z);if(void 0===N){const k=c&&Object.keys(c).some((Z=>Z.startsWith("uv")));if((Z=Z instanceof EZ.e?Z.Ic[L.materialIndex]:Z)instanceof xZ.e)N=await this._materialExporter.exportPBRMaterialAsync(Z,"image/png",k);else{if(!(Z instanceof qZ.c))return void S.e.Warn(`Unsupported material '${Z.name}' with type ${Z.getClassName()}`);N=await this._materialExporter.exportStandardMaterialAsync(Z,"image/png",k)}this._materialMap.set(Z,N)}k.material=N}async _exportMeshAsync(Z,c){var L;let k=c.getMesh(Z);if(void 0!==k)return k;const N={primitives:[]};k=this._meshes.length,this._meshes.push(N),c.setMesh(Z,k);const G=Z.isUnIndexed?null:Z.tc(),V=null===(L=Z.zc)||void 0===L?void 0:L.getVertexBuffers(),p=c.getMorphTargetsFromMesh(Z),J=Z instanceof uZ.b,z=Z instanceof AZ,i=Z.ec;if(V&&i&&i.length>0)for(const x of i){const L={attributes:{}},k=x.rZ()||this._babylonScene.defaultMaterial;if(z){var t,E;const c={name:k.name},N=Z,R=O.d.White(),G=(null===(t=N.material)||void 0===t?void 0:t.alpha)??1,V=(null===(E=N.greasedLineMaterial)||void 0===E?void 0:E.color)??R;(!V.equalsWithEpsilon(R,m.e)||G<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...V.xc(),G]}),this._materials.push(c),L.material=this._materials.length-1}else if(J){const c={name:k.name},N=Z;(!N.color.equalsWithEpsilon(O.d.White(),m.e)||N.alpha<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...N.color.xc(),N.alpha]}),this._materials.push(c),L.material=this._materials.length-1}else await this._exportMaterialAsync(k,V,x,L);const i=J||z?R.e.LineListDrawMode:Z.overrideRenderingFillMode??k.fillMode,q=k._getEffectiveOrientation(Z);this._exportIndices(G,G?(0,f.d)(G,x.indexCount,x.indexStart,x.verticesStart):x.verticesCount>65535,G?x.indexStart:x.verticesStart,G?x.indexCount:x.verticesCount,-x.verticesStart,i,q,c,L);for(const Z of Object.values(V))this._exportVertexBuffer(Z,k,x.verticesStart,x.verticesCount,c,L);if(p){L.targets=[];for(const Z of p)L.targets.push(Z.attributes)}N.primitives.push(L),this._extensionsPostExportMeshPrimitive(L)}if(p){N.weights=[],N.extras||(N.extras={}),N.extras.targetNames=[];for(const Z of p)N.weights.push(Z.influence),N.extras.targetNames.push(Z.name)}return k}}FZ._ExtensionNames=new Array,FZ._ExtensionFactories={};class UZ{static async GLTFAsync(Z,c,L){L&&L.exportWithoutWaitingForScene||await Z.whenReadyAsync();const k=new FZ(Z,L),N=await k.generateGLTFAsync(c.replace(/\.[^/.]+$/,""));return k.dispose(),N}static async GLBAsync(Z,c,L){L&&L.exportWithoutWaitingForScene||await Z.whenReadyAsync();const k=new FZ(Z,L),N=await k.generateGLBAsync(c.replace(/\.[^/.]+$/,""));return k.dispose(),N}}L(11760);const KZ="EXT_mesh_gpu_instancing";class nZ{constructor(Z){this.name=KZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(Z,c,L,N,R,G){return await new Promise((Z=>{if(c&&L instanceof MZ.c&&L.hasThinInstances&&this._exporter){this._wasUsed=!0;const Z=k.h.Zero(),N=k.c.Identity(),V=k.h.One(),p=L.thinInstanceGetWorldMatrices(),J=k.d.Mc[2],z=k.d.Quaternion[1],i=k.d.Mc[3];let t=!1,E=!1,x=!1;const q=new Float32Array(3*L.dc),O=new Float32Array(4*L.dc),w=new Float32Array(3*L.dc);let M=0;for(const c of p)c.decompose(i,z,J),R&&(Y(J),a(z)),q.set(J.xc(),3*M),O.set(z.normalize().xc(),4*M),w.set(i.xc(),3*M),t=t||!J.equalsWithEpsilon(Z),E=E||!z.equalsWithEpsilon(N),x=x||!i.equalsWithEpsilon(V),M++;const P={attributes:{}};t&&(P.attributes.TRANSLATION=this._buildAccessor(q,"VEC3",L.dc,G)),E&&(P.attributes.ROTATION=this._buildAccessor(O,"VEC4",L.dc,G)),x&&(P.attributes.SCALE=this._buildAccessor(w,"VEC3",L.dc,G)),c.extensions=c.extensions||{},c.extensions[KZ]=P}Z(c)}))}_buildAccessor(Z,c,L,k){const N=k.createBufferView(Z),R=k.createAccessor(N,c,5126,L);return this._exporter._accessors.push(R),this._exporter._accessors.length-1}}FZ.RegisterExtension(KZ,(Z=>new nZ(Z)));var gZ=L(11765),yZ=L(11777),vZ=L(11781),YZ=L(11787);function aZ(Z){return Z===vZ.c.PositionKind?"POSITION":Z===vZ.c.NormalKind?"NORMAL":Z===vZ.c.ColorKind?"COLOR":Z.startsWith(vZ.c.UVKind)?"TEX_COORD":"GENERIC"}const CZ={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Zc extends gZ.c{static get DefaultAvailable(){return(0,gZ.h)(Zc.DefaultConfiguration)}static get Default(){return Zc._Default??(Zc._Default=new Zc),Zc._Default}static ResetDefault(Z){Zc._Default&&(Z||Zc._Default.dispose(),Zc._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(Z,c){return{module:await(c||DracoEncoderModule)({wasmBinary:Z})}}_getWorkerContent(){return`${yZ.g}(${yZ.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Zc.DefaultConfiguration)}async _encodeAsync(Z,c,L){const k=L?(0,YZ.e)(CZ,L):CZ;if(this._workerPoolPromise){const L=await this._workerPoolPromise;return await new Promise(((N,R)=>{L.push(((L,G)=>{const V=Z=>{L.removeEventListener("error",V),L.removeEventListener("message",p),R(Z),G()},p=Z=>{"encodeMeshDone"===Z.data.id&&(L.removeEventListener("error",V),L.removeEventListener("message",p),N(Z.data.encodedMeshData),G())};L.addEventListener("error",V),L.addEventListener("message",p);const J=[];for(const c of Z)J.push(c.data.buffer);c&&J.push(c.buffer),L.postMessage({id:"encodeMesh",attributes:Z,indices:c,options:k},J)}))}))}if(this._modulePromise){const L=await this._modulePromise;return(0,yZ.g)(L.module,Z,c,k)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(Z,c){if(0==Z.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");Z instanceof MZ.c&&Z.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===c||void 0===c?void 0:c.method)&&(S.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),c.method="MESH_SEQUENTIAL_ENCODING");const L=function(Z){let c=Z.tc(void 0,!0);return!c||c instanceof Uint32Array||c instanceof Uint16Array||(c=((0,f.d)(c,c.length)?Uint32Array:Uint16Array).from(c)),c}(Z),k=function(Z,c){const L=[];for(const k of Z.getVerticesDataKinds()){if(null!==c&&void 0!==c&&c.includes(k)){if(k===vZ.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const N=Z.getVertexBuffer(k),R=N.getSize(),G=(0,f.t)(N.getData(),R,N.type,N.byteOffset,N.byteStride,N.normalized,Z.getTotalVertices(),!0);L.push({kind:k,dracoName:aZ(k),size:R,data:G})}return L}(Z,null===c||void 0===c?void 0:c.excludedAttributes);return await this._encodeAsync(k,L,c)}}Zc.DefaultConfiguration={wasmUrl:`${N.c._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${N.c._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${N.c._DefaultCdnUrl}/draco_encoder.js`},Zc._Default=null;const cc="KHR_draco_mesh_compression";class Lc{get wasUsed(){return this._wasUsed}constructor(Z){this.name=cc,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===Z.options.meshCompressionMethod&&Zc.DefaultAvailable}dispose(){}postExportMeshPrimitive(Z,c,L){if(!this.enabled)return;if(4!==Z.mode&&5!==Z.mode)return void S.e.Warn("Cannot compress primitive with mode "+Z.mode+".");const k=[],N=[];let R=null;if(void 0!==Z.indices){const G=L[Z.indices],V=c.getBufferView(G);R=c.getData(V).slice(),k.push(V),N.push(G)}const G=[];for(const[z,i]of Object.entries(Z.attributes)){const Z=L[i],R=c.getBufferView(Z),p=n(Z.type),J=(0,f.t)(c.getData(R),p,Z.componentType,Z.byteOffset||0,R.byteStride||(0,f.n)(Z.componentType)*p,Z.normalized||!1,Z.count,!0);G.push({kind:z,dracoName:(V=z,"POSITION"===V?"POSITION":"NORMAL"===V?"NORMAL":V.startsWith("COLOR")?"COLOR":V.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:n(Z.type),data:J}),k.push(R),N.push(Z)}var V;const p={method:Z.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},J=Zc.Default._encodeAsync(G,R,p).then((L=>{if(!L)return void S.e.Error("Draco encoding failed for primitive.");const R={bufferView:-1,attributes:L.attributeIds},G=c.createBufferView(L.data);c.setBufferView(R,G);for(const Z of k)this._bufferViewsUsed.add(Z);for(const Z of N)this._accessorsUsed.add(Z);Z.extensions||(Z.extensions={}),Z.extensions[cc]=R})).catch((Z=>{S.e.Error("Draco encoding failed for primitive: "+Z)}));this._encodePromises.push(J),this._wasUsed=!0}async preGenerateBinaryAsync(Z){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((c=>{Z.getPropertiesWithBufferView(c).every((Z=>this._accessorsUsed.has(Z)))&&Z.removeBufferView(c)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}FZ.RegisterExtension(cc,(Z=>new Lc(Z)));var kc=L(11792);const Nc="KHR_lights_punctual",Rc={name:"",color:[1,1,1],Qc:1,range:Number.MAX_VALUE},Gc={innerConeAngle:0,outerConeAngle:Math.PI/4},Vc=k.h.Backward();class pc{constructor(Z){this.name=Nc,this.enabled=!0,this.required=!1,this._exporter=Z}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Nc]=this._lights}async postExportNodeAsync(Z,c,L,N,R){return await new Promise((G=>{if(!(L instanceof PZ.e))return void G(c);const V=L.getTypeID()==PZ.e.LIGHTTYPEID_POINTLIGHT?"point":L.getTypeID()==PZ.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":L.getTypeID()==PZ.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!V||!(L instanceof kc.b))return S.e.Warn(`${Z}: Light ${L.name} is not supported in ${Nc}`),void G(c);if(L.falloffType!==PZ.e.FALLOFF_GLTF&&S.e.Warn(`${Z}: Light falloff for ${L.name} does not match the ${Nc} specification!`),!L.position.equalsToFloats(0,0,0)){const Z=k.d.Mc[0].R(L.position);R&&Y(Z),c.translation=Z.xc()}if("point"!==V){const Z=L.direction.normalizeToRef(k.d.Mc[0]);R&&Y(Z);const N=k.c.FromUnitVectorsToRef(Vc,Z,k.d.Quaternion[0]);k.c.IsIdentity(N)||(c.rotation=N.xc())}const p={type:V,name:L.name,color:L.rc.xc(),Qc:L.Qc,range:L.range};if(kZ(p,Rc),"spot"===V){const Z=L;p.spot={innerConeAngle:Z.innerAngle/2,outerConeAngle:Z.angle/2},kZ(p.spot,Gc)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(p);const J={Vc:this._lights.lights.length-1},z=L.parent;if(z&&cZ(L,z)){const Z=N.get(z);if(Z){const L=this._exporter._nodes[Z];return ZZ(c,L),L.extensions||(L.extensions={}),L.extensions[Nc]=J,void G(null)}}c.extensions||(c.extensions={}),c.extensions[Nc]=J,G(c)}))}}FZ.RegisterExtension(Nc,(Z=>new pc(Z)));var Jc=L(11580);const zc="KHR_materials_anisotropy";class ic{constructor(Z){this.name=zc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,c,L){const k=[];return L instanceof Jc.c&&L.anisotropy.isEnabled&&!L.anisotropy.legacy?(L.anisotropy.texture&&k.push(L.anisotropy.texture),k):[]}postExportMaterialAsync(Z,c,L){return new Promise((Z=>{if(L instanceof Jc.c){if(!L.anisotropy.isEnabled||L.anisotropy.legacy)return void Z(c);this._wasUsed=!0,c.extensions=c.extensions||{};const k=this._exporter._materialExporter.getTextureInfo(L.anisotropy.texture),N={anisotropyStrength:L.anisotropy.Qc,anisotropyRotation:L.anisotropy.angle,anisotropyTexture:k??void 0};null!==N.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(L),c.extensions[zc]=N}Z(c)}))}}FZ.RegisterExtension(zc,(Z=>new ic(Z)));const tc="KHR_materials_clearcoat";class Ec{constructor(Z){this.name=tc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,c,L){const k=[];return L instanceof Jc.c&&L.clearCoat.isEnabled?(L.clearCoat.texture&&k.push(L.clearCoat.texture),!L.clearCoat.useRoughnessFromMainTexture&&L.clearCoat.textureRoughness&&k.push(L.clearCoat.textureRoughness),L.clearCoat.bumpTexture&&k.push(L.clearCoat.bumpTexture),k):[]}postExportMaterialAsync(Z,c,L){return new Promise((Z=>{if(L instanceof Jc.c){if(!L.clearCoat.isEnabled)return void Z(c);this._wasUsed=!0,c.extensions=c.extensions||{};const k=this._exporter._materialExporter.getTextureInfo(L.clearCoat.texture);let R;R=L.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(L.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(L.clearCoat.textureRoughness),L.clearCoat.isTintEnabled&&N.c.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${L.name}`),L.clearCoat.remapF0OnInterfaceChange&&N.c.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${L.name}`);const G=this._exporter._materialExporter.getTextureInfo(L.clearCoat.bumpTexture),V={clearcoatFactor:L.clearCoat.Qc,clearcoatTexture:k??void 0,clearcoatRoughnessFactor:L.clearCoat.roughness,clearcoatRoughnessTexture:R??void 0,clearcoatNormalTexture:G??void 0};null===V.clearcoatTexture&&null===V.clearcoatRoughnessTexture&&null===V.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(L),c.extensions[tc]=V}Z(c)}))}}FZ.RegisterExtension(tc,(Z=>new Ec(Z)));const xc="KHR_materials_diffuse_transmission";function qc(Z,c){const L=c.subSurface;let k=null;return L.translucencyIntensityTexture?k=L.translucencyIntensityTexture:L.thicknessTexture&&L.useMaskFromThicknessTexture&&(k=L.thicknessTexture),k&&!L.useGltfStyleTextures?(S.e.Warn(`${Z}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${c.name}`,1),null):k}class Oc{constructor(Z){this.name=xc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,c,L){const k=[];if(L instanceof xZ.e&&this._isExtensionEnabled(L)){const c=qc(Z,L);return c&&k.push(c),L.subSurface.translucencyColorTexture&&k.push(L.subSurface.translucencyColorTexture),k}return k}_isExtensionEnabled(Z){if(Z.unlit)return!1;const c=Z.subSurface;return!!c.isTranslucencyEnabled&&(!Z.unlit&&!c.useAlbedoToTintTranslucency&&c.useGltfStyleTextures&&1===c.volumeIndexOfRefraction&&0===c.minimumThickness&&0===c.maximumThickness)}postExportMaterialAsync(Z,c,L){return new Promise((k=>{if(L instanceof xZ.e&&this._isExtensionEnabled(L)){this._wasUsed=!0;const k=L.subSurface,N=qc(Z,L),R=0==k.translucencyIntensity?void 0:k.translucencyIntensity,G=this._exporter._materialExporter.getTextureInfo(N)??void 0,V=!k.translucencyColor||k.translucencyColor.equalsFloats(1,1,1)?void 0:k.translucencyColor.xc(),p=this._exporter._materialExporter.getTextureInfo(k.translucencyColorTexture)??void 0,J={diffuseTransmissionFactor:R,diffuseTransmissionTexture:G,diffuseTransmissionColorFactor:V,diffuseTransmissionColorTexture:p};(G||p)&&this._exporter._materialNeedsUVsSet.add(L),c.extensions=c.extensions||{},c.extensions[xc]=J}k(c)}))}}FZ.RegisterExtension(xc,(Z=>new Oc(Z)));const wc="KHR_materials_dispersion";class Mc{constructor(){this.name=wc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Z){if(Z.unlit)return!1;const c=Z.subSurface;return!(!c.isRefractionEnabled&&!c.isDispersionEnabled)}postExportMaterialAsync(Z,c,L){return new Promise((Z=>{if(L instanceof xZ.e&&this._isExtensionEnabled(L)){this._wasUsed=!0;const Z={dispersion:L.subSurface.dispersion};c.extensions=c.extensions||{},c.extensions[wc]=Z}Z(c)}))}}FZ.RegisterExtension(wc,(()=>new Mc));const Pc="KHR_materials_emissive_strength";class jc{constructor(){this.name=Pc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(Z,c,L){return await new Promise((Z=>{if(!(L instanceof xZ.e))return Z(c);const k=L.emissiveColor.xc(),N=Math.max(...k);if(N>1){this._wasUsed=!0,c.extensions||(c.extensions={});const Z={emissiveStrength:N},k=L.emissiveColor.scale(1/Z.emissiveStrength);c.emissiveFactor=k.xc(),c.extensions[Pc]=Z}return Z(c)}))}}FZ.RegisterExtension(Pc,(Z=>new jc));const oc="KHR_materials_ior";class uc{constructor(){this.name=oc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Z){return!Z.unlit&&(void 0!=Z.indexOfRefraction&&1.5!=Z.indexOfRefraction)}postExportMaterialAsync(Z,c,L){return new Promise((Z=>{if(L instanceof xZ.e&&this._isExtensionEnabled(L)){this._wasUsed=!0;const Z={ior:L.indexOfRefraction};c.extensions=c.extensions||{},c.extensions[oc]=Z}Z(c)}))}}FZ.RegisterExtension(oc,(Z=>new uc));const Xc="KHR_materials_iridescence";class hc{constructor(Z){this.name=Xc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,c,L){const k=[];return L instanceof Jc.c&&L.iridescence.isEnabled?(L.iridescence.texture&&k.push(L.iridescence.texture),L.iridescence.thicknessTexture&&L.iridescence.thicknessTexture!==L.iridescence.texture&&k.push(L.iridescence.thicknessTexture),k):[]}postExportMaterialAsync(Z,c,L){return new Promise((Z=>{if(L instanceof Jc.c){if(!L.iridescence.isEnabled)return void Z(c);this._wasUsed=!0,c.extensions=c.extensions||{};const k=this._exporter._materialExporter.getTextureInfo(L.iridescence.texture),N=this._exporter._materialExporter.getTextureInfo(L.iridescence.thicknessTexture),R={iridescenceFactor:L.iridescence.Qc,iridescenceIor:L.iridescence.indexOfRefraction,iridescenceThicknessMinimum:L.iridescence.minimumThickness,iridescenceThicknessMaximum:L.iridescence.maximumThickness,iridescenceTexture:k??void 0,iridescenceThicknessTexture:N??void 0};null===R.iridescenceTexture&&null===R.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(L),c.extensions[Xc]=R}Z(c)}))}}FZ.RegisterExtension(Xc,(Z=>new hc(Z)));const Bc="KHR_materials_sheen";class Dc{constructor(Z){this.name=Bc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,c,L){return L instanceof xZ.e&&L.sheen.isEnabled&&L.sheen.texture?[L.sheen.texture]:[]}async postExportMaterialAsync(Z,c,L){return await new Promise((Z=>{if(L instanceof xZ.e){if(!L.sheen.isEnabled)return void Z(c);this._wasUsed=!0,null==c.extensions&&(c.extensions={});const k={sheenColorFactor:L.sheen.color.xc(),sheenRoughnessFactor:L.sheen.roughness??0};null===k.sheenColorTexture&&null===k.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(L),L.sheen.texture&&(k.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(L.sheen.texture)??void 0),L.sheen.textureRoughness&&!L.sheen.useRoughnessFromMainTexture?k.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(L.sheen.textureRoughness)??void 0:L.sheen.texture&&L.sheen.useRoughnessFromMainTexture&&(k.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(L.sheen.texture)??void 0),c.extensions[Bc]=k}Z(c)}))}}FZ.RegisterExtension(Bc,(Z=>new Dc(Z)));const ec="KHR_materials_specular";class Hc{constructor(Z){this.name=ec,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,c,L){const k=[];return L instanceof xZ.e&&this._isExtensionEnabled(L)?(L.metallicReflectanceTexture&&k.push(L.metallicReflectanceTexture),L.reflectanceTexture&&k.push(L.reflectanceTexture),k):k}_isExtensionEnabled(Z){return!Z.unlit&&(void 0!=Z.metallicF0Factor&&1!=Z.metallicF0Factor||void 0!=Z.metallicReflectanceColor&&!Z.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(Z))}_hasTexturesExtension(Z){return null!=Z.metallicReflectanceTexture||null!=Z.reflectanceTexture}postExportMaterialAsync(Z,c,L){return new Promise((Z=>{if(L instanceof xZ.e&&this._isExtensionEnabled(L)){this._wasUsed=!0,c.extensions=c.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(L.metallicReflectanceTexture)??void 0,k=this._exporter._materialExporter.getTextureInfo(L.reflectanceTexture)??void 0,N={specularFactor:1==L.metallicF0Factor?void 0:L.metallicF0Factor,specularTexture:Z,specularColorFactor:L.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:L.metallicReflectanceColor.xc(),specularColorTexture:k};this._hasTexturesExtension(L)&&this._exporter._materialNeedsUVsSet.add(L),c.extensions[ec]=N}Z(c)}))}}FZ.RegisterExtension(ec,(Z=>new Hc(Z)));const lc="KHR_materials_transmission";class Wc{constructor(Z){this.name=lc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,c,L){const k=[];return L instanceof xZ.e&&this._isExtensionEnabled(L)?(L.subSurface.thicknessTexture&&k.push(L.subSurface.thicknessTexture),k):k}_isExtensionEnabled(Z){if(Z.unlit)return!1;const c=Z.subSurface;return c.isRefractionEnabled&&void 0!=c.refractionIntensity&&0!=c.refractionIntensity||this._hasTexturesExtension(Z)}_hasTexturesExtension(Z){return null!=Z.subSurface.refractionIntensityTexture}async postExportMaterialAsync(Z,c,L){if(L instanceof xZ.e&&this._isExtensionEnabled(L)){this._wasUsed=!0;const k=L.subSurface,N={transmissionFactor:0===k.refractionIntensity?void 0:k.refractionIntensity};if(this._hasTexturesExtension(L)&&this._exporter._materialNeedsUVsSet.add(L),k.refractionIntensityTexture)if(k.useGltfStyleTextures){const Z=await this._exporter._materialExporter.exportTextureAsync(k.refractionIntensityTexture,"image/png");Z&&(N.transmissionTexture=Z)}else S.e.Warn(`${Z}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);c.extensions||(c.extensions={}),c.extensions[lc]=N}return c}}FZ.RegisterExtension(lc,(Z=>new Wc(Z)));const Tc="KHR_materials_unlit";class Ic{constructor(){this.name=Tc,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(Z,c,L){return new Promise((Z=>{let k=!1;L instanceof xZ.e?k=L.unlit:L instanceof qZ.c&&(k=L.disableLighting),k&&(this._wasUsed=!0,null==c.extensions&&(c.extensions={}),c.extensions[Tc]={}),Z(c)}))}}FZ.RegisterExtension(Tc,(()=>new Ic));const dc="KHR_materials_volume";class Qc{constructor(Z){this.name=dc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,c,L){const k=[];return L instanceof xZ.e&&this._isExtensionEnabled(L)?(L.subSurface.thicknessTexture&&k.push(L.subSurface.thicknessTexture),k):k}_isExtensionEnabled(Z){if(Z.unlit)return!1;const c=Z.subSurface;return!(!c.isRefractionEnabled&&!c.isTranslucencyEnabled)&&(void 0!=c.maximumThickness&&0!=c.maximumThickness||void 0!=c.tintColorAtDistance&&c.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=c.tintColor&&c.tintColor!=O.d.White()||this._hasTexturesExtension(Z))}_hasTexturesExtension(Z){return null!=Z.subSurface.thicknessTexture}postExportMaterialAsync(Z,c,L){return new Promise((Z=>{if(L instanceof xZ.e&&this._isExtensionEnabled(L)){this._wasUsed=!0;const Z=L.subSurface,k={thicknessFactor:0==Z.maximumThickness?void 0:Z.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(Z.thicknessTexture)??void 0,attenuationDistance:Z.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:Z.tintColorAtDistance,attenuationColor:Z.tintColor.equalsFloats(1,1,1)?void 0:Z.tintColor.xc()};this._hasTexturesExtension(L)&&this._exporter._materialNeedsUVsSet.add(L),c.extensions=c.extensions||{},c.extensions[dc]=k}Z(c)}))}}FZ.RegisterExtension(dc,(Z=>new Qc(Z)));const rc="EXT_materials_diffuse_roughness";class fc{constructor(Z){this.name=rc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,c,L){const k=[];return L instanceof Jc.c&&L._baseDiffuseRoughness?(L._baseDiffuseRoughnessTexture&&k.push(L._baseDiffuseRoughnessTexture),k):[]}postExportMaterialAsync(Z,c,L){return new Promise((Z=>{if(L instanceof Jc.c){if(!L._baseDiffuseRoughness)return void Z(c);this._wasUsed=!0,c.extensions=c.extensions||{};const k=this._exporter._materialExporter.getTextureInfo(L._baseDiffuseRoughnessTexture),N={diffuseRoughnessFactor:L._baseDiffuseRoughness,diffuseRoughnessTexture:k??void 0};null!==N.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(L),c.extensions[rc]=N}Z(c)}))}}FZ.RegisterExtension(rc,(Z=>new fc(Z)));const Sc="KHR_texture_transform";class sc{constructor(){this.name=Sc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(Z,c,L){if(L.XZ()||N.c.Warn(`${Z}: /*@__KEY__*/"scene" is not defined for Babylon texture ${L.name}!`),(0!==L.uAng||0!==L.vAng)&&(N.c.Warn(`${Z}: Texture ${L.name} with rotation in the u or v axis is not supported in glTF.`),0!==L.uRotationCenter||0!==L.vRotationCenter))return;const k={};let R=!1;if(0===L.uOffset&&0===L.vOffset||(k.offset=[L.uOffset,L.vOffset],R=!0),1===L.uScale&&1===L.vScale||(k.scale=[L.uScale,L.vScale],R=!0),0!==L.wAng){if(0!==L.uRotationCenter||0!==L.vRotationCenter){if(L.homogeneousRotationInUVTransform&&L.uScale!==L.vScale)return void N.c.Warn(`${Z}: Texture ${L.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Sc}.`);N.c.Warn(`${Z}: Texture ${L.name} with non-origin rotation center will be exported using an adjusted offset with ${Sc}.`),k.offset=function(Z){const{uOffset:c,vOffset:L,uRotationCenter:k,vRotationCenter:N,uScale:R,vScale:G,wAng:V}=Z,p=Math.cos(V),J=Math.sin(V),z=k*R,i=N*G;return[c+(z*(1-p)+i*J),L+(i*(1-p)-z*J)]}(L)}k.rotation=-L.wAng,R=!0}0!==L.coordinatesIndex&&(k.texCoord=L.coordinatesIndex,R=!0),R&&(this._wasUsed=!0,c.extensions||(c.extensions={}),c.extensions[Sc]=k)}}FZ.RegisterExtension(Sc,(()=>new sc));class mc{static CreateSTL(Z){let c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",N=arguments.length>3&&void 0!==arguments[3]&&arguments[3],R=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],G=arguments.length>5&&void 0!==arguments[5]&&arguments[5],V=arguments.length>6&&void 0!==arguments[6]&&arguments[6],p=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const J=function(Z,c,L){const N=[3*Z[L],3*Z[L+1],3*Z[L+2]],R=[new k.h(c[N[0]],c[N[0]+2],c[N[0]+1]),new k.h(c[N[1]],c[N[1]+2],c[N[1]+1]),new k.h(c[N[2]],c[N[2]+2],c[N[2]+1])],G=R[0].yL(R[1]),V=R[2].yL(R[1]);return{v:R,n:k.h.Cross(V,G).normalize()}},i=function(Z,c,L,k){return c=t(Z,c,L.x,k),c=t(Z,c,L.y,k),t(Z,c,L.z,k)},t=function(Z,c,L,k){return Z.setFloat32(c,L,k),c+4},x=function(Z){if(V){let c=Z;Z instanceof E.e&&(c=Z.sourceMesh);const L=c.getVerticesData(z.g.PositionKind,!0,!0);if(!L)return[];const N=k.h.Zero();let R;for(R=0;R<L.length;R+=3)k.h.TransformCoordinatesFromFloatsToRef(L[R],L[R+1],L[R+2],Z.Jc(!0),N).toArray(L,R);return L}return Z.getVerticesData(z.g.PositionKind)||[]};V&&(G=!0);let q="",O=0,w=0;if(N){for(let L=0;L<Z.length;L++){const c=Z[L].tc();O+=c?c.length/3:0}const c=new ArrayBuffer(84+50*O);q=new DataView(c),w+=80,q.setUint32(w,O,R),w+=4}else p||(q="solid stlmesh\r\n");for(let k=0;k<Z.length;k++){const c=Z[k];!N&&p&&(q+="solid "+c.name+"\r\n"),!G&&c instanceof MZ.c&&c.bakeCurrentTransformIntoVertices();const L=x(c),V=c.tc()||[];for(let Z=0;Z<V.length;Z+=3){const c=J(V,L,Z);N?(w=i(q,w,c.n,R),w=i(q,w,c.v[0],R),w=i(q,w,c.v[1],R),w=i(q,w,c.v[2],R),w+=2):(q+="\tfacet normal "+c.n.x+" "+c.n.y+" "+c.n.z+"\r\n",q+="\t\touter loop\r\n",q+="\t\t\tvertex "+c.v[0].x+" "+c.v[0].y+" "+c.v[0].z+"\r\n",q+="\t\t\tvertex "+c.v[1].x+" "+c.v[1].y+" "+c.v[1].z+"\r\n",q+="\t\t\tvertex "+c.v[2].x+" "+c.v[2].y+" "+c.v[2].z+"\r\n",q+="\t\tendloop\r\n",q+="\tendfacet\r\n")}!N&&p&&(q+="endsolid "+name+"\r\n")}if(N||p||(q+="endsolid stlmesh"),c){const Z=document.createElement("a"),c=new Blob([q],{type:"application/octet-stream"});Z.href=window.URL.createObjectURL(c),Z.download=L+".stl",Z.click()}return q}}function Ac(Z,c){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const k=[];for(let N=0;N<Z.length/L;N++){const R=Z[N*L],G=Z[N*L+1],V=Z[N*L+2];k.push(`(${R.toPrecision(c.precision)}, ${G.toPrecision(c.precision)}, ${V.toPrecision(c.precision)})`)}return k.join(", ")}function bc(Z,c){const L=[];for(let k=0;k<Z.length/2;k++){const N=Z[2*k],R=Z[2*k+1];L.push(`(${N.toPrecision(c.precision)}, ${(1-R).toPrecision(c.precision)})`)}return L.join(", ")}function Fc(Z,c){const L=Z.getVerticesData(z.g.PositionKind),k=Z.getVerticesData(z.g.NormalKind);if(L&&k)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(Z){var c;const L=null!==(c=Z.tc())&&void 0!==c&&c.length?Z.getTotalIndices():Z.getTotalVertices();return Array(L/3).fill(3).join(", ")}(Z)}]\n\t\tint[] faceVertexIndices = [${function(Z){const c=Z.tc(),L=[];if(null!==c)for(let k=0;k<c.length;k++)L.push(c[k]);else{const c=Z.getTotalVertices();for(let Z=0;Z<c;Z++)L.push(Z)}return L.join(", ")}(Z)}]\n\t\tnormal3f[] normals = [${Ac(k,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Ac(L,c)}]\n        ${function(Z,c){let L="";for(let N=0;N<4;N++){const k=N>0?N:"",R=Z.getVerticesData(z.g.UVKind+(k?k+1:""));R&&(L+=`\n\t\ttexCoord2f[] primvars:st${k} = [${bc(R,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const k=Z.getVerticesData(z.g.ColorKind);return k&&(L+=`\n\tcolor3f[] primvars:displayColor = [${Ac(k,c,k.length/Z.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),L}(Z,c)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Uc(Z,c){return`\n        def "Geometry"\n        {\n        ${Fc(Z,c)}\n        }\n        `}function Kc(Z){let c='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return c+=Z,fflate.strToU8(c)}function nc(Z){const c=Z.m;return`( ${gc(c,0)}, ${gc(c,4)}, ${gc(c,8)}, ${gc(c,12)} )`}function gc(Z,c){return`(${Z[c+0]}, ${Z[c+1]}, ${Z[c+2]}, ${Z[c+3]})`}function yc(Z){const c="Object_"+Z.uniqueId,L=function(Z){const c=Z.getWorldMatrix().clone(),L=Z.XZ().useRightHandedSystem;if(!L){let k=Z.parent;for(;k;){if(GZ(k,L)){c.multiplyToRef(k.getWorldMatrix().invert(),c);break}k=k.parent}}return c.determinant()<0&&N.c.Warn(`Exporting mesh ${Z.name} with negative scale. Result may look incorrect in destination engine.`),c}(Z),k=nc(L);return`def Xform "${c}" (\n\tprepend references = @./geometries/Geometry_${Z.zc.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${k}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${Z.material.uniqueId}>\n}\n\n`}function vc(Z){switch(Z){case X.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case X.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case X.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Yc(Z){return`(${Z.x}, ${Z.y})`}function ac(Z){return`(${Z.r}, ${Z.g}, ${Z.b})`}function Cc(Z,c,L,N,R,G){const V=Z.getInternalTexture().uniqueId+"_"+Z.invertY;R[V]=Z;const p=Z.coordinatesIndex>0?"st"+Z.coordinatesIndex:"st",J=new k.f(Z.uScale,Z.vScale),z=new k.f(Z.uOffset,Z.vOffset),i=Z.wAng,t=Math.sin(i),E=Math.cos(i);return z.y=1-z.y-J.y,z.x+=t*J.x,z.y+=(1-E)*J.y,`\n    def Shader "PrimvarReader_${L}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${p}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${L}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${c.uniqueId}/PrimvarReader_${L}.outputs:result>\n        float inputs:rotation = ${(i*(180/Math.PI)).toFixed(G.precision)}\n        float2 inputs:scale = ${Yc(J)}\n        float2 inputs:translation = ${Yc(z)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${Z.uniqueId}_${L}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${V}.png@\n        float2 inputs:st.connect = </Materials/Material_${c.uniqueId}/Transform2d_${L}.outputs:result>\n        ${N?"float4 inputs:scale = "+function(Z){return`(${Z.r}, ${Z.g}, ${Z.b}, 1.0)`}(N):""}\n        token inputs:sourceColorSpace = "${Z.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${vc(Z.wrapU)}"\n        token inputs:wrapT = "${vc(Z.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${c.needAlphaBlending()?"float outputs:a":""}\n    }`}function ZL(Z,c,L){const k="\t\t\t",N=[],R=[],{diffuseMap:G,rc:V,alphaCutOff:p,emissiveMap:J,emissive:z,normalMap:i,roughnessMap:t,roughnessChannel:E,roughness:x,metalnessMap:q,metalnessChannel:w,metalness:M,aoMap:P,aoMapChannel:j,aoMapIntensity:o,alphaMap:u,ior:X,clearCoatEnabled:h,clearCoat:B,clearCoatMap:D,clearCoatRoughness:e,clearCoatRoughnessMap:H}=function(Z){const c={diffuseMap:null,rc:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return Z instanceof qZ.c?{...c,diffuseMap:Z.diffuseTexture,rc:Z.diffuseColor,alphaCutOff:Z.alphaCutOff,emissiveMap:Z.emissiveTexture,emissive:Z.emissiveColor,roughness:1,alphaMap:Z.opacityTexture}:Z instanceof Jc.c?{...c,diffuseMap:Z._albedoTexture,rc:Z._albedoColor,alphaCutOff:Z._alphaCutOff,emissiveMap:Z._emissiveTexture,emissive:Z._emissiveColor,normalMap:Z._bumpTexture,roughnessMap:Z._metallicTexture,roughnessChannel:Z._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:Z._roughness??1,metalnessMap:Z._metallicTexture,metalnessChannel:Z._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:Z._metallic??0,aoMap:Z._ambientTexture,aoMapChannel:Z._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:Z._ambientTextureStrength,alphaMap:Z._opacityTexture,ior:Z.subSurface.indexOfRefraction,clearCoatEnabled:Z.clearCoat.isEnabled,clearCoat:Z.clearCoat.Qc,clearCoatMap:Z.clearCoat.texture,clearCoatRoughness:Z.clearCoat.roughness,clearCoatRoughnessMap:Z.clearCoat.useRoughnessFromMainTexture?Z.clearCoat.texture:Z.clearCoat.textureRoughness}:c}(Z);return null!==G?(N.push(`${k}color3f inputs:diffuseColor.connect = </Materials/Material_${Z.uniqueId}/Texture_${G.uniqueId}_diffuse.outputs:rgb>`),Z.needAlphaBlending()?N.push(`${k}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${G.uniqueId}_diffuse.outputs:a>`):Z.needAlphaTesting()&&(N.push(`${k}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${G.uniqueId}_diffuse.outputs:a>`),N.push(`${k}float inputs:opacityThreshold = ${p}`)),R.push(Cc(G,Z,"diffuse",V,c,L))):N.push(`${k}color3f inputs:diffuseColor = ${ac(V||O.d.White())}`),null!==J?(N.push(`${k}color3f inputs:emissiveColor.connect = </Materials/Material_${Z.uniqueId}/Texture_${J.uniqueId}_emissive.outputs:rgb>`),R.push(Cc(J,Z,"emissive",z,c,L))):z&&z.toLuminance()>0&&N.push(`${k}color3f inputs:emissiveColor = ${ac(z)}`),null!==i&&(N.push(`${k}normal3f inputs:normal.connect = </Materials/Material_${Z.uniqueId}/Texture_${i.uniqueId}_normal.outputs:rgb>`),R.push(Cc(i,Z,"kc",null,c,L))),null!==P&&(N.push(`${k}float inputs:occlusion.connect = </Materials/Material_${Z.uniqueId}/Texture_${P.uniqueId}_occlusion.outputs:${j}>`),R.push(Cc(P,Z,"occlusion",new O.d(o,o,o),c,L))),null!==t?(N.push(`${k}float inputs:roughness.connect = </Materials/Material_${Z.uniqueId}/Texture_${t.uniqueId}_roughness.outputs:${E}>`),R.push(Cc(t,Z,"roughness",new O.d(x,x,x),c,L))):N.push(`${k}float inputs:roughness = ${x}`),null!==q?(N.push(`${k}float inputs:metallic.connect = </Materials/Material_${Z.uniqueId}/Texture_${q.uniqueId}_metallic.outputs:${w}>`),R.push(Cc(q,Z,"metallic",new O.d(M,M,M),c,L))):N.push(`${k}float inputs:metallic = ${M}`),null!==u?(N.push(`${k}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${u.uniqueId}_opacity.outputs:r>`),N.push(`${k}float inputs:opacityThreshold = 0.0001`),R.push(Cc(u,Z,"opacity",null,c,L))):N.push(`${k}float inputs:opacity = ${Z.alpha}`),h&&(null!==D?(N.push(`${k}float inputs:clearcoat.connect = </Materials/Material_${Z.uniqueId}/Texture_${D.uniqueId}_clearcoat.outputs:r>`),R.push(Cc(D,Z,"clearcoat",new O.d(B,B,B),c,L))):N.push(`${k}float inputs:clearcoat = ${B}`),null!==H?(N.push(`${k}float inputs:clearcoatRoughness.connect = </Materials/Material_${Z.uniqueId}/Texture_${H.uniqueId}_clearcoatRoughness.outputs:g>`),R.push(Cc(H,Z,"clearcoatRoughness",new O.d(e,e,e),c,L))):N.push(`${k}float inputs:clearcoatRoughness = ${e}`)),N.push(`${k}float inputs:ior = ${X}`),`\n\tdef Material "Material_${Z.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${N.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${Z.uniqueId}/PreviewSurface.outputs:surface>\n\n${R.join("\n")}\n\n\t}\n`}async function cL(Z,c,L){const R={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...c};"undefined"===typeof fflate&&await N.c.LoadScriptAsync(R.fflateUrl);const G={};G[R.modelFileName]=null;let V='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';V+=function(Z){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===Z.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${Z.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${Z.planeAnchoringAlignment}"`:""}\n            `}(R);const p={};for(const k of Z.meshes){if(0===k.getTotalVertices())continue;const Z=k,c=Z.zc,J=Z.material;if(!J||!c||L&&!L(Z))continue;if(-1!==["Sc","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(J.getClassName())){const L="geometries/Geometry_"+c.uniqueId+".usda";if(!(L in G)){const Z=Uc(c,R);G[L]=Kc(Z)}J.uniqueId in p||(p[J.uniqueId]=J),V+=yc(Z)}else N.c.Warn("USDZExportAsync does not support this material type: "+J.getClassName())}Z.activeCamera&&R.exportCamera&&(V+=function(Z,c){const L="Camera_"+Z.uniqueId,N=nc(k.b.RotationY(Math.PI).multiply(Z.getWorldMatrix()));if(Z.mode===X.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${L}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${N}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Z.Dc.toPrecision(c.precision)}, ${Z.maxZ.toPrecision(c.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(Z.orthoLeft||1)+Math.abs(Z.orthoRight||1))).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(Z.orthoTop||1)+Math.abs(Z.orthoBottom||1))).toPrecision(c.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const k=Z.getEngine().getAspectRatio(Z),R=c.cameraSensorWidth||35;return`def Camera "${L}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${N}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Z.Dc.toPrecision(c.precision)}, ${Z.maxZ.toPrecision(c.precision)})\n\t\t\tfloat focalLength = ${(R/(2*Math.tan(.5*Z.fov))).toPrecision(c.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(R*k).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(R/k).toPrecision(c.precision)}            \n\t\t}\n\t\n\t`}}(Z.activeCamera,R)),V+="\n            }\n        }\n    }";const J={};V+=function(Z,c,L){const k=[];for(const N in Z){const R=Z[N];k.push(ZL(R,c,L))}return`\n    def "Materials"\n{\n${k.join("")}\n}\n\n`}(p,J,R),G[R.modelFileName]=fflate.strToU8(V);for(const k in J){const Z=J[k],c=Z.getSize(),L=await Z.readPixels();if(!L)throw new Error("Texture data is not available");const N=await h.DumpTools.DumpDataAsync(c.width,c.height,L,"image/png",void 0,!1,!0);G[`textures/Texture_${k}.png`]=new Uint8Array(N).slice()}let z=0;for(const k in G){const Z=G[k];if(!Z)continue;z+=34+k.length;const c=63&z;if(4!==c){const L=new Uint8Array(64-c);G[k]=[Z,{extra:{12345:L}}]}z=Z.length}return fflate.zipSync(G,{level:0})}}}]);