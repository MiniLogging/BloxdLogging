"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10894:(z,u,Y)=>{Y.r(u),Y.d(u,{EXT_materials_diffuse_roughness:()=>Ou,EXT_mesh_gpu_instancing:()=>kz,GLTF2Export:()=>az,GLTFData:()=>L,KHR_draco_mesh_compression:()=>Yu,KHR_lights_punctual:()=>bu,KHR_materials_anisotropy:()=>gu,KHR_materials_clearcoat:()=>qu,KHR_materials_diffuse_transmission:()=>hu,KHR_materials_dispersion:()=>du,KHR_materials_emissive_strength:()=>Wu,KHR_materials_ior:()=>su,KHR_materials_iridescence:()=>iu,KHR_materials_sheen:()=>Qu,KHR_materials_specular:()=>Au,KHR_materials_transmission:()=>Gu,KHR_materials_unlit:()=>Ru,KHR_materials_volume:()=>cu,KHR_texture_transform:()=>mu,OBJExport:()=>l,STLExport:()=>pu,USDZExportAsync:()=>uY,_ConvertToGLTFPBRMetallicRoughness:()=>F,_SolveMetallic:()=>G,__IGLTFExporterExtension:()=>T});var H=Y(10903),E=Y(10945),J=Y(11077);class l{static OBJ(z,u,Y,l){const T=[];let b=1,L=1;u&&(Y||(Y="mat"),T.push("mtllib "+Y+".mtl"));for(let D=0;D<z.length;D++){const Y=z[D],g=Y.name||`mesh${D}}`;T.push(`o ${g}`);let M=null;if(l){const z=Y.pl(!0);M=new H.b,z.invertToRef(M),Y.bakeTransformIntoVertices(z)}if(u){const z=Y.material;z&&T.push("usemtl "+z.id)}const q=Y.Sl;if(!q){E.e.Warn("No geometry is present on the mesh");continue}const C=q.getVerticesData("position"),K=q.getVerticesData("wl"),h=q.getVerticesData("uv"),o=q.Il();let d=0,t=0;if(!C||!o){E.e.Warn("There are no position vertices or indices on the mesh!");continue}const W=z[0].iz().useRightHandedSystem?1:-1;for(let z=0;z<C.length;z+=3)T.push("v "+C[z]*W+" "+C[z+1]+" "+C[z+2]),d++;if(null!=K)for(let z=0;z<K.length;z+=3)T.push("vn "+K[z]*W+" "+K[z+1]+" "+K[z+2]);if(null!=h)for(let z=0;z<h.length;z+=2)T.push("vt "+h[z]+" "+h[z+1]),t++;const Z=["","",""],s=(Y.material||Y.iz().defaultMaterial)._getEffectiveOrientation(Y),[v,i]=s===J.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let z=0;z<o.length;z+=3){const u=[String(o[z]+b),String(o[z+v]+b),String(o[z+i]+b)],Y=[String(o[z]+L),String(o[z+v]+L),String(o[z+i]+L)],H=u,E=null!=h?Y:Z,J=null!=K?u:Z;T.push("f "+H[0]+"/"+E[0]+"/"+J[0]+" "+H[1]+"/"+E[1]+"/"+J[1]+" "+H[2]+"/"+E[2]+"/"+J[2])}l&&M&&Y.bakeTransformIntoVertices(M),b+=d,L+=t}return T.join("\n")}static MTL(z){const u=[],Y=z.material;u.push("newmtl mat1"),u.push("  Ns "+Y.specularPower.toFixed(4)),u.push("  Ni 1.5000"),u.push("  d "+Y.alpha.toFixed(4)),u.push("  Tr 0.0000"),u.push("  Tf 1.0000 1.0000 1.0000"),u.push("  illum 2"),u.push("  Ka "+Y.ambientColor.r.toFixed(4)+" "+Y.ambientColor.g.toFixed(4)+" "+Y.ambientColor.b.toFixed(4)),u.push("  Kd "+Y.diffuseColor.r.toFixed(4)+" "+Y.diffuseColor.g.toFixed(4)+" "+Y.diffuseColor.b.toFixed(4)),u.push("  Ks "+Y.specularColor.r.toFixed(4)+" "+Y.specularColor.g.toFixed(4)+" "+Y.specularColor.b.toFixed(4)),u.push("  Ke "+Y.emissiveColor.r.toFixed(4)+" "+Y.emissiveColor.g.toFixed(4)+" "+Y.emissiveColor.b.toFixed(4));Y.ambientTexture&&u.push("  map_Ka "+Y.ambientTexture.name),Y.diffuseTexture&&u.push("  map_Kd "+Y.diffuseTexture.name),Y.specularTexture&&u.push("  map_Ks "+Y.specularTexture.name),Y.bumpTexture&&u.push("  map_bump -imfchan z "+Y.bumpTexture.name),Y.opacityTexture&&u.push("  map_d "+Y.opacityTexture.name);return u.join("\n")}}var T=0,b=Y(10980);class L{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const z in this.files){const u=this.files[z],Y=new Blob([u],{type:(0,b.i)(z)});E.e.Download(Y,z)}}}var D=Y(11103),g=Y(11218),M=Y(11229),q=Y(11259),C=Y(11325),K=Y(10928),h=Y(11188),o=Y(10937);const d=o.HighestCommonFactor,t={...o,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:d};var W=Y(11408),Z=Y(11415),s=Y(11461),v=Y(11464),i=Y(11473);const X=1e-6,Q=new h.c(.04,.04,.04),V=1024,A=h.c.White(),x=h.c.Black();function G(z,u,Y){if(u<Q.r)return 0;const H=Q.r,E=z*Y/(1-Q.r)+u-2*Q.r,J=E*E-4*H*(Q.r-u);return t.Clamp((-E+Math.sqrt(J))/(2*H),0,1)}function F(z){const u=z.diffuseColor.toLinearSpace(z.iz().getEngine().useExactSrgbConversions).scale(.5),Y=z.alpha,E=function(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new H.m(0,1),Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new H.m(0,.1),E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new H.m(0,.1),J=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new H.m(1300,.1);return function(z,u,Y,H,E){return(1-z)*(1-z)*(1-z)*u+3*(1-z)*(1-z)*z*Y+3*(1-z)*z*z*H+z*z*z*E}(Math.pow(z/J.x,.333333),u.y,Y.y,E.y,J.y)}(t.Clamp(z.specularPower,0,V));return{baseColorFactor:[u.r,u.g,u.b,Y],metallicFactor:0,roughnessFactor:E}}function R(z,u){u.needAlphaBlending()?z.alphaMode="BLEND":u.needAlphaTesting()&&(z.alphaMode="MASK",z.alphaCutoff=u.alphaCutOff)}function w(z,u,Y){const H=new Uint8Array(z*u*4);for(let E=0;E<H.length;E+=4)H[E]=H[E+1]=H[E+2]=H[E+3]=255;return s.e.CreateRGBATexture(H,z,u,Y)}function c(z){if(z instanceof Uint8Array){const u=z.length,Y=new Float32Array(z.length);for(let H=0;H<u;++H)Y[H]=z[H]/255;return Y}if(z instanceof Float32Array)return z;throw new Error("Unsupported pixel format!")}class U{constructor(z){this._exporter=z,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(z){return z?this._textureMap.get(z)??null:null}async exportStandardMaterialAsync(z,u,Y){const H=F(z),J={name:z.name};if(null==z.yl||z.yl||(z.twoSidedLighting||E.e.Warn(z.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),J.doubleSided=!0),Y){const Y=[],E=z.diffuseTexture;E&&Y.push(this.exportTextureAsync(E,u).then((z=>{z&&(H.baseColorTexture=z)})));const l=z.bumpTexture;l&&Y.push(this.exportTextureAsync(l,u).then((z=>{z&&(J.normalTexture=z,1!==l.level&&(J.normalTexture.scale=l.level))})));const T=z.emissiveTexture;T&&(J.emissiveFactor=[1,1,1],Y.push(this.exportTextureAsync(T,u).then((z=>{z&&(J.emissiveTexture=z)}))));const b=z.ambientTexture;b&&Y.push(this.exportTextureAsync(b,u).then((z=>{if(z){const u={index:z.index};J.occlusionTexture=u}}))),Y.length>0&&(this._exporter._materialNeedsUVsSet.add(z),await Promise.all(Y))}(z.alpha<1||z.opacityTexture)&&(z.alphaMode===v.b.ALPHA_COMBINE?J.alphaMode="BLEND":E.e.Warn(z.name+": glTF 2.0 does not support alpha mode: "+z.alphaMode.toString())),z.emissiveColor&&!z.emissiveColor.equalsWithEpsilon(x,X)&&(J.emissiveFactor=z.emissiveColor.al()),J.pbrMetallicRoughness=H,R(J,z),await this._finishMaterialAsync(J,z,u);const l=this._exporter._materials;return l.push(J),l.length-1}async _finishMaterialAsync(z,u,Y){const H=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",z,u),E=[];for(const J of H)E.push(this.exportTextureAsync(J,Y));await Promise.all(E),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",z,u)}async _getImageDataAsync(z,u,H,E){const J=v.b.TEXTURETYPE_UNSIGNED_BYTE,l=this._exporter._babylonScene,T=l.getEngine(),b=T.createRawTexture(z,u,H,v.b.TEXTUREFORMAT_RGBA,!1,!0,Z.b.NEAREST_SAMPLINGMODE,null,J);T.isWebGPU?await Y.e(36).then(Y.bind(Y,13253)):await Y.e(37).then(Y.bind(Y,13257)),await W.j.ApplyPostProcess("pass",b,l,J,v.b.TEXTURE_NEAREST_SAMPLINGMODE,v.b.TEXTUREFORMAT_RGBA);const L=await T._readTexturePixels(b,u,H);return await i.DumpTools.DumpDataAsync(u,H,L,E,void 0,!0,!0)}_resizeTexturesToSameDimensions(z,u,Y){const H=z?z.getSize():{width:0,height:0},E=u?u.getSize():{width:0,height:0};let J,l;return H.width<E.width?(J=z&&z instanceof Z.b?W.j.CreateResizedCopy(z,E.width,E.height,!0):w(E.width,E.height,Y),l=u):H.width>E.width?(l=u&&u instanceof Z.b?W.j.CreateResizedCopy(u,H.width,H.height,!0):w(H.width,H.height,Y),J=z):(J=z,l=u),{texture1:J,texture2:l}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(z,u,Y,H){const E=new Array;if(!z&&!u)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const J=z?z.iz():u?u.iz():null;if(J){var l;const T=this._resizeTexturesToSameDimensions(z,u,J),b=null===(l=T.texture1)||void 0===l?void 0:l.getSize();let L,D;const g=b.width,M=b.height,q=await T.texture1.readPixels(),C=await T.texture2.readPixels();if(!q)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(L=c(q),!C)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");D=c(C);const K=D.byteLength,o=new Uint8Array(K),d=new Uint8Array(K),t=4,W=x;let Z=0,s=0;for(let z=0;z<M;++z)for(let u=0;u<g;++u){const H=(g*z+u)*t,E={diffuseColor:new h.c(L[H],L[H+1],L[H+2]).toLinearSpace(J.getEngine().useExactSrgbConversions).multiply(Y.diffuseColor),specularColor:new h.c(D[H],D[H+1],D[H+2]).toLinearSpace(J.getEngine().useExactSrgbConversions).multiply(Y.specularColor),glossiness:D[H+3]*Y.glossiness},l=this._convertSpecularGlossinessToMetallicRoughness(E);W.r=Math.max(W.r,l.baseColor.r),W.g=Math.max(W.g,l.baseColor.g),W.b=Math.max(W.b,l.baseColor.b),Z=Math.max(Z,l.metallic),s=Math.max(s,l.roughness),d[H]=255*l.baseColor.r,d[H+1]=255*l.baseColor.g,d[H+2]=255*l.baseColor.b,d[H+3]=T.texture1.jl?255*L[H+3]:255,o[H]=0,o[H+1]=255*l.roughness,o[H+2]=255*l.metallic,o[H+3]=255}const v={baseColor:W,metallic:Z,roughness:s};let i=!1,Q=!1;for(let z=0;z<M;++z)for(let u=0;u<g;++u){const Y=(g*z+u)*t;d[Y]/=v.baseColor.r>X?v.baseColor.r:1,d[Y+1]/=v.baseColor.g>X?v.baseColor.g:1,d[Y+2]/=v.baseColor.b>X?v.baseColor.b:1;const H=h.c.FromInts(d[Y],d[Y+1],d[Y+2]).toGammaSpace(J.getEngine().useExactSrgbConversions);d[Y]=255*H.r,d[Y+1]=255*H.g,d[Y+2]=255*H.b,H.equalsWithEpsilon(A,X)||(Q=!0),o[Y+1]/=v.roughness>X?v.roughness:1,o[Y+2]/=v.metallic>X?v.metallic:1;h.c.FromInts(255,o[Y+1],o[Y+2]).equalsWithEpsilon(A,X)||(i=!0)}return i&&E.push(this._getImageDataAsync(o,g,M,H).then((z=>{v.metallicRoughnessTextureData=z}))),Q&&E.push(this._getImageDataAsync(d,g,M,H).then((z=>{v.baseColorTextureData=z}))),await Promise.all(E).then((()=>v))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(z){const u=this._getPerceivedBrightness(z.diffuseColor),Y=this._getPerceivedBrightness(z.specularColor),H=1-this._getMaxComponent(z.specularColor),E=G(u,Y,H),J=z.diffuseColor.scale(H/(1-Q.r)/Math.max(1-E)),l=z.specularColor.JY(Q.scale(1-E)).scale(1/Math.max(E));let T=h.c.Lerp(J,l,E*E);T=T.clampToRef(0,1,T);return{baseColor:T,metallic:E,roughness:1-z.glossiness}}_getPerceivedBrightness(z){return z?Math.sqrt(.299*z.r*z.r+.587*z.g*z.g+.114*z.b*z.b):0}_getMaxComponent(z){return z?Math.max(z.r,Math.max(z.g,z.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(z,u,Y,H){const E=[],J={baseColor:z._albedoColor,metallic:z._metallic,roughness:z._roughness};if(H){z._albedoTexture&&E.push(this.exportTextureAsync(z._albedoTexture,u).then((z=>{z&&(Y.baseColorTexture=z)})));const H=z._metallicTexture;H&&E.push(this.exportTextureAsync(H,u).then((z=>{z&&(Y.metallicRoughnessTexture=z)})))}return E.length>0&&(this._exporter._materialNeedsUVsSet.add(z),await Promise.all(E)),J}_getTextureSampler(z){const u={};if(!z||!(z instanceof Z.b))return u;const Y=this._getGLTFTextureWrapMode(z.wrapU);10497!==Y&&(u.wrapS=Y);const H=this._getGLTFTextureWrapMode(z.wrapV);switch(10497!==H&&(u.wrapT=H),z.samplingMode){case Z.b.LINEAR_LINEAR:u.magFilter=9729,u.minFilter=9729;break;case Z.b.LINEAR_NEAREST:u.magFilter=9729,u.minFilter=9728;break;case Z.b.NEAREST_LINEAR:u.magFilter=9728,u.minFilter=9729;break;case Z.b.NEAREST_LINEAR_MIPLINEAR:u.magFilter=9728,u.minFilter=9987;break;case Z.b.NEAREST_NEAREST:u.magFilter=9728,u.minFilter=9728;break;case Z.b.NEAREST_LINEAR_MIPNEAREST:u.magFilter=9728,u.minFilter=9985;break;case Z.b.LINEAR_NEAREST_MIPNEAREST:u.magFilter=9729,u.minFilter=9984;break;case Z.b.LINEAR_NEAREST_MIPLINEAR:u.magFilter=9729,u.minFilter=9986;break;case Z.b.NEAREST_NEAREST_MIPLINEAR:u.magFilter=9728,u.minFilter=9986;break;case Z.b.LINEAR_LINEAR_MIPLINEAR:u.magFilter=9729,u.minFilter=9987;break;case Z.b.LINEAR_LINEAR_MIPNEAREST:u.magFilter=9729,u.minFilter=9985;break;case Z.b.NEAREST_NEAREST_MIPNEAREST:u.magFilter=9728,u.minFilter=9984}return u}_getGLTFTextureWrapMode(z){switch(z){case Z.b.WRAP_ADDRESSMODE:return 10497;case Z.b.CLAMP_ADDRESSMODE:return 33071;case Z.b.MIRROR_ADDRESSMODE:return 33648;default:return E.e.Error(`Unsupported Texture Wrap Mode ${z}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(z,u,Y,H){const E={diffuseColor:z._albedoColor,specularColor:z._reflectivityColor,glossiness:z._microSurface},J=z._albedoTexture,l=z._reflectivityTexture,T=z._useMicroSurfaceFromReflectivityMapAlpha;if(l&&!T)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((J||l)&&H){this._exporter._materialNeedsUVsSet.add(z);const H=this._exportTextureSampler(J||l),T=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(J,l,E,u),b=this._exporter._textures;if(T.baseColorTextureData){const z=this._exportImage(`baseColor${b.length}`,u,T.baseColorTextureData);Y.baseColorTexture=this._exportTextureInfo(z,H,null===J||void 0===J?void 0:J.coordinatesIndex)}if(T.metallicRoughnessTextureData){const z=this._exportImage(`metallicRoughness${b.length}`,u,T.metallicRoughnessTextureData);Y.metallicRoughnessTexture=this._exportTextureInfo(z,H,null===l||void 0===l?void 0:l.coordinatesIndex)}return T}return this._convertSpecularGlossinessToMetallicRoughness(E)}async exportPBRMaterialAsync(z,u,Y){const H={},E={name:z.name},J=z.isMetallicWorkflow();if(J){const u=z._albedoColor,Y=z.alpha;u&&(H.baseColorFactor=[u.r,u.g,u.b,Y])}const l=J?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(z,u,H,Y):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(z,u,H,Y);await this._setMetallicRoughnessPbrMaterialAsync(l,z,E,H,u,Y),await this._finishMaterialAsync(E,z,u);const T=this._exporter._materials;return T.push(E),T.length-1}async _setMetallicRoughnessPbrMaterialAsync(z,u,Y,H,J,l){if(R(Y,u),z.baseColor.equalsWithEpsilon(A,X)&&t.WithinEpsilon(u.alpha,1,X)||(H.baseColorFactor=[z.baseColor.r,z.baseColor.g,z.baseColor.b,u.alpha]),null!=z.metallic&&1!==z.metallic&&(H.metallicFactor=z.metallic),null!=z.roughness&&1!==z.roughness&&(H.roughnessFactor=z.roughness),null==u.yl||u.yl||(u._twoSidedLighting||E.e.Warn(u.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Y.doubleSided=!0),l){const z=[],H=u._bumpTexture;H&&z.push(this.exportTextureAsync(H,J).then((z=>{z&&(Y.normalTexture=z,1!==H.level&&(Y.normalTexture.scale=H.level))})));const E=u._ambientTexture;E&&z.push(this.exportTextureAsync(E,J).then((z=>{if(z){const H={index:z.index,texCoord:z.texCoord,extensions:z.extensions};Y.occlusionTexture=H;const E=u._ambientTextureStrength;E&&(H.strength=E)}})));const l=u._emissiveTexture;l&&z.push(this.exportTextureAsync(l,J).then((z=>{z&&(Y.emissiveTexture=z)}))),z.length>0&&(this._exporter._materialNeedsUVsSet.add(u),await Promise.all(z))}const T=u._emissiveColor;T.equalsWithEpsilon(x,X)||(Y.emissiveFactor=T.al()),Y.pbrMetallicRoughness=H}_getPixelsFromTextureAsync(z){return function(z){switch(z){case v.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case v.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case v.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case v.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case v.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case v.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case v.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case v.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case v.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case v.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case v.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case v.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case v.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case v.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case v.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case v.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case v.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case v.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case v.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case v.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case v.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(z.textureFormat)?(0,W.i)(z,z._texture.width,z._texture.height):(z.textureType,v.b.TEXTURETYPE_UNSIGNED_BYTE,z.readPixels())}async exportTextureAsync(z,u){const Y=this._exporter._extensionsPreExportTextureAsync("exporter",z,u);return Y?await Y.then((async Y=>Y?await this._exportTextureInfoAsync(Y,u):await this._exportTextureInfoAsync(z,u))):await this._exportTextureInfoAsync(z,u)}async _exportTextureInfoAsync(z,u){let Y=this._textureMap.get(z);if(!Y){const H=await this._getPixelsFromTextureAsync(z);if(!H)return null;const J=this._exportTextureSampler(z),l=z.mimeType;if(l)switch(l){case"image/jpeg":case"image/png":case"image/webp":u=l;break;default:E.e.Warn(`Unsupported media type: ${l}. Exporting texture as PNG.`)}const T=this._internalTextureToImage,b=z.getInternalTexture().uniqueId;T[b]||(T[b]={});let L=T[b][u];if(void 0===L){const Y=z.getSize();L=(async()=>{const E=await this._getImageDataAsync(H,Y.width,Y.height,u);return this._exportImage(z.name,u,E)})(),T[b][u]=L}Y=this._exportTextureInfo(await L,J,z.coordinatesIndex),this._textureMap.set(z,Y),this._exporter._extensionsPostExportTextures("exporter",Y,z)}return Y}_exportImage(z,u,Y){const H=this._exporter._images;let J;if(this._exporter._shouldUseGlb){J={name:z,mimeType:u,bufferView:void 0};const H=this._exporter._bufferManager.createBufferView(new Uint8Array(Y));this._exporter._bufferManager.setBufferView(J,H)}else{const l=z.replace(/\.\/|\/|\.\\|\\/g,"_"),T=function(z){switch(z){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(u);let b=l+T;H.some((z=>z.uri===b))&&(b=`${l}_${E.e.RandomId()}${T}`),J={name:z,uri:b},this._exporter._imageData[b]={data:Y,mimeType:u}}return H.push(J),H.length-1}_exportTextureInfo(z,u,Y){const H=this._exporter._textures;let E=H.findIndex((Y=>Y.sampler==u&&Y.source===z));-1===E&&(E=H.length,H.push({source:z,sampler:u}));const J={index:E};return Y&&(J.texCoord=Y),J}_exportTextureSampler(z){const u=this._getTextureSampler(z),Y=this._exporter._samplers,H=Y.findIndex((z=>z.minFilter===u.minFilter&&z.magFilter===u.magFilter&&z.wrapS===u.wrapS&&z.wrapT===u.wrapT));return-1!==H?H:(Y.push(u),Y.length-1)}}var O=Y(11117),n=Y(10953),m=Y(11475),p=Y(10906);const S=H.p.Zero(),I=H.f.Identity(),y=H.p.One(),a=new H.p(-1,1,1);function j(z,u){const{byteOffset:Y,byteStride:H,type:E,normalized:J}=z,l=z.getSize(),T=u.reduce(((z,u)=>u.getTotalVertices()>z?u.getTotalVertices():z),-Number.MAX_VALUE);return{byteOffset:Y,byteStride:H,componentCount:l,type:E,count:T*l,normalized:J,totalVertices:T,kind:z.getKind()}}function k(z){switch(z){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function P(z){switch(z){case D.f.PositionKind:case D.f.NormalKind:case D.f.TangentKind:case D.f.ColorKind:case D.f.MatricesIndicesKind:case D.f.MatricesIndicesExtraKind:case D.f.MatricesWeightsKind:case D.f.MatricesWeightsExtraKind:case D.f.UVKind:case D.f.UV2Kind:case D.f.UV3Kind:case D.f.UV4Kind:case D.f.UV5Kind:case D.f.UV6Kind:return!0}return!1}function e(z){switch(z){case J.d.TriangleFillMode:return 4;case J.d.TriangleStripDrawMode:return 5;case J.d.TriangleFanDrawMode:return 6;case J.d.PointListDrawMode:case J.d.PointFillMode:return 0;case J.d.LineLoopDrawMode:return 2;case J.d.LineListDrawMode:return 1;case J.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${z}`)}function N(z){const u=Math.sqrt(z.x*z.x+z.y*z.y+z.z*z.z);u>0&&(z.x/=u,z.y/=u,z.z/=u)}function B(z){return z.x*=-1,z}function f(z){if(z.x*z.x+z.y*z.y>.5){const u=Math.abs(z.x),Y=Math.abs(z.y);if(u>Y){const Y=Math.sign(z.x);z.x=u,z.y*=-Y,z.z*=-Y,z.w*=Y}else{const u=Math.sign(z.y);z.x*=-u,z.y=Y,z.z*=u,z.w*=-u}}else{const u=Math.abs(z.z),Y=Math.abs(z.w);if(u>Y){const Y=Math.sign(z.z);z.x*=-Y,z.y*=Y,z.z=u,z.w*=-Y}else{const u=Math.sign(z.w);z.x*=u,z.y*=-u,z.z*=-u,z.w=Y}}return z}function r(z){z.kl(-z.z,z.w,z.x,-z.y)}function zz(z,u){const Y=H.p.FromArrayToRef(u.translation||[0,0,0],0,H.i.Pl[0]),E=H.f.FromArrayToRef(u.rotation||[0,0,0,1],0,H.i.Quaternion[0]),J=H.b.ComposeToRef(y,E,Y,H.i.Matrix[0]),l=H.p.FromArrayToRef(z.translation||[0,0,0],0,H.i.Pl[2]),T=H.f.FromArrayToRef(z.rotation||[0,0,0,1],0,H.i.Quaternion[1]),b=H.b.ComposeToRef(y,T,l,H.i.Matrix[1]);J.multiplyToRef(b,b),b.decompose(void 0,E,Y),Y.equalsWithEpsilon(S,p.e)?delete u.translation:u.translation=Y.al(),E.equalsWithEpsilon(I,p.e)?delete u.rotation:u.rotation=E.al(),u.scale&&delete u.scale}function uz(z,u){if(!(u instanceof g.d))return!1;if(!(1===u.getChildren().length&&0===z.getChildren().length&&z.parent===u))return!1;const Y=z.iz(),H=z instanceof m.b&&!Y.useRightHandedSystem?a:y;return!!u.el.equalsWithEpsilon(H,p.e)||(n.b.Warn(`Cannot collapse node ${z.name} into parent node ${u.name} with modified scaling.`),!1)}function Yz(z){if(z instanceof Array){const u=new Float32Array(z);return new Uint8Array(u.buffer,u.byteOffset,u.byteLength)}return ArrayBuffer.isView(z)?new Uint8Array(z.buffer,z.byteOffset,z.byteLength):new Uint8Array(z)}function Hz(z,u){for(const[Y,H]of Object.entries(z)){const E=u[Y];(Array.isArray(H)&&Array.isArray(E)&&Ez(H,E)||H===E)&&delete z[Y]}return z}function Ez(z,u){return z.length===u.length&&z.every(((z,Y)=>z===u[Y]))}const Jz=H.b.Compose(new H.p(-1,1,1),H.f.Identity(),H.p.Zero());function lz(z,u){if(!(z instanceof g.d))return!1;if(u){if(!z.getWorldMatrix().equalsWithEpsilon(H.b.IdentityReadOnly,p.e))return!1}else{if(!z.getWorldMatrix().multiplyToRef(Jz,H.i.Matrix[0]).equalsWithEpsilon(H.b.IdentityReadOnly,p.e))return!1}return!(z instanceof M.b&&z.Sl)}const Tz=new Map([[Int8Array,(z,u,Y)=>z.setInt8(u,Y)],[Uint8Array,(z,u,Y)=>z.setUint8(u,Y)],[Uint8ClampedArray,(z,u,Y)=>z.setUint8(u,Y)],[Int16Array,(z,u,Y)=>z.setInt16(u,Y,!0)],[Uint16Array,(z,u,Y)=>z.setUint16(u,Y,!0)],[Int32Array,(z,u,Y)=>z.setInt32(u,Y,!0)],[Uint32Array,(z,u,Y)=>z.setUint32(u,Y,!0)],[Float32Array,(z,u,Y)=>z.setFloat32(u,Y,!0)],[Float64Array,(z,u,Y)=>z.setFloat64(u,Y,!0)]]);class bz{writeTypedArray(z){this._checkGrowBuffer(z.byteLength);const u=Tz.get(z.constructor);for(let Y=0;Y<z.length;Y++)u(this._dataView,this._byteOffset,z[Y]),this._byteOffset+=z.BYTES_PER_ELEMENT}constructor(z){this._data=new Uint8Array(z),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(z){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,z),this._byteOffset++}writeInt8(z){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,z),this._byteOffset++}writeInt16(z){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,z,!0),this._byteOffset+=2}writeUInt16(z){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,z,!0),this._byteOffset+=2}writeInt32(z){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,z,!0),this._byteOffset+=4}writeUInt32(z){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,z,!0),this._byteOffset+=4}writeFloat32(z){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,z,!0),this._byteOffset+=4}writeFloat64(z){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,z,!0),this._byteOffset+=8}_checkGrowBuffer(z){const u=this.byteOffset+z;if(u>this._data.byteLength){const z=new Uint8Array(2*u);z.set(this._data),this._data=z,this._dataView=new DataView(this._data.buffer)}}}function Lz(z){return z%4===0?4:z%2===0?2:1}class Dz{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(z){let u=0;this._bufferViewToData.forEach((z=>{u+=z.byteLength}));const Y=new bz(u),H=Array.from(this._bufferViewToData.keys()).sort(((z,u)=>Lz(u.byteLength)-Lz(z.byteLength)));for(const E of H){E.byteOffset=Y.byteOffset,z.push(E);const u=z.length-1,H=this.getPropertiesWithBufferView(E);for(const z of H)z.bufferView=u;Y.writeTypedArray(this._bufferViewToData.get(E)),this._bufferViewToData.delete(E)}return Y.getOutputData()}createBufferView(z,u){const Y={buffer:0,byteOffset:void 0,byteLength:z.byteLength,byteStride:u};return this._bufferViewToData.set(Y,z),Y}createAccessor(z,u,Y,H,E,J,l){this._verifyBufferView(z);const T={bufferView:void 0,componentType:Y,count:H,type:u,min:null===J||void 0===J?void 0:J.min,max:null===J||void 0===J?void 0:J.max,normalized:l,byteOffset:E};return this.setBufferView(T,z),this._accessorToBufferView.set(T,z),T}setBufferView(z,u){this._verifyBufferView(u);this.getPropertiesWithBufferView(u).push(z)}removeBufferView(z){const u=this.getPropertiesWithBufferView(z);for(const Y of u)void 0!==Y.bufferView&&delete Y.bufferView;this._bufferViewToData.delete(z),this._bufferViewToProperties.delete(z),this._accessorToBufferView.forEach(((u,Y)=>{u===z&&(void 0!==Y.byteOffset&&delete Y.byteOffset,this._accessorToBufferView.delete(Y))}))}getBufferView(z){const u=this._accessorToBufferView.get(z);return this._verifyBufferView(u),u}getPropertiesWithBufferView(z){return this._verifyBufferView(z),this._bufferViewToProperties.set(z,this._bufferViewToProperties.get(z)??[]),this._bufferViewToProperties.get(z)}getData(z){return this._verifyBufferView(z),this._bufferViewToData.get(z)}_verifyBufferView(z){if(void 0===z||!this._bufferViewToData.has(z))throw new Error(`BufferView ${z} not found in BufferManager.`)}}var gz,Mz=Y(11275),qz=Y(11316),Cz=Y(11479),Kz=Y(11616),hz=Y(11619),oz=Y(11633),dz=Y(11267),tz=Y(11637);!function(z){z[z.INTANGENT=0]="INTANGENT",z[z.OUTTANGENT=1]="OUTTANGENT"}(gz||(gz={}));class Wz{static _IsTransformable(z){return z&&(z instanceof g.d||z instanceof Mz.d||z instanceof tz.e)}static _CreateNodeAnimation(z,u,Y,H,J){if(this._IsTransformable(z)){const l=[],T=[],b=u.getKeys(),L=Wz._CalculateMinMaxKeyFrames(b),D=Wz._DeduceInterpolation(b,Y,H),g=D.interpolationType,M=D.shouldBakeAnimation;if(M?Wz._CreateBakedAnimation(z,u,Y,L.min,L.max,u.framePerSecond,J,l,T,L,H):"LINEAR"===g||"STEP"===g?Wz._CreateLinearOrStepAnimation(z,u,Y,l,T,H):"CUBICSPLINE"===g?Wz._CreateCubicSplineAnimation(z,u,Y,l,T,H):Wz._CreateBakedAnimation(z,u,Y,L.min,L.max,u.framePerSecond,J,l,T,L,H),l.length&&T.length){return{inputs:l,outputs:T,samplerInterpolation:g,inputsMin:M?L.min:E.e.FloatRound(L.min/u.framePerSecond),inputsMax:M?L.max:E.e.FloatRound(L.max/u.framePerSecond)}}}return null}static _DeduceAnimationInfo(z){let u=null,Y="VEC3",H=!1;const J=z.targetProperty.split(".");switch(J[0]){case"el":u="scale";break;case"position":u="translation";break;case"rotation":Y="VEC4",u="rotation";break;case"rotationQuaternion":Y="VEC4",H=!0,u="rotation";break;case"influence":Y="SCALAR",u="weights";break;default:E.e.Error(`Unsupported animatable property ${J[0]}`)}return u?{animationChannelTargetPath:u,dataAccessorType:Y,useQuaternion:H}:(E.e.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(z,u,Y,H,E,J,l,T,b,L,D){let g;if(Wz._IsTransformable(z)&&z.animations)for(const M of z.animations){if(D&&!D(M))continue;const E=Wz._DeduceAnimationInfo(M);E&&(g={name:M.name,samplers:[],channels:[]},Wz._AddAnimation(`${M.name}`,M.hasRunningRuntimeAnimations?u:g,z,M,E.dataAccessorType,E.animationChannelTargetPath,H,J,l,T,E.useQuaternion,b,L),g.samplers.length&&g.channels.length&&Y.push(g))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(z,u,Y,H,E,J,l,T,b,L,D){let g;if(z instanceof dz.b){const E=z.morphTargetManager;if(E)for(let M=0;M<E.numTargets;++M){const q=E.getTarget(M);for(const C of q.animations){if(D&&!D(C))continue;const q=new hz.e(`${C.name}`,"influence",C.framePerSecond,C.dataType,C.loopMode,C.enableBlending),K=[],h=C.getKeys();for(let z=0;z<h.length;++z){const u=h[z];for(let z=0;z<E.numTargets;++z)z==M?K.push(u):K.push({frame:u.frame,value:0})}q.setKeys(K);const o=Wz._DeduceAnimationInfo(q);o&&(g={name:q.name,samplers:[],channels:[]},Wz._AddAnimation(C.name,C.hasRunningRuntimeAnimations?u:g,z,q,o.dataAccessorType,o.animationChannelTargetPath,H,J,l,T,o.useQuaternion,b,L,E.numTargets),g.samplers.length&&g.channels.length&&Y.push(g))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(z,u,Y,H,E,J,l,T,b){let L;if(z.animationGroups){const g=z.animationGroups;for(const M of g){const g=new Map,q=new Map,C=new Set,K=M.to-M.from;L={name:M.name,channels:[],samplers:[]};for(let u=0;u<M.targetedAnimations.length;++u){const K=M.targetedAnimations[u],h=K.target,o=K.animation;if(b&&!b(o))continue;const d=T.has(h);if(this._IsTransformable(h)||1===h.length&&this._IsTransformable(h[0])){const z=Wz._DeduceAnimationInfo(K.animation);if(z){const u=this._IsTransformable(h)?h:this._IsTransformable(h[0])?h[0]:null;u&&Wz._AddAnimation(`${o.name}`,L,u,o,z.dataAccessorType,z.animationChannelTargetPath,Y,H,E,J,z.useQuaternion,l,d)}}else if(h instanceof oz.d||1===h.length&&h[0]instanceof oz.d){if(Wz._DeduceAnimationInfo(K.animation)){const u=h instanceof oz.d?h:h[0];if(u){const Y=z.morphTargetManagers.find((z=>{for(let Y=0;Y<z.numTargets;++Y)if(z.getTarget(Y)===u)return!0;return!1}));if(Y){const H=z.meshes.find((z=>z.morphTargetManager===Y));var D;if(H)g.has(H)||g.set(H,new Map),null===(D=g.get(H))||void 0===D||D.set(u,o),C.add(H),q.set(H,o)}}}}}C.forEach((z=>{const u=z.morphTargetManager;let T=null;const b=[],D=q.get(z).getKeys(),C=D.length;for(let Y=0;Y<C;++Y)for(let H=0;H<u.numTargets;++H){const E=u.getTarget(H),J=g.get(z);if(J){const u=J.get(E);u?(T||(T=new hz.e(`${M.name}_${z.name}_MorphWeightAnimation`,"influence",u.framePerSecond,hz.e.ANIMATIONTYPE_FLOAT,u.loopMode,u.enableBlending)),b.push(u.getKeys()[Y])):b.push({frame:M.from+K/C*Y,value:E.influence,inTangent:D[0].inTangent?0:void 0,outTangent:D[0].outTangent?0:void 0})}}T.setKeys(b);const h=Wz._DeduceAnimationInfo(T);h&&Wz._AddAnimation(`${M.name}_${z.name}_MorphWeightAnimation`,L,z,T,h.dataAccessorType,h.animationChannelTargetPath,Y,H,E,J,h.useQuaternion,l,!1,null===u||void 0===u?void 0:u.numTargets)})),L.channels.length&&L.samplers.length&&u.push(L)}}}static _AddAnimation(z,u,Y,E,J,l,T,b,L,D,g,M,q,C){const K=Wz._CreateNodeAnimation(Y,E,l,g,M);let h,o,d,t,W,Z;if(K){if(C){let z=0,u=0;const Y=[];for(;K.inputs.length>0;)u=K.inputs.shift(),z%C==0&&Y.push(u),z++;K.inputs=Y}const z=T.get(Y),E=new Float32Array(K.inputs);h=b.createBufferView(E),o=b.createAccessor(h,"SCALAR",5126,K.inputs.length,void 0,{min:[K.inputsMin],max:[K.inputsMax]}),D.push(o),d=D.length-1;const L=new H.f,g=new H.p,M=new H.p,s=Y instanceof Mz.d,v=k(J),i=new Float32Array(K.outputs.length*v);K.outputs.forEach((function(z,u){let Y=z;switch(l){case"translation":q&&(H.p.FromArrayToRef(z,0,M),B(M),M.toArray(Y));break;case"rotation":4===z.length?H.f.FromArrayToRef(z,0,L):(Y=new Array(4),H.p.FromArrayToRef(z,0,g),H.f.FromEulerVectorToRef(g,L)),q&&(f(L),s&&r(L)),L.toArray(Y)}i.set(Y,u*v)})),h=b.createBufferView(i),o=b.createAccessor(h,J,5126,K.outputs.length),D.push(o),t=D.length-1,W={interpolation:K.samplerInterpolation,input:d,output:t},u.samplers.push(W),Z={sampler:u.samplers.length-1,target:{node:z,path:l}},u.channels.push(Z)}}static _CreateBakedAnimation(z,u,Y,J,l,T,b,L,D,g,M){let q;const C=H.f.Identity();let K,h=null,o=null,d=null,t=null,W=null,Z=null;g.min=E.e.FloatRound(J/T);const s=u.getKeys();for(let H=0,v=s.length;H<v;++H){if(Z=null,d=s[H],H+1<v)if(t=s[H+1],d.value.equals&&d.value.equals(t.value)||d.value===t.value){if(0!==H)continue;Z=d.frame}else Z=t.frame;else{if(W=s[H-1],d.value.equals&&d.value.equals(W.value)||d.value===W.value)continue;Z=l}if(Z)for(let H=d.frame;H<=Z;H+=b){if(K=E.e.FloatRound(H/T),K===h)continue;h=K,o=K;const J={key:0,repeatCount:0,loopMode:u.loopMode};q=u._interpolate(H,J),Wz._SetInterpolatedValue(z,q,K,u,Y,C,L,D,M)}}o&&(g.max=o)}static _ConvertFactorToVector3OrQuaternion(z,u,Y,J,l){const T=Wz._GetBasePositionRotationOrScale(u,J,l),b=Y.targetProperty.split("."),L=b?b[1]:"",D=l?H.f.Nl(T).normalize():H.p.Nl(T);switch(L){case"x":case"y":case"z":D[L]=z;break;case"w":D.w=z;break;default:E.e.Error(`glTFAnimation: Unsupported component name "${L}"!`)}return D}static _SetInterpolatedValue(z,u,Y,E,J,l,T,b,L){let D;T.push(Y),"weights"!==J?(E.dataType===hz.e.ANIMATIONTYPE_FLOAT&&(u=this._ConvertFactorToVector3OrQuaternion(u,z,E,J,L)),"rotation"===J?(L?l=u:(D=u,H.f.RotationYawPitchRollToRef(D.y,D.x,D.z,l)),b.push(l.al())):(D=u,b.push(D.al()))):b.push([u])}static _CreateLinearOrStepAnimation(z,u,Y,H,E,J){for(const l of u.getKeys())H.push(l.frame/u.framePerSecond),Wz._AddKeyframeValue(l,u,E,Y,z,J)}static _CreateCubicSplineAnimation(z,u,Y,H,E,J){u.getKeys().forEach((function(l){H.push(l.frame/u.framePerSecond),Wz._AddSplineTangent(gz.INTANGENT,E,Y,"CUBICSPLINE",l,J),Wz._AddKeyframeValue(l,u,E,Y,z,J),Wz._AddSplineTangent(gz.OUTTANGENT,E,Y,"CUBICSPLINE",l,J)}))}static _GetBasePositionRotationOrScale(z,u,Y){let E;if("rotation"===u)if(Y){E=(z.rotationQuaternion??H.f.Identity()).al()}else{E=(z.rotation??H.p.Zero()).al()}else if("translation"===u){E=(z.position??H.p.Zero()).al()}else{E=(z.el??H.p.One()).al()}return E}static _AddKeyframeValue(z,u,Y,J,l,T){let b;const L=u.dataType;if(L===hz.e.ANIMATIONTYPE_VECTOR3){let u=z.value.al();if("rotation"===J){const z=H.p.Nl(u);u=H.f.RotationYawPitchRoll(z.y,z.x,z.z).al()}Y.push(u)}else if(L===hz.e.ANIMATIONTYPE_FLOAT){if("weights"===J)Y.push([z.value]);else if(b=this._ConvertFactorToVector3OrQuaternion(z.value,l,u,J,T),b){if("rotation"===J){const z=T?b:H.f.RotationYawPitchRoll(b.y,b.x,b.z).normalize();Y.push(z.al())}Y.push(b.al())}}else L===hz.e.ANIMATIONTYPE_QUATERNION?Y.push(z.value.normalize().al()):E.e.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(z,u,Y){let H,E,J=!1;if("rotation"===u&&!Y)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let l=0,T=z.length;l<T;++l)if(E=z[l],E.inTangent||E.outTangent)if(H){if("CUBICSPLINE"!==H){H="LINEAR",J=!0;break}}else H="CUBICSPLINE";else if(H){if("CUBICSPLINE"===H||E.interpolation&&1===E.interpolation&&"STEP"!==H){H="LINEAR",J=!0;break}}else H=E.interpolation&&1===E.interpolation?"STEP":"LINEAR";return H||(H="LINEAR"),{interpolationType:H,shouldBakeAnimation:J}}static _AddSplineTangent(z,u,Y,E,J,l){let T;const b=z===gz.INTANGENT?J.inTangent:J.outTangent;if("CUBICSPLINE"===E){if("rotation"===Y)if(b)if(l)T=b.al();else{const z=b;T=H.f.RotationYawPitchRoll(z.y,z.x,z.z).al()}else T=[0,0,0,0];else T="weights"===Y?b?[b]:[0]:b?b.al():[0,0,0];u.push(T)}}static _CalculateMinMaxKeyFrames(z){let u=1/0,Y=-1/0;return z.forEach((function(z){u=Math.min(u,z.frame),Y=Math.max(Y,z.frame)})),{min:u,max:Y}}}function Zz(z,u,Y,J,l,T){const b={attributes:{},influence:z.influence,name:z.name},L=u.Sl;if(!L)return E.e.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),b;const g=T?-1:1,M=H.p.Zero();let q=0,C=0;if(z.hasPositions){const J=z.getPositions(),T=L.getVerticesData(D.f.PositionKind);if(T){const z=new Float32Array(T.length),u=[1/0,1/0,1/0],E=[-1/0,-1/0,-1/0];C=T.length/3,q=0;for(let Y=q;Y<C;++Y){const l=H.p.Nl(T,3*Y);H.p.Nl(J,3*Y).subtractToRef(l,M),M.x*=g,u[0]=Math.min(u[0],M.x),E[0]=Math.max(E[0],M.x),u[1]=Math.min(u[1],M.y),E[1]=Math.max(E[1],M.y),u[2]=Math.min(u[2],M.z),E[2]=Math.max(E[2],M.z),z[3*Y]=M.x,z[3*Y+1]=M.y,z[3*Y+2]=M.z}const L=Y.createBufferView(z,12),D=Y.createAccessor(L,"VEC3",5126,J.length/3,0,{min:u,max:E});l.push(D),b.attributes.POSITION=l.length-1}else E.e.Warn(`Morph target positions for mesh ${u.name} were not exported. Mesh does not have position vertex data`)}if(z.hasNormals){const J=z.getNormals(),T=L.getVerticesData(D.f.NormalKind);if(T){const z=new Float32Array(T.length);C=T.length/3,q=0;for(let Y=q;Y<C;++Y){const u=H.p.Nl(T,3*Y).normalize();H.p.Nl(J,3*Y).normalize().subtractToRef(u,M),z[3*Y]=M.x*g,z[3*Y+1]=M.y,z[3*Y+2]=M.z}const u=Y.createBufferView(z,12),E=Y.createAccessor(u,"VEC3",5126,J.length/3,0);l.push(E),b.attributes.NORMAL=l.length-1}else E.e.Warn(`Morph target normals for mesh ${u.name} were not exported. Mesh does not have normals vertex data`)}if(z.hasTangents){const J=z.getTangents(),T=L.getVerticesData(D.f.TangentKind);if(T){C=T.length/4;const z=new Float32Array(3*C);q=0;for(let Y=q;Y<C;++Y){const u=H.p.Nl(T,4*Y);N(u);const E=H.p.Nl(J,3*Y);N(E),E.subtractToRef(u,M),z[3*Y]=M.x*g,z[3*Y+1]=M.y,z[3*Y+2]=M.z}const u=Y.createBufferView(z,12),E=Y.createAccessor(u,"VEC3",5126,C,0);l.push(E),b.attributes.TANGENT=l.length-1}else E.e.Warn(`Morph target tangents for mesh ${u.name} were not exported. Mesh does not have tangents vertex data`)}if(z.hasColors){const J=z.getColors(),T=L.getVerticesData(D.f.ColorKind),g=L.getVertexBuffer(D.f.ColorKind);if(T&&g){const z=g.getSize();C=T.length/z;const u=new Float32Array(C*z);q=0;for(let Y=q;Y<C;++Y)if(3===z){const E=H.p.Nl(T,Y*z);H.p.Nl(J,Y*z).subtractToRef(E,M),u[3*Y]=M.x,u[3*Y+1]=M.y,u[3*Y+2]=M.z}else if(4===z){const E=new H.t,l=H.t.Nl(T,Y*z);H.t.Nl(J,Y*z).subtractToRef(l,E),u[4*Y]=E.x,u[4*Y+1]=E.y,u[4*Y+2]=E.z,u[4*Y+3]=E.w}else E.e.Warn(`Unsupported number of components for color attribute: ${z}`);const L=Y.createBufferView(u,4*z),D=Y.createAccessor(L,3===z?"VEC3":"VEC4",5126,C,0);l.push(D),b.attributes.COLOR_0=l.length-1}else E.e.Warn(`Morph target colors for mesh ${u.name} were not exported. Mesh does not have colors vertex data`)}return b}var sz=Y(11639),vz=Y(11568),iz=Y(11559),Xz=Y(10918);class Qz{}Qz.DEFAULT_COLOR=h.c.White(),Qz.DEFAULT_WIDTH_ATTENUATED=1,Qz.DEFAULT_WIDTH=.1;var Vz=Y(11389),Az=Y(11650);class xz{static ConvertPoints(z,u){if(z.length&&Array.isArray(z)&&"number"===typeof z[0])return[z];if(z.length&&Array.isArray(z[0])&&"number"===typeof z[0][0])return z;if(z.length&&!Array.isArray(z[0])&&z[0]instanceof H.p){const u=[];for(let Y=0;Y<z.length;Y++){const H=z[Y];u.push(H.x,H.y,H.z)}return[u]}if(z.length>0&&Array.isArray(z[0])&&z[0].length>0&&z[0][0]instanceof H.p){const u=[],Y=z;for(const z of Y)u.push(z.flatMap((z=>[z.x,z.y,z.z])));return u}if(z instanceof Float32Array){if(null!==u&&void 0!==u&&u.floatArrayStride){const Y=[],H=3*u.floatArrayStride;for(let u=0;u<z.length;u+=H){const E=new Array(H);for(let Y=0;Y<H;Y++)E[Y]=z[u+Y];Y.push(E)}return Y}return[Array.from(z)]}if(z.length&&z[0]instanceof Float32Array){const u=[];for(const Y of z)u.push(Array.from(Y));return u}return[]}static OmitZeroLengthPredicate(z,u,Y){const H=[];return u.JY(z).lengthSquared()>0&&H.push([z,u]),Y.JY(u).lengthSquared()>0&&H.push([u,Y]),z.JY(Y).lengthSquared()>0&&H.push([Y,z]),0===H.length?null:H}static OmitDuplicatesPredicate(z,u,Y,H){const E=[];return xz._SearchInPoints(z,u,H)||E.push([z,u]),xz._SearchInPoints(u,Y,H)||E.push([u,Y]),xz._SearchInPoints(Y,z,H)||E.push([Y,z]),0===E.length?null:E}static _SearchInPoints(z,u,Y){for(const l of Y)for(let Y=0;Y<l.length;Y++){var H,E,J;if(null!==(H=l[Y])&&void 0!==H&&H.equals(z))if(null!==(E=l[Y+1])&&void 0!==E&&E.equals(u)||null!==(J=l[Y-1])&&void 0!==J&&J.equals(u))return!0}return!1}static MeshesToLines(z,u){const Y=[];for(let E=0;E<z.length;E++){const J=z[E],l=J.getVerticesData(D.f.PositionKind),T=J.Il();if(l&&T)for(let z=0,b=0;z<T.length;z++){const L=3*T[b++],D=3*T[b++],g=3*T[b++],M=new H.p(l[L],l[L+1],l[L+2]),q=new H.p(l[D],l[D+1],l[D+2]),C=new H.p(l[g],l[g+1],l[g+2]);if(u){const H=u(M,q,C,Y,z,L,J,E,l,T);if(H)for(const z of H)Y.push(z)}else Y.push([M,q],[q,C],[C,M])}}return Y}static ToVector3Array(z){if(Array.isArray(z[0])){const u=[],Y=z;for(const z of Y){const Y=[];for(let u=0;u<z.length;u+=3)Y.push(new H.p(z[u],z[u+1],z[u+2]));u.push(Y)}return u}const u=z,Y=[];for(let E=0;E<u.length;E+=3)Y.push(new H.p(u[E],u[E+1],u[E+2]));return Y}static ToNumberArray(z){return z.flatMap((z=>[z.x,z.y,z.z]))}static GetPointsCountInfo(z){const u=new Array(z.length);let Y=0;for(let H=z.length;H--;)u[H]=z[H].length/3,Y+=u[H];return{total:Y,counts:u}}static GetLineLength(z){if(0===z.length)return 0;let u;u="number"===typeof z[0]?xz.ToVector3Array(z):z;const Y=H.i.Pl[0];let E=0;for(let H=0;H<u.length-1;H++){const z=u[H];E+=u[H+1].subtractToRef(z,Y).length()}return E}static GetLineLengthArray(z){const u=new Float32Array(z.length/3);let Y=0;for(let H=0,E=z.length/3-1;H<E;H++){let E=z[3*H+0],J=z[3*H+1],l=z[3*H+2];E-=z[3*H+3],J-=z[3*H+4],l-=z[3*H+5];Y+=Math.sqrt(E*E+J*J+l*l),u[H+1]=Y}return u}static SegmentizeSegmentByCount(z,u,Y){const E=[],J=u.JY(z),l=H.i.Pl[0];l.Bl(Y);const T=H.i.Pl[1];J.divideToRef(l,T);let b=z.clone();E.push(b);for(let H=0;H<Y;H++)b=b.clone(),E.push(b.addInPlace(T));return E}static SegmentizeLineBySegmentLength(z,u){const Y=z[0]instanceof H.p?xz.GetLineSegments(z):"number"===typeof z[0]?xz.GetLineSegments(xz.ToVector3Array(z)):z,E=[];for(const H of Y)if(H.length>u){const z=xz.SegmentizeSegmentByCount(H.point1,H.point2,Math.ceil(H.length/u));for(const u of z)E.push(u)}else E.push(H.point1),E.push(H.point2);return E}static SegmentizeLineBySegmentCount(z,u){const Y="number"===typeof z[0]?xz.ToVector3Array(z):z,H=xz.GetLineLength(Y)/u;return xz.SegmentizeLineBySegmentLength(Y,H)}static GetLineSegments(z){const u=[];for(let Y=0;Y<z.length-1;Y++){const H=z[Y],E=z[Y+1],J=E.JY(H).length();u.push({point1:H,point2:E,length:J})}return u}static GetMinMaxSegmentLength(z){const u=xz.GetLineSegments(z).sort((z=>z.length));return{min:u[0].length,max:u[u.length-1].length}}static GetPositionOnLineByVisibility(z,u,Y){let E=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const J=u*Y;let l=0,T=0;const b=z.length;for(let H=0;H<b;H++){if(J<=l+z[H].length){T=H;break}l+=z[H].length}const L=(J-l)/z[T].length;return z[T].point2.subtractToRef(z[T].point1,H.i.Pl[0]),H.i.Pl[1]=H.i.Pl[0].multiplyByFloats(L,L,L),E||H.i.Pl[1].addInPlace(z[T].point1),H.i.Pl[1].clone()}static GetCircleLinePoints(z,u){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z,J=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/u;const l=[];for(let T=0;T<=u;T++)l.push(new H.p(Math.cos(T*J)*z,Math.sin(T*J)*E,Y));return l}static GetBezierLinePoints(z,u,Y,H){return Vz.d.CreateQuadraticBezier(z,u,Y,H).getPoints().flatMap((z=>[z.x,z.y,z.z]))}static GetArrowCap(z,u,Y,H,E){let J=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[z.clone(),z.add(u.multiplyByFloats(Y,Y,Y))],widths:[H,E,J,l]}}static GetPointsFromText(z,u,Y,H){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,J=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const l=[],T=(0,Az.d)(z,u,Y,H);for(const b of T){for(const z of b.paths){const u=[],Y=z.getPoints();for(const z of Y)u.push(z.x,z.y,E);l.push(u)}if(J)for(const z of b.holes){const u=[],Y=z.getPoints();for(const z of Y)u.push(z.x,z.y,E);l.push(u)}}return l}static Color3toRGBAUint8(z){const u=new Uint8Array(4*z.length);for(let Y=0,H=0;Y<z.length;Y++)u[H++]=255*z[Y].r,u[H++]=255*z[Y].g,u[H++]=255*z[Y].b,u[H++]=255;return u}static CreateColorsTexture(z,u,Y,H){const E=H.getEngine().getCaps().maxTextureSize??1,J=u.length>E?E:u.length,l=Math.ceil(u.length/E);l>1&&(u=[...u,...Array(J*l-u.length).fill(u[0])]);const T=xz.Color3toRGBAUint8(u),b=new s.e(T,J,l,C.b.TEXTUREFORMAT_RGBA,H,!1,!0,Y);return b.name=z,b}static PrepareEmptyColorsTexture(z){if(!Qz.EmptyColorsTexture){const u=new Uint8Array(4);Qz.EmptyColorsTexture=new s.e(u,1,1,C.b.TEXTUREFORMAT_RGBA,z,!1,!1,s.e.NEAREST_NEAREST),Qz.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Qz.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var z;null===(z=Qz.EmptyColorsTexture)||void 0===z||z.dispose(),Qz.EmptyColorsTexture=null}static BooleanToNumber(z){return z?1:0}}class Gz extends iz.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Fz extends vz.b{isCompatible(z){return!0}constructor(z,u,Y){var E;Y=Y||{color:Qz.DEFAULT_COLOR};const J=new Gz;J.GREASED_LINE_HAS_COLOR=!!Y.color&&!Y.useColors,J.GREASED_LINE_SIZE_ATTENUATION=Y.sizeAttenuation??!1,J.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===Y.colorDistributionType,J.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(u??z.iz()).useRightHandedSystem,J.GREASED_LINE_CAMERA_FACING=Y.cameraFacing??!0,super(z,Fz.GREASED_LINE_MATERIAL_NAME,200,J,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(E=Y)||void 0===E?void 0:E.forceGLSL)||Fz.ForceGLSL,this._scene=u??z.iz(),this._engine=this._scene.getEngine(),this._cameraFacing=Y.cameraFacing??!0,this.visibility=Y.visibility??1,this.useDash=Y.useDash??!1,this.dashRatio=Y.dashRatio??.5,this.dashOffset=Y.dashOffset??0,this.width=Y.width?Y.width:Y.sizeAttenuation?Qz.DEFAULT_WIDTH_ATTENUATED:Qz.DEFAULT_WIDTH,this._sizeAttenuation=Y.sizeAttenuation??!1,this.colorMode=Y.colorMode??0,this._color=Y.color??null,this.useColors=Y.useColors??!1,this._colorsDistributionType=Y.colorDistributionType??0,this.colorsSampling=Y.colorsSampling??s.e.NEAREST_NEAREST,this._colors=Y.Az??null,this.dashCount=Y.dashCount??1,this.resolution=Y.resolution??new H.m(this._engine.getRenderWidth(),this._engine.getRenderHeight()),Y.colorsTexture?this.colorsTexture=Y.colorsTexture:this._colors?this.colorsTexture=xz.CreateColorsTexture(`${z.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Qz.DEFAULT_COLOR,xz.PrepareEmptyColorsTexture(this._scene)),this._engine.fl.add((()=>{xz.DisposeEmptyColorsTexture()}))}getAttributes(z){z.push("grl_offsets"),z.push("grl_widths"),z.push("grl_colorPointers"),z.push("grl_counters"),this._cameraFacing?(z.push("grl_previousAndSide"),z.push("grl_nextAndCounters")):z.push("grl_slopes")}getSamplers(z){z.push("grl_colors")}getActiveTextures(z){this.colorsTexture&&z.push(this.colorsTexture)}getUniforms(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const u=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&u.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===z&&u.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:u,vertex:this._cameraFacing&&this._isGLSL(z)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(z)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(z){if(this._cameraFacing){z.rl("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||z.rl("viewProjection",this._scene.getTransformMatrix());const u=H.i.Vector4[0];u.x=this._aspect,u.y=this._resolution.x,u.z=this._resolution.y,u.w=this.width,z.updateVector4("grl_aspect_resolution_lineWidth",u)}const u=H.i.Vector4[0];u.x=xz.BooleanToNumber(this.useDash),u.y=this._dashArray,u.z=this.dashOffset,u.w=this.dashRatio,z.updateVector4("grl_dashOptions",u);const Y=H.i.Vector4[1];Y.x=this.colorMode,Y.y=this.visibility,Y.z=this.colorsTexture?this.colorsTexture.getSize().width:0,Y.w=xz.BooleanToNumber(this.useColors),z.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",Y),this._color&&z.updateColor3("grl_singleColor",this._color);const E=this.colorsTexture??Qz.EmptyColorsTexture;z.setTexture("grl_colors",E),z.updateFloat2("grl_textureSize",(null===E||void 0===E?void 0:E.getSize().width)??1,(null===E||void 0===E?void 0:E.getSize().height)??1)}prepareDefines(z,u,Y){z.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,z.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=u.useRightHandedSystem,z.GREASED_LINE_CAMERA_FACING=this._cameraFacing,z.GREASED_LINE_USE_OFFSETS=!!Y.offsets}getClassName(){return Fz.GREASED_LINE_MATERIAL_NAME}getCustomCode(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(u)?function(z,u){if("vertex"===z){const z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return u&&(z["!gl_Position\\=viewProjection\\*worldPos;"]="//"),z}return"fragment"===z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(z,this._cameraFacing):function(z,u){if("vertex"===z){const z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return u&&(z["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),z}return"fragment"===z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(z,this._cameraFacing)}dispose(){var z;null===(z=this.colorsTexture)||void 0===z||z.dispose(),super.dispose()}get Az(){return this._colors}set Az(z){this.setColors(z)}setColors(z){var u;let Y=arguments.length>1&&void 0!==arguments[1]&&arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(u=this._colors)||void 0===u?void 0:u.length)??0;var J;if(this._colors=z,null!==z&&0!==z.length){if(!Y||H)if(this.colorsTexture&&E===z.length&&!H){const u=xz.Color3toRGBAUint8(z);this.colorsTexture.update(u)}else{var l;null===(l=this.colorsTexture)||void 0===l||l.dispose(),this.colorsTexture=xz.CreateColorsTexture(`${this._material.name}-colors-texture`,z,this.colorsSampling,this._scene)}}else null===(J=this.colorsTexture)||void 0===J||J.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(z){this._dashCount=z,this._dashArray=1/z}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(z){this._sizeAttenuation=z,this.markAllDefinesAsDirty()}get color(){return this._color}set color(z){this.setColor(z)}setColor(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==z||null!==this._color&&null===z?(this._color=z,u||this.markAllDefinesAsDirty()):this._color=z}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(z){this._colorsDistributionType=z,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(z){this._aspect=z.x/z.y,this._resolution=z}serialize(){const z=super.serialize(),u={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(u.Az=this._colors),this._color&&(u.color=this._color),z.greasedLineMaterialOptions=u,z}parse(z,u,Y){var H;super.parse(z,u,Y);const E=z.greasedLineMaterialOptions;null===(H=this.colorsTexture)||void 0===H||H.dispose(),E.color&&this.setColor(E.color,!0),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.Az&&(this.Az=E.Az),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),this.Az?this.colorsTexture=xz.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Az,this.colorsSampling,u):xz.PrepareEmptyColorsTexture(u),this.markAllDefinesAsDirty()}copyTo(z){var u;const Y=z;null===(u=Y.colorsTexture)||void 0===u||u.dispose(),this._colors&&(Y.colorsTexture=xz.CreateColorsTexture(`${Y._material.name}-colors-texture`,this._colors,Y.colorsSampling,this._scene)),Y.setColor(this.color,!0),Y.colorsDistributionType=this.colorsDistributionType,Y.colorsSampling=this.colorsSampling,Y.colorMode=this.colorMode,Y.useColors=this.useColors,Y.visibility=this.visibility,Y.useDash=this.useDash,Y.dashCount=this.dashCount,Y.dashRatio=this.dashRatio,Y.dashOffset=this.dashOffset,Y.width=this.width,Y.sizeAttenuation=this.sizeAttenuation,Y.resolution=this.resolution,Y.markAllDefinesAsDirty()}_isGLSL(z){return 0===z||this._forceGLSL}}Fz.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Fz.ForceGLSL=!1,(0,Xz.d)(`BABYLON.${Fz.GREASED_LINE_MATERIAL_NAME}`,Fz);var Rz=Y(11231),wz=Y(10959),cz=Y(11643),Uz=Y(11049);class Oz extends cz.b{constructor(z,u,E){const J=u.getEngine(),l=J.isWebGPU&&!(E.forceGLSL||Oz.ForceGLSL),T=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];u.useRightHandedSystem&&T.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const b=["position","grl_widths","grl_offsets","grl_colorPointers"];E.cameraFacing?(T.push("GREASED_LINE_CAMERA_FACING"),b.push("grl_previousAndSide","grl_nextAndCounters")):(b.push("grl_slopes"),b.push("grl_counters"));const L=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(l||L.push("world","viewProjection","view","projection"),super(z,u,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:l?["Scene","Mesh"]:void 0,attributes:b,uniforms:L,samplers:l?[]:["grlColors"],defines:T,extraInitializationsAsync:async()=>{l?await Promise.all([Y.e(47).then(Y.bind(Y,13895)),Y.e(55).then(Y.bind(Y,13900))]):await Promise.all([Y.e(50).then(Y.bind(Y,13904)),Y.e(56).then(Y.bind(Y,13911))])},shaderLanguage:l?1:0}),this._color=h.c.White(),this._colorsDistributionType=0,this._colorsTexture=null,E=E||{color:Qz.DEFAULT_COLOR},this.visibility=E.visibility??1,this.useDash=E.useDash??!1,this.dashRatio=E.dashRatio??.5,this.dashOffset=E.dashOffset??0,this.dashCount=E.dashCount??1,this.width=E.width?E.width:E.sizeAttenuation&&E.cameraFacing?Qz.DEFAULT_WIDTH_ATTENUATED:Qz.DEFAULT_WIDTH,this.sizeAttenuation=E.sizeAttenuation??!1,this.color=E.color??h.c.White(),this.useColors=E.useColors??!1,this.colorsDistributionType=E.colorDistributionType??0,this.colorsSampling=E.colorsSampling??s.e.NEAREST_NEAREST,this.colorMode=E.colorMode??0,this._colors=E.Az??null,this._cameraFacing=E.cameraFacing??!0,this.resolution=E.resolution??new H.m(J.getRenderWidth(),J.getRenderHeight()),E.colorsTexture?this.colorsTexture=E.colorsTexture:this._colors?this.colorsTexture=xz.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,u):(this._color=this._color??Qz.DEFAULT_COLOR,this.colorsTexture=xz.PrepareEmptyColorsTexture(u)),l){const z=new Uz.c;z.setParameters(),z.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",z)}J.fl.add((()=>{xz.DisposeEmptyColorsTexture()}))}dispose(){var z;null===(z=this._colorsTexture)||void 0===z||z.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new H.m(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Az(){return this._colors}set Az(z){this.setColors(z)}setColors(z){var u;let Y=arguments.length>1&&void 0!==arguments[1]&&arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const E=(null===(u=this._colors)||void 0===u?void 0:u.length)??0;var J;if(this._colors=z,null!==z&&0!==z.length){if(!Y||H)if(this._colorsTexture&&E===z.length&&!H){const u=xz.Color3toRGBAUint8(z);this._colorsTexture.update(u)}else{var l;null===(l=this._colorsTexture)||void 0===l||l.dispose(),this.colorsTexture=xz.CreateColorsTexture(`${this.name}-colors-texture`,z,this.colorsSampling,this.iz())}}else null===(J=this._colorsTexture)||void 0===J||J.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(z){this._colorsTexture=z,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(z){this._width=z,this.setFloat("grlWidth",z)}get useColors(){return this._useColors}set useColors(z){this._useColors=z,this.setFloat("grlUseColors",xz.BooleanToNumber(z))}get colorsSampling(){return this._colorsSampling}set colorsSampling(z){this._colorsSampling=z}get visibility(){return this._visibility}set visibility(z){this._visibility=z,this.setFloat("grlVisibility",z)}get useDash(){return this._useDash}set useDash(z){this._useDash=z,this.setFloat("grlUseDash",xz.BooleanToNumber(z))}get dashOffset(){return this._dashOffset}set dashOffset(z){this._dashOffset=z,this.setFloat("grlDashOffset",z)}get dashRatio(){return this._dashRatio}set dashRatio(z){this._dashRatio=z,this.setFloat("grlDashRatio",z)}get dashCount(){return this._dashCount}set dashCount(z){this._dashCount=z,this._dashArray=1/z,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(z){this._sizeAttenuation=z,this.setFloat("grlSizeAttenuation",xz.BooleanToNumber(z))}get color(){return this._color}set color(z){this.setColor(z)}setColor(z){z=z??Qz.DEFAULT_COLOR,this._color=z,this.setColor3("grlColor",z)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(z){this._colorsDistributionType=z,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(z){this._colorMode=z,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(z){this._resolution=z,this.setVector2("grlResolution",z),this.setFloat("grlAspect",z.x/z.y)}serialize(){const z=super.serialize(),u={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(u.Az=this._colors),z.greasedLineMaterialOptions=u,z}parse(z,u,Y){var H;const E=z.greasedLineMaterialOptions;null===(H=this._colorsTexture)||void 0===H||H.dispose(),E.color&&(this.color=E.color),E.colorDistributionType&&(this.colorsDistributionType=E.colorDistributionType),E.colorsSampling&&(this.colorsSampling=E.colorsSampling),E.colorMode&&(this.colorMode=E.colorMode),E.useColors&&(this.useColors=E.useColors),E.visibility&&(this.visibility=E.visibility),E.useDash&&(this.useDash=E.useDash),E.dashCount&&(this.dashCount=E.dashCount),E.dashRatio&&(this.dashRatio=E.dashRatio),E.dashOffset&&(this.dashOffset=E.dashOffset),E.width&&(this.width=E.width),E.sizeAttenuation&&(this.sizeAttenuation=E.sizeAttenuation),E.resolution&&(this.resolution=E.resolution),E.Az?this.colorsTexture=xz.CreateColorsTexture(`${this.name}-colors-texture`,E.Az,this.colorsSampling,this.iz()):this.colorsTexture=xz.PrepareEmptyColorsTexture(u),this._cameraFacing=E.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var nz,mz,pz;Oz.ForceGLSL=!1,function(z){z[z.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",z[z.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(nz||(nz={})),function(z){z[z.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",z[z.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",z[z.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(mz||(mz={})),function(z){z[z.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",z[z.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",z[z.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",z[z.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",z[z.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(pz||(pz={}));class Sz extends dz.b{constructor(z,u,Y){super(z,u,null,null,!1,!1),this.name=z,this._options=Y,this._lazy=!1,this._updatable=!1,this._engine=u.getEngine(),this._lazy=Y.lazy??!1,this._updatable=Y.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=Y.colorPointers??[],this._widths=Y.widths??new Array(Y.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(z){let u=0;for(const H of this._points)u+=H.length;const Y=u/3*2-this._widths.length;for(let H=0;H<Y;H++)this._widths.push(z)}updateLazy(){var z,u;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(z=this._options.ribbonOptions)||void 0===z?void 0:z.smoothShading),!this.Rz&&this.refreshBoundingInfo(),null===(u=this.greasedLineMaterial)||void 0===u||u.updateLazy()}addPoints(z,u){for(const Y of z)this._points.push(Y);this._lazy||this.setPoints(this._points,u)}dispose(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(z,u)}isLazy(){return this._lazy}get xz(){return this._uvs}set xz(z){this._uvs=z instanceof Float32Array?z:new Float32Array(z),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(z){this.material instanceof Oz&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===z||void 0===z?void 0:z.length)>0),this._offsets=z,this._offsetsBuffer?this._offsetsBuffer.update(z):this._createOffsetsBuffer(z)}get widths(){return this._widths}set widths(z){this._widths=z,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(z)}get colorPointers(){return this._colorPointers}set colorPointers(z){this._colorPointers=z,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(z)}get greasedLineMaterial(){var z,u;if(this.material&&this.material instanceof Oz)return this.material;const Y=null===(z=this.material)||void 0===z||null===(u=z.pluginManager)||void 0===u?void 0:u.getPlugin(Fz.GREASED_LINE_MATERIAL_NAME);return Y||void 0}get points(){const z=[];return wz.b.DeepCopy(this._points,z),z}setPoints(z,u){this._points=xz.ConvertPoints(z,(null===u||void 0===u?void 0:u.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==u&&void 0!==u&&u.colorPointers||this._updateColorPointers(),this._setPoints(this._points,u)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,xz:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(z){super.serialize(z),z.type=this.getClassName(),z.lineOptions=this._createLineOptions()}_createVertexBuffers(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new Rz.e;return u.Qz=this._vertexPositions,u.indices=this._indices,u.xz=this._uvs,z&&(u.Vz=[],Rz.e.ComputeNormals(this._vertexPositions,this._indices,u.Vz)),u.Fz(this,this._options.updatable),u}_createOffsetsBuffer(z){const u=this._scene.getEngine(),Y=new D.d(u,z,this._updatable,3);this.setVerticesBuffer(Y.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=Y}}class Iz{constructor(z,u){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=z,this.wasAddedByNoopNode=u}getIndicesAccessor(z,u,Y,H,E){var J,l,T,b;return null===(J=this._indicesAccessorMap.get(z))||void 0===J||null===(l=J.get(u))||void 0===l||null===(T=l.get(Y))||void 0===T||null===(b=T.get(H))||void 0===b?void 0:b.get(E)}setIndicesAccessor(z,u,Y,H,E,J){let l=this._indicesAccessorMap.get(z);l||(l=new Map,this._indicesAccessorMap.set(z,l));let T=l.get(u);T||(T=new Map,l.set(u,T));let b=T.get(Y);b||(b=new Map,T.set(Y,b));let L=b.get(H);L||(L=new Map,b.set(H,L)),L.set(E,J)}pushExportedNode(z){this._exportedNodes.has(z)||this._exportedNodes.add(z)}getNodesSet(){return this._exportedNodes}getVertexBufferView(z){return this._vertexBufferViewMap.get(z)}setVertexBufferView(z,u){this._vertexBufferViewMap.set(z,u)}setRemappedBufferView(z,u,Y){this._remappedBufferView.set(z,new Map),this._remappedBufferView.get(z).set(u,Y)}getRemappedBufferView(z,u){var Y;return null===(Y=this._remappedBufferView.get(z))||void 0===Y?void 0:Y.get(u)}getVertexAccessor(z,u,Y){var H,E;return null===(H=this._vertexAccessorMap.get(z))||void 0===H||null===(E=H.get(u))||void 0===E?void 0:E.get(Y)}setVertexAccessor(z,u,Y,H){let E=this._vertexAccessorMap.get(z);E||(E=new Map,this._vertexAccessorMap.set(z,E));let J=E.get(u);J||(J=new Map,E.set(u,J)),J.set(Y,H)}hasVertexColorAlpha(z){return this._vertexMapColorAlpha.get(z)||!1}setHasVertexColorAlpha(z,u){return this._vertexMapColorAlpha.set(z,u)}getMesh(z){return this._meshMap.get(z)}setMesh(z,u){this._meshMap.set(z,u)}bindMorphDataToMesh(z,u){const Y=this._meshMorphTargetMap.get(z)||[];this._meshMorphTargetMap.set(z,Y),-1===Y.indexOf(u)&&Y.push(u)}getMorphTargetsFromMesh(z){return this._meshMorphTargetMap.get(z)}}class yz{_ApplyExtension(z,u,Y,H){if(Y>=u.length)return Promise.resolve(z);const E=H(u[Y],z);return E?E.then((async z=>z?await this._ApplyExtension(z,u,Y+1,H):null)):this._ApplyExtension(z,u,Y+1,H)}_ApplyExtensions(z,u){const Y=[];for(const H of yz._ExtensionNames)Y.push(this._extensions[H]);return this._ApplyExtension(z,Y,0,u)}_extensionsPreExportTextureAsync(z,u,Y){return this._ApplyExtensions(u,((u,H)=>u.preExportTextureAsync&&u.preExportTextureAsync(z,H,Y)))}_extensionsPostExportNodeAsync(z,u,Y,H,E){return this._ApplyExtensions(u,((u,J)=>u.postExportNodeAsync&&u.postExportNodeAsync(z,J,Y,H,E,this._bufferManager)))}_extensionsPostExportMaterialAsync(z,u,Y){return this._ApplyExtensions(u,((u,H)=>u.postExportMaterialAsync&&u.postExportMaterialAsync(z,H,Y)))}_extensionsPostExportMaterialAdditionalTextures(z,u,Y){const H=[];for(const E of yz._ExtensionNames){const J=this._extensions[E];J.postExportMaterialAdditionalTextures&&H.push(...J.postExportMaterialAdditionalTextures(z,u,Y))}return H}_extensionsPostExportTextures(z,u,Y){for(const H of yz._ExtensionNames){const E=this._extensions[H];E.postExportTexture&&E.postExportTexture(z,u,Y)}}_extensionsPostExportMeshPrimitive(z){for(const u of yz._ExtensionNames){const Y=this._extensions[u];Y.postExportMeshPrimitive&&Y.postExportMeshPrimitive(z,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const z of yz._ExtensionNames){const u=this._extensions[z];u.preGenerateBinaryAsync&&await u.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(z){for(const u of yz._ExtensionNames){const Y=this._extensions[u];Y.enabled&&z(Y)}}_extensionsOnExporting(){this._forEachExtensions((z=>{var u,Y,H;z.wasUsed&&((u=this._glTF).extensionsUsed||(u.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(z.name)&&this._glTF.extensionsUsed.push(z.name),z.required&&((Y=this._glTF).extensionsRequired||(Y.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(z.name)&&this._glTF.extensionsRequired.push(z.name)),(H=this._glTF).extensions||(H.extensions={}),z.onExporting&&z.onExporting())}))}_loadExtensions(){for(const z of yz._ExtensionNames){const u=yz._ExtensionFactories[z](this);this._extensions[z]=u}}constructor(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:K.d.LastCreatedScene,u=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${C.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new U(this),this._extensions={},this._bufferManager=new Dz,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!z)throw new Error("No scene available to export");this._babylonScene=z,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:z=>{var u;return null===z||void 0===z||null===(u=z.zT)||void 0===u?void 0:u.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...u},this._loadExtensions()}dispose(){for(const z in this._extensions){this._extensions[z].dispose()}}get options(){return this._options}static RegisterExtension(z,u){yz.UnregisterExtension(z)&&E.e.Warn(`Extension with the name ${z} already exists`),yz._ExtensionFactories[z]=u,yz._ExtensionNames.push(z)}static UnregisterExtension(z){if(!yz._ExtensionFactories[z])return!1;delete yz._ExtensionFactories[z];const u=yz._ExtensionNames.indexOf(z);return-1!==u&&yz._ExtensionNames.splice(u,1),!0}_generateJSON(z,u,Y){const H={byteLength:z};return H.byteLength&&(this._glTF.buffers=[H]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Cu=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(H.uri=u+".bin"),Y?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(z){const u=await this._generateBinaryAsync();this._extensionsOnExporting();const Y=this._generateJSON(u.byteLength,z,!0),H=new Blob([u],{type:"application/octet-stream"}),E=z+".gltf",J=z+".bin",l=new L;if(l.files[E]=Y,l.files[J]=H,this._imageData)for(const T in this._imageData)l.files[T]=new Blob([this._imageData[T].data],{type:this._imageData[T].mimeType});return l}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(z){const u=z%4;return 0===u?u:4-u}async generateGLBAsync(z){this._shouldUseGlb=!0;const u=await this._generateBinaryAsync();this._extensionsOnExporting();const Y=this._generateJSON(u.byteLength),H=z+".glb";let E,J=Y.length;if("undefined"!==typeof TextEncoder){E=(new TextEncoder).encode(Y),J=E.length}const l=this._getPadding(J),T=this._getPadding(u.byteLength),b=28+J+l+u.byteLength+T,D=new bz(b);if(D.writeUInt32(1179937895),D.writeUInt32(2),D.writeUInt32(b),D.writeUInt32(J+l),D.writeUInt32(1313821514),E)D.writeTypedArray(E);else{const z="_".charCodeAt(0);for(let u=0;u<J;++u){const H=Y.charCodeAt(u);H!=Y.codePointAt(u)?D.writeUInt8(z):D.writeUInt8(H)}}for(let L=0;L<l;++L)D.writeUInt8(32);D.writeUInt32(u.byteLength+T),D.writeUInt32(5130562),D.writeTypedArray(u);for(let L=0;L<T;++L)D.writeUInt8(0);const g=new L;return g.files[H]=new Blob([D.getOutputData()],{type:"application/octet-stream"}),g}_setNodeTransformation(z,u,Y){if(u.getPivotPoint().equalsWithEpsilon(S,p.e)||E.e.Warn("Pivot points are not supported in the glTF serializer"),!u.position.equalsWithEpsilon(S,p.e)){const E=H.i.Pl[0].J(u.position);Y&&B(E),z.translation=E.al()}u.el.equalsWithEpsilon(y,p.e)||(z.scale=u.el.al());const J=u.rotationQuaternion||H.f.FromEulerAngles(u.rotation.x,u.rotation.y,u.rotation.z);J.equalsWithEpsilon(I,p.e)||(Y&&f(J),z.rotation=J.normalize().al())}_setCameraTransformation(z,u,Y){if(!u.position.equalsWithEpsilon(S,p.e)){const E=H.i.Pl[0].J(u.position);Y&&B(E),z.translation=E.al()}const E=u.rotationQuaternion||H.f.FromEulerAngles(u.rotation.x,u.rotation.y,u.rotation.z);Y&&f(E),this._babylonScene.useRightHandedSystem||r(E),E.equalsWithEpsilon(I,p.e)||(z.rotation=E.al())}_listAvailableCameras(){for(const z of this._babylonScene.cameras){const u={type:z.mode===Mz.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(z.name&&(u.name=z.name),"perspective"===u.type)u.perspective={aspectRatio:z.getEngine().getAspectRatio(z),yfov:z.fovMode===Mz.d.FOVMODE_VERTICAL_FIXED?z.fov:z.fov*z.getEngine().getAspectRatio(z),znear:z.uT,zfar:z.maxZ};else if("orthographic"===u.type){const Y=z.orthoLeft&&z.orthoRight?.5*(z.orthoRight-z.orthoLeft):.5*z.getEngine().getRenderWidth(),H=z.orthoBottom&&z.orthoTop?.5*(z.orthoTop-z.orthoBottom):.5*z.getEngine().getRenderHeight();u.orthographic={xmag:Y,ymag:H,znear:z.uT,zfar:z.maxZ}}this._camerasMap.set(z,u)}}_exportAndAssignCameras(){const z=Array.from(this._camerasMap.values());for(const u of z){const z=this._nodesCameraMap.get(u);if(void 0!==z){this._cameras.push(u);for(const u of z)u.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const z of this._babylonScene.skeletons){if(z.bones.length<=0)continue;const u={joints:[]};this._skinMap.set(z,u)}}_exportAndAssignSkeletons(){for(const z of this._babylonScene.skeletons){if(z.bones.length<=0)continue;const u=this._skinMap.get(z);if(void 0==u)continue;const Y={},H=[];let J=-1;for(let E=0;E<z.bones.length;++E){const u=z.bones[E],H=u.getIndex()??E;-1!==H&&(Y[H]=u,H>J&&(J=H))}for(let z=0;z<=J;++z){const J=Y[z];H.push(J.getAbsoluteInverseBindMatrix());const l=J.getTransformNode();if(null!==l){const z=this._nodeMap.get(l);l&&null!==z&&void 0!==z?u.joints.push(z):E.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}else E.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}const l=this._nodesSkinMap.get(u);if(u.joints.length>0&&void 0!==l){const z=64*H.length,Y=new Float32Array(z/4);H.forEach(((z,u)=>{Y.set(z.m,16*u)}));const E=this._bufferManager.createBufferView(Y);this._accessors.push(this._bufferManager.createAccessor(E,"MAT4",5126,H.length)),u.inverseBindMatrices=this._accessors.length-1,this._skins.push(u);for(const u of l)u.skin=this._skins.length-1}}}async _exportSceneAsync(){const z={nodes:[]};if(this._babylonScene.metadata){const u=this._options.metadataSelector(this._babylonScene.metadata);u&&(z.extras=u)}const u=new Array,Y=new Array,H=new Array;for(const T of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&lz(T,this._babylonScene.useRightHandedSystem)?H.push(...T.getChildren()):this._babylonScene.useRightHandedSystem?u.push(T):Y.push(T);this._listAvailableCameras(),this._listAvailableSkeletons();const E=new Iz(!0,!1);z.nodes.push(...await this._exportNodesAsync(Y,E));const J=new Iz(!1,!1);z.nodes.push(...await this._exportNodesAsync(u,J));const l=new Iz(!1,!0);z.nodes.push(...await this._exportNodesAsync(H,l)),z.nodes.length&&this._scenes.push(z),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Wz._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,E.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(z){let u=this._shouldExportNodeMap.get(z);return void 0===u&&(u=this._options.shouldExportNode(z),this._shouldExportNodeMap.set(z,u)),u}async _exportNodesAsync(z,u){const Y=new Array;this._exportBuffers(z,u);for(const H of z)await this._exportNodeAsync(H,Y,u);return Y}_collectBuffers(z,u,Y,H,E){if(this._shouldExportNode(z)&&z instanceof M.b&&z.Sl){const J=z.Sl.getVertexBuffers();if(J)for(const H in J){if(!P(H))continue;const l=J[H];E.setHasVertexColorAlpha(l,z.hasVertexAlpha);const T=l._buffer,b=u.get(T)||[];u.set(T,b),-1===b.indexOf(l)&&b.push(l);const L=Y.get(l)||[];Y.set(l,L),-1===L.indexOf(z)&&L.push(z)}const l=z.morphTargetManager;if(l)for(let u=0;u<l.numTargets;u++){const Y=l.getTarget(u),E=H.get(Y)||[];H.set(Y,E),-1===E.indexOf(z)&&E.push(z)}}for(const J of z.getChildren())this._collectBuffers(J,u,Y,H,E)}_exportBuffers(z,u){const Y=new Map,H=new Map,E=new Map;for(const T of z)this._collectBuffers(T,Y,H,E,u);const J=Array.from(Y.keys());for(const T of J){const z=T.getData();if(!z)throw new Error("Buffer data is not available");const E=Y.get(T);if(!E)continue;const J=E[0].byteStride;if(E.some((z=>z.byteStride!==J)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const l=Yz(z).slice();for(const u of E){const z=H.get(u),{byteOffset:Y,byteStride:E,componentCount:J,type:T,count:b,normalized:L,kind:g}=j(u,z);switch(g){case D.f.NormalKind:case D.f.TangentKind:(0,O.j)(l,Y,E,J,T,b,L,(z=>{const u=Math.sqrt(z[0]*z[0]+z[1]*z[1]+z[2]*z[2]);if(u>0){const Y=1/u;z[0]*=Y,z[1]*=Y,z[2]*=Y}}));break;case D.f.ColorKind:{const u=z.filter((z=>z.material instanceof Kz.e||null==z.material)).length;if(0==u)break;if(u!=z.length){n.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}T==D.f.UNSIGNED_BYTE&&n.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const H=new h.c,g=new h.e,M=this._babylonScene.getEngine().useExactSrgbConversions;(0,O.j)(l,Y,E,J,T,b,L,(z=>{3===z.length?(H.lY(z,0),H.toLinearSpaceToRef(H,M),H.toArray(z,0)):(g.lY(z,0),g.toLinearSpaceToRef(g,M),g.toArray(z,0))}))}}}if(u.convertToRightHanded){for(const z of E){const u=H.get(z),{byteOffset:Y,byteStride:E,componentCount:J,type:T,count:b,normalized:L,kind:g}=j(z,u);switch(g){case D.f.PositionKind:case D.f.NormalKind:case D.f.TangentKind:(0,O.j)(l,Y,E,J,T,b,L,(z=>{z[0]=-z[0]}))}}u.convertedToRightHandedBuffers.set(T,l)}const b=this._bufferManager.createBufferView(l,J);u.setVertexBufferView(T,b);const L=new Map;for(const u of E){const z=H.get(u),{kind:Y,totalVertices:E}=j(u,z);switch(Y){case D.f.MatricesIndicesKind:case D.f.MatricesIndicesExtraKind:if(u.type==D.f.FLOAT){const z=u.getFloatData(E);null!==z&&L.set(u,z)}}}0!==L.size&&n.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const g=Array.from(L.keys());for(const Y of g){const z=L.get(Y);if(!z)continue;const H=z.some((z=>z>=256)),E=new(H?Uint16Array:Uint8Array)(z.length);for(let u=0;u<z.length;u++)E[u]=z[u];const J=this._bufferManager.createBufferView(E,4*(H?2:1));u.setRemappedBufferView(T,Y,J)}}const l=Array.from(E.keys());for(const T of l){const z=E.get(T);if(!z)continue;const Y=Zz(T,z[0],this._bufferManager,this._bufferViews,this._accessors,u.convertToRightHanded);for(const H of z)u.bindMorphDataToMesh(H,Y)}}async _exportNodeAsync(z,u,Y){let H=this._nodeMap.get(z);if(void 0!==H)return void(u.includes(H)||u.push(H));const E=await this._createNodeAsync(z,Y);if(E){H=this._nodes.length,this._nodes.push(E),this._nodeMap.set(z,H),Y.pushExportedNode(z),u.push(H);const J={name:"runtime animations",channels:[],samplers:[]},l=[];this._babylonScene.animationGroups.length||(Wz._CreateMorphTargetAnimationFromMorphTargetAnimations(z,J,l,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Y.convertToRightHanded,this._options.shouldExportAnimation),z.animations.length&&Wz._CreateNodeAnimationFromNodeAnimations(z,J,l,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Y.convertToRightHanded,this._options.shouldExportAnimation)),J.channels.length&&J.samplers.length&&this._animations.push(J),l.forEach((z=>{z.channels.length&&z.samplers.length&&this._animations.push(z)}))}const J=E?[]:u;for(const l of z.getChildren())await this._exportNodeAsync(l,J,Y);E&&J.length&&(E.children=J)}async _createNodeAsync(z,u){if(!this._shouldExportNode(z))return null;const Y={};if(z.name&&(Y.name=z.name),z.metadata){const u=this._options.metadataSelector(z.metadata);u&&(Y.extras=u)}if(z instanceof g.d&&(this._setNodeTransformation(Y,z,u.convertToRightHanded),z instanceof M.b)){const E=z instanceof q.e?z.sourceMesh:z;if(E.YT&&E.YT.length>0&&(Y.mesh=await this._exportMeshAsync(E,u)),z.skeleton){const u=this._skinMap.get(z.skeleton);var H;if(void 0!==u)void 0===this._nodesSkinMap.get(u)&&this._nodesSkinMap.set(u,[]),null===(H=this._nodesSkinMap.get(u))||void 0===H||H.push(Y)}}if(z instanceof m.b){const H=this._camerasMap.get(z);if(H){var E;void 0===this._nodesCameraMap.get(H)&&this._nodesCameraMap.set(H,[]),this._setCameraTransformation(Y,z,u.convertToRightHanded);const l=z.parent;if(null!==l&&uz(z,l)){const z=this._nodeMap.get(l);if(void 0!==z){var J;const u=this._nodes[z];return zz(Y,u),null===(J=this._nodesCameraMap.get(H))||void 0===J||J.push(u),null}}null===(E=this._nodesCameraMap.get(H))||void 0===E||E.push(Y)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",Y,z,this._nodeMap,u.convertToRightHanded)?Y:(n.b.Warn(`Not exporting node ${z.name}`),null)}_exportIndices(z,u,Y,H,E,l,T,b,L){let D=z;L.mode=e(l);const g=T!==J.d.CounterClockWiseSideOrientation,M=!b.wasAddedByNoopNode&&g,q=function(z){switch(z){case J.d.TriangleFillMode:case J.d.TriangleStripDrawMode:case J.d.TriangleFanDrawMode:return!0}return!1}(l)&&M;if(q){if(l===J.d.TriangleStripDrawMode||l===J.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");L.mode=e(l);const T=u?new Uint32Array(H):new Uint16Array(H);if(z)for(let u=0;u+2<H;u+=3)T[u]=z[Y+u]+E,T[u+1]=z[Y+u+2]+E,T[u+2]=z[Y+u+1]+E;else for(let z=0;z+2<H;z+=3)T[z]=z,T[z+1]=z+2,T[z+2]=z+1;D=T}else if(z&&0!==E){const J=u?new Uint32Array(H):new Uint16Array(H);for(let u=0;u<H;u++)J[u]=z[Y+u]+E;D=J}if(D){let J=b.getIndicesAccessor(z,Y,H,E,q);if(void 0===J){const l=function(z,u,Y,H){if(z instanceof Uint16Array||z instanceof Uint32Array)return z;if(z instanceof Int32Array)return new Uint32Array(z.buffer,z.byteOffset,z.length);const E=z.slice(u,u+Y);return H?new Uint32Array(E):new Uint16Array(E)}(D,0,H,u),T=this._bufferManager.createBufferView(l),L=u?5125:5123;this._accessors.push(this._bufferManager.createAccessor(T,"SCALAR",L,H,0)),J=this._accessors.length-1,b.setIndicesAccessor(z,Y,H,E,q,J)}L.indices=J}}_exportVertexBuffer(z,u,Y,H,E,J){const l=z.getKind();if(!P(l))return;if(l.startsWith("uv")&&!this._options.exportUnusedUVs&&(!u||!this._materialNeedsUVsSet.has(u)))return;let T=E.getVertexAccessor(z,Y,H);if(void 0===T){const u=E.convertedToRightHandedBuffers.get(z._buffer)||z._buffer.getData(),J=l===D.f.PositionKind?function(z,u,Y,H){const{byteOffset:E,byteStride:J,type:l,normalized:T}=u,b=u.getSize(),L=new Array(b).fill(1/0),D=new Array(b).fill(-1/0);return(0,O.j)(z,E+Y*J,J,b,l,H*b,T,(z=>{for(let u=0;u<b;u++)L[u]=Math.min(L[u],z[u]),D[u]=Math.max(D[u],z[u])})),{min:L,max:D}}(u,z,Y,H):void 0,b=(l===D.f.MatricesIndicesKind||l===D.f.MatricesIndicesExtraKind)&&z.type===D.f.FLOAT,L=b?D.f.UNSIGNED_BYTE:z.type,g=b?void 0:z.normalized,M=b?E.getRemappedBufferView(z._buffer,z):E.getVertexBufferView(z._buffer),q=z.byteOffset+Y*z.byteStride;this._accessors.push(this._bufferManager.createAccessor(M,function(z,u){if(z==D.f.ColorKind)return u?"VEC4":"VEC3";switch(z){case D.f.PositionKind:case D.f.NormalKind:return"VEC3";case D.f.TangentKind:case D.f.MatricesIndicesKind:case D.f.MatricesIndicesExtraKind:case D.f.MatricesWeightsKind:case D.f.MatricesWeightsExtraKind:return"VEC4";case D.f.UVKind:case D.f.UV2Kind:case D.f.UV3Kind:case D.f.UV4Kind:case D.f.UV5Kind:case D.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${z}`)}(l,E.hasVertexColorAlpha(z)),L,H,q,J,g)),T=this._accessors.length-1,E.setVertexAccessor(z,Y,H,T)}J.attributes[function(z){switch(z){case D.f.PositionKind:return"POSITION";case D.f.NormalKind:return"NORMAL";case D.f.TangentKind:return"TANGENT";case D.f.ColorKind:return"COLOR_0";case D.f.UVKind:return"TEXCOORD_0";case D.f.UV2Kind:return"TEXCOORD_1";case D.f.UV3Kind:return"TEXCOORD_2";case D.f.UV4Kind:return"TEXCOORD_3";case D.f.UV5Kind:return"TEXCOORD_4";case D.f.UV6Kind:return"TEXCOORD_5";case D.f.MatricesIndicesKind:return"JOINTS_0";case D.f.MatricesIndicesExtraKind:return"JOINTS_1";case D.f.MatricesWeightsKind:return"WEIGHTS_0";case D.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${z}`)}(l)]=T}async _exportMaterialAsync(z,u,Y,H){let E=this._materialMap.get(z);if(void 0===E){const H=u&&Object.keys(u).some((z=>z.startsWith("uv")));if((z=z instanceof qz.d?z.HT[Y.materialIndex]:z)instanceof Cz.c)E=await this._materialExporter.exportPBRMaterialAsync(z,"image/png",H);else{if(!(z instanceof Kz.e))return void n.b.Warn(`Unsupported material '${z.name}' with type ${z.getClassName()}`);E=await this._materialExporter.exportStandardMaterialAsync(z,"image/png",H)}this._materialMap.set(z,E)}H.material=E}async _exportMeshAsync(z,u){var Y;let H=u.getMesh(z);if(void 0!==H)return H;const E={primitives:[]};H=this._meshes.length,this._meshes.push(E),u.setMesh(z,H);const l=z.isUnIndexed?null:z.Il(),T=null===(Y=z.Sl)||void 0===Y?void 0:Y.getVertexBuffers(),b=u.getMorphTargetsFromMesh(z),L=z instanceof sz.e,D=z instanceof Sz,g=z.YT;if(T&&g&&g.length>0)for(const C of g){const Y={attributes:{}},H=C.Oz()||this._babylonScene.defaultMaterial;if(D){var M,q;const u={name:H.name},E=z,J=h.c.White(),l=(null===(M=E.material)||void 0===M?void 0:M.alpha)??1,T=(null===(q=E.greasedLineMaterial)||void 0===q?void 0:q.color)??J;(!T.equalsWithEpsilon(J,p.e)||l<1)&&(u.pbrMetallicRoughness={baseColorFactor:[...T.al(),l]}),this._materials.push(u),Y.material=this._materials.length-1}else if(L){const u={name:H.name},E=z;(!E.color.equalsWithEpsilon(h.c.White(),p.e)||E.alpha<1)&&(u.pbrMetallicRoughness={baseColorFactor:[...E.color.al(),E.alpha]}),this._materials.push(u),Y.material=this._materials.length-1}else await this._exportMaterialAsync(H,T,C,Y);const g=L||D?J.d.LineListDrawMode:z.overrideRenderingFillMode??H.fillMode,K=H._getEffectiveOrientation(z);this._exportIndices(l,l?(0,O.e)(l,C.indexCount,C.indexStart,C.verticesStart):C.verticesCount>65535,l?C.indexStart:C.verticesStart,l?C.indexCount:C.verticesCount,-C.verticesStart,g,K,u,Y);for(const z of Object.values(T))this._exportVertexBuffer(z,H,C.verticesStart,C.verticesCount,u,Y);if(b){Y.targets=[];for(const z of b)Y.targets.push(z.attributes)}E.primitives.push(Y),this._extensionsPostExportMeshPrimitive(Y)}if(b){E.weights=[],E.extras||(E.extras={}),E.extras.targetNames=[];for(const z of b)E.weights.push(z.influence),E.extras.targetNames.push(z.name)}return H}}yz._ExtensionNames=new Array,yz._ExtensionFactories={};class az{static async GLTFAsync(z,u,Y){Y&&Y.exportWithoutWaitingForScene||await z.whenReadyAsync();const H=new yz(z,Y),E=await H.generateGLTFAsync(u.replace(/\.[^/.]+$/,""));return H.dispose(),E}static async GLBAsync(z,u,Y){Y&&Y.exportWithoutWaitingForScene||await z.whenReadyAsync();const H=new yz(z,Y),E=await H.generateGLBAsync(u.replace(/\.[^/.]+$/,""));return H.dispose(),E}}Y(11657);const jz="EXT_mesh_gpu_instancing";class kz{constructor(z){this.name=jz,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(z,u,Y,E,J,l){return await new Promise((z=>{if(u&&Y instanceof dz.b&&Y.hasThinInstances&&this._exporter){this._wasUsed=!0;const z=H.p.Zero(),E=H.f.Identity(),T=H.p.One(),b=Y.thinInstanceGetWorldMatrices(),L=H.i.Pl[2],D=H.i.Quaternion[1],g=H.i.Pl[3];let M=!1,q=!1,C=!1;const K=new Float32Array(3*Y.ET),h=new Float32Array(4*Y.ET),o=new Float32Array(3*Y.ET);let d=0;for(const u of b)u.decompose(g,D,L),J&&(B(L),f(D)),K.set(L.al(),3*d),h.set(D.normalize().al(),4*d),o.set(g.al(),3*d),M=M||!L.equalsWithEpsilon(z),q=q||!D.equalsWithEpsilon(E),C=C||!g.equalsWithEpsilon(T),d++;const t={attributes:{}};M&&(t.attributes.TRANSLATION=this._buildAccessor(K,"VEC3",Y.ET,l)),q&&(t.attributes.ROTATION=this._buildAccessor(h,"VEC4",Y.ET,l)),C&&(t.attributes.SCALE=this._buildAccessor(o,"VEC3",Y.ET,l)),u.extensions=u.extensions||{},u.extensions[jz]=t}z(u)}))}_buildAccessor(z,u,Y,H){const E=H.createBufferView(z),J=H.createAccessor(E,u,5126,Y);return this._exporter._accessors.push(J),this._exporter._accessors.length-1}}yz.RegisterExtension(jz,(z=>new kz(z)));var Pz=Y(11662),ez=Y(11672),Nz=Y(11674),Bz=Y(11682);function fz(z){return z===Nz.b.PositionKind?"POSITION":z===Nz.b.NormalKind?"NORMAL":z===Nz.b.ColorKind?"COLOR":z.startsWith(Nz.b.UVKind)?"TEX_COORD":"GENERIC"}const rz={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class zu extends Pz.b{static get DefaultAvailable(){return(0,Pz.i)(zu.DefaultConfiguration)}static get Default(){return zu._Default??(zu._Default=new zu),zu._Default}static ResetDefault(z){zu._Default&&(z||zu._Default.dispose(),zu._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(z,u){return{module:await(u||DracoEncoderModule)({wasmBinary:z})}}_getWorkerContent(){return`${ez.j}(${ez.n})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:zu.DefaultConfiguration)}async _encodeAsync(z,u,Y){const H=Y?(0,Bz.e)(rz,Y):rz;if(this._workerPoolPromise){const Y=await this._workerPoolPromise;return await new Promise(((E,J)=>{Y.push(((Y,l)=>{const T=z=>{Y.removeEventListener("error",T),Y.removeEventListener("message",b),J(z),l()},b=z=>{"encodeMeshDone"===z.data.id&&(Y.removeEventListener("error",T),Y.removeEventListener("message",b),E(z.data.encodedMeshData),l())};Y.addEventListener("error",T),Y.addEventListener("message",b);const L=[];for(const u of z)L.push(u.data.buffer);u&&L.push(u.buffer),Y.postMessage({id:"encodeMesh",attributes:z,indices:u,options:H},L)}))}))}if(this._modulePromise){const Y=await this._modulePromise;return(0,ez.j)(Y.module,z,u,H)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(z,u){if(0==z.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");z instanceof dz.b&&z.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===u||void 0===u?void 0:u.method)&&(n.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),u.method="MESH_SEQUENTIAL_ENCODING");const Y=function(z){let u=z.Il(void 0,!0);return!u||u instanceof Uint32Array||u instanceof Uint16Array||(u=((0,O.e)(u,u.length)?Uint32Array:Uint16Array).from(u)),u}(z),H=function(z,u){const Y=[];for(const H of z.getVerticesDataKinds()){if(null!==u&&void 0!==u&&u.includes(H)){if(H===Nz.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const E=z.getVertexBuffer(H),J=E.getSize(),l=(0,O.t)(E.getData(),J,E.type,E.byteOffset,E.byteStride,E.normalized,z.getTotalVertices(),!0);Y.push({kind:H,dracoName:fz(H),size:J,data:l})}return Y}(z,null===u||void 0===u?void 0:u.excludedAttributes);return await this._encodeAsync(H,Y,u)}}zu.DefaultConfiguration={wasmUrl:`${E.e._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${E.e._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${E.e._DefaultCdnUrl}/draco_encoder.js`},zu._Default=null;const uu="KHR_draco_mesh_compression";class Yu{get wasUsed(){return this._wasUsed}constructor(z){this.name=uu,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===z.options.meshCompressionMethod&&zu.DefaultAvailable}dispose(){}postExportMeshPrimitive(z,u,Y){if(!this.enabled)return;if(4!==z.mode&&5!==z.mode)return void n.b.Warn("Cannot compress primitive with mode "+z.mode+".");const H=[],E=[];let J=null;if(void 0!==z.indices){const l=Y[z.indices],T=u.getBufferView(l);J=u.getData(T).slice(),H.push(T),E.push(l)}const l=[];for(const[D,g]of Object.entries(z.attributes)){const z=Y[g],J=u.getBufferView(z),b=k(z.type),L=(0,O.t)(u.getData(J),b,z.componentType,z.byteOffset||0,J.byteStride||(0,O.o)(z.componentType)*b,z.normalized||!1,z.count,!0);l.push({kind:D,dracoName:(T=D,"POSITION"===T?"POSITION":"NORMAL"===T?"NORMAL":T.startsWith("COLOR")?"COLOR":T.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:k(z.type),data:L}),H.push(J),E.push(z)}var T;const b={method:z.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},L=zu.Default._encodeAsync(l,J,b).then((Y=>{if(!Y)return void n.b.Error("Draco encoding failed for primitive.");const J={bufferView:-1,attributes:Y.attributeIds},l=u.createBufferView(Y.data);u.setBufferView(J,l);for(const z of H)this._bufferViewsUsed.add(z);for(const z of E)this._accessorsUsed.add(z);z.extensions||(z.extensions={}),z.extensions[uu]=J})).catch((z=>{n.b.Error("Draco encoding failed for primitive: "+z)}));this._encodePromises.push(L),this._wasUsed=!0}async preGenerateBinaryAsync(z){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((u=>{z.getPropertiesWithBufferView(u).every((z=>this._accessorsUsed.has(z)))&&z.removeBufferView(u)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}yz.RegisterExtension(uu,(z=>new Yu(z)));var Hu=Y(11690);const Eu="KHR_lights_punctual",Ju={name:"",color:[1,1,1],JT:1,range:Number.MAX_VALUE},lu={innerConeAngle:0,outerConeAngle:Math.PI/4},Tu=H.p.Backward();class bu{constructor(z){this.name=Eu,this.enabled=!0,this.required=!1,this._exporter=z}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Eu]=this._lights}async postExportNodeAsync(z,u,Y,E,J){return await new Promise((l=>{if(!(Y instanceof tz.e))return void l(u);const T=Y.getTypeID()==tz.e.LIGHTTYPEID_POINTLIGHT?"point":Y.getTypeID()==tz.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":Y.getTypeID()==tz.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!T||!(Y instanceof Hu.d))return n.b.Warn(`${z}: Light ${Y.name} is not supported in ${Eu}`),void l(u);if(Y.falloffType!==tz.e.FALLOFF_GLTF&&n.b.Warn(`${z}: Light falloff for ${Y.name} does not match the ${Eu} specification!`),!Y.position.equalsToFloats(0,0,0)){const z=H.i.Pl[0].J(Y.position);J&&B(z),u.translation=z.al()}if("point"!==T){const z=Y.direction.normalizeToRef(H.i.Pl[0]);J&&B(z);const E=H.f.FromUnitVectorsToRef(Tu,z,H.i.Quaternion[0]);H.f.IsIdentity(E)||(u.rotation=E.al())}const b={type:T,name:Y.name,color:Y.lT.al(),JT:Y.JT,range:Y.range};if(Hz(b,Ju),"spot"===T){const z=Y;b.spot={innerConeAngle:z.innerAngle/2,outerConeAngle:z.angle/2},Hz(b.spot,lu)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(b);const L={nl:this._lights.lights.length-1},D=Y.parent;if(D&&uz(Y,D)){const z=E.get(D);if(z){const Y=this._exporter._nodes[z];return zz(u,Y),Y.extensions||(Y.extensions={}),Y.extensions[Eu]=L,void l(null)}}u.extensions||(u.extensions={}),u.extensions[Eu]=L,l(u)}))}}yz.RegisterExtension(Eu,(z=>new bu(z)));var Lu=Y(11497);const Du="KHR_materials_anisotropy";class gu{constructor(z){this.name=Du,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,Y){const H=[];return Y instanceof Lu.e&&Y.anisotropy.isEnabled&&!Y.anisotropy.legacy?(Y.anisotropy.texture&&H.push(Y.anisotropy.texture),H):[]}postExportMaterialAsync(z,u,Y){return new Promise((z=>{if(Y instanceof Lu.e){if(!Y.anisotropy.isEnabled||Y.anisotropy.legacy)return void z(u);this._wasUsed=!0,u.extensions=u.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(Y.anisotropy.texture),E={anisotropyStrength:Y.anisotropy.JT,anisotropyRotation:Y.anisotropy.angle,anisotropyTexture:H??void 0};null!==E.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(Y),u.extensions[Du]=E}z(u)}))}}yz.RegisterExtension(Du,(z=>new gu(z)));const Mu="KHR_materials_clearcoat";class qu{constructor(z){this.name=Mu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,Y){const H=[];return Y instanceof Lu.e&&Y.clearCoat.isEnabled?(Y.clearCoat.texture&&H.push(Y.clearCoat.texture),!Y.clearCoat.useRoughnessFromMainTexture&&Y.clearCoat.textureRoughness&&H.push(Y.clearCoat.textureRoughness),Y.clearCoat.bumpTexture&&H.push(Y.clearCoat.bumpTexture),H):[]}postExportMaterialAsync(z,u,Y){return new Promise((z=>{if(Y instanceof Lu.e){if(!Y.clearCoat.isEnabled)return void z(u);this._wasUsed=!0,u.extensions=u.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(Y.clearCoat.texture);let J;J=Y.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(Y.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(Y.clearCoat.textureRoughness),Y.clearCoat.isTintEnabled&&E.e.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${Y.name}`),Y.clearCoat.remapF0OnInterfaceChange&&E.e.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${Y.name}`);const l=this._exporter._materialExporter.getTextureInfo(Y.clearCoat.bumpTexture),T={clearcoatFactor:Y.clearCoat.JT,clearcoatTexture:H??void 0,clearcoatRoughnessFactor:Y.clearCoat.roughness,clearcoatRoughnessTexture:J??void 0,clearcoatNormalTexture:l??void 0};null===T.clearcoatTexture&&null===T.clearcoatRoughnessTexture&&null===T.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Y),u.extensions[Mu]=T}z(u)}))}}yz.RegisterExtension(Mu,(z=>new qu(z)));const Cu="KHR_materials_diffuse_transmission";function Ku(z,u){const Y=u.subSurface;let H=null;return Y.translucencyIntensityTexture?H=Y.translucencyIntensityTexture:Y.thicknessTexture&&Y.useMaskFromThicknessTexture&&(H=Y.thicknessTexture),H&&!Y.useGltfStyleTextures?(n.b.Warn(`${z}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${u.name}`,1),null):H}class hu{constructor(z){this.name=Cu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,Y){const H=[];if(Y instanceof Cz.c&&this._isExtensionEnabled(Y)){const u=Ku(z,Y);return u&&H.push(u),Y.subSurface.translucencyColorTexture&&H.push(Y.subSurface.translucencyColorTexture),H}return H}_isExtensionEnabled(z){if(z.unlit)return!1;const u=z.subSurface;return!!u.isTranslucencyEnabled&&(!z.unlit&&!u.useAlbedoToTintTranslucency&&u.useGltfStyleTextures&&1===u.volumeIndexOfRefraction&&0===u.minimumThickness&&0===u.maximumThickness)}postExportMaterialAsync(z,u,Y){return new Promise((H=>{if(Y instanceof Cz.c&&this._isExtensionEnabled(Y)){this._wasUsed=!0;const H=Y.subSurface,E=Ku(z,Y),J=0==H.translucencyIntensity?void 0:H.translucencyIntensity,l=this._exporter._materialExporter.getTextureInfo(E)??void 0,T=!H.translucencyColor||H.translucencyColor.equalsFloats(1,1,1)?void 0:H.translucencyColor.al(),b=this._exporter._materialExporter.getTextureInfo(H.translucencyColorTexture)??void 0,L={diffuseTransmissionFactor:J,diffuseTransmissionTexture:l,diffuseTransmissionColorFactor:T,diffuseTransmissionColorTexture:b};(l||b)&&this._exporter._materialNeedsUVsSet.add(Y),u.extensions=u.extensions||{},u.extensions[Cu]=L}H(u)}))}}yz.RegisterExtension(Cu,(z=>new hu(z)));const ou="KHR_materials_dispersion";class du{constructor(){this.name=ou,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(z){if(z.unlit)return!1;const u=z.subSurface;return!(!u.isRefractionEnabled&&!u.isDispersionEnabled)}postExportMaterialAsync(z,u,Y){return new Promise((z=>{if(Y instanceof Cz.c&&this._isExtensionEnabled(Y)){this._wasUsed=!0;const z={dispersion:Y.subSurface.dispersion};u.extensions=u.extensions||{},u.extensions[ou]=z}z(u)}))}}yz.RegisterExtension(ou,(()=>new du));const tu="KHR_materials_emissive_strength";class Wu{constructor(){this.name=tu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(z,u,Y){return await new Promise((z=>{if(!(Y instanceof Cz.c))return z(u);const H=Y.emissiveColor.al(),E=Math.max(...H);if(E>1){this._wasUsed=!0,u.extensions||(u.extensions={});const z={emissiveStrength:E},H=Y.emissiveColor.scale(1/z.emissiveStrength);u.emissiveFactor=H.al(),u.extensions[tu]=z}return z(u)}))}}yz.RegisterExtension(tu,(z=>new Wu));const Zu="KHR_materials_ior";class su{constructor(){this.name=Zu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(z){return!z.unlit&&(void 0!=z.indexOfRefraction&&1.5!=z.indexOfRefraction)}postExportMaterialAsync(z,u,Y){return new Promise((z=>{if(Y instanceof Cz.c&&this._isExtensionEnabled(Y)){this._wasUsed=!0;const z={ior:Y.indexOfRefraction};u.extensions=u.extensions||{},u.extensions[Zu]=z}z(u)}))}}yz.RegisterExtension(Zu,(z=>new su));const vu="KHR_materials_iridescence";class iu{constructor(z){this.name=vu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,Y){const H=[];return Y instanceof Lu.e&&Y.iridescence.isEnabled?(Y.iridescence.texture&&H.push(Y.iridescence.texture),Y.iridescence.thicknessTexture&&Y.iridescence.thicknessTexture!==Y.iridescence.texture&&H.push(Y.iridescence.thicknessTexture),H):[]}postExportMaterialAsync(z,u,Y){return new Promise((z=>{if(Y instanceof Lu.e){if(!Y.iridescence.isEnabled)return void z(u);this._wasUsed=!0,u.extensions=u.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(Y.iridescence.texture),E=this._exporter._materialExporter.getTextureInfo(Y.iridescence.thicknessTexture),J={iridescenceFactor:Y.iridescence.JT,iridescenceIor:Y.iridescence.indexOfRefraction,iridescenceThicknessMinimum:Y.iridescence.minimumThickness,iridescenceThicknessMaximum:Y.iridescence.maximumThickness,iridescenceTexture:H??void 0,iridescenceThicknessTexture:E??void 0};null===J.iridescenceTexture&&null===J.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(Y),u.extensions[vu]=J}z(u)}))}}yz.RegisterExtension(vu,(z=>new iu(z)));const Xu="KHR_materials_sheen";class Qu{constructor(z){this.name=Xu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,Y){return Y instanceof Cz.c&&Y.sheen.isEnabled&&Y.sheen.texture?[Y.sheen.texture]:[]}async postExportMaterialAsync(z,u,Y){return await new Promise((z=>{if(Y instanceof Cz.c){if(!Y.sheen.isEnabled)return void z(u);this._wasUsed=!0,null==u.extensions&&(u.extensions={});const H={sheenColorFactor:Y.sheen.color.al(),sheenRoughnessFactor:Y.sheen.roughness??0};null===H.sheenColorTexture&&null===H.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Y),Y.sheen.texture&&(H.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(Y.sheen.texture)??void 0),Y.sheen.textureRoughness&&!Y.sheen.useRoughnessFromMainTexture?H.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Y.sheen.textureRoughness)??void 0:Y.sheen.texture&&Y.sheen.useRoughnessFromMainTexture&&(H.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Y.sheen.texture)??void 0),u.extensions[Xu]=H}z(u)}))}}yz.RegisterExtension(Xu,(z=>new Qu(z)));const Vu="KHR_materials_specular";class Au{constructor(z){this.name=Vu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,Y){const H=[];return Y instanceof Cz.c&&this._isExtensionEnabled(Y)?(Y.metallicReflectanceTexture&&H.push(Y.metallicReflectanceTexture),Y.reflectanceTexture&&H.push(Y.reflectanceTexture),H):H}_isExtensionEnabled(z){return!z.unlit&&(void 0!=z.metallicF0Factor&&1!=z.metallicF0Factor||void 0!=z.metallicReflectanceColor&&!z.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(z))}_hasTexturesExtension(z){return null!=z.metallicReflectanceTexture||null!=z.reflectanceTexture}postExportMaterialAsync(z,u,Y){return new Promise((z=>{if(Y instanceof Cz.c&&this._isExtensionEnabled(Y)){this._wasUsed=!0,u.extensions=u.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(Y.metallicReflectanceTexture)??void 0,H=this._exporter._materialExporter.getTextureInfo(Y.reflectanceTexture)??void 0,E={specularFactor:1==Y.metallicF0Factor?void 0:Y.metallicF0Factor,specularTexture:z,specularColorFactor:Y.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:Y.metallicReflectanceColor.al(),specularColorTexture:H};this._hasTexturesExtension(Y)&&this._exporter._materialNeedsUVsSet.add(Y),u.extensions[Vu]=E}z(u)}))}}yz.RegisterExtension(Vu,(z=>new Au(z)));const xu="KHR_materials_transmission";class Gu{constructor(z){this.name=xu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,Y){const H=[];return Y instanceof Cz.c&&this._isExtensionEnabled(Y)?(Y.subSurface.thicknessTexture&&H.push(Y.subSurface.thicknessTexture),H):H}_isExtensionEnabled(z){if(z.unlit)return!1;const u=z.subSurface;return u.isRefractionEnabled&&void 0!=u.refractionIntensity&&0!=u.refractionIntensity||this._hasTexturesExtension(z)}_hasTexturesExtension(z){return null!=z.subSurface.refractionIntensityTexture}async postExportMaterialAsync(z,u,Y){if(Y instanceof Cz.c&&this._isExtensionEnabled(Y)){this._wasUsed=!0;const H=Y.subSurface,E={transmissionFactor:0===H.refractionIntensity?void 0:H.refractionIntensity};if(this._hasTexturesExtension(Y)&&this._exporter._materialNeedsUVsSet.add(Y),H.refractionIntensityTexture)if(H.useGltfStyleTextures){const z=await this._exporter._materialExporter.exportTextureAsync(H.refractionIntensityTexture,"image/png");z&&(E.transmissionTexture=z)}else n.b.Warn(`${z}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);u.extensions||(u.extensions={}),u.extensions[xu]=E}return u}}yz.RegisterExtension(xu,(z=>new Gu(z)));const Fu="KHR_materials_unlit";class Ru{constructor(){this.name=Fu,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(z,u,Y){return new Promise((z=>{let H=!1;Y instanceof Cz.c?H=Y.unlit:Y instanceof Kz.e&&(H=Y.disableLighting),H&&(this._wasUsed=!0,null==u.extensions&&(u.extensions={}),u.extensions[Fu]={}),z(u)}))}}yz.RegisterExtension(Fu,(()=>new Ru));const wu="KHR_materials_volume";class cu{constructor(z){this.name=wu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,Y){const H=[];return Y instanceof Cz.c&&this._isExtensionEnabled(Y)?(Y.subSurface.thicknessTexture&&H.push(Y.subSurface.thicknessTexture),H):H}_isExtensionEnabled(z){if(z.unlit)return!1;const u=z.subSurface;return!(!u.isRefractionEnabled&&!u.isTranslucencyEnabled)&&(void 0!=u.maximumThickness&&0!=u.maximumThickness||void 0!=u.tintColorAtDistance&&u.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=u.tintColor&&u.tintColor!=h.c.White()||this._hasTexturesExtension(z))}_hasTexturesExtension(z){return null!=z.subSurface.thicknessTexture}postExportMaterialAsync(z,u,Y){return new Promise((z=>{if(Y instanceof Cz.c&&this._isExtensionEnabled(Y)){this._wasUsed=!0;const z=Y.subSurface,H={thicknessFactor:0==z.maximumThickness?void 0:z.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(z.thicknessTexture)??void 0,attenuationDistance:z.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:z.tintColorAtDistance,attenuationColor:z.tintColor.equalsFloats(1,1,1)?void 0:z.tintColor.al()};this._hasTexturesExtension(Y)&&this._exporter._materialNeedsUVsSet.add(Y),u.extensions=u.extensions||{},u.extensions[wu]=H}z(u)}))}}yz.RegisterExtension(wu,(z=>new cu(z)));const Uu="EXT_materials_diffuse_roughness";class Ou{constructor(z){this.name=Uu,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(z,u,Y){const H=[];return Y instanceof Lu.e&&Y._baseDiffuseRoughness?(Y._baseDiffuseRoughnessTexture&&H.push(Y._baseDiffuseRoughnessTexture),H):[]}postExportMaterialAsync(z,u,Y){return new Promise((z=>{if(Y instanceof Lu.e){if(!Y._baseDiffuseRoughness)return void z(u);this._wasUsed=!0,u.extensions=u.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(Y._baseDiffuseRoughnessTexture),E={diffuseRoughnessFactor:Y._baseDiffuseRoughness,diffuseRoughnessTexture:H??void 0};null!==E.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(Y),u.extensions[Uu]=E}z(u)}))}}yz.RegisterExtension(Uu,(z=>new Ou(z)));const nu="KHR_texture_transform";class mu{constructor(){this.name=nu,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(z,u,Y){if(Y.iz()||E.e.Warn(`${z}: /*@__KEY__*/"scene" is not defined for Babylon texture ${Y.name}!`),(0!==Y.uAng||0!==Y.vAng)&&(E.e.Warn(`${z}: Texture ${Y.name} with rotation in the u or v axis is not supported in glTF.`),0!==Y.uRotationCenter||0!==Y.vRotationCenter))return;const H={};let J=!1;if(0===Y.uOffset&&0===Y.vOffset||(H.offset=[Y.uOffset,Y.vOffset],J=!0),1===Y.uScale&&1===Y.vScale||(H.scale=[Y.uScale,Y.vScale],J=!0),0!==Y.wAng){if(0!==Y.uRotationCenter||0!==Y.vRotationCenter){if(Y.homogeneousRotationInUVTransform&&Y.uScale!==Y.vScale)return void E.e.Warn(`${z}: Texture ${Y.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${nu}.`);E.e.Warn(`${z}: Texture ${Y.name} with non-origin rotation center will be exported using an adjusted offset with ${nu}.`),H.offset=function(z){const{uOffset:u,vOffset:Y,uRotationCenter:H,vRotationCenter:E,uScale:J,vScale:l,wAng:T}=z,b=Math.cos(T),L=Math.sin(T),D=H*J,g=E*l;return[u+(D*(1-b)+g*L),Y+(g*(1-b)-D*L)]}(Y)}H.rotation=-Y.wAng,J=!0}0!==Y.coordinatesIndex&&(H.texCoord=Y.coordinatesIndex,J=!0),J&&(this._wasUsed=!0,u.extensions||(u.extensions={}),u.extensions[nu]=H)}}yz.RegisterExtension(nu,(()=>new mu));class pu{static CreateSTL(z){let u=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",E=arguments.length>3&&void 0!==arguments[3]&&arguments[3],J=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],l=arguments.length>5&&void 0!==arguments[5]&&arguments[5],T=arguments.length>6&&void 0!==arguments[6]&&arguments[6],b=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const L=function(z,u,Y){const E=[3*z[Y],3*z[Y+1],3*z[Y+2]],J=[new H.p(u[E[0]],u[E[0]+2],u[E[0]+1]),new H.p(u[E[1]],u[E[1]+2],u[E[1]+1]),new H.p(u[E[2]],u[E[2]+2],u[E[2]+1])],l=J[0].JY(J[1]),T=J[2].JY(J[1]);return{v:J,n:H.p.Cross(T,l).normalize()}},g=function(z,u,Y,H){return u=M(z,u,Y.x,H),u=M(z,u,Y.y,H),M(z,u,Y.z,H)},M=function(z,u,Y,H){return z.setFloat32(u,Y,H),u+4},C=function(z){if(T){let u=z;z instanceof q.e&&(u=z.sourceMesh);const Y=u.getVerticesData(D.f.PositionKind,!0,!0);if(!Y)return[];const E=H.p.Zero();let J;for(J=0;J<Y.length;J+=3)H.p.TransformCoordinatesFromFloatsToRef(Y[J],Y[J+1],Y[J+2],z.pl(!0),E).toArray(Y,J);return Y}return z.getVerticesData(D.f.PositionKind)||[]};T&&(l=!0);let K="",h=0,o=0;if(E){for(let Y=0;Y<z.length;Y++){const u=z[Y].Il();h+=u?u.length/3:0}const u=new ArrayBuffer(84+50*h);K=new DataView(u),o+=80,K.setUint32(o,h,J),o+=4}else b||(K="solid stlmesh\r\n");for(let H=0;H<z.length;H++){const u=z[H];!E&&b&&(K+="solid "+u.name+"\r\n"),!l&&u instanceof dz.b&&u.bakeCurrentTransformIntoVertices();const Y=C(u),T=u.Il()||[];for(let z=0;z<T.length;z+=3){const u=L(T,Y,z);E?(o=g(K,o,u.n,J),o=g(K,o,u.v[0],J),o=g(K,o,u.v[1],J),o=g(K,o,u.v[2],J),o+=2):(K+="\tfacet normal "+u.n.x+" "+u.n.y+" "+u.n.z+"\r\n",K+="\t\touter loop\r\n",K+="\t\t\tvertex "+u.v[0].x+" "+u.v[0].y+" "+u.v[0].z+"\r\n",K+="\t\t\tvertex "+u.v[1].x+" "+u.v[1].y+" "+u.v[1].z+"\r\n",K+="\t\t\tvertex "+u.v[2].x+" "+u.v[2].y+" "+u.v[2].z+"\r\n",K+="\t\tendloop\r\n",K+="\tendfacet\r\n")}!E&&b&&(K+="endsolid "+name+"\r\n")}if(E||b||(K+="endsolid stlmesh"),u){const z=document.createElement("a"),u=new Blob([K],{type:"application/octet-stream"});z.href=window.URL.createObjectURL(u),z.download=Y+".stl",z.click()}return K}}function Su(z,u){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const H=[];for(let E=0;E<z.length/Y;E++){const J=z[E*Y],l=z[E*Y+1],T=z[E*Y+2];H.push(`(${J.toPrecision(u.precision)}, ${l.toPrecision(u.precision)}, ${T.toPrecision(u.precision)})`)}return H.join(", ")}function Iu(z,u){const Y=[];for(let H=0;H<z.length/2;H++){const E=z[2*H],J=z[2*H+1];Y.push(`(${E.toPrecision(u.precision)}, ${(1-J).toPrecision(u.precision)})`)}return Y.join(", ")}function yu(z,u){const Y=z.getVerticesData(D.f.PositionKind),H=z.getVerticesData(D.f.NormalKind);if(Y&&H)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(z){var u;const Y=null!==(u=z.Il())&&void 0!==u&&u.length?z.getTotalIndices():z.getTotalVertices();return Array(Y/3).fill(3).join(", ")}(z)}]\n\t\tint[] faceVertexIndices = [${function(z){const u=z.Il(),Y=[];if(null!==u)for(let H=0;H<u.length;H++)Y.push(u[H]);else{const u=z.getTotalVertices();for(let z=0;z<u;z++)Y.push(z)}return Y.join(", ")}(z)}]\n\t\tnormal3f[] normals = [${Su(H,u)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Su(Y,u)}]\n        ${function(z,u){let Y="";for(let E=0;E<4;E++){const H=E>0?E:"",J=z.getVerticesData(D.f.UVKind+(H?H+1:""));J&&(Y+=`\n\t\ttexCoord2f[] primvars:st${H} = [${Iu(J,u)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const H=z.getVerticesData(D.f.ColorKind);return H&&(Y+=`\n\tcolor3f[] primvars:displayColor = [${Su(H,u,H.length/z.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),Y}(z,u)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function au(z,u){return`\n        def "Geometry"\n        {\n        ${yu(z,u)}\n        }\n        `}function ju(z){let u='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return u+=z,fflate.strToU8(u)}function ku(z){const u=z.m;return`( ${Pu(u,0)}, ${Pu(u,4)}, ${Pu(u,8)}, ${Pu(u,12)} )`}function Pu(z,u){return`(${z[u+0]}, ${z[u+1]}, ${z[u+2]}, ${z[u+3]})`}function eu(z){const u="Object_"+z.uniqueId,Y=function(z){const u=z.getWorldMatrix().clone(),Y=z.iz().useRightHandedSystem;if(!Y){let H=z.parent;for(;H;){if(lz(H,Y)){u.multiplyToRef(H.getWorldMatrix().invert(),u);break}H=H.parent}}return u.determinant()<0&&E.e.Warn(`Exporting mesh ${z.name} with negative scale. Result may look incorrect in destination engine.`),u}(z),H=ku(Y);return`def Xform "${u}" (\n\tprepend references = @./geometries/Geometry_${z.Sl.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${H}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${z.material.uniqueId}>\n}\n\n`}function Nu(z){switch(z){case v.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case v.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case v.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Bu(z){return`(${z.x}, ${z.y})`}function fu(z){return`(${z.r}, ${z.g}, ${z.b})`}function ru(z,u,Y,E,J,l){const T=z.getInternalTexture().uniqueId+"_"+z.invertY;J[T]=z;const b=z.coordinatesIndex>0?"st"+z.coordinatesIndex:"st",L=new H.m(z.uScale,z.vScale),D=new H.m(z.uOffset,z.vOffset),g=z.wAng,M=Math.sin(g),q=Math.cos(g);return D.y=1-D.y-L.y,D.x+=M*L.x,D.y+=(1-q)*L.y,`\n    def Shader "PrimvarReader_${Y}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${b}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${Y}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${u.uniqueId}/PrimvarReader_${Y}.outputs:result>\n        float inputs:rotation = ${(g*(180/Math.PI)).toFixed(l.precision)}\n        float2 inputs:scale = ${Bu(L)}\n        float2 inputs:translation = ${Bu(D)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${z.uniqueId}_${Y}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${T}.png@\n        float2 inputs:st.connect = </Materials/Material_${u.uniqueId}/Transform2d_${Y}.outputs:result>\n        ${E?"float4 inputs:scale = "+function(z){return`(${z.r}, ${z.g}, ${z.b}, 1.0)`}(E):""}\n        token inputs:sourceColorSpace = "${z.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Nu(z.wrapU)}"\n        token inputs:wrapT = "${Nu(z.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${u.needAlphaBlending()?"float outputs:a":""}\n    }`}function zY(z,u,Y){const H="\t\t\t",E=[],J=[],{diffuseMap:l,lT:T,alphaCutOff:b,emissiveMap:L,emissive:D,normalMap:g,roughnessMap:M,roughnessChannel:q,roughness:C,metalnessMap:K,metalnessChannel:o,metalness:d,aoMap:t,aoMapChannel:W,aoMapIntensity:Z,alphaMap:s,ior:v,clearCoatEnabled:i,clearCoat:X,clearCoatMap:Q,clearCoatRoughness:V,clearCoatRoughnessMap:A}=function(z){const u={diffuseMap:null,lT:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return z instanceof Kz.e?{...u,diffuseMap:z.diffuseTexture,lT:z.diffuseColor,alphaCutOff:z.alphaCutOff,emissiveMap:z.emissiveTexture,emissive:z.emissiveColor,roughness:1,alphaMap:z.opacityTexture}:z instanceof Lu.e?{...u,diffuseMap:z._albedoTexture,lT:z._albedoColor,alphaCutOff:z._alphaCutOff,emissiveMap:z._emissiveTexture,emissive:z._emissiveColor,normalMap:z._bumpTexture,roughnessMap:z._metallicTexture,roughnessChannel:z._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:z._roughness??1,metalnessMap:z._metallicTexture,metalnessChannel:z._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:z._metallic??0,aoMap:z._ambientTexture,aoMapChannel:z._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:z._ambientTextureStrength,alphaMap:z._opacityTexture,ior:z.subSurface.indexOfRefraction,clearCoatEnabled:z.clearCoat.isEnabled,clearCoat:z.clearCoat.JT,clearCoatMap:z.clearCoat.texture,clearCoatRoughness:z.clearCoat.roughness,clearCoatRoughnessMap:z.clearCoat.useRoughnessFromMainTexture?z.clearCoat.texture:z.clearCoat.textureRoughness}:u}(z);return null!==l?(E.push(`${H}color3f inputs:diffuseColor.connect = </Materials/Material_${z.uniqueId}/Texture_${l.uniqueId}_diffuse.outputs:rgb>`),z.needAlphaBlending()?E.push(`${H}float inputs:opacity.connect = </Materials/Material_${z.uniqueId}/Texture_${l.uniqueId}_diffuse.outputs:a>`):z.needAlphaTesting()&&(E.push(`${H}float inputs:opacity.connect = </Materials/Material_${z.uniqueId}/Texture_${l.uniqueId}_diffuse.outputs:a>`),E.push(`${H}float inputs:opacityThreshold = ${b}`)),J.push(ru(l,z,"diffuse",T,u,Y))):E.push(`${H}color3f inputs:diffuseColor = ${fu(T||h.c.White())}`),null!==L?(E.push(`${H}color3f inputs:emissiveColor.connect = </Materials/Material_${z.uniqueId}/Texture_${L.uniqueId}_emissive.outputs:rgb>`),J.push(ru(L,z,"emissive",D,u,Y))):D&&D.toLuminance()>0&&E.push(`${H}color3f inputs:emissiveColor = ${fu(D)}`),null!==g&&(E.push(`${H}normal3f inputs:normal.connect = </Materials/Material_${z.uniqueId}/Texture_${g.uniqueId}_normal.outputs:rgb>`),J.push(ru(g,z,"wl",null,u,Y))),null!==t&&(E.push(`${H}float inputs:occlusion.connect = </Materials/Material_${z.uniqueId}/Texture_${t.uniqueId}_occlusion.outputs:${W}>`),J.push(ru(t,z,"occlusion",new h.c(Z,Z,Z),u,Y))),null!==M?(E.push(`${H}float inputs:roughness.connect = </Materials/Material_${z.uniqueId}/Texture_${M.uniqueId}_roughness.outputs:${q}>`),J.push(ru(M,z,"roughness",new h.c(C,C,C),u,Y))):E.push(`${H}float inputs:roughness = ${C}`),null!==K?(E.push(`${H}float inputs:metallic.connect = </Materials/Material_${z.uniqueId}/Texture_${K.uniqueId}_metallic.outputs:${o}>`),J.push(ru(K,z,"metallic",new h.c(d,d,d),u,Y))):E.push(`${H}float inputs:metallic = ${d}`),null!==s?(E.push(`${H}float inputs:opacity.connect = </Materials/Material_${z.uniqueId}/Texture_${s.uniqueId}_opacity.outputs:r>`),E.push(`${H}float inputs:opacityThreshold = 0.0001`),J.push(ru(s,z,"opacity",null,u,Y))):E.push(`${H}float inputs:opacity = ${z.alpha}`),i&&(null!==Q?(E.push(`${H}float inputs:clearcoat.connect = </Materials/Material_${z.uniqueId}/Texture_${Q.uniqueId}_clearcoat.outputs:r>`),J.push(ru(Q,z,"clearcoat",new h.c(X,X,X),u,Y))):E.push(`${H}float inputs:clearcoat = ${X}`),null!==A?(E.push(`${H}float inputs:clearcoatRoughness.connect = </Materials/Material_${z.uniqueId}/Texture_${A.uniqueId}_clearcoatRoughness.outputs:g>`),J.push(ru(A,z,"clearcoatRoughness",new h.c(V,V,V),u,Y))):E.push(`${H}float inputs:clearcoatRoughness = ${V}`)),E.push(`${H}float inputs:ior = ${v}`),`\n\tdef Material "Material_${z.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${E.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${z.uniqueId}/PreviewSurface.outputs:surface>\n\n${J.join("\n")}\n\n\t}\n`}async function uY(z,u,Y){const J={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...u};"undefined"===typeof fflate&&await E.e.LoadScriptAsync(J.fflateUrl);const l={};l[J.modelFileName]=null;let T='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';T+=function(z){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===z.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${z.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${z.planeAnchoringAlignment}"`:""}\n            `}(J);const b={};for(const H of z.meshes){if(0===H.getTotalVertices())continue;const z=H,u=z.Sl,L=z.material;if(!L||!u||Y&&!Y(z))continue;if(-1!==["TT","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(L.getClassName())){const Y="geometries/Geometry_"+u.uniqueId+".usda";if(!(Y in l)){const z=au(u,J);l[Y]=ju(z)}L.uniqueId in b||(b[L.uniqueId]=L),T+=eu(z)}else E.e.Warn("USDZExportAsync does not support this material type: "+L.getClassName())}z.activeCamera&&J.exportCamera&&(T+=function(z,u){const Y="Camera_"+z.uniqueId,E=ku(H.b.RotationY(Math.PI).multiply(z.getWorldMatrix()));if(z.mode===v.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${Y}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${z.uT.toPrecision(u.precision)}, ${z.maxZ.toPrecision(u.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(z.orthoLeft||1)+Math.abs(z.orthoRight||1))).toPrecision(u.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(z.orthoTop||1)+Math.abs(z.orthoBottom||1))).toPrecision(u.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const H=z.getEngine().getAspectRatio(z),J=u.cameraSensorWidth||35;return`def Camera "${Y}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${E}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${z.uT.toPrecision(u.precision)}, ${z.maxZ.toPrecision(u.precision)})\n\t\t\tfloat focalLength = ${(J/(2*Math.tan(.5*z.fov))).toPrecision(u.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(J*H).toPrecision(u.precision)}\n\t\t\tfloat verticalAperture = ${(J/H).toPrecision(u.precision)}            \n\t\t}\n\t\n\t`}}(z.activeCamera,J)),T+="\n            }\n        }\n    }";const L={};T+=function(z,u,Y){const H=[];for(const E in z){const J=z[E];H.push(zY(J,u,Y))}return`\n    def "Materials"\n{\n${H.join("")}\n}\n\n`}(b,L,J),l[J.modelFileName]=fflate.strToU8(T);for(const H in L){const z=L[H],u=z.getSize(),Y=await z.readPixels();if(!Y)throw new Error("Texture data is not available");const E=await i.DumpTools.DumpDataAsync(u.width,u.height,Y,"image/png",void 0,!1,!0);l[`textures/Texture_${H}.png`]=new Uint8Array(E).slice()}let D=0;for(const H in l){const z=l[H];if(!z)continue;D+=34+H.length;const u=63&D;if(4!==u){const Y=new Uint8Array(64-u);l[H]=[z,{extra:{12345:Y}}]}D=z.length}return fflate.zipSync(l,{level:0})}}}]);