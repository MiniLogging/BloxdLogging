"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10988:(T,z,X)=>{X.r(z),X.d(z,{_HDRTextureLoader:()=>k});var b=X(976);class F{static ConvertPanoramaToCubemap(T,z,X,b){let F=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!T)throw"ConvertPanoramaToCubemap: input cannot be null";if(T.length!=z*X*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(b,this.FACE_FRONT,T,z,X,F),back:this.CreateCubemapTexture(b,this.FACE_BACK,T,z,X,F),left:this.CreateCubemapTexture(b,this.FACE_LEFT,T,z,X,F),right:this.CreateCubemapTexture(b,this.FACE_RIGHT,T,z,X,F),up:this.CreateCubemapTexture(b,this.FACE_UP,T,z,X,F),down:this.CreateCubemapTexture(b,this.FACE_DOWN,T,z,X,F),size:b,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(T,z,X,b,F){let A=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const u=new ArrayBuffer(T*T*4*3),y=new Float32Array(u),E=A?Math.max(1,Math.round(b/4/T)):1,v=1/E,k=v*v,L=z[1].Mc(z[0]).scale(v/T),D=z[3].Mc(z[2]).scale(v/T),c=1/T;let p=0;for(let H=0;H<T;H++)for(let A=0;A<E;A++){let A=z[0],u=z[2];for(let z=0;z<T;z++)for(let v=0;v<E;v++){const E=u.Mc(A).scale(p).add(A);E.normalize();const v=this.CalcProjectionSpherical(E,X,b,F);y[H*T*3+3*z+0]+=v.r*k,y[H*T*3+3*z+1]+=v.g*k,y[H*T*3+3*z+2]+=v.b*k,A=A.add(L),u=u.add(D)}p+=c*v}return y}static CalcProjectionSpherical(T,z,X,b){let F=Math.atan2(T.z,T.x);const A=Math.acos(T.y);for(;F<-Math.PI;)F+=2*Math.PI;for(;F>Math.PI;)F-=2*Math.PI;let u=F/Math.PI;const y=A/Math.PI;u=.5*u+.5;let E=Math.round(u*X);E<0?E=0:E>=X&&(E=X-1);let v=Math.round(y*b);v<0?v=0:v>=b&&(v=b-1);const k=b-v-1;return{r:z[k*X*3+3*E+0],g:z[k*X*3+3*E+1],b:z[k*X*3+3*E+2]}}}function A(T,z,X,b,F,A){F>0?(F=function(T,z){return z>1023?T*Math.pow(2,1023)*Math.pow(2,z-1023):z<-1074?T*Math.pow(2,-1074)*Math.pow(2,z+1074):T*Math.pow(2,z)}(1,F-136),T[A+0]=z*F,T[A+1]=X*F,T[A+2]=b*F):(T[A+0]=0,T[A+1]=0,T[A+2]=0)}function u(T,z){let X="",b="";for(let F=z;F<T.length-z&&(b=String.fromCharCode(T[F]),"\n"!=b);F++)X+=b;return X}function y(T){let z=0,X=0,b=u(T,0);if("#"!=b[0]||"?"!=b[1])throw"Bad HDR Format.";let F=!1,A=!1,y=0;do{y+=b.length+1,b=u(T,y),"FORMAT=32-bit_rle_rgbe"==b?A=!0:0==b.length&&(F=!0)}while(!F);if(!A)throw"HDR Bad header format, unsupported FORMAT";y+=b.length+1,b=u(T,y);const E=/^-Y (.*) \+X (.*)$/g.exec(b);if(!E||E.length<3)throw"HDR Bad header format, no size";if(X=parseInt(E[2]),z=parseInt(E[1]),X<8||X>32767)throw"HDR Bad header format, unsupported size";return y+=b.length+1,{height:z,width:X,dataPosition:y}}function E(T,z){return function(T,z){let X=z.height;const b=z.width;let F,u,y,E,k,L=z.dataPosition,D=0,c=0,p=0;const H=new ArrayBuffer(4*b),U=new Uint8Array(H),s=new ArrayBuffer(z.width*z.height*4*3),x=new Float32Array(s);for(;X>0;){if(F=T[L++],u=T[L++],y=T[L++],E=T[L++],2!=F||2!=u||128&y||z.width<8||z.width>32767)return v(T,z);if((y<<8|E)!=b)throw"HDR Bad header format, wrong scan line width";for(D=0,p=0;p<4;p++)for(c=(p+1)*b;D<c;)if(F=T[L++],u=T[L++],F>128){if(k=F-128,0==k||k>c-D)throw"HDR Bad Format, bad scanline data (run)";for(;k-- >0;)U[D++]=u}else{if(k=F,0==k||k>c-D)throw"HDR Bad Format, bad scanline data (non-run)";if(U[D++]=u,--k>0)for(let z=0;z<k;z++)U[D++]=T[L++]}for(p=0;p<b;p++)F=U[p],u=U[p+b],y=U[p+2*b],E=U[p+3*b],A(x,F,u,y,E,(z.height-X)*b*3+3*p);X--}return x}(T,z)}function v(T,z){let X=z.height;const b=z.width;let F,u,y,E,v,k=z.dataPosition;const L=new ArrayBuffer(z.width*z.height*4*3),D=new Float32Array(L);for(;X>0;){for(v=0;v<z.width;v++)F=T[k++],u=T[k++],y=T[k++],E=T[k++],A(D,F,u,y,E,(z.height-X)*b*3+3*v);X--}return D}F.FACE_LEFT=[new b.j(-1,-1,-1),new b.j(1,-1,-1),new b.j(-1,1,-1),new b.j(1,1,-1)],F.FACE_RIGHT=[new b.j(1,-1,1),new b.j(-1,-1,1),new b.j(1,1,1),new b.j(-1,1,1)],F.FACE_FRONT=[new b.j(1,-1,-1),new b.j(1,-1,1),new b.j(1,1,-1),new b.j(1,1,1)],F.FACE_BACK=[new b.j(-1,-1,1),new b.j(-1,-1,-1),new b.j(-1,1,1),new b.j(-1,1,-1)],F.FACE_DOWN=[new b.j(1,1,-1),new b.j(1,1,1),new b.j(-1,1,-1),new b.j(-1,1,1)],F.FACE_UP=[new b.j(-1,-1,-1),new b.j(-1,-1,1),new b.j(1,-1,-1),new b.j(1,-1,1)];class k{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(T,z,X){const b=new Uint8Array(T.buffer,T.byteOffset,T.byteLength),F=y(b),A=E(b,F),u=F.width*F.height,v=new Float32Array(4*u);for(let y=0;y<u;y+=1)v[4*y]=A[3*y],v[4*y+1]=A[3*y+1],v[4*y+2]=A[3*y+2],v[4*y+3]=1;X(F.width,F.height,z.generateMipMaps,!1,(()=>{const T=z.getEngine();z.type=1,z.format=5,z._gammaSpace=!1,T._uploadDataToTextureDirectly(z,v)}))}}}}]);