"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10826:(q,c,U)=>{U.r(c),U.d(c,{EXT_materials_diffuse_roughness:()=>yc,EXT_mesh_gpu_instancing:()=>wq,GLTF2Export:()=>Nq,GLTFData:()=>W,KHR_draco_mesh_compression:()=>Uc,KHR_lights_punctual:()=>nc,KHR_materials_anisotropy:()=>uc,KHR_materials_clearcoat:()=>rc,KHR_materials_diffuse_transmission:()=>hc,KHR_materials_dispersion:()=>ac,KHR_materials_emissive_strength:()=>Rc,KHR_materials_ior:()=>tc,KHR_materials_iridescence:()=>ic,KHR_materials_sheen:()=>vc,KHR_materials_specular:()=>kc,KHR_materials_transmission:()=>Oc,KHR_materials_unlit:()=>Sc,KHR_materials_volume:()=>xc,KHR_texture_transform:()=>Tc,OBJExport:()=>g,STLExport:()=>mc,USDZExportAsync:()=>cU,_ConvertToGLTFPBRMetallicRoughness:()=>G,_SolveMetallic:()=>O,__IGLTFExporterExtension:()=>X});var J=U(10833),Q=U(10879),s=U(11004);class g{static OBJ(q,c,U,g){const X=[];let n=1,W=1;c&&(U||(U="mat"),X.push("mtllib "+U+".mtl"));for(let D=0;D<q.length;D++){const U=q[D],u=U.name||`mesh${D}}`;X.push(`o ${u}`);let K=null;if(g){const q=U.o(!0);K=new J.d,q.invertToRef(K),U.bakeTransformIntoVertices(q)}if(c){const q=U.material;q&&X.push("usemtl "+q.id)}const r=U.Dc;if(!r){Q.e.Warn("No geometry is present on the mesh");continue}const H=r.getVerticesData("position"),b=r.getVerticesData("Jc"),h=r.getVerticesData("uv"),o=r.uc();let a=0,p=0;if(!H||!o){Q.e.Warn("There are no position vertices or indices on the mesh!");continue}const R=q[0].Cq().useRightHandedSystem?1:-1;for(let q=0;q<H.length;q+=3)X.push("v "+H[q]*R+" "+H[q+1]+" "+H[q+2]),a++;if(null!=b)for(let q=0;q<b.length;q+=3)X.push("vn "+b[q]*R+" "+b[q+1]+" "+b[q+2]);if(null!=h)for(let q=0;q<h.length;q+=2)X.push("vt "+h[q]+" "+h[q+1]),p++;const I=["","",""],t=(U.material||U.Cq().defaultMaterial)._getEffectiveOrientation(U),[C,i]=t===s.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let q=0;q<o.length;q+=3){const c=[String(o[q]+n),String(o[q+C]+n),String(o[q+i]+n)],U=[String(o[q]+W),String(o[q+C]+W),String(o[q+i]+W)],J=c,Q=null!=h?U:I,s=null!=b?c:I;X.push("f "+J[0]+"/"+Q[0]+"/"+s[0]+" "+J[1]+"/"+Q[1]+"/"+s[1]+" "+J[2]+"/"+Q[2]+"/"+s[2])}g&&K&&U.bakeTransformIntoVertices(K),n+=a,W+=p}return X.join("\n")}static MTL(q){const c=[],U=q.material;c.push("newmtl mat1"),c.push("  Ns "+U.specularPower.toFixed(4)),c.push("  Ni 1.5000"),c.push("  d "+U.alpha.toFixed(4)),c.push("  Tr 0.0000"),c.push("  Tf 1.0000 1.0000 1.0000"),c.push("  illum 2"),c.push("  Ka "+U.ambientColor.r.toFixed(4)+" "+U.ambientColor.g.toFixed(4)+" "+U.ambientColor.b.toFixed(4)),c.push("  Kd "+U.diffuseColor.r.toFixed(4)+" "+U.diffuseColor.g.toFixed(4)+" "+U.diffuseColor.b.toFixed(4)),c.push("  Ks "+U.specularColor.r.toFixed(4)+" "+U.specularColor.g.toFixed(4)+" "+U.specularColor.b.toFixed(4)),c.push("  Ke "+U.emissiveColor.r.toFixed(4)+" "+U.emissiveColor.g.toFixed(4)+" "+U.emissiveColor.b.toFixed(4));U.ambientTexture&&c.push("  map_Ka "+U.ambientTexture.name),U.diffuseTexture&&c.push("  map_Kd "+U.diffuseTexture.name),U.specularTexture&&c.push("  map_Ks "+U.specularTexture.name),U.bumpTexture&&c.push("  map_bump -imfchan z "+U.bumpTexture.name),U.opacityTexture&&c.push("  map_d "+U.opacityTexture.name);return c.join("\n")}}var X=0,n=U(10922);class W{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const q in this.files){const c=this.files[q],U=new Blob([c],{type:(0,n.f)(q)});Q.e.Download(U,q)}}}var D=U(11031),u=U(11107),K=U(11119),r=U(11144),H=U(11196),b=U(10864),h=U(11093),o=U(10870);const a=o.HighestCommonFactor,p={...o,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:a};var R=U(11285),I=U(11288),t=U(11321),C=U(11328),i=U(11337);const F=1e-6,v=new h.c(.04,.04,.04),Y=1024,k=h.c.White(),V=h.c.Black();function O(q,c,U){if(c<v.r)return 0;const J=v.r,Q=q*U/(1-v.r)+c-2*v.r,s=Q*Q-4*J*(v.r-c);return p.Clamp((-Q+Math.sqrt(s))/(2*J),0,1)}function G(q){const c=q.diffuseColor.toLinearSpace(q.Cq().getEngine().useExactSrgbConversions).scale(.5),U=q.alpha,Q=function(q){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new J.l(0,1),U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new J.l(0,.1),Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new J.l(0,.1),s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new J.l(1300,.1);return function(q,c,U,J,Q){return(1-q)*(1-q)*(1-q)*c+3*(1-q)*(1-q)*q*U+3*(1-q)*q*q*J+q*q*q*Q}(Math.pow(q/s.x,.333333),c.y,U.y,Q.y,s.y)}(p.Clamp(q.specularPower,0,Y));return{baseColorFactor:[c.r,c.g,c.b,U],metallicFactor:0,roughnessFactor:Q}}function S(q,c){c.needAlphaBlending()?q.alphaMode="BLEND":c.needAlphaTesting()&&(q.alphaMode="MASK",q.alphaCutoff=c.alphaCutOff)}function Z(q,c,U){const J=new Uint8Array(q*c*4);for(let Q=0;Q<J.length;Q+=4)J[Q]=J[Q+1]=J[Q+2]=J[Q+3]=255;return t.e.CreateRGBATexture(J,q,c,U)}function x(q){if(q instanceof Uint8Array){const c=q.length,U=new Float32Array(q.length);for(let J=0;J<c;++J)U[J]=q[J]/255;return U}if(q instanceof Float32Array)return q;throw new Error("Unsupported pixel format!")}class z{constructor(q){this._exporter=q,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(q){return q?this._textureMap.get(q)??null:null}async exportStandardMaterialAsync(q,c,U){const J=G(q),s={name:q.name};if(null==q.Kc||q.Kc||(q.twoSidedLighting||Q.e.Warn(q.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),s.doubleSided=!0),U){const U=[],Q=q.diffuseTexture;Q&&U.push(this.exportTextureAsync(Q,c).then((q=>{q&&(J.baseColorTexture=q)})));const g=q.bumpTexture;g&&U.push(this.exportTextureAsync(g,c).then((q=>{q&&(s.normalTexture=q,1!==g.level&&(s.normalTexture.scale=g.level))})));const X=q.emissiveTexture;X&&(s.emissiveFactor=[1,1,1],U.push(this.exportTextureAsync(X,c).then((q=>{q&&(s.emissiveTexture=q)}))));const n=q.ambientTexture;n&&U.push(this.exportTextureAsync(n,c).then((q=>{if(q){const c={index:q.index};s.occlusionTexture=c}}))),U.length>0&&(this._exporter._materialNeedsUVsSet.add(q),await Promise.all(U))}(q.alpha<1||q.opacityTexture)&&(q.alphaMode===C.c.ALPHA_COMBINE?s.alphaMode="BLEND":Q.e.Warn(q.name+": glTF 2.0 does not support alpha mode: "+q.alphaMode.toString())),q.emissiveColor&&!q.emissiveColor.equalsWithEpsilon(V,F)&&(s.emissiveFactor=q.emissiveColor.rc()),s.pbrMetallicRoughness=J,S(s,q),await this._finishMaterialAsync(s,q,c);const g=this._exporter._materials;return g.push(s),g.length-1}async _finishMaterialAsync(q,c,U){const J=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",q,c),Q=[];for(const s of J)Q.push(this.exportTextureAsync(s,U));await Promise.all(Q),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",q,c)}async _getImageDataAsync(q,c,J,Q){const s=C.c.TEXTURETYPE_UNSIGNED_BYTE,g=this._exporter._babylonScene,X=g.getEngine(),n=X.createRawTexture(q,c,J,C.c.TEXTUREFORMAT_RGBA,!1,!0,I.c.NEAREST_SAMPLINGMODE,null,s);X.isWebGPU?await U.e(36).then(U.bind(U,13413)):await U.e(37).then(U.bind(U,13421)),await R.l.ApplyPostProcess("pass",n,g,s,C.c.TEXTURE_NEAREST_SAMPLINGMODE,C.c.TEXTUREFORMAT_RGBA);const W=await X._readTexturePixels(n,c,J);return await i.DumpTools.DumpDataAsync(c,J,W,Q,void 0,!0,!0)}_resizeTexturesToSameDimensions(q,c,U){const J=q?q.getSize():{width:0,height:0},Q=c?c.getSize():{width:0,height:0};let s,g;return J.width<Q.width?(s=q&&q instanceof I.c?R.l.CreateResizedCopy(q,Q.width,Q.height,!0):Z(Q.width,Q.height,U),g=c):J.width>Q.width?(g=c&&c instanceof I.c?R.l.CreateResizedCopy(c,J.width,J.height,!0):Z(J.width,J.height,U),s=q):(s=q,g=c),{texture1:s,texture2:g}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(q,c,U,J){const Q=new Array;if(!q&&!c)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const s=q?q.Cq():c?c.Cq():null;if(s){var g;const X=this._resizeTexturesToSameDimensions(q,c,s),n=null===(g=X.texture1)||void 0===g?void 0:g.getSize();let W,D;const u=n.width,K=n.height,r=await X.texture1.readPixels(),H=await X.texture2.readPixels();if(!r)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(W=x(r),!H)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");D=x(H);const b=D.byteLength,o=new Uint8Array(b),a=new Uint8Array(b),p=4,R=V;let I=0,t=0;for(let q=0;q<K;++q)for(let c=0;c<u;++c){const J=(u*q+c)*p,Q={diffuseColor:new h.c(W[J],W[J+1],W[J+2]).toLinearSpace(s.getEngine().useExactSrgbConversions).multiply(U.diffuseColor),specularColor:new h.c(D[J],D[J+1],D[J+2]).toLinearSpace(s.getEngine().useExactSrgbConversions).multiply(U.specularColor),glossiness:D[J+3]*U.glossiness},g=this._convertSpecularGlossinessToMetallicRoughness(Q);R.r=Math.max(R.r,g.baseColor.r),R.g=Math.max(R.g,g.baseColor.g),R.b=Math.max(R.b,g.baseColor.b),I=Math.max(I,g.metallic),t=Math.max(t,g.roughness),a[J]=255*g.baseColor.r,a[J+1]=255*g.baseColor.g,a[J+2]=255*g.baseColor.b,a[J+3]=X.texture1.Hc?255*W[J+3]:255,o[J]=0,o[J+1]=255*g.roughness,o[J+2]=255*g.metallic,o[J+3]=255}const C={baseColor:R,metallic:I,roughness:t};let i=!1,v=!1;for(let q=0;q<K;++q)for(let c=0;c<u;++c){const U=(u*q+c)*p;a[U]/=C.baseColor.r>F?C.baseColor.r:1,a[U+1]/=C.baseColor.g>F?C.baseColor.g:1,a[U+2]/=C.baseColor.b>F?C.baseColor.b:1;const J=h.c.FromInts(a[U],a[U+1],a[U+2]).toGammaSpace(s.getEngine().useExactSrgbConversions);a[U]=255*J.r,a[U+1]=255*J.g,a[U+2]=255*J.b,J.equalsWithEpsilon(k,F)||(v=!0),o[U+1]/=C.roughness>F?C.roughness:1,o[U+2]/=C.metallic>F?C.metallic:1;h.c.FromInts(255,o[U+1],o[U+2]).equalsWithEpsilon(k,F)||(i=!0)}return i&&Q.push(this._getImageDataAsync(o,u,K,J).then((q=>{C.metallicRoughnessTextureData=q}))),v&&Q.push(this._getImageDataAsync(a,u,K,J).then((q=>{C.baseColorTextureData=q}))),await Promise.all(Q).then((()=>C))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(q){const c=this._getPerceivedBrightness(q.diffuseColor),U=this._getPerceivedBrightness(q.specularColor),J=1-this._getMaxComponent(q.specularColor),Q=O(c,U,J),s=q.diffuseColor.scale(J/(1-v.r)/Math.max(1-Q)),g=q.specularColor.eU(v.scale(1-Q)).scale(1/Math.max(Q));let X=h.c.Lerp(s,g,Q*Q);X=X.clampToRef(0,1,X);return{baseColor:X,metallic:Q,roughness:1-q.glossiness}}_getPerceivedBrightness(q){return q?Math.sqrt(.299*q.r*q.r+.587*q.g*q.g+.114*q.b*q.b):0}_getMaxComponent(q){return q?Math.max(q.r,Math.max(q.g,q.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(q,c,U,J){const Q=[],s={baseColor:q._albedoColor,metallic:q._metallic,roughness:q._roughness};if(J){q._albedoTexture&&Q.push(this.exportTextureAsync(q._albedoTexture,c).then((q=>{q&&(U.baseColorTexture=q)})));const J=q._metallicTexture;J&&Q.push(this.exportTextureAsync(J,c).then((q=>{q&&(U.metallicRoughnessTexture=q)})))}return Q.length>0&&(this._exporter._materialNeedsUVsSet.add(q),await Promise.all(Q)),s}_getTextureSampler(q){const c={};if(!q||!(q instanceof I.c))return c;const U=this._getGLTFTextureWrapMode(q.wrapU);10497!==U&&(c.wrapS=U);const J=this._getGLTFTextureWrapMode(q.wrapV);switch(10497!==J&&(c.wrapT=J),q.samplingMode){case I.c.LINEAR_LINEAR:c.magFilter=9729,c.minFilter=9729;break;case I.c.LINEAR_NEAREST:c.magFilter=9729,c.minFilter=9728;break;case I.c.NEAREST_LINEAR:c.magFilter=9728,c.minFilter=9729;break;case I.c.NEAREST_LINEAR_MIPLINEAR:c.magFilter=9728,c.minFilter=9987;break;case I.c.NEAREST_NEAREST:c.magFilter=9728,c.minFilter=9728;break;case I.c.NEAREST_LINEAR_MIPNEAREST:c.magFilter=9728,c.minFilter=9985;break;case I.c.LINEAR_NEAREST_MIPNEAREST:c.magFilter=9729,c.minFilter=9984;break;case I.c.LINEAR_NEAREST_MIPLINEAR:c.magFilter=9729,c.minFilter=9986;break;case I.c.NEAREST_NEAREST_MIPLINEAR:c.magFilter=9728,c.minFilter=9986;break;case I.c.LINEAR_LINEAR_MIPLINEAR:c.magFilter=9729,c.minFilter=9987;break;case I.c.LINEAR_LINEAR_MIPNEAREST:c.magFilter=9729,c.minFilter=9985;break;case I.c.NEAREST_NEAREST_MIPNEAREST:c.magFilter=9728,c.minFilter=9984}return c}_getGLTFTextureWrapMode(q){switch(q){case I.c.WRAP_ADDRESSMODE:return 10497;case I.c.CLAMP_ADDRESSMODE:return 33071;case I.c.MIRROR_ADDRESSMODE:return 33648;default:return Q.e.Error(`Unsupported Texture Wrap Mode ${q}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(q,c,U,J){const Q={diffuseColor:q._albedoColor,specularColor:q._reflectivityColor,glossiness:q._microSurface},s=q._albedoTexture,g=q._reflectivityTexture,X=q._useMicroSurfaceFromReflectivityMapAlpha;if(g&&!X)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((s||g)&&J){this._exporter._materialNeedsUVsSet.add(q);const J=this._exportTextureSampler(s||g),X=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(s,g,Q,c),n=this._exporter._textures;if(X.baseColorTextureData){const q=this._exportImage(`baseColor${n.length}`,c,X.baseColorTextureData);U.baseColorTexture=this._exportTextureInfo(q,J,null===s||void 0===s?void 0:s.coordinatesIndex)}if(X.metallicRoughnessTextureData){const q=this._exportImage(`metallicRoughness${n.length}`,c,X.metallicRoughnessTextureData);U.metallicRoughnessTexture=this._exportTextureInfo(q,J,null===g||void 0===g?void 0:g.coordinatesIndex)}return X}return this._convertSpecularGlossinessToMetallicRoughness(Q)}async exportPBRMaterialAsync(q,c,U){const J={},Q={name:q.name},s=q.isMetallicWorkflow();if(s){const c=q._albedoColor,U=q.alpha;c&&(J.baseColorFactor=[c.r,c.g,c.b,U])}const g=s?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(q,c,J,U):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(q,c,J,U);await this._setMetallicRoughnessPbrMaterialAsync(g,q,Q,J,c,U),await this._finishMaterialAsync(Q,q,c);const X=this._exporter._materials;return X.push(Q),X.length-1}async _setMetallicRoughnessPbrMaterialAsync(q,c,U,J,s,g){if(S(U,c),q.baseColor.equalsWithEpsilon(k,F)&&p.WithinEpsilon(c.alpha,1,F)||(J.baseColorFactor=[q.baseColor.r,q.baseColor.g,q.baseColor.b,c.alpha]),null!=q.metallic&&1!==q.metallic&&(J.metallicFactor=q.metallic),null!=q.roughness&&1!==q.roughness&&(J.roughnessFactor=q.roughness),null==c.Kc||c.Kc||(c._twoSidedLighting||Q.e.Warn(c.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),U.doubleSided=!0),g){const q=[],J=c._bumpTexture;J&&q.push(this.exportTextureAsync(J,s).then((q=>{q&&(U.normalTexture=q,1!==J.level&&(U.normalTexture.scale=J.level))})));const Q=c._ambientTexture;Q&&q.push(this.exportTextureAsync(Q,s).then((q=>{if(q){const J={index:q.index,texCoord:q.texCoord,extensions:q.extensions};U.occlusionTexture=J;const Q=c._ambientTextureStrength;Q&&(J.strength=Q)}})));const g=c._emissiveTexture;g&&q.push(this.exportTextureAsync(g,s).then((q=>{q&&(U.emissiveTexture=q)}))),q.length>0&&(this._exporter._materialNeedsUVsSet.add(c),await Promise.all(q))}const X=c._emissiveColor;X.equalsWithEpsilon(V,F)||(U.emissiveFactor=X.rc()),U.pbrMetallicRoughness=J}_getPixelsFromTextureAsync(q){return function(q){switch(q){case C.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case C.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case C.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case C.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case C.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case C.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case C.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case C.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case C.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case C.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case C.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case C.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case C.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case C.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case C.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case C.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case C.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case C.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case C.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case C.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case C.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(q.textureFormat)?(0,R.k)(q,q._texture.width,q._texture.height):(q.textureType,C.c.TEXTURETYPE_UNSIGNED_BYTE,q.readPixels())}async exportTextureAsync(q,c){const U=this._exporter._extensionsPreExportTextureAsync("exporter",q,c);return U?await U.then((async U=>U?await this._exportTextureInfoAsync(U,c):await this._exportTextureInfoAsync(q,c))):await this._exportTextureInfoAsync(q,c)}async _exportTextureInfoAsync(q,c){let U=this._textureMap.get(q);if(!U){const J=await this._getPixelsFromTextureAsync(q);if(!J)return null;const s=this._exportTextureSampler(q),g=q.mimeType;if(g)switch(g){case"image/jpeg":case"image/png":case"image/webp":c=g;break;default:Q.e.Warn(`Unsupported media type: ${g}. Exporting texture as PNG.`)}const X=this._internalTextureToImage,n=q.getInternalTexture().uniqueId;X[n]||(X[n]={});let W=X[n][c];if(void 0===W){const U=q.getSize();W=(async()=>{const Q=await this._getImageDataAsync(J,U.width,U.height,c);return this._exportImage(q.name,c,Q)})(),X[n][c]=W}U=this._exportTextureInfo(await W,s,q.coordinatesIndex),this._textureMap.set(q,U),this._exporter._extensionsPostExportTextures("exporter",U,q)}return U}_exportImage(q,c,U){const J=this._exporter._images;let s;if(this._exporter._shouldUseGlb){s={name:q,mimeType:c,bufferView:void 0};const J=this._exporter._bufferManager.createBufferView(new Uint8Array(U));this._exporter._bufferManager.setBufferView(s,J)}else{const g=q.replace(/\.\/|\/|\.\\|\\/g,"_"),X=function(q){switch(q){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(c);let n=g+X;J.some((q=>q.uri===n))&&(n=`${g}_${Q.e.RandomId()}${X}`),s={name:q,uri:n},this._exporter._imageData[n]={data:U,mimeType:c}}return J.push(s),J.length-1}_exportTextureInfo(q,c,U){const J=this._exporter._textures;let Q=J.findIndex((U=>U.sampler==c&&U.source===q));-1===Q&&(Q=J.length,J.push({source:q,sampler:c}));const s={index:Q};return U&&(s.texCoord=U),s}_exportTextureSampler(q){const c=this._getTextureSampler(q),U=this._exporter._samplers,J=U.findIndex((q=>q.minFilter===c.minFilter&&q.magFilter===c.magFilter&&q.wrapS===c.wrapS&&q.wrapT===c.wrapT));return-1!==J?J:(U.push(c),U.length-1)}}var y=U(11035),M=U(10886),T=U(11339),m=U(10836);const d=J.p.Zero(),e=J.g.Identity(),B=J.p.One(),N=new J.p(-1,1,1);function P(q,c){const{byteOffset:U,byteStride:J,type:Q,normalized:s}=q,g=q.getSize(),X=c.reduce(((q,c)=>c.getTotalVertices()>q?c.getTotalVertices():q),-Number.MAX_VALUE);return{byteOffset:U,byteStride:J,componentCount:g,type:Q,count:X*g,normalized:s,totalVertices:X,kind:q.getKind()}}function w(q){switch(q){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function L(q){switch(q){case D.h.PositionKind:case D.h.NormalKind:case D.h.TangentKind:case D.h.ColorKind:case D.h.MatricesIndicesKind:case D.h.MatricesIndicesExtraKind:case D.h.MatricesWeightsKind:case D.h.MatricesWeightsExtraKind:case D.h.UVKind:case D.h.UV2Kind:case D.h.UV3Kind:case D.h.UV4Kind:case D.h.UV5Kind:case D.h.UV6Kind:return!0}return!1}function l(q){switch(q){case s.b.TriangleFillMode:return 4;case s.b.TriangleStripDrawMode:return 5;case s.b.TriangleFanDrawMode:return 6;case s.b.PointListDrawMode:case s.b.PointFillMode:return 0;case s.b.LineLoopDrawMode:return 2;case s.b.LineListDrawMode:return 1;case s.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${q}`)}function j(q){const c=Math.sqrt(q.x*q.x+q.y*q.y+q.z*q.z);c>0&&(q.x/=c,q.y/=c,q.z/=c)}function f(q){return q.x*=-1,q}function A(q){if(q.x*q.x+q.y*q.y>.5){const c=Math.abs(q.x),U=Math.abs(q.y);if(c>U){const U=Math.sign(q.x);q.x=c,q.y*=-U,q.z*=-U,q.w*=U}else{const c=Math.sign(q.y);q.x*=-c,q.y=U,q.z*=c,q.w*=-c}}else{const c=Math.abs(q.z),U=Math.abs(q.w);if(c>U){const U=Math.sign(q.z);q.x*=-U,q.y*=U,q.z=c,q.w*=-U}else{const c=Math.sign(q.w);q.x*=c,q.y*=-c,q.z*=-c,q.w=U}}return q}function E(q){q.bc(-q.z,q.w,q.x,-q.y)}function qq(q,c){const U=J.p.FromArrayToRef(c.translation||[0,0,0],0,J.j.hc[0]),Q=J.g.FromArrayToRef(c.rotation||[0,0,0,1],0,J.j.Quaternion[0]),s=J.d.ComposeToRef(B,Q,U,J.j.Matrix[0]),g=J.p.FromArrayToRef(q.translation||[0,0,0],0,J.j.hc[2]),X=J.g.FromArrayToRef(q.rotation||[0,0,0,1],0,J.j.Quaternion[1]),n=J.d.ComposeToRef(B,X,g,J.j.Matrix[1]);s.multiplyToRef(n,n),n.decompose(void 0,Q,U),U.equalsWithEpsilon(d,m.d)?delete c.translation:c.translation=U.rc(),Q.equalsWithEpsilon(e,m.d)?delete c.rotation:c.rotation=Q.rc(),c.scale&&delete c.scale}function cq(q,c){if(!(c instanceof u.c))return!1;if(!(1===c.getChildren().length&&0===q.getChildren().length&&q.parent===c))return!1;const U=q.Cq(),J=q instanceof T.c&&!U.useRightHandedSystem?N:B;return!!c.ac.equalsWithEpsilon(J,m.d)||(M.c.Warn(`Cannot collapse node ${q.name} into parent node ${c.name} with modified scaling.`),!1)}function Uq(q){if(q instanceof Array){const c=new Float32Array(q);return new Uint8Array(c.buffer,c.byteOffset,c.byteLength)}return ArrayBuffer.isView(q)?new Uint8Array(q.buffer,q.byteOffset,q.byteLength):new Uint8Array(q)}function Jq(q,c){for(const[U,J]of Object.entries(q)){const Q=c[U];(Array.isArray(J)&&Array.isArray(Q)&&Qq(J,Q)||J===Q)&&delete q[U]}return q}function Qq(q,c){return q.length===c.length&&q.every(((q,U)=>q===c[U]))}const sq=J.d.Compose(new J.p(-1,1,1),J.g.Identity(),J.p.Zero());function gq(q,c){if(!(q instanceof u.c))return!1;if(c){if(!q.getWorldMatrix().equalsWithEpsilon(J.d.IdentityReadOnly,m.d))return!1}else{if(!q.getWorldMatrix().multiplyToRef(sq,J.j.Matrix[0]).equalsWithEpsilon(J.d.IdentityReadOnly,m.d))return!1}return!(q instanceof K.c&&q.Dc)}const Xq=new Map([[Int8Array,(q,c,U)=>q.setInt8(c,U)],[Uint8Array,(q,c,U)=>q.setUint8(c,U)],[Uint8ClampedArray,(q,c,U)=>q.setUint8(c,U)],[Int16Array,(q,c,U)=>q.setInt16(c,U,!0)],[Uint16Array,(q,c,U)=>q.setUint16(c,U,!0)],[Int32Array,(q,c,U)=>q.setInt32(c,U,!0)],[Uint32Array,(q,c,U)=>q.setUint32(c,U,!0)],[Float32Array,(q,c,U)=>q.setFloat32(c,U,!0)],[Float64Array,(q,c,U)=>q.setFloat64(c,U,!0)]]);class nq{writeTypedArray(q){this._checkGrowBuffer(q.byteLength);const c=Xq.get(q.constructor);for(let U=0;U<q.length;U++)c(this._dataView,this._byteOffset,q[U]),this._byteOffset+=q.BYTES_PER_ELEMENT}constructor(q){this._data=new Uint8Array(q),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(q){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,q),this._byteOffset++}writeInt8(q){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,q),this._byteOffset++}writeInt16(q){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,q,!0),this._byteOffset+=2}writeUInt16(q){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,q,!0),this._byteOffset+=2}writeInt32(q){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,q,!0),this._byteOffset+=4}writeUInt32(q){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,q,!0),this._byteOffset+=4}writeFloat32(q){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,q,!0),this._byteOffset+=4}writeFloat64(q){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,q,!0),this._byteOffset+=8}_checkGrowBuffer(q){const c=this.byteOffset+q;if(c>this._data.byteLength){const q=new Uint8Array(2*c);q.set(this._data),this._data=q,this._dataView=new DataView(this._data.buffer)}}}function Wq(q){return q%4===0?4:q%2===0?2:1}class Dq{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(q){let c=0;this._bufferViewToData.forEach((q=>{c+=q.byteLength}));const U=new nq(c),J=Array.from(this._bufferViewToData.keys()).sort(((q,c)=>Wq(c.byteLength)-Wq(q.byteLength)));for(const Q of J){Q.byteOffset=U.byteOffset,q.push(Q);const c=q.length-1,J=this.getPropertiesWithBufferView(Q);for(const q of J)q.bufferView=c;U.writeTypedArray(this._bufferViewToData.get(Q)),this._bufferViewToData.delete(Q)}return U.getOutputData()}createBufferView(q,c){const U={buffer:0,byteOffset:void 0,byteLength:q.byteLength,byteStride:c};return this._bufferViewToData.set(U,q),U}createAccessor(q,c,U,J,Q,s,g){this._verifyBufferView(q);const X={bufferView:void 0,componentType:U,count:J,type:c,min:null===s||void 0===s?void 0:s.min,max:null===s||void 0===s?void 0:s.max,normalized:g,byteOffset:Q};return this.setBufferView(X,q),this._accessorToBufferView.set(X,q),X}setBufferView(q,c){this._verifyBufferView(c);this.getPropertiesWithBufferView(c).push(q)}removeBufferView(q){const c=this.getPropertiesWithBufferView(q);for(const U of c)void 0!==U.bufferView&&delete U.bufferView;this._bufferViewToData.delete(q),this._bufferViewToProperties.delete(q),this._accessorToBufferView.forEach(((c,U)=>{c===q&&(void 0!==U.byteOffset&&delete U.byteOffset,this._accessorToBufferView.delete(U))}))}getBufferView(q){const c=this._accessorToBufferView.get(q);return this._verifyBufferView(c),c}getPropertiesWithBufferView(q){return this._verifyBufferView(q),this._bufferViewToProperties.set(q,this._bufferViewToProperties.get(q)??[]),this._bufferViewToProperties.get(q)}getData(q){return this._verifyBufferView(q),this._bufferViewToData.get(q)}_verifyBufferView(q){if(void 0===q||!this._bufferViewToData.has(q))throw new Error(`BufferView ${q} not found in BufferManager.`)}}var uq,Kq=U(11151),rq=U(11183),Hq=U(11341),bq=U(11463),hq=U(11468),oq=U(11481),aq=U(11149),pq=U(11483);!function(q){q[q.INTANGENT=0]="INTANGENT",q[q.OUTTANGENT=1]="OUTTANGENT"}(uq||(uq={}));class Rq{static _IsTransformable(q){return q&&(q instanceof u.c||q instanceof Kq.d||q instanceof pq.c)}static _CreateNodeAnimation(q,c,U,J,s){if(this._IsTransformable(q)){const g=[],X=[],n=c.getKeys(),W=Rq._CalculateMinMaxKeyFrames(n),D=Rq._DeduceInterpolation(n,U,J),u=D.interpolationType,K=D.shouldBakeAnimation;if(K?Rq._CreateBakedAnimation(q,c,U,W.min,W.max,c.framePerSecond,s,g,X,W,J):"LINEAR"===u||"STEP"===u?Rq._CreateLinearOrStepAnimation(q,c,U,g,X,J):"CUBICSPLINE"===u?Rq._CreateCubicSplineAnimation(q,c,U,g,X,J):Rq._CreateBakedAnimation(q,c,U,W.min,W.max,c.framePerSecond,s,g,X,W,J),g.length&&X.length){return{inputs:g,outputs:X,samplerInterpolation:u,inputsMin:K?W.min:Q.e.FloatRound(W.min/c.framePerSecond),inputsMax:K?W.max:Q.e.FloatRound(W.max/c.framePerSecond)}}}return null}static _DeduceAnimationInfo(q){let c=null,U="VEC3",J=!1;const s=q.targetProperty.split(".");switch(s[0]){case"ac":c="scale";break;case"position":c="translation";break;case"rotation":U="VEC4",c="rotation";break;case"rotationQuaternion":U="VEC4",J=!0,c="rotation";break;case"influence":U="SCALAR",c="weights";break;default:Q.e.Error(`Unsupported animatable property ${s[0]}`)}return c?{animationChannelTargetPath:c,dataAccessorType:U,useQuaternion:J}:(Q.e.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(q,c,U,J,Q,s,g,X,n,W,D){let u;if(Rq._IsTransformable(q)&&q.animations)for(const K of q.animations){if(D&&!D(K))continue;const Q=Rq._DeduceAnimationInfo(K);Q&&(u={name:K.name,samplers:[],channels:[]},Rq._AddAnimation(`${K.name}`,K.hasRunningRuntimeAnimations?c:u,q,K,Q.dataAccessorType,Q.animationChannelTargetPath,J,s,g,X,Q.useQuaternion,n,W),u.samplers.length&&u.channels.length&&U.push(u))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(q,c,U,J,Q,s,g,X,n,W,D){let u;if(q instanceof aq.b){const Q=q.morphTargetManager;if(Q)for(let K=0;K<Q.numTargets;++K){const r=Q.getTarget(K);for(const H of r.animations){if(D&&!D(H))continue;const r=new hq.b(`${H.name}`,"influence",H.framePerSecond,H.dataType,H.loopMode,H.enableBlending),b=[],h=H.getKeys();for(let q=0;q<h.length;++q){const c=h[q];for(let q=0;q<Q.numTargets;++q)q==K?b.push(c):b.push({frame:c.frame,value:0})}r.setKeys(b);const o=Rq._DeduceAnimationInfo(r);o&&(u={name:r.name,samplers:[],channels:[]},Rq._AddAnimation(H.name,H.hasRunningRuntimeAnimations?c:u,q,r,o.dataAccessorType,o.animationChannelTargetPath,J,s,g,X,o.useQuaternion,n,W,Q.numTargets),u.samplers.length&&u.channels.length&&U.push(u))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(q,c,U,J,Q,s,g,X,n){let W;if(q.animationGroups){const u=q.animationGroups;for(const K of u){const u=new Map,r=new Map,H=new Set,b=K.to-K.from;W={name:K.name,channels:[],samplers:[]};for(let c=0;c<K.targetedAnimations.length;++c){const b=K.targetedAnimations[c],h=b.target,o=b.animation;if(n&&!n(o))continue;const a=X.has(h);if(this._IsTransformable(h)||1===h.length&&this._IsTransformable(h[0])){const q=Rq._DeduceAnimationInfo(b.animation);if(q){const c=this._IsTransformable(h)?h:this._IsTransformable(h[0])?h[0]:null;c&&Rq._AddAnimation(`${o.name}`,W,c,o,q.dataAccessorType,q.animationChannelTargetPath,U,J,Q,s,q.useQuaternion,g,a)}}else if(h instanceof oq.c||1===h.length&&h[0]instanceof oq.c){if(Rq._DeduceAnimationInfo(b.animation)){const c=h instanceof oq.c?h:h[0];if(c){const U=q.morphTargetManagers.find((q=>{for(let U=0;U<q.numTargets;++U)if(q.getTarget(U)===c)return!0;return!1}));if(U){const J=q.meshes.find((q=>q.morphTargetManager===U));var D;if(J)u.has(J)||u.set(J,new Map),null===(D=u.get(J))||void 0===D||D.set(c,o),H.add(J),r.set(J,o)}}}}}H.forEach((q=>{const c=q.morphTargetManager;let X=null;const n=[],D=r.get(q).getKeys(),H=D.length;for(let U=0;U<H;++U)for(let J=0;J<c.numTargets;++J){const Q=c.getTarget(J),s=u.get(q);if(s){const c=s.get(Q);c?(X||(X=new hq.b(`${K.name}_${q.name}_MorphWeightAnimation`,"influence",c.framePerSecond,hq.b.ANIMATIONTYPE_FLOAT,c.loopMode,c.enableBlending)),n.push(c.getKeys()[U])):n.push({frame:K.from+b/H*U,value:Q.influence,inTangent:D[0].inTangent?0:void 0,outTangent:D[0].outTangent?0:void 0})}}X.setKeys(n);const h=Rq._DeduceAnimationInfo(X);h&&Rq._AddAnimation(`${K.name}_${q.name}_MorphWeightAnimation`,W,q,X,h.dataAccessorType,h.animationChannelTargetPath,U,J,Q,s,h.useQuaternion,g,!1,null===c||void 0===c?void 0:c.numTargets)})),W.channels.length&&W.samplers.length&&c.push(W)}}}static _AddAnimation(q,c,U,Q,s,g,X,n,W,D,u,K,r,H){const b=Rq._CreateNodeAnimation(U,Q,g,u,K);let h,o,a,p,R,I;if(b){if(H){let q=0,c=0;const U=[];for(;b.inputs.length>0;)c=b.inputs.shift(),q%H==0&&U.push(c),q++;b.inputs=U}const q=X.get(U),Q=new Float32Array(b.inputs);h=n.createBufferView(Q),o=n.createAccessor(h,"SCALAR",5126,b.inputs.length,void 0,{min:[b.inputsMin],max:[b.inputsMax]}),D.push(o),a=D.length-1;const W=new J.g,u=new J.p,K=new J.p,t=U instanceof Kq.d,C=w(s),i=new Float32Array(b.outputs.length*C);b.outputs.forEach((function(q,c){let U=q;switch(g){case"translation":r&&(J.p.FromArrayToRef(q,0,K),f(K),K.toArray(U));break;case"rotation":4===q.length?J.g.FromArrayToRef(q,0,W):(U=new Array(4),J.p.FromArrayToRef(q,0,u),J.g.FromEulerVectorToRef(u,W)),r&&(A(W),t&&E(W)),W.toArray(U)}i.set(U,c*C)})),h=n.createBufferView(i),o=n.createAccessor(h,s,5126,b.outputs.length),D.push(o),p=D.length-1,R={interpolation:b.samplerInterpolation,input:a,output:p},c.samplers.push(R),I={sampler:c.samplers.length-1,target:{node:q,path:g}},c.channels.push(I)}}static _CreateBakedAnimation(q,c,U,s,g,X,n,W,D,u,K){let r;const H=J.g.Identity();let b,h=null,o=null,a=null,p=null,R=null,I=null;u.min=Q.e.FloatRound(s/X);const t=c.getKeys();for(let J=0,C=t.length;J<C;++J){if(I=null,a=t[J],J+1<C)if(p=t[J+1],a.value.equals&&a.value.equals(p.value)||a.value===p.value){if(0!==J)continue;I=a.frame}else I=p.frame;else{if(R=t[J-1],a.value.equals&&a.value.equals(R.value)||a.value===R.value)continue;I=g}if(I)for(let J=a.frame;J<=I;J+=n){if(b=Q.e.FloatRound(J/X),b===h)continue;h=b,o=b;const s={key:0,repeatCount:0,loopMode:c.loopMode};r=c._interpolate(J,s),Rq._SetInterpolatedValue(q,r,b,c,U,H,W,D,K)}}o&&(u.max=o)}static _ConvertFactorToVector3OrQuaternion(q,c,U,s,g){const X=Rq._GetBasePositionRotationOrScale(c,s,g),n=U.targetProperty.split("."),W=n?n[1]:"",D=g?J.g.Ic(X).normalize():J.p.Ic(X);switch(W){case"x":case"y":case"z":D[W]=q;break;case"w":D.w=q;break;default:Q.e.Error(`glTFAnimation: Unsupported component name "${W}"!`)}return D}static _SetInterpolatedValue(q,c,U,Q,s,g,X,n,W){let D;X.push(U),"weights"!==s?(Q.dataType===hq.b.ANIMATIONTYPE_FLOAT&&(c=this._ConvertFactorToVector3OrQuaternion(c,q,Q,s,W)),"rotation"===s?(W?g=c:(D=c,J.g.RotationYawPitchRollToRef(D.y,D.x,D.z,g)),n.push(g.rc())):(D=c,n.push(D.rc()))):n.push([c])}static _CreateLinearOrStepAnimation(q,c,U,J,Q,s){for(const g of c.getKeys())J.push(g.frame/c.framePerSecond),Rq._AddKeyframeValue(g,c,Q,U,q,s)}static _CreateCubicSplineAnimation(q,c,U,J,Q,s){c.getKeys().forEach((function(g){J.push(g.frame/c.framePerSecond),Rq._AddSplineTangent(uq.INTANGENT,Q,U,"CUBICSPLINE",g,s),Rq._AddKeyframeValue(g,c,Q,U,q,s),Rq._AddSplineTangent(uq.OUTTANGENT,Q,U,"CUBICSPLINE",g,s)}))}static _GetBasePositionRotationOrScale(q,c,U){let Q;if("rotation"===c)if(U){Q=(q.rotationQuaternion??J.g.Identity()).rc()}else{Q=(q.rotation??J.p.Zero()).rc()}else if("translation"===c){Q=(q.position??J.p.Zero()).rc()}else{Q=(q.ac??J.p.One()).rc()}return Q}static _AddKeyframeValue(q,c,U,s,g,X){let n;const W=c.dataType;if(W===hq.b.ANIMATIONTYPE_VECTOR3){let c=q.value.rc();if("rotation"===s){const q=J.p.Ic(c);c=J.g.RotationYawPitchRoll(q.y,q.x,q.z).rc()}U.push(c)}else if(W===hq.b.ANIMATIONTYPE_FLOAT){if("weights"===s)U.push([q.value]);else if(n=this._ConvertFactorToVector3OrQuaternion(q.value,g,c,s,X),n){if("rotation"===s){const q=X?n:J.g.RotationYawPitchRoll(n.y,n.x,n.z).normalize();U.push(q.rc())}U.push(n.rc())}}else W===hq.b.ANIMATIONTYPE_QUATERNION?U.push(q.value.normalize().rc()):Q.e.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(q,c,U){let J,Q,s=!1;if("rotation"===c&&!U)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let g=0,X=q.length;g<X;++g)if(Q=q[g],Q.inTangent||Q.outTangent)if(J){if("CUBICSPLINE"!==J){J="LINEAR",s=!0;break}}else J="CUBICSPLINE";else if(J){if("CUBICSPLINE"===J||Q.interpolation&&1===Q.interpolation&&"STEP"!==J){J="LINEAR",s=!0;break}}else J=Q.interpolation&&1===Q.interpolation?"STEP":"LINEAR";return J||(J="LINEAR"),{interpolationType:J,shouldBakeAnimation:s}}static _AddSplineTangent(q,c,U,Q,s,g){let X;const n=q===uq.INTANGENT?s.inTangent:s.outTangent;if("CUBICSPLINE"===Q){if("rotation"===U)if(n)if(g)X=n.rc();else{const q=n;X=J.g.RotationYawPitchRoll(q.y,q.x,q.z).rc()}else X=[0,0,0,0];else X="weights"===U?n?[n]:[0]:n?n.rc():[0,0,0];c.push(X)}}static _CalculateMinMaxKeyFrames(q){let c=1/0,U=-1/0;return q.forEach((function(q){c=Math.min(c,q.frame),U=Math.max(U,q.frame)})),{min:c,max:U}}}function Iq(q,c,U,s,g,X){const n={attributes:{},influence:q.influence,name:q.name},W=c.Dc;if(!W)return Q.e.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),n;const u=X?-1:1,K=J.p.Zero();let r=0,H=0;if(q.hasPositions){const s=q.getPositions(),X=W.getVerticesData(D.h.PositionKind);if(X){const q=new Float32Array(X.length),c=[1/0,1/0,1/0],Q=[-1/0,-1/0,-1/0];H=X.length/3,r=0;for(let U=r;U<H;++U){const g=J.p.Ic(X,3*U);J.p.Ic(s,3*U).subtractToRef(g,K),K.x*=u,c[0]=Math.min(c[0],K.x),Q[0]=Math.max(Q[0],K.x),c[1]=Math.min(c[1],K.y),Q[1]=Math.max(Q[1],K.y),c[2]=Math.min(c[2],K.z),Q[2]=Math.max(Q[2],K.z),q[3*U]=K.x,q[3*U+1]=K.y,q[3*U+2]=K.z}const W=U.createBufferView(q,12),D=U.createAccessor(W,"VEC3",5126,s.length/3,0,{min:c,max:Q});g.push(D),n.attributes.POSITION=g.length-1}else Q.e.Warn(`Morph target positions for mesh ${c.name} were not exported. Mesh does not have position vertex data`)}if(q.hasNormals){const s=q.getNormals(),X=W.getVerticesData(D.h.NormalKind);if(X){const q=new Float32Array(X.length);H=X.length/3,r=0;for(let U=r;U<H;++U){const c=J.p.Ic(X,3*U).normalize();J.p.Ic(s,3*U).normalize().subtractToRef(c,K),q[3*U]=K.x*u,q[3*U+1]=K.y,q[3*U+2]=K.z}const c=U.createBufferView(q,12),Q=U.createAccessor(c,"VEC3",5126,s.length/3,0);g.push(Q),n.attributes.NORMAL=g.length-1}else Q.e.Warn(`Morph target normals for mesh ${c.name} were not exported. Mesh does not have normals vertex data`)}if(q.hasTangents){const s=q.getTangents(),X=W.getVerticesData(D.h.TangentKind);if(X){H=X.length/4;const q=new Float32Array(3*H);r=0;for(let U=r;U<H;++U){const c=J.p.Ic(X,4*U);j(c);const Q=J.p.Ic(s,3*U);j(Q),Q.subtractToRef(c,K),q[3*U]=K.x*u,q[3*U+1]=K.y,q[3*U+2]=K.z}const c=U.createBufferView(q,12),Q=U.createAccessor(c,"VEC3",5126,H,0);g.push(Q),n.attributes.TANGENT=g.length-1}else Q.e.Warn(`Morph target tangents for mesh ${c.name} were not exported. Mesh does not have tangents vertex data`)}if(q.hasColors){const s=q.getColors(),X=W.getVerticesData(D.h.ColorKind),u=W.getVertexBuffer(D.h.ColorKind);if(X&&u){const q=u.getSize();H=X.length/q;const c=new Float32Array(H*q);r=0;for(let U=r;U<H;++U)if(3===q){const Q=J.p.Ic(X,U*q);J.p.Ic(s,U*q).subtractToRef(Q,K),c[3*U]=K.x,c[3*U+1]=K.y,c[3*U+2]=K.z}else if(4===q){const Q=new J.q,g=J.q.Ic(X,U*q);J.q.Ic(s,U*q).subtractToRef(g,Q),c[4*U]=Q.x,c[4*U+1]=Q.y,c[4*U+2]=Q.z,c[4*U+3]=Q.w}else Q.e.Warn(`Unsupported number of components for color attribute: ${q}`);const W=U.createBufferView(c,4*q),D=U.createAccessor(W,3===q?"VEC3":"VEC4",5126,H,0);g.push(D),n.attributes.COLOR_0=g.length-1}else Q.e.Warn(`Morph target colors for mesh ${c.name} were not exported. Mesh does not have colors vertex data`)}return n}var tq=U(11486),Cq=U(11418),iq=U(11416),Fq=U(10850);class vq{}vq.DEFAULT_COLOR=h.c.White(),vq.DEFAULT_WIDTH_ATTENUATED=1,vq.DEFAULT_WIDTH=.1;var Yq=U(11266),kq=U(11502);class Vq{static ConvertPoints(q,c){if(q.length&&Array.isArray(q)&&"number"===typeof q[0])return[q];if(q.length&&Array.isArray(q[0])&&"number"===typeof q[0][0])return q;if(q.length&&!Array.isArray(q[0])&&q[0]instanceof J.p){const c=[];for(let U=0;U<q.length;U++){const J=q[U];c.push(J.x,J.y,J.z)}return[c]}if(q.length>0&&Array.isArray(q[0])&&q[0].length>0&&q[0][0]instanceof J.p){const c=[],U=q;for(const q of U)c.push(q.flatMap((q=>[q.x,q.y,q.z])));return c}if(q instanceof Float32Array){if(null!==c&&void 0!==c&&c.floatArrayStride){const U=[],J=3*c.floatArrayStride;for(let c=0;c<q.length;c+=J){const Q=new Array(J);for(let U=0;U<J;U++)Q[U]=q[c+U];U.push(Q)}return U}return[Array.from(q)]}if(q.length&&q[0]instanceof Float32Array){const c=[];for(const U of q)c.push(Array.from(U));return c}return[]}static OmitZeroLengthPredicate(q,c,U){const J=[];return c.eU(q).lengthSquared()>0&&J.push([q,c]),U.eU(c).lengthSquared()>0&&J.push([c,U]),q.eU(U).lengthSquared()>0&&J.push([U,q]),0===J.length?null:J}static OmitDuplicatesPredicate(q,c,U,J){const Q=[];return Vq._SearchInPoints(q,c,J)||Q.push([q,c]),Vq._SearchInPoints(c,U,J)||Q.push([c,U]),Vq._SearchInPoints(U,q,J)||Q.push([U,q]),0===Q.length?null:Q}static _SearchInPoints(q,c,U){for(const g of U)for(let U=0;U<g.length;U++){var J,Q,s;if(null!==(J=g[U])&&void 0!==J&&J.equals(q))if(null!==(Q=g[U+1])&&void 0!==Q&&Q.equals(c)||null!==(s=g[U-1])&&void 0!==s&&s.equals(c))return!0}return!1}static MeshesToLines(q,c){const U=[];for(let Q=0;Q<q.length;Q++){const s=q[Q],g=s.getVerticesData(D.h.PositionKind),X=s.uc();if(g&&X)for(let q=0,n=0;q<X.length;q++){const W=3*X[n++],D=3*X[n++],u=3*X[n++],K=new J.p(g[W],g[W+1],g[W+2]),r=new J.p(g[D],g[D+1],g[D+2]),H=new J.p(g[u],g[u+1],g[u+2]);if(c){const J=c(K,r,H,U,q,W,s,Q,g,X);if(J)for(const q of J)U.push(q)}else U.push([K,r],[r,H],[H,K])}}return U}static ToVector3Array(q){if(Array.isArray(q[0])){const c=[],U=q;for(const q of U){const U=[];for(let c=0;c<q.length;c+=3)U.push(new J.p(q[c],q[c+1],q[c+2]));c.push(U)}return c}const c=q,U=[];for(let Q=0;Q<c.length;Q+=3)U.push(new J.p(c[Q],c[Q+1],c[Q+2]));return U}static ToNumberArray(q){return q.flatMap((q=>[q.x,q.y,q.z]))}static GetPointsCountInfo(q){const c=new Array(q.length);let U=0;for(let J=q.length;J--;)c[J]=q[J].length/3,U+=c[J];return{total:U,counts:c}}static GetLineLength(q){if(0===q.length)return 0;let c;c="number"===typeof q[0]?Vq.ToVector3Array(q):q;const U=J.j.hc[0];let Q=0;for(let J=0;J<c.length-1;J++){const q=c[J];Q+=c[J+1].subtractToRef(q,U).length()}return Q}static GetLineLengthArray(q){const c=new Float32Array(q.length/3);let U=0;for(let J=0,Q=q.length/3-1;J<Q;J++){let Q=q[3*J+0],s=q[3*J+1],g=q[3*J+2];Q-=q[3*J+3],s-=q[3*J+4],g-=q[3*J+5];U+=Math.sqrt(Q*Q+s*s+g*g),c[J+1]=U}return c}static SegmentizeSegmentByCount(q,c,U){const Q=[],s=c.eU(q),g=J.j.hc[0];g.tc(U);const X=J.j.hc[1];s.divideToRef(g,X);let n=q.clone();Q.push(n);for(let J=0;J<U;J++)n=n.clone(),Q.push(n.addInPlace(X));return Q}static SegmentizeLineBySegmentLength(q,c){const U=q[0]instanceof J.p?Vq.GetLineSegments(q):"number"===typeof q[0]?Vq.GetLineSegments(Vq.ToVector3Array(q)):q,Q=[];for(const J of U)if(J.length>c){const q=Vq.SegmentizeSegmentByCount(J.point1,J.point2,Math.ceil(J.length/c));for(const c of q)Q.push(c)}else Q.push(J.point1),Q.push(J.point2);return Q}static SegmentizeLineBySegmentCount(q,c){const U="number"===typeof q[0]?Vq.ToVector3Array(q):q,J=Vq.GetLineLength(U)/c;return Vq.SegmentizeLineBySegmentLength(U,J)}static GetLineSegments(q){const c=[];for(let U=0;U<q.length-1;U++){const J=q[U],Q=q[U+1],s=Q.eU(J).length();c.push({point1:J,point2:Q,length:s})}return c}static GetMinMaxSegmentLength(q){const c=Vq.GetLineSegments(q).sort((q=>q.length));return{min:c[0].length,max:c[c.length-1].length}}static GetPositionOnLineByVisibility(q,c,U){let Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=c*U;let g=0,X=0;const n=q.length;for(let J=0;J<n;J++){if(s<=g+q[J].length){X=J;break}g+=q[J].length}const W=(s-g)/q[X].length;return q[X].point2.subtractToRef(q[X].point1,J.j.hc[0]),J.j.hc[1]=J.j.hc[0].multiplyByFloats(W,W,W),Q||J.j.hc[1].addInPlace(q[X].point1),J.j.hc[1].clone()}static GetCircleLinePoints(q,c){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:q,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/c;const g=[];for(let X=0;X<=c;X++)g.push(new J.p(Math.cos(X*s)*q,Math.sin(X*s)*Q,U));return g}static GetBezierLinePoints(q,c,U,J){return Yq.f.CreateQuadraticBezier(q,c,U,J).getPoints().flatMap((q=>[q.x,q.y,q.z]))}static GetArrowCap(q,c,U,J,Q){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[q.clone(),q.add(c.multiplyByFloats(U,U,U))],widths:[J,Q,s,g]}}static GetPointsFromText(q,c,U,J){let Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const g=[],X=(0,kq.e)(q,c,U,J);for(const n of X){for(const q of n.paths){const c=[],U=q.getPoints();for(const q of U)c.push(q.x,q.y,Q);g.push(c)}if(s)for(const q of n.holes){const c=[],U=q.getPoints();for(const q of U)c.push(q.x,q.y,Q);g.push(c)}}return g}static Color3toRGBAUint8(q){const c=new Uint8Array(4*q.length);for(let U=0,J=0;U<q.length;U++)c[J++]=255*q[U].r,c[J++]=255*q[U].g,c[J++]=255*q[U].b,c[J++]=255;return c}static CreateColorsTexture(q,c,U,J){const Q=J.getEngine().getCaps().maxTextureSize??1,s=c.length>Q?Q:c.length,g=Math.ceil(c.length/Q);g>1&&(c=[...c,...Array(s*g-c.length).fill(c[0])]);const X=Vq.Color3toRGBAUint8(c),n=new t.e(X,s,g,H.e.TEXTUREFORMAT_RGBA,J,!1,!0,U);return n.name=q,n}static PrepareEmptyColorsTexture(q){if(!vq.EmptyColorsTexture){const c=new Uint8Array(4);vq.EmptyColorsTexture=new t.e(c,1,1,H.e.TEXTUREFORMAT_RGBA,q,!1,!1,t.e.NEAREST_NEAREST),vq.EmptyColorsTexture.name="grlEmptyColorsTexture"}return vq.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var q;null===(q=vq.EmptyColorsTexture)||void 0===q||q.dispose(),vq.EmptyColorsTexture=null}static BooleanToNumber(q){return q?1:0}}class Oq extends iq.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Gq extends Cq.e{isCompatible(q){return!0}constructor(q,c,U){var Q;U=U||{color:vq.DEFAULT_COLOR};const s=new Oq;s.GREASED_LINE_HAS_COLOR=!!U.color&&!U.useColors,s.GREASED_LINE_SIZE_ATTENUATION=U.sizeAttenuation??!1,s.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===U.colorDistributionType,s.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(c??q.Cq()).useRightHandedSystem,s.GREASED_LINE_CAMERA_FACING=U.cameraFacing??!0,super(q,Gq.GREASED_LINE_MATERIAL_NAME,200,s,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(Q=U)||void 0===Q?void 0:Q.forceGLSL)||Gq.ForceGLSL,this._scene=c??q.Cq(),this._engine=this._scene.getEngine(),this._cameraFacing=U.cameraFacing??!0,this.visibility=U.visibility??1,this.useDash=U.useDash??!1,this.dashRatio=U.dashRatio??.5,this.dashOffset=U.dashOffset??0,this.width=U.width?U.width:U.sizeAttenuation?vq.DEFAULT_WIDTH_ATTENUATED:vq.DEFAULT_WIDTH,this._sizeAttenuation=U.sizeAttenuation??!1,this.colorMode=U.colorMode??0,this._color=U.color??null,this.useColors=U.useColors??!1,this._colorsDistributionType=U.colorDistributionType??0,this.colorsSampling=U.colorsSampling??t.e.NEAREST_NEAREST,this._colors=U.Yq??null,this.dashCount=U.dashCount??1,this.resolution=U.resolution??new J.l(this._engine.getRenderWidth(),this._engine.getRenderHeight()),U.colorsTexture?this.colorsTexture=U.colorsTexture:this._colors?this.colorsTexture=Vq.CreateColorsTexture(`${q.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??vq.DEFAULT_COLOR,Vq.PrepareEmptyColorsTexture(this._scene)),this._engine.Cc.add((()=>{Vq.DisposeEmptyColorsTexture()}))}getAttributes(q){q.push("grl_offsets"),q.push("grl_widths"),q.push("grl_colorPointers"),q.push("grl_counters"),this._cameraFacing?(q.push("grl_previousAndSide"),q.push("grl_nextAndCounters")):q.push("grl_slopes")}getSamplers(q){q.push("grl_colors")}getActiveTextures(q){this.colorsTexture&&q.push(this.colorsTexture)}getUniforms(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const c=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&c.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===q&&c.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:c,vertex:this._cameraFacing&&this._isGLSL(q)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(q)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(q){if(this._cameraFacing){q.vc("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||q.vc("viewProjection",this._scene.getTransformMatrix());const c=J.j.Vector4[0];c.x=this._aspect,c.y=this._resolution.x,c.z=this._resolution.y,c.w=this.width,q.updateVector4("grl_aspect_resolution_lineWidth",c)}const c=J.j.Vector4[0];c.x=Vq.BooleanToNumber(this.useDash),c.y=this._dashArray,c.z=this.dashOffset,c.w=this.dashRatio,q.updateVector4("grl_dashOptions",c);const U=J.j.Vector4[1];U.x=this.colorMode,U.y=this.visibility,U.z=this.colorsTexture?this.colorsTexture.getSize().width:0,U.w=Vq.BooleanToNumber(this.useColors),q.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",U),this._color&&q.updateColor3("grl_singleColor",this._color);const Q=this.colorsTexture??vq.EmptyColorsTexture;q.setTexture("grl_colors",Q),q.updateFloat2("grl_textureSize",(null===Q||void 0===Q?void 0:Q.getSize().width)??1,(null===Q||void 0===Q?void 0:Q.getSize().height)??1)}prepareDefines(q,c,U){q.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,q.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,q.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,q.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=c.useRightHandedSystem,q.GREASED_LINE_CAMERA_FACING=this._cameraFacing,q.GREASED_LINE_USE_OFFSETS=!!U.offsets}getClassName(){return Gq.GREASED_LINE_MATERIAL_NAME}getCustomCode(q){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(c)?function(q,c){if("vertex"===q){const q={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return c&&(q["!gl_Position\\=viewProjection\\*worldPos;"]="//"),q}return"fragment"===q?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(q,this._cameraFacing):function(q,c){if("vertex"===q){const q={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return c&&(q["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),q}return"fragment"===q?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(q,this._cameraFacing)}dispose(){var q;null===(q=this.colorsTexture)||void 0===q||q.dispose(),super.dispose()}get Yq(){return this._colors}set Yq(q){this.setColors(q)}setColors(q){var c;let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1],J=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var s;if(this._colors=q,null!==q&&0!==q.length){if(!U||J)if(this.colorsTexture&&Q===q.length&&!J){const c=Vq.Color3toRGBAUint8(q);this.colorsTexture.update(c)}else{var g;null===(g=this.colorsTexture)||void 0===g||g.dispose(),this.colorsTexture=Vq.CreateColorsTexture(`${this._material.name}-colors-texture`,q,this.colorsSampling,this._scene)}}else null===(s=this.colorsTexture)||void 0===s||s.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(q){this._dashCount=q,this._dashArray=1/q}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(q){this._sizeAttenuation=q,this.markAllDefinesAsDirty()}get color(){return this._color}set color(q){this.setColor(q)}setColor(q){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==q||null!==this._color&&null===q?(this._color=q,c||this.markAllDefinesAsDirty()):this._color=q}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(q){this._colorsDistributionType=q,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(q){this._aspect=q.x/q.y,this._resolution=q}serialize(){const q=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(c.Yq=this._colors),this._color&&(c.color=this._color),q.greasedLineMaterialOptions=c,q}parse(q,c,U){var J;super.parse(q,c,U);const Q=q.greasedLineMaterialOptions;null===(J=this.colorsTexture)||void 0===J||J.dispose(),Q.color&&this.setColor(Q.color,!0),Q.colorDistributionType&&(this.colorsDistributionType=Q.colorDistributionType),Q.Yq&&(this.Yq=Q.Yq),Q.colorsSampling&&(this.colorsSampling=Q.colorsSampling),Q.colorMode&&(this.colorMode=Q.colorMode),Q.useColors&&(this.useColors=Q.useColors),Q.visibility&&(this.visibility=Q.visibility),Q.useDash&&(this.useDash=Q.useDash),Q.dashCount&&(this.dashCount=Q.dashCount),Q.dashRatio&&(this.dashRatio=Q.dashRatio),Q.dashOffset&&(this.dashOffset=Q.dashOffset),Q.width&&(this.width=Q.width),Q.sizeAttenuation&&(this.sizeAttenuation=Q.sizeAttenuation),Q.resolution&&(this.resolution=Q.resolution),this.Yq?this.colorsTexture=Vq.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Yq,this.colorsSampling,c):Vq.PrepareEmptyColorsTexture(c),this.markAllDefinesAsDirty()}copyTo(q){var c;const U=q;null===(c=U.colorsTexture)||void 0===c||c.dispose(),this._colors&&(U.colorsTexture=Vq.CreateColorsTexture(`${U._material.name}-colors-texture`,this._colors,U.colorsSampling,this._scene)),U.setColor(this.color,!0),U.colorsDistributionType=this.colorsDistributionType,U.colorsSampling=this.colorsSampling,U.colorMode=this.colorMode,U.useColors=this.useColors,U.visibility=this.visibility,U.useDash=this.useDash,U.dashCount=this.dashCount,U.dashRatio=this.dashRatio,U.dashOffset=this.dashOffset,U.width=this.width,U.sizeAttenuation=this.sizeAttenuation,U.resolution=this.resolution,U.markAllDefinesAsDirty()}_isGLSL(q){return 0===q||this._forceGLSL}}Gq.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Gq.ForceGLSL=!1,(0,Fq.f)(`BABYLON.${Gq.GREASED_LINE_MATERIAL_NAME}`,Gq);var Sq=U(11125),Zq=U(10895),xq=U(11495),zq=U(10980);class yq extends xq.b{constructor(q,c,Q){const s=c.getEngine(),g=s.isWebGPU&&!(Q.forceGLSL||yq.ForceGLSL),X=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];c.useRightHandedSystem&&X.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const n=["position","grl_widths","grl_offsets","grl_colorPointers"];Q.cameraFacing?(X.push("GREASED_LINE_CAMERA_FACING"),n.push("grl_previousAndSide","grl_nextAndCounters")):(n.push("grl_slopes"),n.push("grl_counters"));const W=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(g||W.push("world","viewProjection","view","projection"),super(q,c,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:g?["Scene","Mesh"]:void 0,attributes:n,uniforms:W,samplers:g?[]:["grlColors"],defines:X,extraInitializationsAsync:async()=>{g?await Promise.all([U.e(47).then(U.bind(U,14015)),U.e(55).then(U.bind(U,14020))]):await Promise.all([U.e(50).then(U.bind(U,14026)),U.e(56).then(U.bind(U,14028))])},shaderLanguage:g?1:0}),this._color=h.c.White(),this._colorsDistributionType=0,this._colorsTexture=null,Q=Q||{color:vq.DEFAULT_COLOR},this.visibility=Q.visibility??1,this.useDash=Q.useDash??!1,this.dashRatio=Q.dashRatio??.5,this.dashOffset=Q.dashOffset??0,this.dashCount=Q.dashCount??1,this.width=Q.width?Q.width:Q.sizeAttenuation&&Q.cameraFacing?vq.DEFAULT_WIDTH_ATTENUATED:vq.DEFAULT_WIDTH,this.sizeAttenuation=Q.sizeAttenuation??!1,this.color=Q.color??h.c.White(),this.useColors=Q.useColors??!1,this.colorsDistributionType=Q.colorDistributionType??0,this.colorsSampling=Q.colorsSampling??t.e.NEAREST_NEAREST,this.colorMode=Q.colorMode??0,this._colors=Q.Yq??null,this._cameraFacing=Q.cameraFacing??!0,this.resolution=Q.resolution??new J.l(s.getRenderWidth(),s.getRenderHeight()),Q.colorsTexture?this.colorsTexture=Q.colorsTexture:this._colors?this.colorsTexture=Vq.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,c):(this._color=this._color??vq.DEFAULT_COLOR,this.colorsTexture=Vq.PrepareEmptyColorsTexture(c)),g){const q=new zq.d;q.setParameters(),q.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",q)}s.Cc.add((()=>{Vq.DisposeEmptyColorsTexture()}))}dispose(){var q;null===(q=this._colorsTexture)||void 0===q||q.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new J.l(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Yq(){return this._colors}set Yq(q){this.setColors(q)}setColors(q){var c;let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1],J=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var s;if(this._colors=q,null!==q&&0!==q.length){if(!U||J)if(this._colorsTexture&&Q===q.length&&!J){const c=Vq.Color3toRGBAUint8(q);this._colorsTexture.update(c)}else{var g;null===(g=this._colorsTexture)||void 0===g||g.dispose(),this.colorsTexture=Vq.CreateColorsTexture(`${this.name}-colors-texture`,q,this.colorsSampling,this.Cq())}}else null===(s=this._colorsTexture)||void 0===s||s.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(q){this._colorsTexture=q,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(q){this._width=q,this.setFloat("grlWidth",q)}get useColors(){return this._useColors}set useColors(q){this._useColors=q,this.setFloat("grlUseColors",Vq.BooleanToNumber(q))}get colorsSampling(){return this._colorsSampling}set colorsSampling(q){this._colorsSampling=q}get visibility(){return this._visibility}set visibility(q){this._visibility=q,this.setFloat("grlVisibility",q)}get useDash(){return this._useDash}set useDash(q){this._useDash=q,this.setFloat("grlUseDash",Vq.BooleanToNumber(q))}get dashOffset(){return this._dashOffset}set dashOffset(q){this._dashOffset=q,this.setFloat("grlDashOffset",q)}get dashRatio(){return this._dashRatio}set dashRatio(q){this._dashRatio=q,this.setFloat("grlDashRatio",q)}get dashCount(){return this._dashCount}set dashCount(q){this._dashCount=q,this._dashArray=1/q,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(q){this._sizeAttenuation=q,this.setFloat("grlSizeAttenuation",Vq.BooleanToNumber(q))}get color(){return this._color}set color(q){this.setColor(q)}setColor(q){q=q??vq.DEFAULT_COLOR,this._color=q,this.setColor3("grlColor",q)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(q){this._colorsDistributionType=q,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(q){this._colorMode=q,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(q){this._resolution=q,this.setVector2("grlResolution",q),this.setFloat("grlAspect",q.x/q.y)}serialize(){const q=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(c.Yq=this._colors),q.greasedLineMaterialOptions=c,q}parse(q,c,U){var J;const Q=q.greasedLineMaterialOptions;null===(J=this._colorsTexture)||void 0===J||J.dispose(),Q.color&&(this.color=Q.color),Q.colorDistributionType&&(this.colorsDistributionType=Q.colorDistributionType),Q.colorsSampling&&(this.colorsSampling=Q.colorsSampling),Q.colorMode&&(this.colorMode=Q.colorMode),Q.useColors&&(this.useColors=Q.useColors),Q.visibility&&(this.visibility=Q.visibility),Q.useDash&&(this.useDash=Q.useDash),Q.dashCount&&(this.dashCount=Q.dashCount),Q.dashRatio&&(this.dashRatio=Q.dashRatio),Q.dashOffset&&(this.dashOffset=Q.dashOffset),Q.width&&(this.width=Q.width),Q.sizeAttenuation&&(this.sizeAttenuation=Q.sizeAttenuation),Q.resolution&&(this.resolution=Q.resolution),Q.Yq?this.colorsTexture=Vq.CreateColorsTexture(`${this.name}-colors-texture`,Q.Yq,this.colorsSampling,this.Cq()):this.colorsTexture=Vq.PrepareEmptyColorsTexture(c),this._cameraFacing=Q.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Mq,Tq,mq;yq.ForceGLSL=!1,function(q){q[q.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",q[q.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Mq||(Mq={})),function(q){q[q.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",q[q.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",q[q.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Tq||(Tq={})),function(q){q[q.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",q[q.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",q[q.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",q[q.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",q[q.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(mq||(mq={}));class dq extends aq.b{constructor(q,c,U){super(q,c,null,null,!1,!1),this.name=q,this._options=U,this._lazy=!1,this._updatable=!1,this._engine=c.getEngine(),this._lazy=U.lazy??!1,this._updatable=U.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=U.colorPointers??[],this._widths=U.widths??new Array(U.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(q){let c=0;for(const J of this._points)c+=J.length;const U=c/3*2-this._widths.length;for(let J=0;J<U;J++)this._widths.push(q)}updateLazy(){var q,c;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(q=this._options.ribbonOptions)||void 0===q?void 0:q.smoothShading),!this.Gq&&this.refreshBoundingInfo(),null===(c=this.greasedLineMaterial)||void 0===c||c.updateLazy()}addPoints(q,c){for(const U of q)this._points.push(U);this._lazy||this.setPoints(this._points,c)}dispose(q){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(q,c)}isLazy(){return this._lazy}get kq(){return this._uvs}set kq(q){this._uvs=q instanceof Float32Array?q:new Float32Array(q),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(q){this.material instanceof yq&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===q||void 0===q?void 0:q.length)>0),this._offsets=q,this._offsetsBuffer?this._offsetsBuffer.update(q):this._createOffsetsBuffer(q)}get widths(){return this._widths}set widths(q){this._widths=q,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(q)}get colorPointers(){return this._colorPointers}set colorPointers(q){this._colorPointers=q,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(q)}get greasedLineMaterial(){var q,c;if(this.material&&this.material instanceof yq)return this.material;const U=null===(q=this.material)||void 0===q||null===(c=q.pluginManager)||void 0===c?void 0:c.getPlugin(Gq.GREASED_LINE_MATERIAL_NAME);return U||void 0}get points(){const q=[];return Zq.e.DeepCopy(this._points,q),q}setPoints(q,c){this._points=Vq.ConvertPoints(q,(null===c||void 0===c?void 0:c.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==c&&void 0!==c&&c.colorPointers||this._updateColorPointers(),this._setPoints(this._points,c)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,kq:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(q){super.serialize(q),q.type=this.getClassName(),q.lineOptions=this._createLineOptions()}_createVertexBuffers(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new Sq.c;return c.Fq=this._vertexPositions,c.indices=this._indices,c.kq=this._uvs,q&&(c.vq=[],Sq.c.ComputeNormals(this._vertexPositions,this._indices,c.vq)),c.Oq(this,this._options.updatable),c}_createOffsetsBuffer(q){const c=this._scene.getEngine(),U=new D.e(c,q,this._updatable,3);this.setVerticesBuffer(U.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=U}}class eq{constructor(q,c){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=q,this.wasAddedByNoopNode=c}getIndicesAccessor(q,c,U,J,Q){var s,g,X,n;return null===(s=this._indicesAccessorMap.get(q))||void 0===s||null===(g=s.get(c))||void 0===g||null===(X=g.get(U))||void 0===X||null===(n=X.get(J))||void 0===n?void 0:n.get(Q)}setIndicesAccessor(q,c,U,J,Q,s){let g=this._indicesAccessorMap.get(q);g||(g=new Map,this._indicesAccessorMap.set(q,g));let X=g.get(c);X||(X=new Map,g.set(c,X));let n=X.get(U);n||(n=new Map,X.set(U,n));let W=n.get(J);W||(W=new Map,n.set(J,W)),W.set(Q,s)}pushExportedNode(q){this._exportedNodes.has(q)||this._exportedNodes.add(q)}getNodesSet(){return this._exportedNodes}getVertexBufferView(q){return this._vertexBufferViewMap.get(q)}setVertexBufferView(q,c){this._vertexBufferViewMap.set(q,c)}setRemappedBufferView(q,c,U){this._remappedBufferView.set(q,new Map),this._remappedBufferView.get(q).set(c,U)}getRemappedBufferView(q,c){var U;return null===(U=this._remappedBufferView.get(q))||void 0===U?void 0:U.get(c)}getVertexAccessor(q,c,U){var J,Q;return null===(J=this._vertexAccessorMap.get(q))||void 0===J||null===(Q=J.get(c))||void 0===Q?void 0:Q.get(U)}setVertexAccessor(q,c,U,J){let Q=this._vertexAccessorMap.get(q);Q||(Q=new Map,this._vertexAccessorMap.set(q,Q));let s=Q.get(c);s||(s=new Map,Q.set(c,s)),s.set(U,J)}hasVertexColorAlpha(q){return this._vertexMapColorAlpha.get(q)||!1}setHasVertexColorAlpha(q,c){return this._vertexMapColorAlpha.set(q,c)}getMesh(q){return this._meshMap.get(q)}setMesh(q,c){this._meshMap.set(q,c)}bindMorphDataToMesh(q,c){const U=this._meshMorphTargetMap.get(q)||[];this._meshMorphTargetMap.set(q,U),-1===U.indexOf(c)&&U.push(c)}getMorphTargetsFromMesh(q){return this._meshMorphTargetMap.get(q)}}class Bq{_ApplyExtension(q,c,U,J){if(U>=c.length)return Promise.resolve(q);const Q=J(c[U],q);return Q?Q.then((async q=>q?await this._ApplyExtension(q,c,U+1,J):null)):this._ApplyExtension(q,c,U+1,J)}_ApplyExtensions(q,c){const U=[];for(const J of Bq._ExtensionNames)U.push(this._extensions[J]);return this._ApplyExtension(q,U,0,c)}_extensionsPreExportTextureAsync(q,c,U){return this._ApplyExtensions(c,((c,J)=>c.preExportTextureAsync&&c.preExportTextureAsync(q,J,U)))}_extensionsPostExportNodeAsync(q,c,U,J,Q){return this._ApplyExtensions(c,((c,s)=>c.postExportNodeAsync&&c.postExportNodeAsync(q,s,U,J,Q,this._bufferManager)))}_extensionsPostExportMaterialAsync(q,c,U){return this._ApplyExtensions(c,((c,J)=>c.postExportMaterialAsync&&c.postExportMaterialAsync(q,J,U)))}_extensionsPostExportMaterialAdditionalTextures(q,c,U){const J=[];for(const Q of Bq._ExtensionNames){const s=this._extensions[Q];s.postExportMaterialAdditionalTextures&&J.push(...s.postExportMaterialAdditionalTextures(q,c,U))}return J}_extensionsPostExportTextures(q,c,U){for(const J of Bq._ExtensionNames){const Q=this._extensions[J];Q.postExportTexture&&Q.postExportTexture(q,c,U)}}_extensionsPostExportMeshPrimitive(q){for(const c of Bq._ExtensionNames){const U=this._extensions[c];U.postExportMeshPrimitive&&U.postExportMeshPrimitive(q,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const q of Bq._ExtensionNames){const c=this._extensions[q];c.preGenerateBinaryAsync&&await c.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(q){for(const c of Bq._ExtensionNames){const U=this._extensions[c];U.enabled&&q(U)}}_extensionsOnExporting(){this._forEachExtensions((q=>{var c,U,J;q.wasUsed&&((c=this._glTF).extensionsUsed||(c.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(q.name)&&this._glTF.extensionsUsed.push(q.name),q.required&&((U=this._glTF).extensionsRequired||(U.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(q.name)&&this._glTF.extensionsRequired.push(q.name)),(J=this._glTF).extensions||(J.extensions={}),q.onExporting&&q.onExporting())}))}_loadExtensions(){for(const q of Bq._ExtensionNames){const c=Bq._ExtensionFactories[q](this);this._extensions[q]=c}}constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:b.c.LastCreatedScene,c=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${H.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new z(this),this._extensions={},this._bufferManager=new Dq,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!q)throw new Error("No scene available to export");this._babylonScene=q,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:q=>{var c;return null===q||void 0===q||null===(c=q.Vc)||void 0===c?void 0:c.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...c},this._loadExtensions()}dispose(){for(const q in this._extensions){this._extensions[q].dispose()}}get options(){return this._options}static RegisterExtension(q,c){Bq.UnregisterExtension(q)&&Q.e.Warn(`Extension with the name ${q} already exists`),Bq._ExtensionFactories[q]=c,Bq._ExtensionNames.push(q)}static UnregisterExtension(q){if(!Bq._ExtensionFactories[q])return!1;delete Bq._ExtensionFactories[q];const c=Bq._ExtensionNames.indexOf(q);return-1!==c&&Bq._ExtensionNames.splice(c,1),!0}_generateJSON(q,c,U){const J={byteLength:q};return J.byteLength&&(this._glTF.buffers=[J]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.mc=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(J.uri=c+".bin"),U?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(q){const c=await this._generateBinaryAsync();this._extensionsOnExporting();const U=this._generateJSON(c.byteLength,q,!0),J=new Blob([c],{type:"application/octet-stream"}),Q=q+".gltf",s=q+".bin",g=new W;if(g.files[Q]=U,g.files[s]=J,this._imageData)for(const X in this._imageData)g.files[X]=new Blob([this._imageData[X].data],{type:this._imageData[X].mimeType});return g}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(q){const c=q%4;return 0===c?c:4-c}async generateGLBAsync(q){this._shouldUseGlb=!0;const c=await this._generateBinaryAsync();this._extensionsOnExporting();const U=this._generateJSON(c.byteLength),J=q+".glb";let Q,s=U.length;if("undefined"!==typeof TextEncoder){Q=(new TextEncoder).encode(U),s=Q.length}const g=this._getPadding(s),X=this._getPadding(c.byteLength),n=28+s+g+c.byteLength+X,D=new nq(n);if(D.writeUInt32(1179937895),D.writeUInt32(2),D.writeUInt32(n),D.writeUInt32(s+g),D.writeUInt32(1313821514),Q)D.writeTypedArray(Q);else{const q="_".charCodeAt(0);for(let c=0;c<s;++c){const J=U.charCodeAt(c);J!=U.codePointAt(c)?D.writeUInt8(q):D.writeUInt8(J)}}for(let W=0;W<g;++W)D.writeUInt8(32);D.writeUInt32(c.byteLength+X),D.writeUInt32(5130562),D.writeTypedArray(c);for(let W=0;W<X;++W)D.writeUInt8(0);const u=new W;return u.files[J]=new Blob([D.getOutputData()],{type:"application/octet-stream"}),u}_setNodeTransformation(q,c,U){if(c.getPivotPoint().equalsWithEpsilon(d,m.d)||Q.e.Warn("Pivot points are not supported in the glTF serializer"),!c.position.equalsWithEpsilon(d,m.d)){const Q=J.j.hc[0].X(c.position);U&&f(Q),q.translation=Q.rc()}c.ac.equalsWithEpsilon(B,m.d)||(q.scale=c.ac.rc());const s=c.rotationQuaternion||J.g.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);s.equalsWithEpsilon(e,m.d)||(U&&A(s),q.rotation=s.normalize().rc())}_setCameraTransformation(q,c,U){if(!c.position.equalsWithEpsilon(d,m.d)){const Q=J.j.hc[0].X(c.position);U&&f(Q),q.translation=Q.rc()}const Q=c.rotationQuaternion||J.g.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);U&&A(Q),this._babylonScene.useRightHandedSystem||E(Q),Q.equalsWithEpsilon(e,m.d)||(q.rotation=Q.rc())}_listAvailableCameras(){for(const q of this._babylonScene.cameras){const c={type:q.mode===Kq.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(q.name&&(c.name=q.name),"perspective"===c.type)c.perspective={aspectRatio:q.getEngine().getAspectRatio(q),yfov:q.fovMode===Kq.d.FOVMODE_VERTICAL_FIXED?q.fov:q.fov*q.getEngine().getAspectRatio(q),znear:q.Oc,zfar:q.maxZ};else if("orthographic"===c.type){const U=q.orthoLeft&&q.orthoRight?.5*(q.orthoRight-q.orthoLeft):.5*q.getEngine().getRenderWidth(),J=q.orthoBottom&&q.orthoTop?.5*(q.orthoTop-q.orthoBottom):.5*q.getEngine().getRenderHeight();c.orthographic={xmag:U,ymag:J,znear:q.Oc,zfar:q.maxZ}}this._camerasMap.set(q,c)}}_exportAndAssignCameras(){const q=Array.from(this._camerasMap.values());for(const c of q){const q=this._nodesCameraMap.get(c);if(void 0!==q){this._cameras.push(c);for(const c of q)c.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const q of this._babylonScene.skeletons){if(q.bones.length<=0)continue;const c={joints:[]};this._skinMap.set(q,c)}}_exportAndAssignSkeletons(){for(const q of this._babylonScene.skeletons){if(q.bones.length<=0)continue;const c=this._skinMap.get(q);if(void 0==c)continue;const U={},J=[];let s=-1;for(let Q=0;Q<q.bones.length;++Q){const c=q.bones[Q],J=c.getIndex()??Q;-1!==J&&(U[J]=c,J>s&&(s=J))}for(let q=0;q<=s;++q){const s=U[q];J.push(s.getAbsoluteInverseBindMatrix());const g=s.getTransformNode();if(null!==g){const q=this._nodeMap.get(g);g&&null!==q&&void 0!==q?c.joints.push(q):Q.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}else Q.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}const g=this._nodesSkinMap.get(c);if(c.joints.length>0&&void 0!==g){const q=64*J.length,U=new Float32Array(q/4);J.forEach(((q,c)=>{U.set(q.m,16*c)}));const Q=this._bufferManager.createBufferView(U);this._accessors.push(this._bufferManager.createAccessor(Q,"MAT4",5126,J.length)),c.inverseBindMatrices=this._accessors.length-1,this._skins.push(c);for(const c of g)c.skin=this._skins.length-1}}}async _exportSceneAsync(){const q={nodes:[]};if(this._babylonScene.metadata){const c=this._options.metadataSelector(this._babylonScene.metadata);c&&(q.extras=c)}const c=new Array,U=new Array,J=new Array;for(const X of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&gq(X,this._babylonScene.useRightHandedSystem)?J.push(...X.getChildren()):this._babylonScene.useRightHandedSystem?c.push(X):U.push(X);this._listAvailableCameras(),this._listAvailableSkeletons();const Q=new eq(!0,!1);q.nodes.push(...await this._exportNodesAsync(U,Q));const s=new eq(!1,!1);q.nodes.push(...await this._exportNodesAsync(c,s));const g=new eq(!1,!0);q.nodes.push(...await this._exportNodesAsync(J,g)),q.nodes.length&&this._scenes.push(q),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Rq._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Q.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(q){let c=this._shouldExportNodeMap.get(q);return void 0===c&&(c=this._options.shouldExportNode(q),this._shouldExportNodeMap.set(q,c)),c}async _exportNodesAsync(q,c){const U=new Array;this._exportBuffers(q,c);for(const J of q)await this._exportNodeAsync(J,U,c);return U}_collectBuffers(q,c,U,J,Q){if(this._shouldExportNode(q)&&q instanceof K.c&&q.Dc){const s=q.Dc.getVertexBuffers();if(s)for(const J in s){if(!L(J))continue;const g=s[J];Q.setHasVertexColorAlpha(g,q.hasVertexAlpha);const X=g._buffer,n=c.get(X)||[];c.set(X,n),-1===n.indexOf(g)&&n.push(g);const W=U.get(g)||[];U.set(g,W),-1===W.indexOf(q)&&W.push(q)}const g=q.morphTargetManager;if(g)for(let c=0;c<g.numTargets;c++){const U=g.getTarget(c),Q=J.get(U)||[];J.set(U,Q),-1===Q.indexOf(q)&&Q.push(q)}}for(const s of q.getChildren())this._collectBuffers(s,c,U,J,Q)}_exportBuffers(q,c){const U=new Map,J=new Map,Q=new Map;for(const X of q)this._collectBuffers(X,U,J,Q,c);const s=Array.from(U.keys());for(const X of s){const q=X.getData();if(!q)throw new Error("Buffer data is not available");const Q=U.get(X);if(!Q)continue;const s=Q[0].byteStride;if(Q.some((q=>q.byteStride!==s)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const g=Uq(q).slice();for(const c of Q){const q=J.get(c),{byteOffset:U,byteStride:Q,componentCount:s,type:X,count:n,normalized:W,kind:u}=P(c,q);switch(u){case D.h.NormalKind:case D.h.TangentKind:(0,y.i)(g,U,Q,s,X,n,W,(q=>{const c=Math.sqrt(q[0]*q[0]+q[1]*q[1]+q[2]*q[2]);if(c>0){const U=1/c;q[0]*=U,q[1]*=U,q[2]*=U}}));break;case D.h.ColorKind:{const c=q.filter((q=>q.material instanceof bq.b||null==q.material)).length;if(0==c)break;if(c!=q.length){M.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}X==D.h.UNSIGNED_BYTE&&M.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const J=new h.c,u=new h.e,K=this._babylonScene.getEngine().useExactSrgbConversions;(0,y.i)(g,U,Q,s,X,n,W,(q=>{3===q.length?(J.BU(q,0),J.toLinearSpaceToRef(J,K),J.toArray(q,0)):(u.BU(q,0),u.toLinearSpaceToRef(u,K),u.toArray(q,0))}))}}}if(c.convertToRightHanded){for(const q of Q){const c=J.get(q),{byteOffset:U,byteStride:Q,componentCount:s,type:X,count:n,normalized:W,kind:u}=P(q,c);switch(u){case D.h.PositionKind:case D.h.NormalKind:case D.h.TangentKind:(0,y.i)(g,U,Q,s,X,n,W,(q=>{q[0]=-q[0]}))}}c.convertedToRightHandedBuffers.set(X,g)}const n=this._bufferManager.createBufferView(g,s);c.setVertexBufferView(X,n);const W=new Map;for(const c of Q){const q=J.get(c),{kind:U,totalVertices:Q}=P(c,q);switch(U){case D.h.MatricesIndicesKind:case D.h.MatricesIndicesExtraKind:if(c.type==D.h.FLOAT){const q=c.getFloatData(Q);null!==q&&W.set(c,q)}}}0!==W.size&&M.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const u=Array.from(W.keys());for(const U of u){const q=W.get(U);if(!q)continue;const J=q.some((q=>q>=256)),Q=new(J?Uint16Array:Uint8Array)(q.length);for(let c=0;c<q.length;c++)Q[c]=q[c];const s=this._bufferManager.createBufferView(Q,4*(J?2:1));c.setRemappedBufferView(X,U,s)}}const g=Array.from(Q.keys());for(const X of g){const q=Q.get(X);if(!q)continue;const U=Iq(X,q[0],this._bufferManager,this._bufferViews,this._accessors,c.convertToRightHanded);for(const J of q)c.bindMorphDataToMesh(J,U)}}async _exportNodeAsync(q,c,U){let J=this._nodeMap.get(q);if(void 0!==J)return void(c.includes(J)||c.push(J));const Q=await this._createNodeAsync(q,U);if(Q){J=this._nodes.length,this._nodes.push(Q),this._nodeMap.set(q,J),U.pushExportedNode(q),c.push(J);const s={name:"runtime animations",channels:[],samplers:[]},g=[];this._babylonScene.animationGroups.length||(Rq._CreateMorphTargetAnimationFromMorphTargetAnimations(q,s,g,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,U.convertToRightHanded,this._options.shouldExportAnimation),q.animations.length&&Rq._CreateNodeAnimationFromNodeAnimations(q,s,g,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,U.convertToRightHanded,this._options.shouldExportAnimation)),s.channels.length&&s.samplers.length&&this._animations.push(s),g.forEach((q=>{q.channels.length&&q.samplers.length&&this._animations.push(q)}))}const s=Q?[]:c;for(const g of q.getChildren())await this._exportNodeAsync(g,s,U);Q&&s.length&&(Q.children=s)}async _createNodeAsync(q,c){if(!this._shouldExportNode(q))return null;const U={};if(q.name&&(U.name=q.name),q.metadata){const c=this._options.metadataSelector(q.metadata);c&&(U.extras=c)}if(q instanceof u.c&&(this._setNodeTransformation(U,q,c.convertToRightHanded),q instanceof K.c)){const Q=q instanceof r.d?q.sourceMesh:q;if(Q.Gc&&Q.Gc.length>0&&(U.mesh=await this._exportMeshAsync(Q,c)),q.skeleton){const c=this._skinMap.get(q.skeleton);var J;if(void 0!==c)void 0===this._nodesSkinMap.get(c)&&this._nodesSkinMap.set(c,[]),null===(J=this._nodesSkinMap.get(c))||void 0===J||J.push(U)}}if(q instanceof T.c){const J=this._camerasMap.get(q);if(J){var Q;void 0===this._nodesCameraMap.get(J)&&this._nodesCameraMap.set(J,[]),this._setCameraTransformation(U,q,c.convertToRightHanded);const g=q.parent;if(null!==g&&cq(q,g)){const q=this._nodeMap.get(g);if(void 0!==q){var s;const c=this._nodes[q];return qq(U,c),null===(s=this._nodesCameraMap.get(J))||void 0===s||s.push(c),null}}null===(Q=this._nodesCameraMap.get(J))||void 0===Q||Q.push(U)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",U,q,this._nodeMap,c.convertToRightHanded)?U:(M.c.Warn(`Not exporting node ${q.name}`),null)}_exportIndices(q,c,U,J,Q,g,X,n,W){let D=q;W.mode=l(g);const u=X!==s.b.CounterClockWiseSideOrientation,K=!n.wasAddedByNoopNode&&u,r=function(q){switch(q){case s.b.TriangleFillMode:case s.b.TriangleStripDrawMode:case s.b.TriangleFanDrawMode:return!0}return!1}(g)&&K;if(r){if(g===s.b.TriangleStripDrawMode||g===s.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");W.mode=l(g);const X=c?new Uint32Array(J):new Uint16Array(J);if(q)for(let c=0;c+2<J;c+=3)X[c]=q[U+c]+Q,X[c+1]=q[U+c+2]+Q,X[c+2]=q[U+c+1]+Q;else for(let q=0;q+2<J;q+=3)X[q]=q,X[q+1]=q+2,X[q+2]=q+1;D=X}else if(q&&0!==Q){const s=c?new Uint32Array(J):new Uint16Array(J);for(let c=0;c<J;c++)s[c]=q[U+c]+Q;D=s}if(D){let s=n.getIndicesAccessor(q,U,J,Q,r);if(void 0===s){const g=function(q,c,U,J){if(q instanceof Uint16Array||q instanceof Uint32Array)return q;if(q instanceof Int32Array)return new Uint32Array(q.buffer,q.byteOffset,q.length);const Q=q.slice(c,c+U);return J?new Uint32Array(Q):new Uint16Array(Q)}(D,0,J,c),X=this._bufferManager.createBufferView(g),W=c?5125:5123;this._accessors.push(this._bufferManager.createAccessor(X,"SCALAR",W,J,0)),s=this._accessors.length-1,n.setIndicesAccessor(q,U,J,Q,r,s)}W.indices=s}}_exportVertexBuffer(q,c,U,J,Q,s){const g=q.getKind();if(!L(g))return;if(g.startsWith("uv")&&!this._options.exportUnusedUVs&&(!c||!this._materialNeedsUVsSet.has(c)))return;let X=Q.getVertexAccessor(q,U,J);if(void 0===X){const c=Q.convertedToRightHandedBuffers.get(q._buffer)||q._buffer.getData(),s=g===D.h.PositionKind?function(q,c,U,J){const{byteOffset:Q,byteStride:s,type:g,normalized:X}=c,n=c.getSize(),W=new Array(n).fill(1/0),D=new Array(n).fill(-1/0);return(0,y.i)(q,Q+U*s,s,n,g,J*n,X,(q=>{for(let c=0;c<n;c++)W[c]=Math.min(W[c],q[c]),D[c]=Math.max(D[c],q[c])})),{min:W,max:D}}(c,q,U,J):void 0,n=(g===D.h.MatricesIndicesKind||g===D.h.MatricesIndicesExtraKind)&&q.type===D.h.FLOAT,W=n?D.h.UNSIGNED_BYTE:q.type,u=n?void 0:q.normalized,K=n?Q.getRemappedBufferView(q._buffer,q):Q.getVertexBufferView(q._buffer),r=q.byteOffset+U*q.byteStride;this._accessors.push(this._bufferManager.createAccessor(K,function(q,c){if(q==D.h.ColorKind)return c?"VEC4":"VEC3";switch(q){case D.h.PositionKind:case D.h.NormalKind:return"VEC3";case D.h.TangentKind:case D.h.MatricesIndicesKind:case D.h.MatricesIndicesExtraKind:case D.h.MatricesWeightsKind:case D.h.MatricesWeightsExtraKind:return"VEC4";case D.h.UVKind:case D.h.UV2Kind:case D.h.UV3Kind:case D.h.UV4Kind:case D.h.UV5Kind:case D.h.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${q}`)}(g,Q.hasVertexColorAlpha(q)),W,J,r,s,u)),X=this._accessors.length-1,Q.setVertexAccessor(q,U,J,X)}s.attributes[function(q){switch(q){case D.h.PositionKind:return"POSITION";case D.h.NormalKind:return"NORMAL";case D.h.TangentKind:return"TANGENT";case D.h.ColorKind:return"COLOR_0";case D.h.UVKind:return"TEXCOORD_0";case D.h.UV2Kind:return"TEXCOORD_1";case D.h.UV3Kind:return"TEXCOORD_2";case D.h.UV4Kind:return"TEXCOORD_3";case D.h.UV5Kind:return"TEXCOORD_4";case D.h.UV6Kind:return"TEXCOORD_5";case D.h.MatricesIndicesKind:return"JOINTS_0";case D.h.MatricesIndicesExtraKind:return"JOINTS_1";case D.h.MatricesWeightsKind:return"WEIGHTS_0";case D.h.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${q}`)}(g)]=X}async _exportMaterialAsync(q,c,U,J){let Q=this._materialMap.get(q);if(void 0===Q){const J=c&&Object.keys(c).some((q=>q.startsWith("uv")));if((q=q instanceof rq.e?q.Sc[U.materialIndex]:q)instanceof Hq.d)Q=await this._materialExporter.exportPBRMaterialAsync(q,"image/png",J);else{if(!(q instanceof bq.b))return void M.c.Warn(`Unsupported material '${q.name}' with type ${q.getClassName()}`);Q=await this._materialExporter.exportStandardMaterialAsync(q,"image/png",J)}this._materialMap.set(q,Q)}J.material=Q}async _exportMeshAsync(q,c){var U;let J=c.getMesh(q);if(void 0!==J)return J;const Q={primitives:[]};J=this._meshes.length,this._meshes.push(Q),c.setMesh(q,J);const g=q.isUnIndexed?null:q.uc(),X=null===(U=q.Dc)||void 0===U?void 0:U.getVertexBuffers(),n=c.getMorphTargetsFromMesh(q),W=q instanceof tq.d,D=q instanceof dq,u=q.Gc;if(X&&u&&u.length>0)for(const H of u){const U={attributes:{}},J=H.zq()||this._babylonScene.defaultMaterial;if(D){var K,r;const c={name:J.name},Q=q,s=h.c.White(),g=(null===(K=Q.material)||void 0===K?void 0:K.alpha)??1,X=(null===(r=Q.greasedLineMaterial)||void 0===r?void 0:r.color)??s;(!X.equalsWithEpsilon(s,m.d)||g<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...X.rc(),g]}),this._materials.push(c),U.material=this._materials.length-1}else if(W){const c={name:J.name},Q=q;(!Q.color.equalsWithEpsilon(h.c.White(),m.d)||Q.alpha<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...Q.color.rc(),Q.alpha]}),this._materials.push(c),U.material=this._materials.length-1}else await this._exportMaterialAsync(J,X,H,U);const u=W||D?s.b.LineListDrawMode:q.overrideRenderingFillMode??J.fillMode,b=J._getEffectiveOrientation(q);this._exportIndices(g,g?(0,y.d)(g,H.indexCount,H.indexStart,H.verticesStart):H.verticesCount>65535,g?H.indexStart:H.verticesStart,g?H.indexCount:H.verticesCount,-H.verticesStart,u,b,c,U);for(const q of Object.values(X))this._exportVertexBuffer(q,J,H.verticesStart,H.verticesCount,c,U);if(n){U.targets=[];for(const q of n)U.targets.push(q.attributes)}Q.primitives.push(U),this._extensionsPostExportMeshPrimitive(U)}if(n){Q.weights=[],Q.extras||(Q.extras={}),Q.extras.targetNames=[];for(const q of n)Q.weights.push(q.influence),Q.extras.targetNames.push(q.name)}return J}}Bq._ExtensionNames=new Array,Bq._ExtensionFactories={};class Nq{static async GLTFAsync(q,c,U){U&&U.exportWithoutWaitingForScene||await q.whenReadyAsync();const J=new Bq(q,U),Q=await J.generateGLTFAsync(c.replace(/\.[^/.]+$/,""));return J.dispose(),Q}static async GLBAsync(q,c,U){U&&U.exportWithoutWaitingForScene||await q.whenReadyAsync();const J=new Bq(q,U),Q=await J.generateGLBAsync(c.replace(/\.[^/.]+$/,""));return J.dispose(),Q}}U(11510);const Pq="EXT_mesh_gpu_instancing";class wq{constructor(q){this.name=Pq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(q,c,U,Q,s,g){return await new Promise((q=>{if(c&&U instanceof aq.b&&U.hasThinInstances&&this._exporter){this._wasUsed=!0;const q=J.p.Zero(),Q=J.g.Identity(),X=J.p.One(),n=U.thinInstanceGetWorldMatrices(),W=J.j.hc[2],D=J.j.Quaternion[1],u=J.j.hc[3];let K=!1,r=!1,H=!1;const b=new Float32Array(3*U.xc),h=new Float32Array(4*U.xc),o=new Float32Array(3*U.xc);let a=0;for(const c of n)c.decompose(u,D,W),s&&(f(W),A(D)),b.set(W.rc(),3*a),h.set(D.normalize().rc(),4*a),o.set(u.rc(),3*a),K=K||!W.equalsWithEpsilon(q),r=r||!D.equalsWithEpsilon(Q),H=H||!u.equalsWithEpsilon(X),a++;const p={attributes:{}};K&&(p.attributes.TRANSLATION=this._buildAccessor(b,"VEC3",U.xc,g)),r&&(p.attributes.ROTATION=this._buildAccessor(h,"VEC4",U.xc,g)),H&&(p.attributes.SCALE=this._buildAccessor(o,"VEC3",U.xc,g)),c.extensions=c.extensions||{},c.extensions[Pq]=p}q(c)}))}_buildAccessor(q,c,U,J){const Q=J.createBufferView(q),s=J.createAccessor(Q,c,5126,U);return this._exporter._accessors.push(s),this._exporter._accessors.length-1}}Bq.RegisterExtension(Pq,(q=>new wq(q)));var Lq=U(11517),lq=U(11532),jq=U(11539),fq=U(11542);function Aq(q){return q===jq.c.PositionKind?"POSITION":q===jq.c.NormalKind?"NORMAL":q===jq.c.ColorKind?"COLOR":q.startsWith(jq.c.UVKind)?"TEX_COORD":"GENERIC"}const Eq={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class qc extends Lq.c{static get DefaultAvailable(){return(0,Lq.k)(qc.DefaultConfiguration)}static get Default(){return qc._Default??(qc._Default=new qc),qc._Default}static ResetDefault(q){qc._Default&&(q||qc._Default.dispose(),qc._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(q,c){return{module:await(c||DracoEncoderModule)({wasmBinary:q})}}_getWorkerContent(){return`${lq.j}(${lq.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:qc.DefaultConfiguration)}async _encodeAsync(q,c,U){const J=U?(0,fq.e)(Eq,U):Eq;if(this._workerPoolPromise){const U=await this._workerPoolPromise;return await new Promise(((Q,s)=>{U.push(((U,g)=>{const X=q=>{U.removeEventListener("error",X),U.removeEventListener("message",n),s(q),g()},n=q=>{"encodeMeshDone"===q.data.id&&(U.removeEventListener("error",X),U.removeEventListener("message",n),Q(q.data.encodedMeshData),g())};U.addEventListener("error",X),U.addEventListener("message",n);const W=[];for(const c of q)W.push(c.data.buffer);c&&W.push(c.buffer),U.postMessage({id:"encodeMesh",attributes:q,indices:c,options:J},W)}))}))}if(this._modulePromise){const U=await this._modulePromise;return(0,lq.j)(U.module,q,c,J)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(q,c){if(0==q.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");q instanceof aq.b&&q.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===c||void 0===c?void 0:c.method)&&(M.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),c.method="MESH_SEQUENTIAL_ENCODING");const U=function(q){let c=q.uc(void 0,!0);return!c||c instanceof Uint32Array||c instanceof Uint16Array||(c=((0,y.d)(c,c.length)?Uint32Array:Uint16Array).from(c)),c}(q),J=function(q,c){const U=[];for(const J of q.getVerticesDataKinds()){if(null!==c&&void 0!==c&&c.includes(J)){if(J===jq.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const Q=q.getVertexBuffer(J),s=Q.getSize(),g=(0,y.s)(Q.getData(),s,Q.type,Q.byteOffset,Q.byteStride,Q.normalized,q.getTotalVertices(),!0);U.push({kind:J,dracoName:Aq(J),size:s,data:g})}return U}(q,null===c||void 0===c?void 0:c.excludedAttributes);return await this._encodeAsync(J,U,c)}}qc.DefaultConfiguration={wasmUrl:`${Q.e._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${Q.e._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${Q.e._DefaultCdnUrl}/draco_encoder.js`},qc._Default=null;const cc="KHR_draco_mesh_compression";class Uc{get wasUsed(){return this._wasUsed}constructor(q){this.name=cc,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===q.options.meshCompressionMethod&&qc.DefaultAvailable}dispose(){}postExportMeshPrimitive(q,c,U){if(!this.enabled)return;if(4!==q.mode&&5!==q.mode)return void M.c.Warn("Cannot compress primitive with mode "+q.mode+".");const J=[],Q=[];let s=null;if(void 0!==q.indices){const g=U[q.indices],X=c.getBufferView(g);s=c.getData(X).slice(),J.push(X),Q.push(g)}const g=[];for(const[D,u]of Object.entries(q.attributes)){const q=U[u],s=c.getBufferView(q),n=w(q.type),W=(0,y.s)(c.getData(s),n,q.componentType,q.byteOffset||0,s.byteStride||(0,y.p)(q.componentType)*n,q.normalized||!1,q.count,!0);g.push({kind:D,dracoName:(X=D,"POSITION"===X?"POSITION":"NORMAL"===X?"NORMAL":X.startsWith("COLOR")?"COLOR":X.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:w(q.type),data:W}),J.push(s),Q.push(q)}var X;const n={method:q.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},W=qc.Default._encodeAsync(g,s,n).then((U=>{if(!U)return void M.c.Error("Draco encoding failed for primitive.");const s={bufferView:-1,attributes:U.attributeIds},g=c.createBufferView(U.data);c.setBufferView(s,g);for(const q of J)this._bufferViewsUsed.add(q);for(const q of Q)this._accessorsUsed.add(q);q.extensions||(q.extensions={}),q.extensions[cc]=s})).catch((q=>{M.c.Error("Draco encoding failed for primitive: "+q)}));this._encodePromises.push(W),this._wasUsed=!0}async preGenerateBinaryAsync(q){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((c=>{q.getPropertiesWithBufferView(c).every((q=>this._accessorsUsed.has(q)))&&q.removeBufferView(c)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Bq.RegisterExtension(cc,(q=>new Uc(q)));var Jc=U(11545);const Qc="KHR_lights_punctual",sc={name:"",color:[1,1,1],zc:1,range:Number.MAX_VALUE},gc={innerConeAngle:0,outerConeAngle:Math.PI/4},Xc=J.p.Backward();class nc{constructor(q){this.name=Qc,this.enabled=!0,this.required=!1,this._exporter=q}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Qc]=this._lights}async postExportNodeAsync(q,c,U,Q,s){return await new Promise((g=>{if(!(U instanceof pq.c))return void g(c);const X=U.getTypeID()==pq.c.LIGHTTYPEID_POINTLIGHT?"point":U.getTypeID()==pq.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":U.getTypeID()==pq.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!X||!(U instanceof Jc.b))return M.c.Warn(`${q}: Light ${U.name} is not supported in ${Qc}`),void g(c);if(U.falloffType!==pq.c.FALLOFF_GLTF&&M.c.Warn(`${q}: Light falloff for ${U.name} does not match the ${Qc} specification!`),!U.position.equalsToFloats(0,0,0)){const q=J.j.hc[0].X(U.position);s&&f(q),c.translation=q.rc()}if("point"!==X){const q=U.direction.normalizeToRef(J.j.hc[0]);s&&f(q);const Q=J.g.FromUnitVectorsToRef(Xc,q,J.j.Quaternion[0]);J.g.IsIdentity(Q)||(c.rotation=Q.rc())}const n={type:X,name:U.name,color:U.dc.rc(),zc:U.zc,range:U.range};if(Jq(n,sc),"spot"===X){const q=U;n.spot={innerConeAngle:q.innerAngle/2,outerConeAngle:q.angle/2},Jq(n.spot,gc)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(n);const W={Wc:this._lights.lights.length-1},D=U.parent;if(D&&cq(U,D)){const q=Q.get(D);if(q){const U=this._exporter._nodes[q];return qq(c,U),U.extensions||(U.extensions={}),U.extensions[Qc]=W,void g(null)}}c.extensions||(c.extensions={}),c.extensions[Qc]=W,g(c)}))}}Bq.RegisterExtension(Qc,(q=>new nc(q)));var Wc=U(11355);const Dc="KHR_materials_anisotropy";class uc{constructor(q){this.name=Dc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,c,U){const J=[];return U instanceof Wc.d&&U.anisotropy.isEnabled&&!U.anisotropy.legacy?(U.anisotropy.texture&&J.push(U.anisotropy.texture),J):[]}postExportMaterialAsync(q,c,U){return new Promise((q=>{if(U instanceof Wc.d){if(!U.anisotropy.isEnabled||U.anisotropy.legacy)return void q(c);this._wasUsed=!0,c.extensions=c.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(U.anisotropy.texture),Q={anisotropyStrength:U.anisotropy.zc,anisotropyRotation:U.anisotropy.angle,anisotropyTexture:J??void 0};null!==Q.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(U),c.extensions[Dc]=Q}q(c)}))}}Bq.RegisterExtension(Dc,(q=>new uc(q)));const Kc="KHR_materials_clearcoat";class rc{constructor(q){this.name=Kc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,c,U){const J=[];return U instanceof Wc.d&&U.clearCoat.isEnabled?(U.clearCoat.texture&&J.push(U.clearCoat.texture),!U.clearCoat.useRoughnessFromMainTexture&&U.clearCoat.textureRoughness&&J.push(U.clearCoat.textureRoughness),U.clearCoat.bumpTexture&&J.push(U.clearCoat.bumpTexture),J):[]}postExportMaterialAsync(q,c,U){return new Promise((q=>{if(U instanceof Wc.d){if(!U.clearCoat.isEnabled)return void q(c);this._wasUsed=!0,c.extensions=c.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(U.clearCoat.texture);let s;s=U.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(U.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(U.clearCoat.textureRoughness),U.clearCoat.isTintEnabled&&Q.e.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${U.name}`),U.clearCoat.remapF0OnInterfaceChange&&Q.e.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${U.name}`);const g=this._exporter._materialExporter.getTextureInfo(U.clearCoat.bumpTexture),X={clearcoatFactor:U.clearCoat.zc,clearcoatTexture:J??void 0,clearcoatRoughnessFactor:U.clearCoat.roughness,clearcoatRoughnessTexture:s??void 0,clearcoatNormalTexture:g??void 0};null===X.clearcoatTexture&&null===X.clearcoatRoughnessTexture&&null===X.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(U),c.extensions[Kc]=X}q(c)}))}}Bq.RegisterExtension(Kc,(q=>new rc(q)));const Hc="KHR_materials_diffuse_transmission";function bc(q,c){const U=c.subSurface;let J=null;return U.translucencyIntensityTexture?J=U.translucencyIntensityTexture:U.thicknessTexture&&U.useMaskFromThicknessTexture&&(J=U.thicknessTexture),J&&!U.useGltfStyleTextures?(M.c.Warn(`${q}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${c.name}`,1),null):J}class hc{constructor(q){this.name=Hc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,c,U){const J=[];if(U instanceof Hq.d&&this._isExtensionEnabled(U)){const c=bc(q,U);return c&&J.push(c),U.subSurface.translucencyColorTexture&&J.push(U.subSurface.translucencyColorTexture),J}return J}_isExtensionEnabled(q){if(q.unlit)return!1;const c=q.subSurface;return!!c.isTranslucencyEnabled&&(!q.unlit&&!c.useAlbedoToTintTranslucency&&c.useGltfStyleTextures&&1===c.volumeIndexOfRefraction&&0===c.minimumThickness&&0===c.maximumThickness)}postExportMaterialAsync(q,c,U){return new Promise((J=>{if(U instanceof Hq.d&&this._isExtensionEnabled(U)){this._wasUsed=!0;const J=U.subSurface,Q=bc(q,U),s=0==J.translucencyIntensity?void 0:J.translucencyIntensity,g=this._exporter._materialExporter.getTextureInfo(Q)??void 0,X=!J.translucencyColor||J.translucencyColor.equalsFloats(1,1,1)?void 0:J.translucencyColor.rc(),n=this._exporter._materialExporter.getTextureInfo(J.translucencyColorTexture)??void 0,W={diffuseTransmissionFactor:s,diffuseTransmissionTexture:g,diffuseTransmissionColorFactor:X,diffuseTransmissionColorTexture:n};(g||n)&&this._exporter._materialNeedsUVsSet.add(U),c.extensions=c.extensions||{},c.extensions[Hc]=W}J(c)}))}}Bq.RegisterExtension(Hc,(q=>new hc(q)));const oc="KHR_materials_dispersion";class ac{constructor(){this.name=oc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(q){if(q.unlit)return!1;const c=q.subSurface;return!(!c.isRefractionEnabled&&!c.isDispersionEnabled)}postExportMaterialAsync(q,c,U){return new Promise((q=>{if(U instanceof Hq.d&&this._isExtensionEnabled(U)){this._wasUsed=!0;const q={dispersion:U.subSurface.dispersion};c.extensions=c.extensions||{},c.extensions[oc]=q}q(c)}))}}Bq.RegisterExtension(oc,(()=>new ac));const pc="KHR_materials_emissive_strength";class Rc{constructor(){this.name=pc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(q,c,U){return await new Promise((q=>{if(!(U instanceof Hq.d))return q(c);const J=U.emissiveColor.rc(),Q=Math.max(...J);if(Q>1){this._wasUsed=!0,c.extensions||(c.extensions={});const q={emissiveStrength:Q},J=U.emissiveColor.scale(1/q.emissiveStrength);c.emissiveFactor=J.rc(),c.extensions[pc]=q}return q(c)}))}}Bq.RegisterExtension(pc,(q=>new Rc));const Ic="KHR_materials_ior";class tc{constructor(){this.name=Ic,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(q){return!q.unlit&&(void 0!=q.indexOfRefraction&&1.5!=q.indexOfRefraction)}postExportMaterialAsync(q,c,U){return new Promise((q=>{if(U instanceof Hq.d&&this._isExtensionEnabled(U)){this._wasUsed=!0;const q={ior:U.indexOfRefraction};c.extensions=c.extensions||{},c.extensions[Ic]=q}q(c)}))}}Bq.RegisterExtension(Ic,(q=>new tc));const Cc="KHR_materials_iridescence";class ic{constructor(q){this.name=Cc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,c,U){const J=[];return U instanceof Wc.d&&U.iridescence.isEnabled?(U.iridescence.texture&&J.push(U.iridescence.texture),U.iridescence.thicknessTexture&&U.iridescence.thicknessTexture!==U.iridescence.texture&&J.push(U.iridescence.thicknessTexture),J):[]}postExportMaterialAsync(q,c,U){return new Promise((q=>{if(U instanceof Wc.d){if(!U.iridescence.isEnabled)return void q(c);this._wasUsed=!0,c.extensions=c.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(U.iridescence.texture),Q=this._exporter._materialExporter.getTextureInfo(U.iridescence.thicknessTexture),s={iridescenceFactor:U.iridescence.zc,iridescenceIor:U.iridescence.indexOfRefraction,iridescenceThicknessMinimum:U.iridescence.minimumThickness,iridescenceThicknessMaximum:U.iridescence.maximumThickness,iridescenceTexture:J??void 0,iridescenceThicknessTexture:Q??void 0};null===s.iridescenceTexture&&null===s.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(U),c.extensions[Cc]=s}q(c)}))}}Bq.RegisterExtension(Cc,(q=>new ic(q)));const Fc="KHR_materials_sheen";class vc{constructor(q){this.name=Fc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,c,U){return U instanceof Hq.d&&U.sheen.isEnabled&&U.sheen.texture?[U.sheen.texture]:[]}async postExportMaterialAsync(q,c,U){return await new Promise((q=>{if(U instanceof Hq.d){if(!U.sheen.isEnabled)return void q(c);this._wasUsed=!0,null==c.extensions&&(c.extensions={});const J={sheenColorFactor:U.sheen.color.rc(),sheenRoughnessFactor:U.sheen.roughness??0};null===J.sheenColorTexture&&null===J.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(U),U.sheen.texture&&(J.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(U.sheen.texture)??void 0),U.sheen.textureRoughness&&!U.sheen.useRoughnessFromMainTexture?J.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(U.sheen.textureRoughness)??void 0:U.sheen.texture&&U.sheen.useRoughnessFromMainTexture&&(J.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(U.sheen.texture)??void 0),c.extensions[Fc]=J}q(c)}))}}Bq.RegisterExtension(Fc,(q=>new vc(q)));const Yc="KHR_materials_specular";class kc{constructor(q){this.name=Yc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,c,U){const J=[];return U instanceof Hq.d&&this._isExtensionEnabled(U)?(U.metallicReflectanceTexture&&J.push(U.metallicReflectanceTexture),U.reflectanceTexture&&J.push(U.reflectanceTexture),J):J}_isExtensionEnabled(q){return!q.unlit&&(void 0!=q.metallicF0Factor&&1!=q.metallicF0Factor||void 0!=q.metallicReflectanceColor&&!q.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(q))}_hasTexturesExtension(q){return null!=q.metallicReflectanceTexture||null!=q.reflectanceTexture}postExportMaterialAsync(q,c,U){return new Promise((q=>{if(U instanceof Hq.d&&this._isExtensionEnabled(U)){this._wasUsed=!0,c.extensions=c.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(U.metallicReflectanceTexture)??void 0,J=this._exporter._materialExporter.getTextureInfo(U.reflectanceTexture)??void 0,Q={specularFactor:1==U.metallicF0Factor?void 0:U.metallicF0Factor,specularTexture:q,specularColorFactor:U.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:U.metallicReflectanceColor.rc(),specularColorTexture:J};this._hasTexturesExtension(U)&&this._exporter._materialNeedsUVsSet.add(U),c.extensions[Yc]=Q}q(c)}))}}Bq.RegisterExtension(Yc,(q=>new kc(q)));const Vc="KHR_materials_transmission";class Oc{constructor(q){this.name=Vc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,c,U){const J=[];return U instanceof Hq.d&&this._isExtensionEnabled(U)?(U.subSurface.thicknessTexture&&J.push(U.subSurface.thicknessTexture),J):J}_isExtensionEnabled(q){if(q.unlit)return!1;const c=q.subSurface;return c.isRefractionEnabled&&void 0!=c.refractionIntensity&&0!=c.refractionIntensity||this._hasTexturesExtension(q)}_hasTexturesExtension(q){return null!=q.subSurface.refractionIntensityTexture}async postExportMaterialAsync(q,c,U){if(U instanceof Hq.d&&this._isExtensionEnabled(U)){this._wasUsed=!0;const J=U.subSurface,Q={transmissionFactor:0===J.refractionIntensity?void 0:J.refractionIntensity};if(this._hasTexturesExtension(U)&&this._exporter._materialNeedsUVsSet.add(U),J.refractionIntensityTexture)if(J.useGltfStyleTextures){const q=await this._exporter._materialExporter.exportTextureAsync(J.refractionIntensityTexture,"image/png");q&&(Q.transmissionTexture=q)}else M.c.Warn(`${q}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);c.extensions||(c.extensions={}),c.extensions[Vc]=Q}return c}}Bq.RegisterExtension(Vc,(q=>new Oc(q)));const Gc="KHR_materials_unlit";class Sc{constructor(){this.name=Gc,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(q,c,U){return new Promise((q=>{let J=!1;U instanceof Hq.d?J=U.unlit:U instanceof bq.b&&(J=U.disableLighting),J&&(this._wasUsed=!0,null==c.extensions&&(c.extensions={}),c.extensions[Gc]={}),q(c)}))}}Bq.RegisterExtension(Gc,(()=>new Sc));const Zc="KHR_materials_volume";class xc{constructor(q){this.name=Zc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,c,U){const J=[];return U instanceof Hq.d&&this._isExtensionEnabled(U)?(U.subSurface.thicknessTexture&&J.push(U.subSurface.thicknessTexture),J):J}_isExtensionEnabled(q){if(q.unlit)return!1;const c=q.subSurface;return!(!c.isRefractionEnabled&&!c.isTranslucencyEnabled)&&(void 0!=c.maximumThickness&&0!=c.maximumThickness||void 0!=c.tintColorAtDistance&&c.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=c.tintColor&&c.tintColor!=h.c.White()||this._hasTexturesExtension(q))}_hasTexturesExtension(q){return null!=q.subSurface.thicknessTexture}postExportMaterialAsync(q,c,U){return new Promise((q=>{if(U instanceof Hq.d&&this._isExtensionEnabled(U)){this._wasUsed=!0;const q=U.subSurface,J={thicknessFactor:0==q.maximumThickness?void 0:q.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(q.thicknessTexture)??void 0,attenuationDistance:q.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:q.tintColorAtDistance,attenuationColor:q.tintColor.equalsFloats(1,1,1)?void 0:q.tintColor.rc()};this._hasTexturesExtension(U)&&this._exporter._materialNeedsUVsSet.add(U),c.extensions=c.extensions||{},c.extensions[Zc]=J}q(c)}))}}Bq.RegisterExtension(Zc,(q=>new xc(q)));const zc="EXT_materials_diffuse_roughness";class yc{constructor(q){this.name=zc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,c,U){const J=[];return U instanceof Wc.d&&U._baseDiffuseRoughness?(U._baseDiffuseRoughnessTexture&&J.push(U._baseDiffuseRoughnessTexture),J):[]}postExportMaterialAsync(q,c,U){return new Promise((q=>{if(U instanceof Wc.d){if(!U._baseDiffuseRoughness)return void q(c);this._wasUsed=!0,c.extensions=c.extensions||{};const J=this._exporter._materialExporter.getTextureInfo(U._baseDiffuseRoughnessTexture),Q={diffuseRoughnessFactor:U._baseDiffuseRoughness,diffuseRoughnessTexture:J??void 0};null!==Q.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(U),c.extensions[zc]=Q}q(c)}))}}Bq.RegisterExtension(zc,(q=>new yc(q)));const Mc="KHR_texture_transform";class Tc{constructor(){this.name=Mc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(q,c,U){if(U.Cq()||Q.e.Warn(`${q}: /*@__KEY__*/"scene" is not defined for Babylon texture ${U.name}!`),(0!==U.uAng||0!==U.vAng)&&(Q.e.Warn(`${q}: Texture ${U.name} with rotation in the u or v axis is not supported in glTF.`),0!==U.uRotationCenter||0!==U.vRotationCenter))return;const J={};let s=!1;if(0===U.uOffset&&0===U.vOffset||(J.offset=[U.uOffset,U.vOffset],s=!0),1===U.uScale&&1===U.vScale||(J.scale=[U.uScale,U.vScale],s=!0),0!==U.wAng){if(0!==U.uRotationCenter||0!==U.vRotationCenter){if(U.homogeneousRotationInUVTransform&&U.uScale!==U.vScale)return void Q.e.Warn(`${q}: Texture ${U.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Mc}.`);Q.e.Warn(`${q}: Texture ${U.name} with non-origin rotation center will be exported using an adjusted offset with ${Mc}.`),J.offset=function(q){const{uOffset:c,vOffset:U,uRotationCenter:J,vRotationCenter:Q,uScale:s,vScale:g,wAng:X}=q,n=Math.cos(X),W=Math.sin(X),D=J*s,u=Q*g;return[c+(D*(1-n)+u*W),U+(u*(1-n)-D*W)]}(U)}J.rotation=-U.wAng,s=!0}0!==U.coordinatesIndex&&(J.texCoord=U.coordinatesIndex,s=!0),s&&(this._wasUsed=!0,c.extensions||(c.extensions={}),c.extensions[Mc]=J)}}Bq.RegisterExtension(Mc,(()=>new Tc));class mc{static CreateSTL(q){let c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],g=arguments.length>5&&void 0!==arguments[5]&&arguments[5],X=arguments.length>6&&void 0!==arguments[6]&&arguments[6],n=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const W=function(q,c,U){const Q=[3*q[U],3*q[U+1],3*q[U+2]],s=[new J.p(c[Q[0]],c[Q[0]+2],c[Q[0]+1]),new J.p(c[Q[1]],c[Q[1]+2],c[Q[1]+1]),new J.p(c[Q[2]],c[Q[2]+2],c[Q[2]+1])],g=s[0].eU(s[1]),X=s[2].eU(s[1]);return{v:s,n:J.p.Cross(X,g).normalize()}},u=function(q,c,U,J){return c=K(q,c,U.x,J),c=K(q,c,U.y,J),K(q,c,U.z,J)},K=function(q,c,U,J){return q.setFloat32(c,U,J),c+4},H=function(q){if(X){let c=q;q instanceof r.d&&(c=q.sourceMesh);const U=c.getVerticesData(D.h.PositionKind,!0,!0);if(!U)return[];const Q=J.p.Zero();let s;for(s=0;s<U.length;s+=3)J.p.TransformCoordinatesFromFloatsToRef(U[s],U[s+1],U[s+2],q.o(!0),Q).toArray(U,s);return U}return q.getVerticesData(D.h.PositionKind)||[]};X&&(g=!0);let b="",h=0,o=0;if(Q){for(let U=0;U<q.length;U++){const c=q[U].uc();h+=c?c.length/3:0}const c=new ArrayBuffer(84+50*h);b=new DataView(c),o+=80,b.setUint32(o,h,s),o+=4}else n||(b="solid stlmesh\r\n");for(let J=0;J<q.length;J++){const c=q[J];!Q&&n&&(b+="solid "+c.name+"\r\n"),!g&&c instanceof aq.b&&c.bakeCurrentTransformIntoVertices();const U=H(c),X=c.uc()||[];for(let q=0;q<X.length;q+=3){const c=W(X,U,q);Q?(o=u(b,o,c.n,s),o=u(b,o,c.v[0],s),o=u(b,o,c.v[1],s),o=u(b,o,c.v[2],s),o+=2):(b+="\tfacet normal "+c.n.x+" "+c.n.y+" "+c.n.z+"\r\n",b+="\t\touter loop\r\n",b+="\t\t\tvertex "+c.v[0].x+" "+c.v[0].y+" "+c.v[0].z+"\r\n",b+="\t\t\tvertex "+c.v[1].x+" "+c.v[1].y+" "+c.v[1].z+"\r\n",b+="\t\t\tvertex "+c.v[2].x+" "+c.v[2].y+" "+c.v[2].z+"\r\n",b+="\t\tendloop\r\n",b+="\tendfacet\r\n")}!Q&&n&&(b+="endsolid "+name+"\r\n")}if(Q||n||(b+="endsolid stlmesh"),c){const q=document.createElement("a"),c=new Blob([b],{type:"application/octet-stream"});q.href=window.URL.createObjectURL(c),q.download=U+".stl",q.click()}return b}}function dc(q,c){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const J=[];for(let Q=0;Q<q.length/U;Q++){const s=q[Q*U],g=q[Q*U+1],X=q[Q*U+2];J.push(`(${s.toPrecision(c.precision)}, ${g.toPrecision(c.precision)}, ${X.toPrecision(c.precision)})`)}return J.join(", ")}function ec(q,c){const U=[];for(let J=0;J<q.length/2;J++){const Q=q[2*J],s=q[2*J+1];U.push(`(${Q.toPrecision(c.precision)}, ${(1-s).toPrecision(c.precision)})`)}return U.join(", ")}function Bc(q,c){const U=q.getVerticesData(D.h.PositionKind),J=q.getVerticesData(D.h.NormalKind);if(U&&J)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(q){var c;const U=null!==(c=q.uc())&&void 0!==c&&c.length?q.getTotalIndices():q.getTotalVertices();return Array(U/3).fill(3).join(", ")}(q)}]\n\t\tint[] faceVertexIndices = [${function(q){const c=q.uc(),U=[];if(null!==c)for(let J=0;J<c.length;J++)U.push(c[J]);else{const c=q.getTotalVertices();for(let q=0;q<c;q++)U.push(q)}return U.join(", ")}(q)}]\n\t\tnormal3f[] normals = [${dc(J,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${dc(U,c)}]\n        ${function(q,c){let U="";for(let Q=0;Q<4;Q++){const J=Q>0?Q:"",s=q.getVerticesData(D.h.UVKind+(J?J+1:""));s&&(U+=`\n\t\ttexCoord2f[] primvars:st${J} = [${ec(s,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const J=q.getVerticesData(D.h.ColorKind);return J&&(U+=`\n\tcolor3f[] primvars:displayColor = [${dc(J,c,J.length/q.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),U}(q,c)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Nc(q,c){return`\n        def "Geometry"\n        {\n        ${Bc(q,c)}\n        }\n        `}function Pc(q){let c='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return c+=q,fflate.strToU8(c)}function wc(q){const c=q.m;return`( ${Lc(c,0)}, ${Lc(c,4)}, ${Lc(c,8)}, ${Lc(c,12)} )`}function Lc(q,c){return`(${q[c+0]}, ${q[c+1]}, ${q[c+2]}, ${q[c+3]})`}function lc(q){const c="Object_"+q.uniqueId,U=function(q){const c=q.getWorldMatrix().clone(),U=q.Cq().useRightHandedSystem;if(!U){let J=q.parent;for(;J;){if(gq(J,U)){c.multiplyToRef(J.getWorldMatrix().invert(),c);break}J=J.parent}}return c.determinant()<0&&Q.e.Warn(`Exporting mesh ${q.name} with negative scale. Result may look incorrect in destination engine.`),c}(q),J=wc(U);return`def Xform "${c}" (\n\tprepend references = @./geometries/Geometry_${q.Dc.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${J}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${q.material.uniqueId}>\n}\n\n`}function jc(q){switch(q){case C.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case C.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case C.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function fc(q){return`(${q.x}, ${q.y})`}function Ac(q){return`(${q.r}, ${q.g}, ${q.b})`}function Ec(q,c,U,Q,s,g){const X=q.getInternalTexture().uniqueId+"_"+q.invertY;s[X]=q;const n=q.coordinatesIndex>0?"st"+q.coordinatesIndex:"st",W=new J.l(q.uScale,q.vScale),D=new J.l(q.uOffset,q.vOffset),u=q.wAng,K=Math.sin(u),r=Math.cos(u);return D.y=1-D.y-W.y,D.x+=K*W.x,D.y+=(1-r)*W.y,`\n    def Shader "PrimvarReader_${U}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${n}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${U}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${c.uniqueId}/PrimvarReader_${U}.outputs:result>\n        float inputs:rotation = ${(u*(180/Math.PI)).toFixed(g.precision)}\n        float2 inputs:scale = ${fc(W)}\n        float2 inputs:translation = ${fc(D)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${q.uniqueId}_${U}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${X}.png@\n        float2 inputs:st.connect = </Materials/Material_${c.uniqueId}/Transform2d_${U}.outputs:result>\n        ${Q?"float4 inputs:scale = "+function(q){return`(${q.r}, ${q.g}, ${q.b}, 1.0)`}(Q):""}\n        token inputs:sourceColorSpace = "${q.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${jc(q.wrapU)}"\n        token inputs:wrapT = "${jc(q.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${c.needAlphaBlending()?"float outputs:a":""}\n    }`}function qU(q,c,U){const J="\t\t\t",Q=[],s=[],{diffuseMap:g,dc:X,alphaCutOff:n,emissiveMap:W,emissive:D,normalMap:u,roughnessMap:K,roughnessChannel:r,roughness:H,metalnessMap:b,metalnessChannel:o,metalness:a,aoMap:p,aoMapChannel:R,aoMapIntensity:I,alphaMap:t,ior:C,clearCoatEnabled:i,clearCoat:F,clearCoatMap:v,clearCoatRoughness:Y,clearCoatRoughnessMap:k}=function(q){const c={diffuseMap:null,dc:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return q instanceof bq.b?{...c,diffuseMap:q.diffuseTexture,dc:q.diffuseColor,alphaCutOff:q.alphaCutOff,emissiveMap:q.emissiveTexture,emissive:q.emissiveColor,roughness:1,alphaMap:q.opacityTexture}:q instanceof Wc.d?{...c,diffuseMap:q._albedoTexture,dc:q._albedoColor,alphaCutOff:q._alphaCutOff,emissiveMap:q._emissiveTexture,emissive:q._emissiveColor,normalMap:q._bumpTexture,roughnessMap:q._metallicTexture,roughnessChannel:q._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:q._roughness??1,metalnessMap:q._metallicTexture,metalnessChannel:q._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:q._metallic??0,aoMap:q._ambientTexture,aoMapChannel:q._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:q._ambientTextureStrength,alphaMap:q._opacityTexture,ior:q.subSurface.indexOfRefraction,clearCoatEnabled:q.clearCoat.isEnabled,clearCoat:q.clearCoat.zc,clearCoatMap:q.clearCoat.texture,clearCoatRoughness:q.clearCoat.roughness,clearCoatRoughnessMap:q.clearCoat.useRoughnessFromMainTexture?q.clearCoat.texture:q.clearCoat.textureRoughness}:c}(q);return null!==g?(Q.push(`${J}color3f inputs:diffuseColor.connect = </Materials/Material_${q.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:rgb>`),q.needAlphaBlending()?Q.push(`${J}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:a>`):q.needAlphaTesting()&&(Q.push(`${J}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:a>`),Q.push(`${J}float inputs:opacityThreshold = ${n}`)),s.push(Ec(g,q,"diffuse",X,c,U))):Q.push(`${J}color3f inputs:diffuseColor = ${Ac(X||h.c.White())}`),null!==W?(Q.push(`${J}color3f inputs:emissiveColor.connect = </Materials/Material_${q.uniqueId}/Texture_${W.uniqueId}_emissive.outputs:rgb>`),s.push(Ec(W,q,"emissive",D,c,U))):D&&D.toLuminance()>0&&Q.push(`${J}color3f inputs:emissiveColor = ${Ac(D)}`),null!==u&&(Q.push(`${J}normal3f inputs:normal.connect = </Materials/Material_${q.uniqueId}/Texture_${u.uniqueId}_normal.outputs:rgb>`),s.push(Ec(u,q,"Jc",null,c,U))),null!==p&&(Q.push(`${J}float inputs:occlusion.connect = </Materials/Material_${q.uniqueId}/Texture_${p.uniqueId}_occlusion.outputs:${R}>`),s.push(Ec(p,q,"occlusion",new h.c(I,I,I),c,U))),null!==K?(Q.push(`${J}float inputs:roughness.connect = </Materials/Material_${q.uniqueId}/Texture_${K.uniqueId}_roughness.outputs:${r}>`),s.push(Ec(K,q,"roughness",new h.c(H,H,H),c,U))):Q.push(`${J}float inputs:roughness = ${H}`),null!==b?(Q.push(`${J}float inputs:metallic.connect = </Materials/Material_${q.uniqueId}/Texture_${b.uniqueId}_metallic.outputs:${o}>`),s.push(Ec(b,q,"metallic",new h.c(a,a,a),c,U))):Q.push(`${J}float inputs:metallic = ${a}`),null!==t?(Q.push(`${J}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${t.uniqueId}_opacity.outputs:r>`),Q.push(`${J}float inputs:opacityThreshold = 0.0001`),s.push(Ec(t,q,"opacity",null,c,U))):Q.push(`${J}float inputs:opacity = ${q.alpha}`),i&&(null!==v?(Q.push(`${J}float inputs:clearcoat.connect = </Materials/Material_${q.uniqueId}/Texture_${v.uniqueId}_clearcoat.outputs:r>`),s.push(Ec(v,q,"clearcoat",new h.c(F,F,F),c,U))):Q.push(`${J}float inputs:clearcoat = ${F}`),null!==k?(Q.push(`${J}float inputs:clearcoatRoughness.connect = </Materials/Material_${q.uniqueId}/Texture_${k.uniqueId}_clearcoatRoughness.outputs:g>`),s.push(Ec(k,q,"clearcoatRoughness",new h.c(Y,Y,Y),c,U))):Q.push(`${J}float inputs:clearcoatRoughness = ${Y}`)),Q.push(`${J}float inputs:ior = ${C}`),`\n\tdef Material "Material_${q.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${Q.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${q.uniqueId}/PreviewSurface.outputs:surface>\n\n${s.join("\n")}\n\n\t}\n`}async function cU(q,c,U){const s={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...c};"undefined"===typeof fflate&&await Q.e.LoadScriptAsync(s.fflateUrl);const g={};g[s.modelFileName]=null;let X='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';X+=function(q){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===q.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${q.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${q.planeAnchoringAlignment}"`:""}\n            `}(s);const n={};for(const J of q.meshes){if(0===J.getTotalVertices())continue;const q=J,c=q.Dc,W=q.material;if(!W||!c||U&&!U(q))continue;if(-1!==["ec","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(W.getClassName())){const U="geometries/Geometry_"+c.uniqueId+".usda";if(!(U in g)){const q=Nc(c,s);g[U]=Pc(q)}W.uniqueId in n||(n[W.uniqueId]=W),X+=lc(q)}else Q.e.Warn("USDZExportAsync does not support this material type: "+W.getClassName())}q.activeCamera&&s.exportCamera&&(X+=function(q,c){const U="Camera_"+q.uniqueId,Q=wc(J.d.RotationY(Math.PI).multiply(q.getWorldMatrix()));if(q.mode===C.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${U}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${Q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${q.Oc.toPrecision(c.precision)}, ${q.maxZ.toPrecision(c.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(q.orthoLeft||1)+Math.abs(q.orthoRight||1))).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(q.orthoTop||1)+Math.abs(q.orthoBottom||1))).toPrecision(c.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const J=q.getEngine().getAspectRatio(q),s=c.cameraSensorWidth||35;return`def Camera "${U}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${Q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${q.Oc.toPrecision(c.precision)}, ${q.maxZ.toPrecision(c.precision)})\n\t\t\tfloat focalLength = ${(s/(2*Math.tan(.5*q.fov))).toPrecision(c.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(s*J).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(s/J).toPrecision(c.precision)}            \n\t\t}\n\t\n\t`}}(q.activeCamera,s)),X+="\n            }\n        }\n    }";const W={};X+=function(q,c,U){const J=[];for(const Q in q){const s=q[Q];J.push(qU(s,c,U))}return`\n    def "Materials"\n{\n${J.join("")}\n}\n\n`}(n,W,s),g[s.modelFileName]=fflate.strToU8(X);for(const J in W){const q=W[J],c=q.getSize(),U=await q.readPixels();if(!U)throw new Error("Texture data is not available");const Q=await i.DumpTools.DumpDataAsync(c.width,c.height,U,"image/png",void 0,!1,!0);g[`textures/Texture_${J}.png`]=new Uint8Array(Q).slice()}let D=0;for(const J in g){const q=g[J];if(!q)continue;D+=34+J.length;const c=63&D;if(4!==c){const U=new Uint8Array(64-c);g[J]=[q,{extra:{12345:U}}]}D=q.length}return fflate.zipSync(g,{level:0})}}}]);