"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10156:(I,k,i)=>{i.r(k),i.d(k,{_HDRTextureLoader:()=>g});var d=i(983);class u{static ConvertPanoramaToCubemap(I,k,i,d){let u=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!I)throw"ConvertPanoramaToCubemap: input cannot be null";if(I.length!=k*i*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(d,this.FACE_FRONT,I,k,i,u),back:this.CreateCubemapTexture(d,this.FACE_BACK,I,k,i,u),left:this.CreateCubemapTexture(d,this.FACE_LEFT,I,k,i,u),right:this.CreateCubemapTexture(d,this.FACE_RIGHT,I,k,i,u),up:this.CreateCubemapTexture(d,this.FACE_UP,I,k,i,u),down:this.CreateCubemapTexture(d,this.FACE_DOWN,I,k,i,u),size:d,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(I,k,i,d,u){let H=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const Y=new ArrayBuffer(I*I*4*3),x=new Float32Array(Y),j=H?Math.max(1,Math.round(d/4/I)):1,l=1/j,g=l*l,P=k[1].tc(k[0]).scale(l/I),J=k[3].tc(k[2]).scale(l/I),L=1/I;let s=0;for(let h=0;h<I;h++)for(let H=0;H<j;H++){let H=k[0],Y=k[2];for(let k=0;k<I;k++)for(let l=0;l<j;l++){const j=Y.tc(H).scale(s).add(H);j.normalize();const l=this.CalcProjectionSpherical(j,i,d,u);x[h*I*3+3*k+0]+=l.r*g,x[h*I*3+3*k+1]+=l.g*g,x[h*I*3+3*k+2]+=l.b*g,H=H.add(P),Y=Y.add(J)}s+=L*l}return x}static CalcProjectionSpherical(I,k,i,d){let u=Math.atan2(I.z,I.x);const H=Math.acos(I.y);for(;u<-Math.PI;)u+=2*Math.PI;for(;u>Math.PI;)u-=2*Math.PI;let Y=u/Math.PI;const x=H/Math.PI;Y=.5*Y+.5;let j=Math.round(Y*i);j<0?j=0:j>=i&&(j=i-1);let l=Math.round(x*d);l<0?l=0:l>=d&&(l=d-1);const g=d-l-1;return{r:k[g*i*3+3*j+0],g:k[g*i*3+3*j+1],b:k[g*i*3+3*j+2]}}}function H(I,k,i,d,u,H){u>0?(u=function(I,k){return k>1023?I*Math.pow(2,1023)*Math.pow(2,k-1023):k<-1074?I*Math.pow(2,-1074)*Math.pow(2,k+1074):I*Math.pow(2,k)}(1,u-136),I[H+0]=k*u,I[H+1]=i*u,I[H+2]=d*u):(I[H+0]=0,I[H+1]=0,I[H+2]=0)}function Y(I,k){let i="",d="";for(let u=k;u<I.length-k&&(d=String.fromCharCode(I[u]),"\n"!=d);u++)i+=d;return i}function x(I){let k=0,i=0,d=Y(I,0);if("#"!=d[0]||"?"!=d[1])throw"Bad HDR Format.";let u=!1,H=!1,x=0;do{x+=d.length+1,d=Y(I,x),"FORMAT=32-bit_rle_rgbe"==d?H=!0:0==d.length&&(u=!0)}while(!u);if(!H)throw"HDR Bad header format, unsupported FORMAT";x+=d.length+1,d=Y(I,x);const j=/^-Y (.*) \+X (.*)$/g.exec(d);if(!j||j.length<3)throw"HDR Bad header format, no size";if(i=parseInt(j[2]),k=parseInt(j[1]),i<8||i>32767)throw"HDR Bad header format, unsupported size";return x+=d.length+1,{height:k,width:i,dataPosition:x}}function j(I,k){return function(I,k){let i=k.height;const d=k.width;let u,Y,x,j,g,P=k.dataPosition,J=0,L=0,s=0;const h=new ArrayBuffer(4*d),Z=new Uint8Array(h),n=new ArrayBuffer(k.width*k.height*4*3),B=new Float32Array(n);for(;i>0;){if(u=I[P++],Y=I[P++],x=I[P++],j=I[P++],2!=u||2!=Y||128&x||k.width<8||k.width>32767)return l(I,k);if((x<<8|j)!=d)throw"HDR Bad header format, wrong scan line width";for(J=0,s=0;s<4;s++)for(L=(s+1)*d;J<L;)if(u=I[P++],Y=I[P++],u>128){if(g=u-128,0==g||g>L-J)throw"HDR Bad Format, bad scanline data (run)";for(;g-- >0;)Z[J++]=Y}else{if(g=u,0==g||g>L-J)throw"HDR Bad Format, bad scanline data (non-run)";if(Z[J++]=Y,--g>0)for(let k=0;k<g;k++)Z[J++]=I[P++]}for(s=0;s<d;s++)u=Z[s],Y=Z[s+d],x=Z[s+2*d],j=Z[s+3*d],H(B,u,Y,x,j,(k.height-i)*d*3+3*s);i--}return B}(I,k)}function l(I,k){let i=k.height;const d=k.width;let u,Y,x,j,l,g=k.dataPosition;const P=new ArrayBuffer(k.width*k.height*4*3),J=new Float32Array(P);for(;i>0;){for(l=0;l<k.width;l++)u=I[g++],Y=I[g++],x=I[g++],j=I[g++],H(J,u,Y,x,j,(k.height-i)*d*3+3*l);i--}return J}u.FACE_LEFT=[new d.m(-1,-1,-1),new d.m(1,-1,-1),new d.m(-1,1,-1),new d.m(1,1,-1)],u.FACE_RIGHT=[new d.m(1,-1,1),new d.m(-1,-1,1),new d.m(1,1,1),new d.m(-1,1,1)],u.FACE_FRONT=[new d.m(1,-1,-1),new d.m(1,-1,1),new d.m(1,1,-1),new d.m(1,1,1)],u.FACE_BACK=[new d.m(-1,-1,1),new d.m(-1,-1,-1),new d.m(-1,1,1),new d.m(-1,1,-1)],u.FACE_DOWN=[new d.m(1,1,-1),new d.m(1,1,1),new d.m(-1,1,-1),new d.m(-1,1,1)],u.FACE_UP=[new d.m(-1,-1,-1),new d.m(-1,-1,1),new d.m(1,-1,-1),new d.m(1,-1,1)];class g{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(I,k,i){const d=new Uint8Array(I.buffer,I.byteOffset,I.byteLength),u=x(d),H=j(d,u),Y=u.width*u.height,l=new Float32Array(4*Y);for(let x=0;x<Y;x+=1)l[4*x]=H[3*x],l[4*x+1]=H[3*x+1],l[4*x+2]=H[3*x+2],l[4*x+3]=1;i(u.width,u.height,k.generateMipMaps,!1,(()=>{const I=k.getEngine();k.type=1,k.format=5,k._gammaSpace=!1,I._uploadDataToTextureDirectly(k,l)}))}}}}]);