"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10973:(I,S,d)=>{d.r(S),d.d(S,{_HDRTextureLoader:()=>Y});var N=d(1020);class O{static ConvertPanoramaToCubemap(I,S,d,N){let O=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!I)throw"ConvertPanoramaToCubemap: input cannot be null";if(I.length!=S*d*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(N,this.FACE_FRONT,I,S,d,O),back:this.CreateCubemapTexture(N,this.FACE_BACK,I,S,d,O),left:this.CreateCubemapTexture(N,this.FACE_LEFT,I,S,d,O),right:this.CreateCubemapTexture(N,this.FACE_RIGHT,I,S,d,O),up:this.CreateCubemapTexture(N,this.FACE_UP,I,S,d,O),down:this.CreateCubemapTexture(N,this.FACE_DOWN,I,S,d,O),size:N,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(I,S,d,N,O){let g=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const T=new ArrayBuffer(I*I*4*3),q=new Float32Array(T),a=g?Math.max(1,Math.round(N/4/I)):1,f=1/a,Y=f*f,p=S[1].vc(S[0]).scale(f/I),E=S[3].vc(S[2]).scale(f/I),o=1/I;let k=0;for(let U=0;U<I;U++)for(let g=0;g<a;g++){let g=S[0],T=S[2];for(let S=0;S<I;S++)for(let f=0;f<a;f++){const a=T.vc(g).scale(k).add(g);a.normalize();const f=this.CalcProjectionSpherical(a,d,N,O);q[U*I*3+3*S+0]+=f.r*Y,q[U*I*3+3*S+1]+=f.g*Y,q[U*I*3+3*S+2]+=f.b*Y,g=g.add(p),T=T.add(E)}k+=o*f}return q}static CalcProjectionSpherical(I,S,d,N){let O=Math.atan2(I.z,I.x);const g=Math.acos(I.y);for(;O<-Math.PI;)O+=2*Math.PI;for(;O>Math.PI;)O-=2*Math.PI;let T=O/Math.PI;const q=g/Math.PI;T=.5*T+.5;let a=Math.round(T*d);a<0?a=0:a>=d&&(a=d-1);let f=Math.round(q*N);f<0?f=0:f>=N&&(f=N-1);const Y=N-f-1;return{r:S[Y*d*3+3*a+0],g:S[Y*d*3+3*a+1],b:S[Y*d*3+3*a+2]}}}function g(I,S,d,N,O,g){O>0?(O=function(I,S){return S>1023?I*Math.pow(2,1023)*Math.pow(2,S-1023):S<-1074?I*Math.pow(2,-1074)*Math.pow(2,S+1074):I*Math.pow(2,S)}(1,O-136),I[g+0]=S*O,I[g+1]=d*O,I[g+2]=N*O):(I[g+0]=0,I[g+1]=0,I[g+2]=0)}function T(I,S){let d="",N="";for(let O=S;O<I.length-S&&(N=String.fromCharCode(I[O]),"\n"!=N);O++)d+=N;return d}function q(I){let S=0,d=0,N=T(I,0);if("#"!=N[0]||"?"!=N[1])throw"Bad HDR Format.";let O=!1,g=!1,q=0;do{q+=N.length+1,N=T(I,q),"FORMAT=32-bit_rle_rgbe"==N?g=!0:0==N.length&&(O=!0)}while(!O);if(!g)throw"HDR Bad header format, unsupported FORMAT";q+=N.length+1,N=T(I,q);const a=/^-Y (.*) \+X (.*)$/g.exec(N);if(!a||a.length<3)throw"HDR Bad header format, no size";if(d=parseInt(a[2]),S=parseInt(a[1]),d<8||d>32767)throw"HDR Bad header format, unsupported size";return q+=N.length+1,{height:S,width:d,dataPosition:q}}function a(I,S){return function(I,S){let d=S.height;const N=S.width;let O,T,q,a,Y,p=S.dataPosition,E=0,o=0,k=0;const U=new ArrayBuffer(4*N),i=new Uint8Array(U),G=new ArrayBuffer(S.width*S.height*4*3),t=new Float32Array(G);for(;d>0;){if(O=I[p++],T=I[p++],q=I[p++],a=I[p++],2!=O||2!=T||128&q||S.width<8||S.width>32767)return f(I,S);if((q<<8|a)!=N)throw"HDR Bad header format, wrong scan line width";for(E=0,k=0;k<4;k++)for(o=(k+1)*N;E<o;)if(O=I[p++],T=I[p++],O>128){if(Y=O-128,0==Y||Y>o-E)throw"HDR Bad Format, bad scanline data (run)";for(;Y-- >0;)i[E++]=T}else{if(Y=O,0==Y||Y>o-E)throw"HDR Bad Format, bad scanline data (non-run)";if(i[E++]=T,--Y>0)for(let S=0;S<Y;S++)i[E++]=I[p++]}for(k=0;k<N;k++)O=i[k],T=i[k+N],q=i[k+2*N],a=i[k+3*N],g(t,O,T,q,a,(S.height-d)*N*3+3*k);d--}return t}(I,S)}function f(I,S){let d=S.height;const N=S.width;let O,T,q,a,f,Y=S.dataPosition;const p=new ArrayBuffer(S.width*S.height*4*3),E=new Float32Array(p);for(;d>0;){for(f=0;f<S.width;f++)O=I[Y++],T=I[Y++],q=I[Y++],a=I[Y++],g(E,O,T,q,a,(S.height-d)*N*3+3*f);d--}return E}O.FACE_LEFT=[new N.p(-1,-1,-1),new N.p(1,-1,-1),new N.p(-1,1,-1),new N.p(1,1,-1)],O.FACE_RIGHT=[new N.p(1,-1,1),new N.p(-1,-1,1),new N.p(1,1,1),new N.p(-1,1,1)],O.FACE_FRONT=[new N.p(1,-1,-1),new N.p(1,-1,1),new N.p(1,1,-1),new N.p(1,1,1)],O.FACE_BACK=[new N.p(-1,-1,1),new N.p(-1,-1,-1),new N.p(-1,1,1),new N.p(-1,1,-1)],O.FACE_DOWN=[new N.p(1,1,-1),new N.p(1,1,1),new N.p(-1,1,-1),new N.p(-1,1,1)],O.FACE_UP=[new N.p(-1,-1,-1),new N.p(-1,-1,1),new N.p(1,-1,-1),new N.p(1,-1,1)];class Y{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(I,S,d){const N=new Uint8Array(I.buffer,I.byteOffset,I.byteLength),O=q(N),g=a(N,O),T=O.width*O.height,f=new Float32Array(4*T);for(let q=0;q<T;q+=1)f[4*q]=g[3*q],f[4*q+1]=g[3*q+1],f[4*q+2]=g[3*q+2],f[4*q+3]=1;d(O.width,O.height,S.generateMipMaps,!1,(()=>{const I=S.getEngine();S.type=1,S.format=5,S._gammaSpace=!1,I._uploadDataToTextureDirectly(S,f)}))}}}}]);