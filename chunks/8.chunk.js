"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{11090:(f,H,Q)=>{Q.r(H),Q.d(H,{_HDRTextureLoader:()=>u});var a=Q(1e3);class d{static ConvertPanoramaToCubemap(f,H,Q,a){let d=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!f)throw"ConvertPanoramaToCubemap: input cannot be null";if(f.length!=H*Q*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(a,this.FACE_FRONT,f,H,Q,d),back:this.CreateCubemapTexture(a,this.FACE_BACK,f,H,Q,d),left:this.CreateCubemapTexture(a,this.FACE_LEFT,f,H,Q,d),right:this.CreateCubemapTexture(a,this.FACE_RIGHT,f,H,Q,d),up:this.CreateCubemapTexture(a,this.FACE_UP,f,H,Q,d),down:this.CreateCubemapTexture(a,this.FACE_DOWN,f,H,Q,d),size:a,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(f,H,Q,a,d){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const n=new ArrayBuffer(f*f*4*3),e=new Float32Array(n),c=s?Math.max(1,Math.round(a/4/f)):1,J=1/c,u=J*J,Y=H[1].Ac(H[0]).scale(J/f),k=H[3].Ac(H[2]).scale(J/f),X=1/f;let F=0;for(let r=0;r<f;r++)for(let s=0;s<c;s++){let s=H[0],n=H[2];for(let H=0;H<f;H++)for(let J=0;J<c;J++){const c=n.Ac(s).scale(F).add(s);c.normalize();const J=this.CalcProjectionSpherical(c,Q,a,d);e[r*f*3+3*H+0]+=J.r*u,e[r*f*3+3*H+1]+=J.g*u,e[r*f*3+3*H+2]+=J.b*u,s=s.add(Y),n=n.add(k)}F+=X*J}return e}static CalcProjectionSpherical(f,H,Q,a){let d=Math.atan2(f.z,f.x);const s=Math.acos(f.y);for(;d<-Math.PI;)d+=2*Math.PI;for(;d>Math.PI;)d-=2*Math.PI;let n=d/Math.PI;const e=s/Math.PI;n=.5*n+.5;let c=Math.round(n*Q);c<0?c=0:c>=Q&&(c=Q-1);let J=Math.round(e*a);J<0?J=0:J>=a&&(J=a-1);const u=a-J-1;return{r:H[u*Q*3+3*c+0],g:H[u*Q*3+3*c+1],b:H[u*Q*3+3*c+2]}}}function s(f,H,Q,a,d,s){d>0?(d=function(f,H){return H>1023?f*Math.pow(2,1023)*Math.pow(2,H-1023):H<-1074?f*Math.pow(2,-1074)*Math.pow(2,H+1074):f*Math.pow(2,H)}(1,d-136),f[s+0]=H*d,f[s+1]=Q*d,f[s+2]=a*d):(f[s+0]=0,f[s+1]=0,f[s+2]=0)}function n(f,H){let Q="",a="";for(let d=H;d<f.length-H&&(a=String.fromCharCode(f[d]),"\n"!=a);d++)Q+=a;return Q}function e(f){let H=0,Q=0,a=n(f,0);if("#"!=a[0]||"?"!=a[1])throw"Bad HDR Format.";let d=!1,s=!1,e=0;do{e+=a.length+1,a=n(f,e),"FORMAT=32-bit_rle_rgbe"==a?s=!0:0==a.length&&(d=!0)}while(!d);if(!s)throw"HDR Bad header format, unsupported FORMAT";e+=a.length+1,a=n(f,e);const c=/^-Y (.*) \+X (.*)$/g.exec(a);if(!c||c.length<3)throw"HDR Bad header format, no size";if(Q=parseInt(c[2]),H=parseInt(c[1]),Q<8||Q>32767)throw"HDR Bad header format, unsupported size";return e+=a.length+1,{height:H,width:Q,dataPosition:e}}function c(f,H){return function(f,H){let Q=H.height;const a=H.width;let d,n,e,c,u,Y=H.dataPosition,k=0,X=0,F=0;const r=new ArrayBuffer(4*a),v=new Uint8Array(r),S=new ArrayBuffer(H.width*H.height*4*3),M=new Float32Array(S);for(;Q>0;){if(d=f[Y++],n=f[Y++],e=f[Y++],c=f[Y++],2!=d||2!=n||128&e||H.width<8||H.width>32767)return J(f,H);if((e<<8|c)!=a)throw"HDR Bad header format, wrong scan line width";for(k=0,F=0;F<4;F++)for(X=(F+1)*a;k<X;)if(d=f[Y++],n=f[Y++],d>128){if(u=d-128,0==u||u>X-k)throw"HDR Bad Format, bad scanline data (run)";for(;u-- >0;)v[k++]=n}else{if(u=d,0==u||u>X-k)throw"HDR Bad Format, bad scanline data (non-run)";if(v[k++]=n,--u>0)for(let H=0;H<u;H++)v[k++]=f[Y++]}for(F=0;F<a;F++)d=v[F],n=v[F+a],e=v[F+2*a],c=v[F+3*a],s(M,d,n,e,c,(H.height-Q)*a*3+3*F);Q--}return M}(f,H)}function J(f,H){let Q=H.height;const a=H.width;let d,n,e,c,J,u=H.dataPosition;const Y=new ArrayBuffer(H.width*H.height*4*3),k=new Float32Array(Y);for(;Q>0;){for(J=0;J<H.width;J++)d=f[u++],n=f[u++],e=f[u++],c=f[u++],s(k,d,n,e,c,(H.height-Q)*a*3+3*J);Q--}return k}d.FACE_LEFT=[new a.r(-1,-1,-1),new a.r(1,-1,-1),new a.r(-1,1,-1),new a.r(1,1,-1)],d.FACE_RIGHT=[new a.r(1,-1,1),new a.r(-1,-1,1),new a.r(1,1,1),new a.r(-1,1,1)],d.FACE_FRONT=[new a.r(1,-1,-1),new a.r(1,-1,1),new a.r(1,1,-1),new a.r(1,1,1)],d.FACE_BACK=[new a.r(-1,-1,1),new a.r(-1,-1,-1),new a.r(-1,1,1),new a.r(-1,1,-1)],d.FACE_DOWN=[new a.r(1,1,-1),new a.r(1,1,1),new a.r(-1,1,-1),new a.r(-1,1,1)],d.FACE_UP=[new a.r(-1,-1,-1),new a.r(-1,-1,1),new a.r(1,-1,-1),new a.r(1,-1,1)];class u{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(f,H,Q){const a=new Uint8Array(f.buffer,f.byteOffset,f.byteLength),d=e(a),s=c(a,d),n=d.width*d.height,J=new Float32Array(4*n);for(let e=0;e<n;e+=1)J[4*e]=s[3*e],J[4*e+1]=s[3*e+1],J[4*e+2]=s[3*e+2],J[4*e+3]=1;Q(d.width,d.height,H.generateMipMaps,!1,(()=>{const f=H.getEngine();H.type=1,H.format=5,H._gammaSpace=!1,f._uploadDataToTextureDirectly(H,J)}))}}}}]);