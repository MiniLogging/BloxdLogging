"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10867:(v,T,X)=>{X.r(T),X.d(T,{_HDRTextureLoader:()=>M});var O=X(1006);class u{static ConvertPanoramaToCubemap(v,T,X,O){let u=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!v)throw"ConvertPanoramaToCubemap: input cannot be null";if(v.length!=T*X*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(O,this.FACE_FRONT,v,T,X,u),back:this.CreateCubemapTexture(O,this.FACE_BACK,v,T,X,u),left:this.CreateCubemapTexture(O,this.FACE_LEFT,v,T,X,u),right:this.CreateCubemapTexture(O,this.FACE_RIGHT,v,T,X,u),up:this.CreateCubemapTexture(O,this.FACE_UP,v,T,X,u),down:this.CreateCubemapTexture(O,this.FACE_DOWN,v,T,X,u),size:O,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(v,T,X,O,u){let B=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const m=new ArrayBuffer(v*v*4*3),A=new Float32Array(m),x=B?Math.max(1,Math.round(O/4/v)):1,f=1/x,M=f*f,H=T[1].Xc(T[0]).scale(f/v),n=T[3].Xc(T[2]).scale(f/v),V=1/v;let D=0;for(let s=0;s<v;s++)for(let B=0;B<x;B++){let B=T[0],m=T[2];for(let T=0;T<v;T++)for(let f=0;f<x;f++){const x=m.Xc(B).scale(D).add(B);x.normalize();const f=this.CalcProjectionSpherical(x,X,O,u);A[s*v*3+3*T+0]+=f.r*M,A[s*v*3+3*T+1]+=f.g*M,A[s*v*3+3*T+2]+=f.b*M,B=B.add(H),m=m.add(n)}D+=V*f}return A}static CalcProjectionSpherical(v,T,X,O){let u=Math.atan2(v.z,v.x);const B=Math.acos(v.y);for(;u<-Math.PI;)u+=2*Math.PI;for(;u>Math.PI;)u-=2*Math.PI;let m=u/Math.PI;const A=B/Math.PI;m=.5*m+.5;let x=Math.round(m*X);x<0?x=0:x>=X&&(x=X-1);let f=Math.round(A*O);f<0?f=0:f>=O&&(f=O-1);const M=O-f-1;return{r:T[M*X*3+3*x+0],g:T[M*X*3+3*x+1],b:T[M*X*3+3*x+2]}}}function B(v,T,X,O,u,B){u>0?(u=function(v,T){return T>1023?v*Math.pow(2,1023)*Math.pow(2,T-1023):T<-1074?v*Math.pow(2,-1074)*Math.pow(2,T+1074):v*Math.pow(2,T)}(1,u-136),v[B+0]=T*u,v[B+1]=X*u,v[B+2]=O*u):(v[B+0]=0,v[B+1]=0,v[B+2]=0)}function m(v,T){let X="",O="";for(let u=T;u<v.length-T&&(O=String.fromCharCode(v[u]),"\n"!=O);u++)X+=O;return X}function A(v){let T=0,X=0,O=m(v,0);if("#"!=O[0]||"?"!=O[1])throw"Bad HDR Format.";let u=!1,B=!1,A=0;do{A+=O.length+1,O=m(v,A),"FORMAT=32-bit_rle_rgbe"==O?B=!0:0==O.length&&(u=!0)}while(!u);if(!B)throw"HDR Bad header format, unsupported FORMAT";A+=O.length+1,O=m(v,A);const x=/^-Y (.*) \+X (.*)$/g.exec(O);if(!x||x.length<3)throw"HDR Bad header format, no size";if(X=parseInt(x[2]),T=parseInt(x[1]),X<8||X>32767)throw"HDR Bad header format, unsupported size";return A+=O.length+1,{height:T,width:X,dataPosition:A}}function x(v,T){return function(v,T){let X=T.height;const O=T.width;let u,m,A,x,M,H=T.dataPosition,n=0,V=0,D=0;const s=new ArrayBuffer(4*O),F=new Uint8Array(s),k=new ArrayBuffer(T.width*T.height*4*3),b=new Float32Array(k);for(;X>0;){if(u=v[H++],m=v[H++],A=v[H++],x=v[H++],2!=u||2!=m||128&A||T.width<8||T.width>32767)return f(v,T);if((A<<8|x)!=O)throw"HDR Bad header format, wrong scan line width";for(n=0,D=0;D<4;D++)for(V=(D+1)*O;n<V;)if(u=v[H++],m=v[H++],u>128){if(M=u-128,0==M||M>V-n)throw"HDR Bad Format, bad scanline data (run)";for(;M-- >0;)F[n++]=m}else{if(M=u,0==M||M>V-n)throw"HDR Bad Format, bad scanline data (non-run)";if(F[n++]=m,--M>0)for(let T=0;T<M;T++)F[n++]=v[H++]}for(D=0;D<O;D++)u=F[D],m=F[D+O],A=F[D+2*O],x=F[D+3*O],B(b,u,m,A,x,(T.height-X)*O*3+3*D);X--}return b}(v,T)}function f(v,T){let X=T.height;const O=T.width;let u,m,A,x,f,M=T.dataPosition;const H=new ArrayBuffer(T.width*T.height*4*3),n=new Float32Array(H);for(;X>0;){for(f=0;f<T.width;f++)u=v[M++],m=v[M++],A=v[M++],x=v[M++],B(n,u,m,A,x,(T.height-X)*O*3+3*f);X--}return n}u.FACE_LEFT=[new O.l(-1,-1,-1),new O.l(1,-1,-1),new O.l(-1,1,-1),new O.l(1,1,-1)],u.FACE_RIGHT=[new O.l(1,-1,1),new O.l(-1,-1,1),new O.l(1,1,1),new O.l(-1,1,1)],u.FACE_FRONT=[new O.l(1,-1,-1),new O.l(1,-1,1),new O.l(1,1,-1),new O.l(1,1,1)],u.FACE_BACK=[new O.l(-1,-1,1),new O.l(-1,-1,-1),new O.l(-1,1,1),new O.l(-1,1,-1)],u.FACE_DOWN=[new O.l(1,1,-1),new O.l(1,1,1),new O.l(-1,1,-1),new O.l(-1,1,1)],u.FACE_UP=[new O.l(-1,-1,-1),new O.l(-1,-1,1),new O.l(1,-1,-1),new O.l(1,-1,1)];class M{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(v,T,X){const O=new Uint8Array(v.buffer,v.byteOffset,v.byteLength),u=A(O),B=x(O,u),m=u.width*u.height,f=new Float32Array(4*m);for(let A=0;A<m;A+=1)f[4*A]=B[3*A],f[4*A+1]=B[3*A+1],f[4*A+2]=B[3*A+2],f[4*A+3]=1;X(u.width,u.height,T.generateMipMaps,!1,(()=>{const v=T.getEngine();T.type=1,T.format=5,T._gammaSpace=!1,v._uploadDataToTextureDirectly(T,f)}))}}}}]);