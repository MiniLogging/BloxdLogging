"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10300:(L,J,o)=>{o.r(J),o.d(J,{_HDRTextureLoader:()=>C});var g=o(982);class V{static ConvertPanoramaToCubemap(L,J,o,g){let V=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!L)throw"ConvertPanoramaToCubemap: input cannot be null";if(L.length!=J*o*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(g,this.FACE_FRONT,L,J,o,V),back:this.CreateCubemapTexture(g,this.FACE_BACK,L,J,o,V),left:this.CreateCubemapTexture(g,this.FACE_LEFT,L,J,o,V),right:this.CreateCubemapTexture(g,this.FACE_RIGHT,L,J,o,V),up:this.CreateCubemapTexture(g,this.FACE_UP,L,J,o,V),down:this.CreateCubemapTexture(g,this.FACE_DOWN,L,J,o,V),size:g,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(L,J,o,g,V){let q=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const I=new ArrayBuffer(L*L*4*3),b=new Float32Array(I),D=q?Math.max(1,Math.round(g/4/L)):1,Z=1/D,C=Z*Z,v=J[1].Uc(J[0]).scale(Z/L),U=J[3].Uc(J[2]).scale(Z/L),k=1/L;let H=0;for(let e=0;e<L;e++)for(let q=0;q<D;q++){let q=J[0],I=J[2];for(let J=0;J<L;J++)for(let Z=0;Z<D;Z++){const D=I.Uc(q).scale(H).add(q);D.normalize();const Z=this.CalcProjectionSpherical(D,o,g,V);b[e*L*3+3*J+0]+=Z.r*C,b[e*L*3+3*J+1]+=Z.g*C,b[e*L*3+3*J+2]+=Z.b*C,q=q.add(v),I=I.add(U)}H+=k*Z}return b}static CalcProjectionSpherical(L,J,o,g){let V=Math.atan2(L.z,L.x);const q=Math.acos(L.y);for(;V<-Math.PI;)V+=2*Math.PI;for(;V>Math.PI;)V-=2*Math.PI;let I=V/Math.PI;const b=q/Math.PI;I=.5*I+.5;let D=Math.round(I*o);D<0?D=0:D>=o&&(D=o-1);let Z=Math.round(b*g);Z<0?Z=0:Z>=g&&(Z=g-1);const C=g-Z-1;return{r:J[C*o*3+3*D+0],g:J[C*o*3+3*D+1],b:J[C*o*3+3*D+2]}}}function q(L,J,o,g,V,q){V>0?(V=function(L,J){return J>1023?L*Math.pow(2,1023)*Math.pow(2,J-1023):J<-1074?L*Math.pow(2,-1074)*Math.pow(2,J+1074):L*Math.pow(2,J)}(1,V-136),L[q+0]=J*V,L[q+1]=o*V,L[q+2]=g*V):(L[q+0]=0,L[q+1]=0,L[q+2]=0)}function I(L,J){let o="",g="";for(let V=J;V<L.length-J&&(g=String.fromCharCode(L[V]),"\n"!=g);V++)o+=g;return o}function b(L){let J=0,o=0,g=I(L,0);if("#"!=g[0]||"?"!=g[1])throw"Bad HDR Format.";let V=!1,q=!1,b=0;do{b+=g.length+1,g=I(L,b),"FORMAT=32-bit_rle_rgbe"==g?q=!0:0==g.length&&(V=!0)}while(!V);if(!q)throw"HDR Bad header format, unsupported FORMAT";b+=g.length+1,g=I(L,b);const D=/^-Y (.*) \+X (.*)$/g.exec(g);if(!D||D.length<3)throw"HDR Bad header format, no size";if(o=parseInt(D[2]),J=parseInt(D[1]),o<8||o>32767)throw"HDR Bad header format, unsupported size";return b+=g.length+1,{height:J,width:o,dataPosition:b}}function D(L,J){return function(L,J){let o=J.height;const g=J.width;let V,I,b,D,C,v=J.dataPosition,U=0,k=0,H=0;const e=new ArrayBuffer(4*g),T=new Uint8Array(e),O=new ArrayBuffer(J.width*J.height*4*3),l=new Float32Array(O);for(;o>0;){if(V=L[v++],I=L[v++],b=L[v++],D=L[v++],2!=V||2!=I||128&b||J.width<8||J.width>32767)return Z(L,J);if((b<<8|D)!=g)throw"HDR Bad header format, wrong scan line width";for(U=0,H=0;H<4;H++)for(k=(H+1)*g;U<k;)if(V=L[v++],I=L[v++],V>128){if(C=V-128,0==C||C>k-U)throw"HDR Bad Format, bad scanline data (run)";for(;C-- >0;)T[U++]=I}else{if(C=V,0==C||C>k-U)throw"HDR Bad Format, bad scanline data (non-run)";if(T[U++]=I,--C>0)for(let J=0;J<C;J++)T[U++]=L[v++]}for(H=0;H<g;H++)V=T[H],I=T[H+g],b=T[H+2*g],D=T[H+3*g],q(l,V,I,b,D,(J.height-o)*g*3+3*H);o--}return l}(L,J)}function Z(L,J){let o=J.height;const g=J.width;let V,I,b,D,Z,C=J.dataPosition;const v=new ArrayBuffer(J.width*J.height*4*3),U=new Float32Array(v);for(;o>0;){for(Z=0;Z<J.width;Z++)V=L[C++],I=L[C++],b=L[C++],D=L[C++],q(U,V,I,b,D,(J.height-o)*g*3+3*Z);o--}return U}V.FACE_LEFT=[new g.o(-1,-1,-1),new g.o(1,-1,-1),new g.o(-1,1,-1),new g.o(1,1,-1)],V.FACE_RIGHT=[new g.o(1,-1,1),new g.o(-1,-1,1),new g.o(1,1,1),new g.o(-1,1,1)],V.FACE_FRONT=[new g.o(1,-1,-1),new g.o(1,-1,1),new g.o(1,1,-1),new g.o(1,1,1)],V.FACE_BACK=[new g.o(-1,-1,1),new g.o(-1,-1,-1),new g.o(-1,1,1),new g.o(-1,1,-1)],V.FACE_DOWN=[new g.o(1,1,-1),new g.o(1,1,1),new g.o(-1,1,-1),new g.o(-1,1,1)],V.FACE_UP=[new g.o(-1,-1,-1),new g.o(-1,-1,1),new g.o(1,-1,-1),new g.o(1,-1,1)];class C{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(L,J,o){const g=new Uint8Array(L.buffer,L.byteOffset,L.byteLength),V=b(g),q=D(g,V),I=V.width*V.height,Z=new Float32Array(4*I);for(let b=0;b<I;b+=1)Z[4*b]=q[3*b],Z[4*b+1]=q[3*b+1],Z[4*b+2]=q[3*b+2],Z[4*b+3]=1;o(V.width,V.height,J.generateMipMaps,!1,(()=>{const L=J.getEngine();J.type=1,J.format=5,J._gammaSpace=!1,L._uploadDataToTextureDirectly(J,Z)}))}}}}]);