"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10731:(O,q,s)=>{s.r(q),s.d(q,{_HDRTextureLoader:()=>h});var Z=s(993);class D{static ConvertPanoramaToCubemap(O,q,s,Z){let D=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!O)throw"ConvertPanoramaToCubemap: input cannot be null";if(O.length!=q*s*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(Z,this.FACE_FRONT,O,q,s,D),back:this.CreateCubemapTexture(Z,this.FACE_BACK,O,q,s,D),left:this.CreateCubemapTexture(Z,this.FACE_LEFT,O,q,s,D),right:this.CreateCubemapTexture(Z,this.FACE_RIGHT,O,q,s,D),up:this.CreateCubemapTexture(Z,this.FACE_UP,O,q,s,D),down:this.CreateCubemapTexture(Z,this.FACE_DOWN,O,q,s,D),size:Z,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(O,q,s,Z,D){let B=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const P=new ArrayBuffer(O*O*4*3),y=new Float32Array(P),o=B?Math.max(1,Math.round(Z/4/O)):1,w=1/o,h=w*w,n=q[1].Gc(q[0]).scale(w/O),r=q[3].Gc(q[2]).scale(w/O),j=1/O;let f=0;for(let u=0;u<O;u++)for(let B=0;B<o;B++){let B=q[0],P=q[2];for(let q=0;q<O;q++)for(let w=0;w<o;w++){const o=P.Gc(B).scale(f).add(B);o.normalize();const w=this.CalcProjectionSpherical(o,s,Z,D);y[u*O*3+3*q+0]+=w.r*h,y[u*O*3+3*q+1]+=w.g*h,y[u*O*3+3*q+2]+=w.b*h,B=B.add(n),P=P.add(r)}f+=j*w}return y}static CalcProjectionSpherical(O,q,s,Z){let D=Math.atan2(O.z,O.x);const B=Math.acos(O.y);for(;D<-Math.PI;)D+=2*Math.PI;for(;D>Math.PI;)D-=2*Math.PI;let P=D/Math.PI;const y=B/Math.PI;P=.5*P+.5;let o=Math.round(P*s);o<0?o=0:o>=s&&(o=s-1);let w=Math.round(y*Z);w<0?w=0:w>=Z&&(w=Z-1);const h=Z-w-1;return{r:q[h*s*3+3*o+0],g:q[h*s*3+3*o+1],b:q[h*s*3+3*o+2]}}}function B(O,q,s,Z,D,B){D>0?(D=function(O,q){return q>1023?O*Math.pow(2,1023)*Math.pow(2,q-1023):q<-1074?O*Math.pow(2,-1074)*Math.pow(2,q+1074):O*Math.pow(2,q)}(1,D-136),O[B+0]=q*D,O[B+1]=s*D,O[B+2]=Z*D):(O[B+0]=0,O[B+1]=0,O[B+2]=0)}function P(O,q){let s="",Z="";for(let D=q;D<O.length-q&&(Z=String.fromCharCode(O[D]),"\n"!=Z);D++)s+=Z;return s}function y(O){let q=0,s=0,Z=P(O,0);if("#"!=Z[0]||"?"!=Z[1])throw"Bad HDR Format.";let D=!1,B=!1,y=0;do{y+=Z.length+1,Z=P(O,y),"FORMAT=32-bit_rle_rgbe"==Z?B=!0:0==Z.length&&(D=!0)}while(!D);if(!B)throw"HDR Bad header format, unsupported FORMAT";y+=Z.length+1,Z=P(O,y);const o=/^-Y (.*) \+X (.*)$/g.exec(Z);if(!o||o.length<3)throw"HDR Bad header format, no size";if(s=parseInt(o[2]),q=parseInt(o[1]),s<8||s>32767)throw"HDR Bad header format, unsupported size";return y+=Z.length+1,{height:q,width:s,dataPosition:y}}function o(O,q){return function(O,q){let s=q.height;const Z=q.width;let D,P,y,o,h,n=q.dataPosition,r=0,j=0,f=0;const u=new ArrayBuffer(4*Z),c=new Uint8Array(u),W=new ArrayBuffer(q.width*q.height*4*3),m=new Float32Array(W);for(;s>0;){if(D=O[n++],P=O[n++],y=O[n++],o=O[n++],2!=D||2!=P||128&y||q.width<8||q.width>32767)return w(O,q);if((y<<8|o)!=Z)throw"HDR Bad header format, wrong scan line width";for(r=0,f=0;f<4;f++)for(j=(f+1)*Z;r<j;)if(D=O[n++],P=O[n++],D>128){if(h=D-128,0==h||h>j-r)throw"HDR Bad Format, bad scanline data (run)";for(;h-- >0;)c[r++]=P}else{if(h=D,0==h||h>j-r)throw"HDR Bad Format, bad scanline data (non-run)";if(c[r++]=P,--h>0)for(let q=0;q<h;q++)c[r++]=O[n++]}for(f=0;f<Z;f++)D=c[f],P=c[f+Z],y=c[f+2*Z],o=c[f+3*Z],B(m,D,P,y,o,(q.height-s)*Z*3+3*f);s--}return m}(O,q)}function w(O,q){let s=q.height;const Z=q.width;let D,P,y,o,w,h=q.dataPosition;const n=new ArrayBuffer(q.width*q.height*4*3),r=new Float32Array(n);for(;s>0;){for(w=0;w<q.width;w++)D=O[h++],P=O[h++],y=O[h++],o=O[h++],B(r,D,P,y,o,(q.height-s)*Z*3+3*w);s--}return r}D.FACE_LEFT=[new Z.n(-1,-1,-1),new Z.n(1,-1,-1),new Z.n(-1,1,-1),new Z.n(1,1,-1)],D.FACE_RIGHT=[new Z.n(1,-1,1),new Z.n(-1,-1,1),new Z.n(1,1,1),new Z.n(-1,1,1)],D.FACE_FRONT=[new Z.n(1,-1,-1),new Z.n(1,-1,1),new Z.n(1,1,-1),new Z.n(1,1,1)],D.FACE_BACK=[new Z.n(-1,-1,1),new Z.n(-1,-1,-1),new Z.n(-1,1,1),new Z.n(-1,1,-1)],D.FACE_DOWN=[new Z.n(1,1,-1),new Z.n(1,1,1),new Z.n(-1,1,-1),new Z.n(-1,1,1)],D.FACE_UP=[new Z.n(-1,-1,-1),new Z.n(-1,-1,1),new Z.n(1,-1,-1),new Z.n(1,-1,1)];class h{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(O,q,s){const Z=new Uint8Array(O.buffer,O.byteOffset,O.byteLength),D=y(Z),B=o(Z,D),P=D.width*D.height,w=new Float32Array(4*P);for(let y=0;y<P;y+=1)w[4*y]=B[3*y],w[4*y+1]=B[3*y+1],w[4*y+2]=B[3*y+2],w[4*y+3]=1;s(D.width,D.height,q.generateMipMaps,!1,(()=>{const O=q.getEngine();q.type=1,q.format=5,q._gammaSpace=!1,O._uploadDataToTextureDirectly(q,w)}))}}}}]);