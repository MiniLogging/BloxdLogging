"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10508:(M,E,b)=>{b.r(E),b.d(E,{_HDRTextureLoader:()=>T});var x=b(970);class k{static ConvertPanoramaToCubemap(M,E,b,x){let k=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!M)throw"ConvertPanoramaToCubemap: input cannot be null";if(M.length!=E*b*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(x,this.FACE_FRONT,M,E,b,k),back:this.CreateCubemapTexture(x,this.FACE_BACK,M,E,b,k),left:this.CreateCubemapTexture(x,this.FACE_LEFT,M,E,b,k),right:this.CreateCubemapTexture(x,this.FACE_RIGHT,M,E,b,k),up:this.CreateCubemapTexture(x,this.FACE_UP,M,E,b,k),down:this.CreateCubemapTexture(x,this.FACE_DOWN,M,E,b,k),size:x,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(M,E,b,x,k){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const g=new ArrayBuffer(M*M*4*3),n=new Float32Array(g),J=a?Math.max(1,Math.round(x/4/M)):1,u=1/J,T=u*u,V=E[1].Qc(E[0]).scale(u/M),I=E[3].Qc(E[2]).scale(u/M),t=1/M;let y=0;for(let B=0;B<M;B++)for(let a=0;a<J;a++){let a=E[0],g=E[2];for(let E=0;E<M;E++)for(let u=0;u<J;u++){const J=g.Qc(a).scale(y).add(a);J.normalize();const u=this.CalcProjectionSpherical(J,b,x,k);n[B*M*3+3*E+0]+=u.r*T,n[B*M*3+3*E+1]+=u.g*T,n[B*M*3+3*E+2]+=u.b*T,a=a.add(V),g=g.add(I)}y+=t*u}return n}static CalcProjectionSpherical(M,E,b,x){let k=Math.atan2(M.z,M.x);const a=Math.acos(M.y);for(;k<-Math.PI;)k+=2*Math.PI;for(;k>Math.PI;)k-=2*Math.PI;let g=k/Math.PI;const n=a/Math.PI;g=.5*g+.5;let J=Math.round(g*b);J<0?J=0:J>=b&&(J=b-1);let u=Math.round(n*x);u<0?u=0:u>=x&&(u=x-1);const T=x-u-1;return{r:E[T*b*3+3*J+0],g:E[T*b*3+3*J+1],b:E[T*b*3+3*J+2]}}}function a(M,E,b,x,k,a){k>0?(k=function(M,E){return E>1023?M*Math.pow(2,1023)*Math.pow(2,E-1023):E<-1074?M*Math.pow(2,-1074)*Math.pow(2,E+1074):M*Math.pow(2,E)}(1,k-136),M[a+0]=E*k,M[a+1]=b*k,M[a+2]=x*k):(M[a+0]=0,M[a+1]=0,M[a+2]=0)}function g(M,E){let b="",x="";for(let k=E;k<M.length-E&&(x=String.fromCharCode(M[k]),"\n"!=x);k++)b+=x;return b}function n(M){let E=0,b=0,x=g(M,0);if("#"!=x[0]||"?"!=x[1])throw"Bad HDR Format.";let k=!1,a=!1,n=0;do{n+=x.length+1,x=g(M,n),"FORMAT=32-bit_rle_rgbe"==x?a=!0:0==x.length&&(k=!0)}while(!k);if(!a)throw"HDR Bad header format, unsupported FORMAT";n+=x.length+1,x=g(M,n);const J=/^-Y (.*) \+X (.*)$/g.exec(x);if(!J||J.length<3)throw"HDR Bad header format, no size";if(b=parseInt(J[2]),E=parseInt(J[1]),b<8||b>32767)throw"HDR Bad header format, unsupported size";return n+=x.length+1,{height:E,width:b,dataPosition:n}}function J(M,E){return function(M,E){let b=E.height;const x=E.width;let k,g,n,J,T,V=E.dataPosition,I=0,t=0,y=0;const B=new ArrayBuffer(4*x),r=new Uint8Array(B),c=new ArrayBuffer(E.width*E.height*4*3),C=new Float32Array(c);for(;b>0;){if(k=M[V++],g=M[V++],n=M[V++],J=M[V++],2!=k||2!=g||128&n||E.width<8||E.width>32767)return u(M,E);if((n<<8|J)!=x)throw"HDR Bad header format, wrong scan line width";for(I=0,y=0;y<4;y++)for(t=(y+1)*x;I<t;)if(k=M[V++],g=M[V++],k>128){if(T=k-128,0==T||T>t-I)throw"HDR Bad Format, bad scanline data (run)";for(;T-- >0;)r[I++]=g}else{if(T=k,0==T||T>t-I)throw"HDR Bad Format, bad scanline data (non-run)";if(r[I++]=g,--T>0)for(let E=0;E<T;E++)r[I++]=M[V++]}for(y=0;y<x;y++)k=r[y],g=r[y+x],n=r[y+2*x],J=r[y+3*x],a(C,k,g,n,J,(E.height-b)*x*3+3*y);b--}return C}(M,E)}function u(M,E){let b=E.height;const x=E.width;let k,g,n,J,u,T=E.dataPosition;const V=new ArrayBuffer(E.width*E.height*4*3),I=new Float32Array(V);for(;b>0;){for(u=0;u<E.width;u++)k=M[T++],g=M[T++],n=M[T++],J=M[T++],a(I,k,g,n,J,(E.height-b)*x*3+3*u);b--}return I}k.FACE_LEFT=[new x.m(-1,-1,-1),new x.m(1,-1,-1),new x.m(-1,1,-1),new x.m(1,1,-1)],k.FACE_RIGHT=[new x.m(1,-1,1),new x.m(-1,-1,1),new x.m(1,1,1),new x.m(-1,1,1)],k.FACE_FRONT=[new x.m(1,-1,-1),new x.m(1,-1,1),new x.m(1,1,-1),new x.m(1,1,1)],k.FACE_BACK=[new x.m(-1,-1,1),new x.m(-1,-1,-1),new x.m(-1,1,1),new x.m(-1,1,-1)],k.FACE_DOWN=[new x.m(1,1,-1),new x.m(1,1,1),new x.m(-1,1,-1),new x.m(-1,1,1)],k.FACE_UP=[new x.m(-1,-1,-1),new x.m(-1,-1,1),new x.m(1,-1,-1),new x.m(1,-1,1)];class T{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(M,E,b){const x=new Uint8Array(M.buffer,M.byteOffset,M.byteLength),k=n(x),a=J(x,k),g=k.width*k.height,u=new Float32Array(4*g);for(let n=0;n<g;n+=1)u[4*n]=a[3*n],u[4*n+1]=a[3*n+1],u[4*n+2]=a[3*n+2],u[4*n+3]=1;b(k.width,k.height,E.generateMipMaps,!1,(()=>{const M=E.getEngine();E.type=1,E.format=5,E._gammaSpace=!1,M._uploadDataToTextureDirectly(E,u)}))}}}}]);