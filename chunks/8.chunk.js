"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10846:(x,O,Q)=>{Q.r(O),Q.d(O,{EXT_materials_diffuse_roughness:()=>DO,EXT_mesh_gpu_instancing:()=>ix,GLTF2Export:()=>ex,GLTFData:()=>C,KHR_draco_mesh_compression:()=>QO,KHR_lights_punctual:()=>lO,KHR_materials_anisotropy:()=>LO,KHR_materials_clearcoat:()=>NO,KHR_materials_diffuse_transmission:()=>MO,KHR_materials_dispersion:()=>gO,KHR_materials_emissive_strength:()=>RO,KHR_materials_ior:()=>qO,KHR_materials_iridescence:()=>kO,KHR_materials_sheen:()=>tO,KHR_materials_specular:()=>dO,KHR_materials_transmission:()=>AO,KHR_materials_unlit:()=>EO,KHR_materials_volume:()=>FO,KHR_texture_transform:()=>yO,OBJExport:()=>V,STLExport:()=>IO,USDZExportAsync:()=>OQ,_ConvertToGLTFPBRMetallicRoughness:()=>f,_SolveMetallic:()=>A,__IGLTFExporterExtension:()=>o});var X=Q(10849),Z=Q(10894),n=Q(11031);class V{static OBJ(x,O,Q,V){const o=[];let l=1,C=1;O&&(Q||(Q="mat"),o.push("mtllib "+Q+".mtl"));for(let U=0;U<x.length;U++){const Q=x[U],L=Q.name||`mesh${U}}`;o.push(`o ${L}`);let h=null;if(V){const x=Q.HV(!0);h=new X.c,x.invertToRef(h),Q.bakeTransformIntoVertices(x)}if(O){const x=Q.material;x&&o.push("usemtl "+x.id)}const N=Q.SV;if(!N){Z.g.Warn("No geometry is present on the mesh");continue}const a=N.getVerticesData("position"),K=N.getVerticesData("QQ"),M=N.getVerticesData("uv"),Y=N.pV();let g=0,v=0;if(!a||!Y){Z.g.Warn("There are no position vertices or indices on the mesh!");continue}const R=x[0].kx().useRightHandedSystem?1:-1;for(let x=0;x<a.length;x+=3)o.push("v "+a[x]*R+" "+a[x+1]+" "+a[x+2]),g++;if(null!=K)for(let x=0;x<K.length;x+=3)o.push("vn "+K[x]*R+" "+K[x+1]+" "+K[x+2]);if(null!=M)for(let x=0;x<M.length;x+=2)o.push("vt "+M[x]+" "+M[x+1]),v++;const s=["","",""],q=(Q.material||Q.kx().defaultMaterial)._getEffectiveOrientation(Q),[G,k]=q===n.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let x=0;x<Y.length;x+=3){const O=[String(Y[x]+l),String(Y[x+G]+l),String(Y[x+k]+l)],Q=[String(Y[x]+C),String(Y[x+G]+C),String(Y[x+k]+C)],X=O,Z=null!=M?Q:s,n=null!=K?O:s;o.push("f "+X[0]+"/"+Z[0]+"/"+n[0]+" "+X[1]+"/"+Z[1]+"/"+n[1]+" "+X[2]+"/"+Z[2]+"/"+n[2])}V&&h&&Q.bakeTransformIntoVertices(h),l+=g,C+=v}return o.join("\n")}static MTL(x){const O=[],Q=x.material;O.push("newmtl mat1"),O.push("  Ns "+Q.specularPower.toFixed(4)),O.push("  Ni 1.5000"),O.push("  d "+Q.alpha.toFixed(4)),O.push("  Tr 0.0000"),O.push("  Tf 1.0000 1.0000 1.0000"),O.push("  illum 2"),O.push("  Ka "+Q.ambientColor.r.toFixed(4)+" "+Q.ambientColor.g.toFixed(4)+" "+Q.ambientColor.b.toFixed(4)),O.push("  Kd "+Q.diffuseColor.r.toFixed(4)+" "+Q.diffuseColor.g.toFixed(4)+" "+Q.diffuseColor.b.toFixed(4)),O.push("  Ks "+Q.specularColor.r.toFixed(4)+" "+Q.specularColor.g.toFixed(4)+" "+Q.specularColor.b.toFixed(4)),O.push("  Ke "+Q.emissiveColor.r.toFixed(4)+" "+Q.emissiveColor.g.toFixed(4)+" "+Q.emissiveColor.b.toFixed(4));Q.ambientTexture&&O.push("  map_Ka "+Q.ambientTexture.name),Q.diffuseTexture&&O.push("  map_Kd "+Q.diffuseTexture.name),Q.specularTexture&&O.push("  map_Ks "+Q.specularTexture.name),Q.bumpTexture&&O.push("  map_bump -imfchan z "+Q.bumpTexture.name),Q.opacityTexture&&O.push("  map_d "+Q.opacityTexture.name);return O.join("\n")}}var o=0,l=Q(10934);class C{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const x in this.files){const O=this.files[x],Q=new Blob([O],{type:(0,l.i)(x)});Z.g.Download(Q,x)}}}var U=Q(11060),L=Q(11158),h=Q(11172),N=Q(11196),a=Q(11244),K=Q(10877),M=Q(11133),Y=Q(10889);const g=Y.HighestCommonFactor,v={...Y,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:g};var R=Q(11332),s=Q(11335),q=Q(11378),G=Q(11383),k=Q(11387);const J=1e-6,t=new M.d(.04,.04,.04),c=1024,d=M.d.White(),u=M.d.Black();function A(x,O,Q){if(O<t.r)return 0;const X=t.r,Z=x*Q/(1-t.r)+O-2*t.r,n=Z*Z-4*X*(t.r-O);return v.Clamp((-Z+Math.sqrt(n))/(2*X),0,1)}function f(x){const O=x.diffuseColor.toLinearSpace(x.kx().getEngine().useExactSrgbConversions).scale(.5),Q=x.alpha,Z=function(x){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new X.l(0,1),Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new X.l(0,.1),Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new X.l(0,.1),n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new X.l(1300,.1);return function(x,O,Q,X,Z){return(1-x)*(1-x)*(1-x)*O+3*(1-x)*(1-x)*x*Q+3*(1-x)*x*x*X+x*x*x*Z}(Math.pow(x/n.x,.333333),O.y,Q.y,Z.y,n.y)}(v.Clamp(x.specularPower,0,c));return{baseColorFactor:[O.r,O.g,O.b,Q],metallicFactor:0,roughnessFactor:Z}}function E(x,O){O.needAlphaBlending()?x.alphaMode="BLEND":O.needAlphaTesting()&&(x.alphaMode="MASK",x.alphaCutoff=O.alphaCutOff)}function z(x,O,Q){const X=new Uint8Array(x*O*4);for(let Z=0;Z<X.length;Z+=4)X[Z]=X[Z+1]=X[Z+2]=X[Z+3]=255;return q.b.CreateRGBATexture(X,x,O,Q)}function F(x){if(x instanceof Uint8Array){const O=x.length,Q=new Float32Array(x.length);for(let X=0;X<O;++X)Q[X]=x[X]/255;return Q}if(x instanceof Float32Array)return x;throw new Error("Unsupported pixel format!")}class b{constructor(x){this._exporter=x,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(x){return x?this._textureMap.get(x)??null:null}async exportStandardMaterialAsync(x,O,Q){const X=f(x),n={name:x.name};if(null==x.PV||x.PV||(x.twoSidedLighting||Z.g.Warn(x.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),n.doubleSided=!0),Q){const Q=[],Z=x.diffuseTexture;Z&&Q.push(this.exportTextureAsync(Z,O).then((x=>{x&&(X.baseColorTexture=x)})));const V=x.bumpTexture;V&&Q.push(this.exportTextureAsync(V,O).then((x=>{x&&(n.normalTexture=x,1!==V.level&&(n.normalTexture.scale=V.level))})));const o=x.emissiveTexture;o&&(n.emissiveFactor=[1,1,1],Q.push(this.exportTextureAsync(o,O).then((x=>{x&&(n.emissiveTexture=x)}))));const l=x.ambientTexture;l&&Q.push(this.exportTextureAsync(l,O).then((x=>{if(x){const O={index:x.index};n.occlusionTexture=O}}))),Q.length>0&&(this._exporter._materialNeedsUVsSet.add(x),await Promise.all(Q))}(x.alpha<1||x.opacityTexture)&&(x.alphaMode===G.d.ALPHA_COMBINE?n.alphaMode="BLEND":Z.g.Warn(x.name+": glTF 2.0 does not support alpha mode: "+x.alphaMode.toString())),x.emissiveColor&&!x.emissiveColor.equalsWithEpsilon(u,J)&&(n.emissiveFactor=x.emissiveColor.mV()),n.pbrMetallicRoughness=X,E(n,x),await this._finishMaterialAsync(n,x,O);const V=this._exporter._materials;return V.push(n),V.length-1}async _finishMaterialAsync(x,O,Q){const X=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",x,O),Z=[];for(const n of X)Z.push(this.exportTextureAsync(n,Q));await Promise.all(Z),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",x,O)}async _getImageDataAsync(x,O,X,Z){const n=G.d.TEXTURETYPE_UNSIGNED_BYTE,V=this._exporter._babylonScene,o=V.getEngine(),l=o.createRawTexture(x,O,X,G.d.TEXTUREFORMAT_RGBA,!1,!0,s.b.NEAREST_SAMPLINGMODE,null,n);o.isWebGPU?await Q.e(36).then(Q.bind(Q,13489)):await Q.e(37).then(Q.bind(Q,13497)),await R.k.ApplyPostProcess("pass",l,V,n,G.d.TEXTURE_NEAREST_SAMPLINGMODE,G.d.TEXTUREFORMAT_RGBA);const C=await o._readTexturePixels(l,O,X);return await k.DumpTools.DumpDataAsync(O,X,C,Z,void 0,!0,!0)}_resizeTexturesToSameDimensions(x,O,Q){const X=x?x.getSize():{width:0,height:0},Z=O?O.getSize():{width:0,height:0};let n,V;return X.width<Z.width?(n=x&&x instanceof s.b?R.k.CreateResizedCopy(x,Z.width,Z.height,!0):z(Z.width,Z.height,Q),V=O):X.width>Z.width?(V=O&&O instanceof s.b?R.k.CreateResizedCopy(O,X.width,X.height,!0):z(X.width,X.height,Q),n=x):(n=x,V=O),{texture1:n,texture2:V}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(x,O,Q,X){const Z=new Array;if(!x&&!O)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const n=x?x.kx():O?O.kx():null;if(n){var V;const o=this._resizeTexturesToSameDimensions(x,O,n),l=null===(V=o.texture1)||void 0===V?void 0:V.getSize();let C,U;const L=l.width,h=l.height,N=await o.texture1.readPixels(),a=await o.texture2.readPixels();if(!N)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(C=F(N),!a)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");U=F(a);const K=U.byteLength,Y=new Uint8Array(K),g=new Uint8Array(K),v=4,R=u;let s=0,q=0;for(let x=0;x<h;++x)for(let O=0;O<L;++O){const X=(L*x+O)*v,Z={diffuseColor:new M.d(C[X],C[X+1],C[X+2]).toLinearSpace(n.getEngine().useExactSrgbConversions).multiply(Q.diffuseColor),specularColor:new M.d(U[X],U[X+1],U[X+2]).toLinearSpace(n.getEngine().useExactSrgbConversions).multiply(Q.specularColor),glossiness:U[X+3]*Q.glossiness},V=this._convertSpecularGlossinessToMetallicRoughness(Z);R.r=Math.max(R.r,V.baseColor.r),R.g=Math.max(R.g,V.baseColor.g),R.b=Math.max(R.b,V.baseColor.b),s=Math.max(s,V.metallic),q=Math.max(q,V.roughness),g[X]=255*V.baseColor.r,g[X+1]=255*V.baseColor.g,g[X+2]=255*V.baseColor.b,g[X+3]=o.texture1.wV?255*C[X+3]:255,Y[X]=0,Y[X+1]=255*V.roughness,Y[X+2]=255*V.metallic,Y[X+3]=255}const G={baseColor:R,metallic:s,roughness:q};let k=!1,t=!1;for(let x=0;x<h;++x)for(let O=0;O<L;++O){const Q=(L*x+O)*v;g[Q]/=G.baseColor.r>J?G.baseColor.r:1,g[Q+1]/=G.baseColor.g>J?G.baseColor.g:1,g[Q+2]/=G.baseColor.b>J?G.baseColor.b:1;const X=M.d.FromInts(g[Q],g[Q+1],g[Q+2]).toGammaSpace(n.getEngine().useExactSrgbConversions);g[Q]=255*X.r,g[Q+1]=255*X.g,g[Q+2]=255*X.b,X.equalsWithEpsilon(d,J)||(t=!0),Y[Q+1]/=G.roughness>J?G.roughness:1,Y[Q+2]/=G.metallic>J?G.metallic:1;M.d.FromInts(255,Y[Q+1],Y[Q+2]).equalsWithEpsilon(d,J)||(k=!0)}return k&&Z.push(this._getImageDataAsync(Y,L,h,X).then((x=>{G.metallicRoughnessTextureData=x}))),t&&Z.push(this._getImageDataAsync(g,L,h,X).then((x=>{G.baseColorTextureData=x}))),await Promise.all(Z).then((()=>G))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(x){const O=this._getPerceivedBrightness(x.diffuseColor),Q=this._getPerceivedBrightness(x.specularColor),X=1-this._getMaxComponent(x.specularColor),Z=A(O,Q,X),n=x.diffuseColor.scale(X/(1-t.r)/Math.max(1-Z)),V=x.specularColor.hQ(t.scale(1-Z)).scale(1/Math.max(Z));let o=M.d.Lerp(n,V,Z*Z);o=o.clampToRef(0,1,o);return{baseColor:o,metallic:Z,roughness:1-x.glossiness}}_getPerceivedBrightness(x){return x?Math.sqrt(.299*x.r*x.r+.587*x.g*x.g+.114*x.b*x.b):0}_getMaxComponent(x){return x?Math.max(x.r,Math.max(x.g,x.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(x,O,Q,X){const Z=[],n={baseColor:x._albedoColor,metallic:x._metallic,roughness:x._roughness};if(X){x._albedoTexture&&Z.push(this.exportTextureAsync(x._albedoTexture,O).then((x=>{x&&(Q.baseColorTexture=x)})));const X=x._metallicTexture;X&&Z.push(this.exportTextureAsync(X,O).then((x=>{x&&(Q.metallicRoughnessTexture=x)})))}return Z.length>0&&(this._exporter._materialNeedsUVsSet.add(x),await Promise.all(Z)),n}_getTextureSampler(x){const O={};if(!x||!(x instanceof s.b))return O;const Q=this._getGLTFTextureWrapMode(x.wrapU);10497!==Q&&(O.wrapS=Q);const X=this._getGLTFTextureWrapMode(x.wrapV);switch(10497!==X&&(O.wrapT=X),x.samplingMode){case s.b.LINEAR_LINEAR:O.magFilter=9729,O.minFilter=9729;break;case s.b.LINEAR_NEAREST:O.magFilter=9729,O.minFilter=9728;break;case s.b.NEAREST_LINEAR:O.magFilter=9728,O.minFilter=9729;break;case s.b.NEAREST_LINEAR_MIPLINEAR:O.magFilter=9728,O.minFilter=9987;break;case s.b.NEAREST_NEAREST:O.magFilter=9728,O.minFilter=9728;break;case s.b.NEAREST_LINEAR_MIPNEAREST:O.magFilter=9728,O.minFilter=9985;break;case s.b.LINEAR_NEAREST_MIPNEAREST:O.magFilter=9729,O.minFilter=9984;break;case s.b.LINEAR_NEAREST_MIPLINEAR:O.magFilter=9729,O.minFilter=9986;break;case s.b.NEAREST_NEAREST_MIPLINEAR:O.magFilter=9728,O.minFilter=9986;break;case s.b.LINEAR_LINEAR_MIPLINEAR:O.magFilter=9729,O.minFilter=9987;break;case s.b.LINEAR_LINEAR_MIPNEAREST:O.magFilter=9729,O.minFilter=9985;break;case s.b.NEAREST_NEAREST_MIPNEAREST:O.magFilter=9728,O.minFilter=9984}return O}_getGLTFTextureWrapMode(x){switch(x){case s.b.WRAP_ADDRESSMODE:return 10497;case s.b.CLAMP_ADDRESSMODE:return 33071;case s.b.MIRROR_ADDRESSMODE:return 33648;default:return Z.g.Error(`Unsupported Texture Wrap Mode ${x}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(x,O,Q,X){const Z={diffuseColor:x._albedoColor,specularColor:x._reflectivityColor,glossiness:x._microSurface},n=x._albedoTexture,V=x._reflectivityTexture,o=x._useMicroSurfaceFromReflectivityMapAlpha;if(V&&!o)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((n||V)&&X){this._exporter._materialNeedsUVsSet.add(x);const X=this._exportTextureSampler(n||V),o=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(n,V,Z,O),l=this._exporter._textures;if(o.baseColorTextureData){const x=this._exportImage(`baseColor${l.length}`,O,o.baseColorTextureData);Q.baseColorTexture=this._exportTextureInfo(x,X,null===n||void 0===n?void 0:n.coordinatesIndex)}if(o.metallicRoughnessTextureData){const x=this._exportImage(`metallicRoughness${l.length}`,O,o.metallicRoughnessTextureData);Q.metallicRoughnessTexture=this._exportTextureInfo(x,X,null===V||void 0===V?void 0:V.coordinatesIndex)}return o}return this._convertSpecularGlossinessToMetallicRoughness(Z)}async exportPBRMaterialAsync(x,O,Q){const X={},Z={name:x.name},n=x.isMetallicWorkflow();if(n){const O=x._albedoColor,Q=x.alpha;O&&(X.baseColorFactor=[O.r,O.g,O.b,Q])}const V=n?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(x,O,X,Q):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(x,O,X,Q);await this._setMetallicRoughnessPbrMaterialAsync(V,x,Z,X,O,Q),await this._finishMaterialAsync(Z,x,O);const o=this._exporter._materials;return o.push(Z),o.length-1}async _setMetallicRoughnessPbrMaterialAsync(x,O,Q,X,n,V){if(E(Q,O),x.baseColor.equalsWithEpsilon(d,J)&&v.WithinEpsilon(O.alpha,1,J)||(X.baseColorFactor=[x.baseColor.r,x.baseColor.g,x.baseColor.b,O.alpha]),null!=x.metallic&&1!==x.metallic&&(X.metallicFactor=x.metallic),null!=x.roughness&&1!==x.roughness&&(X.roughnessFactor=x.roughness),null==O.PV||O.PV||(O._twoSidedLighting||Z.g.Warn(O.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Q.doubleSided=!0),V){const x=[],X=O._bumpTexture;X&&x.push(this.exportTextureAsync(X,n).then((x=>{x&&(Q.normalTexture=x,1!==X.level&&(Q.normalTexture.scale=X.level))})));const Z=O._ambientTexture;Z&&x.push(this.exportTextureAsync(Z,n).then((x=>{if(x){const X={index:x.index,texCoord:x.texCoord,extensions:x.extensions};Q.occlusionTexture=X;const Z=O._ambientTextureStrength;Z&&(X.strength=Z)}})));const V=O._emissiveTexture;V&&x.push(this.exportTextureAsync(V,n).then((x=>{x&&(Q.emissiveTexture=x)}))),x.length>0&&(this._exporter._materialNeedsUVsSet.add(O),await Promise.all(x))}const o=O._emissiveColor;o.equalsWithEpsilon(u,J)||(Q.emissiveFactor=o.mV()),Q.pbrMetallicRoughness=X}_getPixelsFromTextureAsync(x){return function(x){switch(x){case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case G.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case G.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case G.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case G.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(x.textureFormat)?(0,R.g)(x,x._texture.width,x._texture.height):(x.textureType,G.d.TEXTURETYPE_UNSIGNED_BYTE,x.readPixels())}async exportTextureAsync(x,O){const Q=this._exporter._extensionsPreExportTextureAsync("exporter",x,O);return Q?await Q.then((async Q=>Q?await this._exportTextureInfoAsync(Q,O):await this._exportTextureInfoAsync(x,O))):await this._exportTextureInfoAsync(x,O)}async _exportTextureInfoAsync(x,O){let Q=this._textureMap.get(x);if(!Q){const X=await this._getPixelsFromTextureAsync(x);if(!X)return null;const n=this._exportTextureSampler(x),V=x.mimeType;if(V)switch(V){case"image/jpeg":case"image/png":case"image/webp":O=V;break;default:Z.g.Warn(`Unsupported media type: ${V}. Exporting texture as PNG.`)}const o=this._internalTextureToImage,l=x.getInternalTexture().uniqueId;o[l]||(o[l]={});let C=o[l][O];if(void 0===C){const Q=x.getSize();C=(async()=>{const Z=await this._getImageDataAsync(X,Q.width,Q.height,O);return this._exportImage(x.name,O,Z)})(),o[l][O]=C}Q=this._exportTextureInfo(await C,n,x.coordinatesIndex),this._textureMap.set(x,Q),this._exporter._extensionsPostExportTextures("exporter",Q,x)}return Q}_exportImage(x,O,Q){const X=this._exporter._images;let n;if(this._exporter._shouldUseGlb){n={name:x,mimeType:O,bufferView:void 0};const X=this._exporter._bufferManager.createBufferView(new Uint8Array(Q));this._exporter._bufferManager.setBufferView(n,X)}else{const V=x.replace(/\.\/|\/|\.\\|\\/g,"_"),o=function(x){switch(x){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(O);let l=V+o;X.some((x=>x.uri===l))&&(l=`${V}_${Z.g.RandomId()}${o}`),n={name:x,uri:l},this._exporter._imageData[l]={data:Q,mimeType:O}}return X.push(n),X.length-1}_exportTextureInfo(x,O,Q){const X=this._exporter._textures;let Z=X.findIndex((Q=>Q.sampler==O&&Q.source===x));-1===Z&&(Z=X.length,X.push({source:x,sampler:O}));const n={index:Z};return Q&&(n.texCoord=Q),n}_exportTextureSampler(x){const O=this._getTextureSampler(x),Q=this._exporter._samplers,X=Q.findIndex((x=>x.minFilter===O.minFilter&&x.magFilter===O.magFilter&&x.wrapS===O.wrapS&&x.wrapT===O.wrapT));return-1!==X?X:(Q.push(O),Q.length-1)}}var D=Q(11077),W=Q(10905),y=Q(11396),I=Q(10853);const r=X.n.Zero(),j=X.g.Identity(),T=X.n.One(),e=new X.n(-1,1,1);function B(x,O){const{byteOffset:Q,byteStride:X,type:Z,normalized:n}=x,V=x.getSize(),o=O.reduce(((x,O)=>O.getTotalVertices()>x?O.getTotalVertices():x),-Number.MAX_VALUE);return{byteOffset:Q,byteStride:X,componentCount:V,type:Z,count:o*V,normalized:n,totalVertices:o,kind:x.getKind()}}function i(x){switch(x){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function H(x){switch(x){case U.g.PositionKind:case U.g.NormalKind:case U.g.TangentKind:case U.g.ColorKind:case U.g.MatricesIndicesKind:case U.g.MatricesIndicesExtraKind:case U.g.MatricesWeightsKind:case U.g.MatricesWeightsExtraKind:case U.g.UVKind:case U.g.UV2Kind:case U.g.UV3Kind:case U.g.UV4Kind:case U.g.UV5Kind:case U.g.UV6Kind:return!0}return!1}function S(x){switch(x){case n.e.TriangleFillMode:return 4;case n.e.TriangleStripDrawMode:return 5;case n.e.TriangleFanDrawMode:return 6;case n.e.PointListDrawMode:case n.e.PointFillMode:return 0;case n.e.LineLoopDrawMode:return 2;case n.e.LineListDrawMode:return 1;case n.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${x}`)}function p(x){const O=Math.sqrt(x.x*x.x+x.y*x.y+x.z*x.z);O>0&&(x.x/=O,x.y/=O,x.z/=O)}function P(x){return x.x*=-1,x}function m(x){if(x.x*x.x+x.y*x.y>.5){const O=Math.abs(x.x),Q=Math.abs(x.y);if(O>Q){const Q=Math.sign(x.x);x.x=O,x.y*=-Q,x.z*=-Q,x.w*=Q}else{const O=Math.sign(x.y);x.x*=-O,x.y=Q,x.z*=O,x.w*=-O}}else{const O=Math.abs(x.z),Q=Math.abs(x.w);if(O>Q){const Q=Math.sign(x.z);x.x*=-Q,x.y*=Q,x.z=O,x.w*=-Q}else{const O=Math.sign(x.w);x.x*=O,x.y*=-O,x.z*=-O,x.w=Q}}return x}function w(x){x.xo(-x.z,x.w,x.x,-x.y)}function xx(x,O){const Q=X.n.FromArrayToRef(O.translation||[0,0,0],0,X.j.Oo[0]),Z=X.g.FromArrayToRef(O.rotation||[0,0,0,1],0,X.j.Quaternion[0]),n=X.c.ComposeToRef(T,Z,Q,X.j.Matrix[0]),V=X.n.FromArrayToRef(x.translation||[0,0,0],0,X.j.Oo[2]),o=X.g.FromArrayToRef(x.rotation||[0,0,0,1],0,X.j.Quaternion[1]),l=X.c.ComposeToRef(T,o,V,X.j.Matrix[1]);n.multiplyToRef(l,l),l.decompose(void 0,Z,Q),Q.equalsWithEpsilon(r,I.e)?delete O.translation:O.translation=Q.mV(),Z.equalsWithEpsilon(j,I.e)?delete O.rotation:O.rotation=Z.mV(),O.scale&&delete O.scale}function Ox(x,O){if(!(O instanceof L.c))return!1;if(!(1===O.getChildren().length&&0===x.getChildren().length&&x.parent===O))return!1;const Q=x.kx(),X=x instanceof y.c&&!Q.useRightHandedSystem?e:T;return!!O.Qo.equalsWithEpsilon(X,I.e)||(W.e.Warn(`Cannot collapse node ${x.name} into parent node ${O.name} with modified scaling.`),!1)}function Qx(x){if(x instanceof Array){const O=new Float32Array(x);return new Uint8Array(O.buffer,O.byteOffset,O.byteLength)}return ArrayBuffer.isView(x)?new Uint8Array(x.buffer,x.byteOffset,x.byteLength):new Uint8Array(x)}function Xx(x,O){for(const[Q,X]of Object.entries(x)){const Z=O[Q];(Array.isArray(X)&&Array.isArray(Z)&&Zx(X,Z)||X===Z)&&delete x[Q]}return x}function Zx(x,O){return x.length===O.length&&x.every(((x,Q)=>x===O[Q]))}const nx=X.c.Compose(new X.n(-1,1,1),X.g.Identity(),X.n.Zero());function Vx(x,O){if(!(x instanceof L.c))return!1;if(O){if(!x.getWorldMatrix().equalsWithEpsilon(X.c.IdentityReadOnly,I.e))return!1}else{if(!x.getWorldMatrix().multiplyToRef(nx,X.j.Matrix[0]).equalsWithEpsilon(X.c.IdentityReadOnly,I.e))return!1}return!(x instanceof h.c&&x.SV)}const ox=new Map([[Int8Array,(x,O,Q)=>x.setInt8(O,Q)],[Uint8Array,(x,O,Q)=>x.setUint8(O,Q)],[Uint8ClampedArray,(x,O,Q)=>x.setUint8(O,Q)],[Int16Array,(x,O,Q)=>x.setInt16(O,Q,!0)],[Uint16Array,(x,O,Q)=>x.setUint16(O,Q,!0)],[Int32Array,(x,O,Q)=>x.setInt32(O,Q,!0)],[Uint32Array,(x,O,Q)=>x.setUint32(O,Q,!0)],[Float32Array,(x,O,Q)=>x.setFloat32(O,Q,!0)],[Float64Array,(x,O,Q)=>x.setFloat64(O,Q,!0)]]);class lx{writeTypedArray(x){this._checkGrowBuffer(x.byteLength);const O=ox.get(x.constructor);for(let Q=0;Q<x.length;Q++)O(this._dataView,this._byteOffset,x[Q]),this._byteOffset+=x.BYTES_PER_ELEMENT}constructor(x){this._data=new Uint8Array(x),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(x){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,x),this._byteOffset++}writeInt8(x){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,x),this._byteOffset++}writeInt16(x){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,x,!0),this._byteOffset+=2}writeUInt16(x){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,x,!0),this._byteOffset+=2}writeInt32(x){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,x,!0),this._byteOffset+=4}writeUInt32(x){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,x,!0),this._byteOffset+=4}writeFloat32(x){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,x,!0),this._byteOffset+=4}writeFloat64(x){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,x,!0),this._byteOffset+=8}_checkGrowBuffer(x){const O=this.byteOffset+x;if(O>this._data.byteLength){const x=new Uint8Array(2*O);x.set(this._data),this._data=x,this._dataView=new DataView(this._data.buffer)}}}function Cx(x){return x%4===0?4:x%2===0?2:1}class Ux{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(x){let O=0;this._bufferViewToData.forEach((x=>{O+=x.byteLength}));const Q=new lx(O),X=Array.from(this._bufferViewToData.keys()).sort(((x,O)=>Cx(O.byteLength)-Cx(x.byteLength)));for(const Z of X){Z.byteOffset=Q.byteOffset,x.push(Z);const O=x.length-1,X=this.getPropertiesWithBufferView(Z);for(const x of X)x.bufferView=O;Q.writeTypedArray(this._bufferViewToData.get(Z)),this._bufferViewToData.delete(Z)}return Q.getOutputData()}createBufferView(x,O){const Q={buffer:0,byteOffset:void 0,byteLength:x.byteLength,byteStride:O};return this._bufferViewToData.set(Q,x),Q}createAccessor(x,O,Q,X,Z,n,V){this._verifyBufferView(x);const o={bufferView:void 0,componentType:Q,count:X,type:O,min:null===n||void 0===n?void 0:n.min,max:null===n||void 0===n?void 0:n.max,normalized:V,byteOffset:Z};return this.setBufferView(o,x),this._accessorToBufferView.set(o,x),o}setBufferView(x,O){this._verifyBufferView(O);this.getPropertiesWithBufferView(O).push(x)}removeBufferView(x){const O=this.getPropertiesWithBufferView(x);for(const Q of O)void 0!==Q.bufferView&&delete Q.bufferView;this._bufferViewToData.delete(x),this._bufferViewToProperties.delete(x),this._accessorToBufferView.forEach(((O,Q)=>{O===x&&(void 0!==Q.byteOffset&&delete Q.byteOffset,this._accessorToBufferView.delete(Q))}))}getBufferView(x){const O=this._accessorToBufferView.get(x);return this._verifyBufferView(O),O}getPropertiesWithBufferView(x){return this._verifyBufferView(x),this._bufferViewToProperties.set(x,this._bufferViewToProperties.get(x)??[]),this._bufferViewToProperties.get(x)}getData(x){return this._verifyBufferView(x),this._bufferViewToData.get(x)}_verifyBufferView(x){if(void 0===x||!this._bufferViewToData.has(x))throw new Error(`BufferView ${x} not found in BufferManager.`)}}var Lx,hx=Q(11206),Nx=Q(11235),ax=Q(11398),Kx=Q(11530),Mx=Q(11538),Yx=Q(11553),gx=Q(11201),vx=Q(11558);!function(x){x[x.INTANGENT=0]="INTANGENT",x[x.OUTTANGENT=1]="OUTTANGENT"}(Lx||(Lx={}));class Rx{static _IsTransformable(x){return x&&(x instanceof L.c||x instanceof hx.e||x instanceof vx.c)}static _CreateNodeAnimation(x,O,Q,X,n){if(this._IsTransformable(x)){const V=[],o=[],l=O.getKeys(),C=Rx._CalculateMinMaxKeyFrames(l),U=Rx._DeduceInterpolation(l,Q,X),L=U.interpolationType,h=U.shouldBakeAnimation;if(h?Rx._CreateBakedAnimation(x,O,Q,C.min,C.max,O.framePerSecond,n,V,o,C,X):"LINEAR"===L||"STEP"===L?Rx._CreateLinearOrStepAnimation(x,O,Q,V,o,X):"CUBICSPLINE"===L?Rx._CreateCubicSplineAnimation(x,O,Q,V,o,X):Rx._CreateBakedAnimation(x,O,Q,C.min,C.max,O.framePerSecond,n,V,o,C,X),V.length&&o.length){return{inputs:V,outputs:o,samplerInterpolation:L,inputsMin:h?C.min:Z.g.FloatRound(C.min/O.framePerSecond),inputsMax:h?C.max:Z.g.FloatRound(C.max/O.framePerSecond)}}}return null}static _DeduceAnimationInfo(x){let O=null,Q="VEC3",X=!1;const n=x.targetProperty.split(".");switch(n[0]){case"Qo":O="scale";break;case"position":O="translation";break;case"rotation":Q="VEC4",O="rotation";break;case"rotationQuaternion":Q="VEC4",X=!0,O="rotation";break;case"influence":Q="SCALAR",O="weights";break;default:Z.g.Error(`Unsupported animatable property ${n[0]}`)}return O?{animationChannelTargetPath:O,dataAccessorType:Q,useQuaternion:X}:(Z.g.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(x,O,Q,X,Z,n,V,o,l,C,U){let L;if(Rx._IsTransformable(x)&&x.animations)for(const h of x.animations){if(U&&!U(h))continue;const Z=Rx._DeduceAnimationInfo(h);Z&&(L={name:h.name,samplers:[],channels:[]},Rx._AddAnimation(`${h.name}`,h.hasRunningRuntimeAnimations?O:L,x,h,Z.dataAccessorType,Z.animationChannelTargetPath,X,n,V,o,Z.useQuaternion,l,C),L.samplers.length&&L.channels.length&&Q.push(L))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(x,O,Q,X,Z,n,V,o,l,C,U){let L;if(x instanceof gx.b){const Z=x.morphTargetManager;if(Z)for(let h=0;h<Z.numTargets;++h){const N=Z.getTarget(h);for(const a of N.animations){if(U&&!U(a))continue;const N=new Mx.b(`${a.name}`,"influence",a.framePerSecond,a.dataType,a.loopMode,a.enableBlending),K=[],M=a.getKeys();for(let x=0;x<M.length;++x){const O=M[x];for(let x=0;x<Z.numTargets;++x)x==h?K.push(O):K.push({frame:O.frame,value:0})}N.setKeys(K);const Y=Rx._DeduceAnimationInfo(N);Y&&(L={name:N.name,samplers:[],channels:[]},Rx._AddAnimation(a.name,a.hasRunningRuntimeAnimations?O:L,x,N,Y.dataAccessorType,Y.animationChannelTargetPath,X,n,V,o,Y.useQuaternion,l,C,Z.numTargets),L.samplers.length&&L.channels.length&&Q.push(L))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(x,O,Q,X,Z,n,V,o,l){let C;if(x.animationGroups){const L=x.animationGroups;for(const h of L){const L=new Map,N=new Map,a=new Set,K=h.to-h.from;C={name:h.name,channels:[],samplers:[]};for(let O=0;O<h.targetedAnimations.length;++O){const K=h.targetedAnimations[O],M=K.target,Y=K.animation;if(l&&!l(Y))continue;const g=o.has(M);if(this._IsTransformable(M)||1===M.length&&this._IsTransformable(M[0])){const x=Rx._DeduceAnimationInfo(K.animation);if(x){const O=this._IsTransformable(M)?M:this._IsTransformable(M[0])?M[0]:null;O&&Rx._AddAnimation(`${Y.name}`,C,O,Y,x.dataAccessorType,x.animationChannelTargetPath,Q,X,Z,n,x.useQuaternion,V,g)}}else if(M instanceof Yx.e||1===M.length&&M[0]instanceof Yx.e){if(Rx._DeduceAnimationInfo(K.animation)){const O=M instanceof Yx.e?M:M[0];if(O){const Q=x.morphTargetManagers.find((x=>{for(let Q=0;Q<x.numTargets;++Q)if(x.getTarget(Q)===O)return!0;return!1}));if(Q){const X=x.meshes.find((x=>x.morphTargetManager===Q));var U;if(X)L.has(X)||L.set(X,new Map),null===(U=L.get(X))||void 0===U||U.set(O,Y),a.add(X),N.set(X,Y)}}}}}a.forEach((x=>{const O=x.morphTargetManager;let o=null;const l=[],U=N.get(x).getKeys(),a=U.length;for(let Q=0;Q<a;++Q)for(let X=0;X<O.numTargets;++X){const Z=O.getTarget(X),n=L.get(x);if(n){const O=n.get(Z);O?(o||(o=new Mx.b(`${h.name}_${x.name}_MorphWeightAnimation`,"influence",O.framePerSecond,Mx.b.ANIMATIONTYPE_FLOAT,O.loopMode,O.enableBlending)),l.push(O.getKeys()[Q])):l.push({frame:h.from+K/a*Q,value:Z.influence,inTangent:U[0].inTangent?0:void 0,outTangent:U[0].outTangent?0:void 0})}}o.setKeys(l);const M=Rx._DeduceAnimationInfo(o);M&&Rx._AddAnimation(`${h.name}_${x.name}_MorphWeightAnimation`,C,x,o,M.dataAccessorType,M.animationChannelTargetPath,Q,X,Z,n,M.useQuaternion,V,!1,null===O||void 0===O?void 0:O.numTargets)})),C.channels.length&&C.samplers.length&&O.push(C)}}}static _AddAnimation(x,O,Q,Z,n,V,o,l,C,U,L,h,N,a){const K=Rx._CreateNodeAnimation(Q,Z,V,L,h);let M,Y,g,v,R,s;if(K){if(a){let x=0,O=0;const Q=[];for(;K.inputs.length>0;)O=K.inputs.shift(),x%a==0&&Q.push(O),x++;K.inputs=Q}const x=o.get(Q),Z=new Float32Array(K.inputs);M=l.createBufferView(Z),Y=l.createAccessor(M,"SCALAR",5126,K.inputs.length,void 0,{min:[K.inputsMin],max:[K.inputsMax]}),U.push(Y),g=U.length-1;const C=new X.g,L=new X.n,h=new X.n,q=Q instanceof hx.e,G=i(n),k=new Float32Array(K.outputs.length*G);K.outputs.forEach((function(x,O){let Q=x;switch(V){case"translation":N&&(X.n.FromArrayToRef(x,0,h),P(h),h.toArray(Q));break;case"rotation":4===x.length?X.g.FromArrayToRef(x,0,C):(Q=new Array(4),X.n.FromArrayToRef(x,0,L),X.g.FromEulerVectorToRef(L,C)),N&&(m(C),q&&w(C)),C.toArray(Q)}k.set(Q,O*G)})),M=l.createBufferView(k),Y=l.createAccessor(M,n,5126,K.outputs.length),U.push(Y),v=U.length-1,R={interpolation:K.samplerInterpolation,input:g,output:v},O.samplers.push(R),s={sampler:O.samplers.length-1,target:{node:x,path:V}},O.channels.push(s)}}static _CreateBakedAnimation(x,O,Q,n,V,o,l,C,U,L,h){let N;const a=X.g.Identity();let K,M=null,Y=null,g=null,v=null,R=null,s=null;L.min=Z.g.FloatRound(n/o);const q=O.getKeys();for(let X=0,G=q.length;X<G;++X){if(s=null,g=q[X],X+1<G)if(v=q[X+1],g.value.equals&&g.value.equals(v.value)||g.value===v.value){if(0!==X)continue;s=g.frame}else s=v.frame;else{if(R=q[X-1],g.value.equals&&g.value.equals(R.value)||g.value===R.value)continue;s=V}if(s)for(let X=g.frame;X<=s;X+=l){if(K=Z.g.FloatRound(X/o),K===M)continue;M=K,Y=K;const n={key:0,repeatCount:0,loopMode:O.loopMode};N=O._interpolate(X,n),Rx._SetInterpolatedValue(x,N,K,O,Q,a,C,U,h)}}Y&&(L.max=Y)}static _ConvertFactorToVector3OrQuaternion(x,O,Q,n,V){const o=Rx._GetBasePositionRotationOrScale(O,n,V),l=Q.targetProperty.split("."),C=l?l[1]:"",U=V?X.g.Xo(o).normalize():X.n.Xo(o);switch(C){case"x":case"y":case"z":U[C]=x;break;case"w":U.w=x;break;default:Z.g.Error(`glTFAnimation: Unsupported component name "${C}"!`)}return U}static _SetInterpolatedValue(x,O,Q,Z,n,V,o,l,C){let U;o.push(Q),"weights"!==n?(Z.dataType===Mx.b.ANIMATIONTYPE_FLOAT&&(O=this._ConvertFactorToVector3OrQuaternion(O,x,Z,n,C)),"rotation"===n?(C?V=O:(U=O,X.g.RotationYawPitchRollToRef(U.y,U.x,U.z,V)),l.push(V.mV())):(U=O,l.push(U.mV()))):l.push([O])}static _CreateLinearOrStepAnimation(x,O,Q,X,Z,n){for(const V of O.getKeys())X.push(V.frame/O.framePerSecond),Rx._AddKeyframeValue(V,O,Z,Q,x,n)}static _CreateCubicSplineAnimation(x,O,Q,X,Z,n){O.getKeys().forEach((function(V){X.push(V.frame/O.framePerSecond),Rx._AddSplineTangent(Lx.INTANGENT,Z,Q,"CUBICSPLINE",V,n),Rx._AddKeyframeValue(V,O,Z,Q,x,n),Rx._AddSplineTangent(Lx.OUTTANGENT,Z,Q,"CUBICSPLINE",V,n)}))}static _GetBasePositionRotationOrScale(x,O,Q){let Z;if("rotation"===O)if(Q){Z=(x.rotationQuaternion??X.g.Identity()).mV()}else{Z=(x.rotation??X.n.Zero()).mV()}else if("translation"===O){Z=(x.position??X.n.Zero()).mV()}else{Z=(x.Qo??X.n.One()).mV()}return Z}static _AddKeyframeValue(x,O,Q,n,V,o){let l;const C=O.dataType;if(C===Mx.b.ANIMATIONTYPE_VECTOR3){let O=x.value.mV();if("rotation"===n){const x=X.n.Xo(O);O=X.g.RotationYawPitchRoll(x.y,x.x,x.z).mV()}Q.push(O)}else if(C===Mx.b.ANIMATIONTYPE_FLOAT){if("weights"===n)Q.push([x.value]);else if(l=this._ConvertFactorToVector3OrQuaternion(x.value,V,O,n,o),l){if("rotation"===n){const x=o?l:X.g.RotationYawPitchRoll(l.y,l.x,l.z).normalize();Q.push(x.mV())}Q.push(l.mV())}}else C===Mx.b.ANIMATIONTYPE_QUATERNION?Q.push(x.value.normalize().mV()):Z.g.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(x,O,Q){let X,Z,n=!1;if("rotation"===O&&!Q)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let V=0,o=x.length;V<o;++V)if(Z=x[V],Z.inTangent||Z.outTangent)if(X){if("CUBICSPLINE"!==X){X="LINEAR",n=!0;break}}else X="CUBICSPLINE";else if(X){if("CUBICSPLINE"===X||Z.interpolation&&1===Z.interpolation&&"STEP"!==X){X="LINEAR",n=!0;break}}else X=Z.interpolation&&1===Z.interpolation?"STEP":"LINEAR";return X||(X="LINEAR"),{interpolationType:X,shouldBakeAnimation:n}}static _AddSplineTangent(x,O,Q,Z,n,V){let o;const l=x===Lx.INTANGENT?n.inTangent:n.outTangent;if("CUBICSPLINE"===Z){if("rotation"===Q)if(l)if(V)o=l.mV();else{const x=l;o=X.g.RotationYawPitchRoll(x.y,x.x,x.z).mV()}else o=[0,0,0,0];else o="weights"===Q?l?[l]:[0]:l?l.mV():[0,0,0];O.push(o)}}static _CalculateMinMaxKeyFrames(x){let O=1/0,Q=-1/0;return x.forEach((function(x){O=Math.min(O,x.frame),Q=Math.max(Q,x.frame)})),{min:O,max:Q}}}function sx(x,O,Q,n,V,o){const l={attributes:{},influence:x.influence,name:x.name},C=O.SV;if(!C)return Z.g.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),l;const L=o?-1:1,h=X.n.Zero();let N=0,a=0;if(x.hasPositions){const n=x.getPositions(),o=C.getVerticesData(U.g.PositionKind);if(o){const x=new Float32Array(o.length),O=[1/0,1/0,1/0],Z=[-1/0,-1/0,-1/0];a=o.length/3,N=0;for(let Q=N;Q<a;++Q){const V=X.n.Xo(o,3*Q);X.n.Xo(n,3*Q).subtractToRef(V,h),h.x*=L,O[0]=Math.min(O[0],h.x),Z[0]=Math.max(Z[0],h.x),O[1]=Math.min(O[1],h.y),Z[1]=Math.max(Z[1],h.y),O[2]=Math.min(O[2],h.z),Z[2]=Math.max(Z[2],h.z),x[3*Q]=h.x,x[3*Q+1]=h.y,x[3*Q+2]=h.z}const C=Q.createBufferView(x,12),U=Q.createAccessor(C,"VEC3",5126,n.length/3,0,{min:O,max:Z});V.push(U),l.attributes.POSITION=V.length-1}else Z.g.Warn(`Morph target positions for mesh ${O.name} were not exported. Mesh does not have position vertex data`)}if(x.hasNormals){const n=x.getNormals(),o=C.getVerticesData(U.g.NormalKind);if(o){const x=new Float32Array(o.length);a=o.length/3,N=0;for(let Q=N;Q<a;++Q){const O=X.n.Xo(o,3*Q).normalize();X.n.Xo(n,3*Q).normalize().subtractToRef(O,h),x[3*Q]=h.x*L,x[3*Q+1]=h.y,x[3*Q+2]=h.z}const O=Q.createBufferView(x,12),Z=Q.createAccessor(O,"VEC3",5126,n.length/3,0);V.push(Z),l.attributes.NORMAL=V.length-1}else Z.g.Warn(`Morph target normals for mesh ${O.name} were not exported. Mesh does not have normals vertex data`)}if(x.hasTangents){const n=x.getTangents(),o=C.getVerticesData(U.g.TangentKind);if(o){a=o.length/4;const x=new Float32Array(3*a);N=0;for(let Q=N;Q<a;++Q){const O=X.n.Xo(o,4*Q);p(O);const Z=X.n.Xo(n,3*Q);p(Z),Z.subtractToRef(O,h),x[3*Q]=h.x*L,x[3*Q+1]=h.y,x[3*Q+2]=h.z}const O=Q.createBufferView(x,12),Z=Q.createAccessor(O,"VEC3",5126,a,0);V.push(Z),l.attributes.TANGENT=V.length-1}else Z.g.Warn(`Morph target tangents for mesh ${O.name} were not exported. Mesh does not have tangents vertex data`)}if(x.hasColors){const n=x.getColors(),o=C.getVerticesData(U.g.ColorKind),L=C.getVertexBuffer(U.g.ColorKind);if(o&&L){const x=L.getSize();a=o.length/x;const O=new Float32Array(a*x);N=0;for(let Q=N;Q<a;++Q)if(3===x){const Z=X.n.Xo(o,Q*x);X.n.Xo(n,Q*x).subtractToRef(Z,h),O[3*Q]=h.x,O[3*Q+1]=h.y,O[3*Q+2]=h.z}else if(4===x){const Z=new X.o,V=X.o.Xo(o,Q*x);X.o.Xo(n,Q*x).subtractToRef(V,Z),O[4*Q]=Z.x,O[4*Q+1]=Z.y,O[4*Q+2]=Z.z,O[4*Q+3]=Z.w}else Z.g.Warn(`Unsupported number of components for color attribute: ${x}`);const C=Q.createBufferView(O,4*x),U=Q.createAccessor(C,3===x?"VEC3":"VEC4",5126,a,0);V.push(U),l.attributes.COLOR_0=V.length-1}else Z.g.Warn(`Morph target colors for mesh ${O.name} were not exported. Mesh does not have colors vertex data`)}return l}var qx=Q(11561),Gx=Q(11474),kx=Q(11466),Jx=Q(10866);class tx{}tx.DEFAULT_COLOR=M.d.White(),tx.DEFAULT_WIDTH_ATTENUATED=1,tx.DEFAULT_WIDTH=.1;var cx=Q(11315),dx=Q(11576);class ux{static ConvertPoints(x,O){if(x.length&&Array.isArray(x)&&"number"===typeof x[0])return[x];if(x.length&&Array.isArray(x[0])&&"number"===typeof x[0][0])return x;if(x.length&&!Array.isArray(x[0])&&x[0]instanceof X.n){const O=[];for(let Q=0;Q<x.length;Q++){const X=x[Q];O.push(X.x,X.y,X.z)}return[O]}if(x.length>0&&Array.isArray(x[0])&&x[0].length>0&&x[0][0]instanceof X.n){const O=[],Q=x;for(const x of Q)O.push(x.flatMap((x=>[x.x,x.y,x.z])));return O}if(x instanceof Float32Array){if(null!==O&&void 0!==O&&O.floatArrayStride){const Q=[],X=3*O.floatArrayStride;for(let O=0;O<x.length;O+=X){const Z=new Array(X);for(let Q=0;Q<X;Q++)Z[Q]=x[O+Q];Q.push(Z)}return Q}return[Array.from(x)]}if(x.length&&x[0]instanceof Float32Array){const O=[];for(const Q of x)O.push(Array.from(Q));return O}return[]}static OmitZeroLengthPredicate(x,O,Q){const X=[];return O.hQ(x).lengthSquared()>0&&X.push([x,O]),Q.hQ(O).lengthSquared()>0&&X.push([O,Q]),x.hQ(Q).lengthSquared()>0&&X.push([Q,x]),0===X.length?null:X}static OmitDuplicatesPredicate(x,O,Q,X){const Z=[];return ux._SearchInPoints(x,O,X)||Z.push([x,O]),ux._SearchInPoints(O,Q,X)||Z.push([O,Q]),ux._SearchInPoints(Q,x,X)||Z.push([Q,x]),0===Z.length?null:Z}static _SearchInPoints(x,O,Q){for(const V of Q)for(let Q=0;Q<V.length;Q++){var X,Z,n;if(null!==(X=V[Q])&&void 0!==X&&X.equals(x))if(null!==(Z=V[Q+1])&&void 0!==Z&&Z.equals(O)||null!==(n=V[Q-1])&&void 0!==n&&n.equals(O))return!0}return!1}static MeshesToLines(x,O){const Q=[];for(let Z=0;Z<x.length;Z++){const n=x[Z],V=n.getVerticesData(U.g.PositionKind),o=n.pV();if(V&&o)for(let x=0,l=0;x<o.length;x++){const C=3*o[l++],U=3*o[l++],L=3*o[l++],h=new X.n(V[C],V[C+1],V[C+2]),N=new X.n(V[U],V[U+1],V[U+2]),a=new X.n(V[L],V[L+1],V[L+2]);if(O){const X=O(h,N,a,Q,x,C,n,Z,V,o);if(X)for(const x of X)Q.push(x)}else Q.push([h,N],[N,a],[a,h])}}return Q}static ToVector3Array(x){if(Array.isArray(x[0])){const O=[],Q=x;for(const x of Q){const Q=[];for(let O=0;O<x.length;O+=3)Q.push(new X.n(x[O],x[O+1],x[O+2]));O.push(Q)}return O}const O=x,Q=[];for(let Z=0;Z<O.length;Z+=3)Q.push(new X.n(O[Z],O[Z+1],O[Z+2]));return Q}static ToNumberArray(x){return x.flatMap((x=>[x.x,x.y,x.z]))}static GetPointsCountInfo(x){const O=new Array(x.length);let Q=0;for(let X=x.length;X--;)O[X]=x[X].length/3,Q+=O[X];return{total:Q,counts:O}}static GetLineLength(x){if(0===x.length)return 0;let O;O="number"===typeof x[0]?ux.ToVector3Array(x):x;const Q=X.j.Oo[0];let Z=0;for(let X=0;X<O.length-1;X++){const x=O[X];Z+=O[X+1].subtractToRef(x,Q).length()}return Z}static GetLineLengthArray(x){const O=new Float32Array(x.length/3);let Q=0;for(let X=0,Z=x.length/3-1;X<Z;X++){let Z=x[3*X+0],n=x[3*X+1],V=x[3*X+2];Z-=x[3*X+3],n-=x[3*X+4],V-=x[3*X+5];Q+=Math.sqrt(Z*Z+n*n+V*V),O[X+1]=Q}return O}static SegmentizeSegmentByCount(x,O,Q){const Z=[],n=O.hQ(x),V=X.j.Oo[0];V.Zo(Q);const o=X.j.Oo[1];n.divideToRef(V,o);let l=x.clone();Z.push(l);for(let X=0;X<Q;X++)l=l.clone(),Z.push(l.addInPlace(o));return Z}static SegmentizeLineBySegmentLength(x,O){const Q=x[0]instanceof X.n?ux.GetLineSegments(x):"number"===typeof x[0]?ux.GetLineSegments(ux.ToVector3Array(x)):x,Z=[];for(const X of Q)if(X.length>O){const x=ux.SegmentizeSegmentByCount(X.point1,X.point2,Math.ceil(X.length/O));for(const O of x)Z.push(O)}else Z.push(X.point1),Z.push(X.point2);return Z}static SegmentizeLineBySegmentCount(x,O){const Q="number"===typeof x[0]?ux.ToVector3Array(x):x,X=ux.GetLineLength(Q)/O;return ux.SegmentizeLineBySegmentLength(Q,X)}static GetLineSegments(x){const O=[];for(let Q=0;Q<x.length-1;Q++){const X=x[Q],Z=x[Q+1],n=Z.hQ(X).length();O.push({point1:X,point2:Z,length:n})}return O}static GetMinMaxSegmentLength(x){const O=ux.GetLineSegments(x).sort((x=>x.length));return{min:O[0].length,max:O[O.length-1].length}}static GetPositionOnLineByVisibility(x,O,Q){let Z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const n=O*Q;let V=0,o=0;const l=x.length;for(let X=0;X<l;X++){if(n<=V+x[X].length){o=X;break}V+=x[X].length}const C=(n-V)/x[o].length;return x[o].point2.subtractToRef(x[o].point1,X.j.Oo[0]),X.j.Oo[1]=X.j.Oo[0].multiplyByFloats(C,C,C),Z||X.j.Oo[1].addInPlace(x[o].point1),X.j.Oo[1].clone()}static GetCircleLinePoints(x,O){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:x,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/O;const V=[];for(let o=0;o<=O;o++)V.push(new X.n(Math.cos(o*n)*x,Math.sin(o*n)*Z,Q));return V}static GetBezierLinePoints(x,O,Q,X){return cx.f.CreateQuadraticBezier(x,O,Q,X).getPoints().flatMap((x=>[x.x,x.y,x.z]))}static GetArrowCap(x,O,Q,X,Z){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,V=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[x.clone(),x.add(O.multiplyByFloats(Q,Q,Q))],widths:[X,Z,n,V]}}static GetPointsFromText(x,O,Q,X){let Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const V=[],o=(0,dx.b)(x,O,Q,X);for(const l of o){for(const x of l.paths){const O=[],Q=x.getPoints();for(const x of Q)O.push(x.x,x.y,Z);V.push(O)}if(n)for(const x of l.holes){const O=[],Q=x.getPoints();for(const x of Q)O.push(x.x,x.y,Z);V.push(O)}}return V}static Color3toRGBAUint8(x){const O=new Uint8Array(4*x.length);for(let Q=0,X=0;Q<x.length;Q++)O[X++]=255*x[Q].r,O[X++]=255*x[Q].g,O[X++]=255*x[Q].b,O[X++]=255;return O}static CreateColorsTexture(x,O,Q,X){const Z=X.getEngine().getCaps().maxTextureSize??1,n=O.length>Z?Z:O.length,V=Math.ceil(O.length/Z);V>1&&(O=[...O,...Array(n*V-O.length).fill(O[0])]);const o=ux.Color3toRGBAUint8(O),l=new q.b(o,n,V,a.b.TEXTUREFORMAT_RGBA,X,!1,!0,Q);return l.name=x,l}static PrepareEmptyColorsTexture(x){if(!tx.EmptyColorsTexture){const O=new Uint8Array(4);tx.EmptyColorsTexture=new q.b(O,1,1,a.b.TEXTUREFORMAT_RGBA,x,!1,!1,q.b.NEAREST_NEAREST),tx.EmptyColorsTexture.name="grlEmptyColorsTexture"}return tx.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var x;null===(x=tx.EmptyColorsTexture)||void 0===x||x.dispose(),tx.EmptyColorsTexture=null}static BooleanToNumber(x){return x?1:0}}class Ax extends kx.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class fx extends Gx.c{isCompatible(x){return!0}constructor(x,O,Q){var Z;Q=Q||{color:tx.DEFAULT_COLOR};const n=new Ax;n.GREASED_LINE_HAS_COLOR=!!Q.color&&!Q.useColors,n.GREASED_LINE_SIZE_ATTENUATION=Q.sizeAttenuation??!1,n.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===Q.colorDistributionType,n.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(O??x.kx()).useRightHandedSystem,n.GREASED_LINE_CAMERA_FACING=Q.cameraFacing??!0,super(x,fx.GREASED_LINE_MATERIAL_NAME,200,n,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(Z=Q)||void 0===Z?void 0:Z.forceGLSL)||fx.ForceGLSL,this._scene=O??x.kx(),this._engine=this._scene.getEngine(),this._cameraFacing=Q.cameraFacing??!0,this.visibility=Q.visibility??1,this.useDash=Q.useDash??!1,this.dashRatio=Q.dashRatio??.5,this.dashOffset=Q.dashOffset??0,this.width=Q.width?Q.width:Q.sizeAttenuation?tx.DEFAULT_WIDTH_ATTENUATED:tx.DEFAULT_WIDTH,this._sizeAttenuation=Q.sizeAttenuation??!1,this.colorMode=Q.colorMode??0,this._color=Q.color??null,this.useColors=Q.useColors??!1,this._colorsDistributionType=Q.colorDistributionType??0,this.colorsSampling=Q.colorsSampling??q.b.NEAREST_NEAREST,this._colors=Q.Ax??null,this.dashCount=Q.dashCount??1,this.resolution=Q.resolution??new X.l(this._engine.getRenderWidth(),this._engine.getRenderHeight()),Q.colorsTexture?this.colorsTexture=Q.colorsTexture:this._colors?this.colorsTexture=ux.CreateColorsTexture(`${x.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??tx.DEFAULT_COLOR,ux.PrepareEmptyColorsTexture(this._scene)),this._engine.no.add((()=>{ux.DisposeEmptyColorsTexture()}))}getAttributes(x){x.push("grl_offsets"),x.push("grl_widths"),x.push("grl_colorPointers"),x.push("grl_counters"),this._cameraFacing?(x.push("grl_previousAndSide"),x.push("grl_nextAndCounters")):x.push("grl_slopes")}getSamplers(x){x.push("grl_colors")}getActiveTextures(x){this.colorsTexture&&x.push(this.colorsTexture)}getUniforms(){let x=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const O=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&O.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===x&&O.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:O,vertex:this._cameraFacing&&this._isGLSL(x)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(x)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(x){if(this._cameraFacing){x.Vo("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||x.Vo("viewProjection",this._scene.getTransformMatrix());const O=X.j.Vector4[0];O.x=this._aspect,O.y=this._resolution.x,O.z=this._resolution.y,O.w=this.width,x.updateVector4("grl_aspect_resolution_lineWidth",O)}const O=X.j.Vector4[0];O.x=ux.BooleanToNumber(this.useDash),O.y=this._dashArray,O.z=this.dashOffset,O.w=this.dashRatio,x.updateVector4("grl_dashOptions",O);const Q=X.j.Vector4[1];Q.x=this.colorMode,Q.y=this.visibility,Q.z=this.colorsTexture?this.colorsTexture.getSize().width:0,Q.w=ux.BooleanToNumber(this.useColors),x.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",Q),this._color&&x.updateColor3("grl_singleColor",this._color);const Z=this.colorsTexture??tx.EmptyColorsTexture;x.setTexture("grl_colors",Z),x.updateFloat2("grl_textureSize",(null===Z||void 0===Z?void 0:Z.getSize().width)??1,(null===Z||void 0===Z?void 0:Z.getSize().height)??1)}prepareDefines(x,O,Q){x.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,x.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,x.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,x.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=O.useRightHandedSystem,x.GREASED_LINE_CAMERA_FACING=this._cameraFacing,x.GREASED_LINE_USE_OFFSETS=!!Q.offsets}getClassName(){return fx.GREASED_LINE_MATERIAL_NAME}getCustomCode(x){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(O)?function(x,O){if("vertex"===x){const x={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return O&&(x["!gl_Position\\=viewProjection\\*worldPos;"]="//"),x}return"fragment"===x?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(x,this._cameraFacing):function(x,O){if("vertex"===x){const x={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return O&&(x["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),x}return"fragment"===x?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(x,this._cameraFacing)}dispose(){var x;null===(x=this.colorsTexture)||void 0===x||x.dispose(),super.dispose()}get Ax(){return this._colors}set Ax(x){this.setColors(x)}setColors(x){var O;let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1],X=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Z=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var n;if(this._colors=x,null!==x&&0!==x.length){if(!Q||X)if(this.colorsTexture&&Z===x.length&&!X){const O=ux.Color3toRGBAUint8(x);this.colorsTexture.update(O)}else{var V;null===(V=this.colorsTexture)||void 0===V||V.dispose(),this.colorsTexture=ux.CreateColorsTexture(`${this._material.name}-colors-texture`,x,this.colorsSampling,this._scene)}}else null===(n=this.colorsTexture)||void 0===n||n.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(x){this._dashCount=x,this._dashArray=1/x}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(x){this._sizeAttenuation=x,this.markAllDefinesAsDirty()}get color(){return this._color}set color(x){this.setColor(x)}setColor(x){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==x||null!==this._color&&null===x?(this._color=x,O||this.markAllDefinesAsDirty()):this._color=x}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(x){this._colorsDistributionType=x,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(x){this._aspect=x.x/x.y,this._resolution=x}serialize(){const x=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(O.Ax=this._colors),this._color&&(O.color=this._color),x.greasedLineMaterialOptions=O,x}parse(x,O,Q){var X;super.parse(x,O,Q);const Z=x.greasedLineMaterialOptions;null===(X=this.colorsTexture)||void 0===X||X.dispose(),Z.color&&this.setColor(Z.color,!0),Z.colorDistributionType&&(this.colorsDistributionType=Z.colorDistributionType),Z.Ax&&(this.Ax=Z.Ax),Z.colorsSampling&&(this.colorsSampling=Z.colorsSampling),Z.colorMode&&(this.colorMode=Z.colorMode),Z.useColors&&(this.useColors=Z.useColors),Z.visibility&&(this.visibility=Z.visibility),Z.useDash&&(this.useDash=Z.useDash),Z.dashCount&&(this.dashCount=Z.dashCount),Z.dashRatio&&(this.dashRatio=Z.dashRatio),Z.dashOffset&&(this.dashOffset=Z.dashOffset),Z.width&&(this.width=Z.width),Z.sizeAttenuation&&(this.sizeAttenuation=Z.sizeAttenuation),Z.resolution&&(this.resolution=Z.resolution),this.Ax?this.colorsTexture=ux.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Ax,this.colorsSampling,O):ux.PrepareEmptyColorsTexture(O),this.markAllDefinesAsDirty()}copyTo(x){var O;const Q=x;null===(O=Q.colorsTexture)||void 0===O||O.dispose(),this._colors&&(Q.colorsTexture=ux.CreateColorsTexture(`${Q._material.name}-colors-texture`,this._colors,Q.colorsSampling,this._scene)),Q.setColor(this.color,!0),Q.colorsDistributionType=this.colorsDistributionType,Q.colorsSampling=this.colorsSampling,Q.colorMode=this.colorMode,Q.useColors=this.useColors,Q.visibility=this.visibility,Q.useDash=this.useDash,Q.dashCount=this.dashCount,Q.dashRatio=this.dashRatio,Q.dashOffset=this.dashOffset,Q.width=this.width,Q.sizeAttenuation=this.sizeAttenuation,Q.resolution=this.resolution,Q.markAllDefinesAsDirty()}_isGLSL(x){return 0===x||this._forceGLSL}}fx.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",fx.ForceGLSL=!1,(0,Jx.d)(`BABYLON.${fx.GREASED_LINE_MATERIAL_NAME}`,fx);var Ex=Q(11179),zx=Q(10912),Fx=Q(11569),bx=Q(10999);class Dx extends Fx.d{constructor(x,O,Z){const n=O.getEngine(),V=n.isWebGPU&&!(Z.forceGLSL||Dx.ForceGLSL),o=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];O.useRightHandedSystem&&o.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const l=["position","grl_widths","grl_offsets","grl_colorPointers"];Z.cameraFacing?(o.push("GREASED_LINE_CAMERA_FACING"),l.push("grl_previousAndSide","grl_nextAndCounters")):(l.push("grl_slopes"),l.push("grl_counters"));const C=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(V||C.push("world","viewProjection","view","projection"),super(x,O,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:V?["Scene","Mesh"]:void 0,attributes:l,uniforms:C,samplers:V?[]:["grlColors"],defines:o,extraInitializationsAsync:async()=>{V?await Promise.all([Q.e(47).then(Q.bind(Q,14124)),Q.e(55).then(Q.bind(Q,14132))]):await Promise.all([Q.e(50).then(Q.bind(Q,14134)),Q.e(56).then(Q.bind(Q,14138))])},shaderLanguage:V?1:0}),this._color=M.d.White(),this._colorsDistributionType=0,this._colorsTexture=null,Z=Z||{color:tx.DEFAULT_COLOR},this.visibility=Z.visibility??1,this.useDash=Z.useDash??!1,this.dashRatio=Z.dashRatio??.5,this.dashOffset=Z.dashOffset??0,this.dashCount=Z.dashCount??1,this.width=Z.width?Z.width:Z.sizeAttenuation&&Z.cameraFacing?tx.DEFAULT_WIDTH_ATTENUATED:tx.DEFAULT_WIDTH,this.sizeAttenuation=Z.sizeAttenuation??!1,this.color=Z.color??M.d.White(),this.useColors=Z.useColors??!1,this.colorsDistributionType=Z.colorDistributionType??0,this.colorsSampling=Z.colorsSampling??q.b.NEAREST_NEAREST,this.colorMode=Z.colorMode??0,this._colors=Z.Ax??null,this._cameraFacing=Z.cameraFacing??!0,this.resolution=Z.resolution??new X.l(n.getRenderWidth(),n.getRenderHeight()),Z.colorsTexture?this.colorsTexture=Z.colorsTexture:this._colors?this.colorsTexture=ux.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,O):(this._color=this._color??tx.DEFAULT_COLOR,this.colorsTexture=ux.PrepareEmptyColorsTexture(O)),V){const x=new bx.e;x.setParameters(),x.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",x)}n.no.add((()=>{ux.DisposeEmptyColorsTexture()}))}dispose(){var x;null===(x=this._colorsTexture)||void 0===x||x.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new X.l(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Ax(){return this._colors}set Ax(x){this.setColors(x)}setColors(x){var O;let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1],X=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Z=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var n;if(this._colors=x,null!==x&&0!==x.length){if(!Q||X)if(this._colorsTexture&&Z===x.length&&!X){const O=ux.Color3toRGBAUint8(x);this._colorsTexture.update(O)}else{var V;null===(V=this._colorsTexture)||void 0===V||V.dispose(),this.colorsTexture=ux.CreateColorsTexture(`${this.name}-colors-texture`,x,this.colorsSampling,this.kx())}}else null===(n=this._colorsTexture)||void 0===n||n.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(x){this._colorsTexture=x,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(x){this._width=x,this.setFloat("grlWidth",x)}get useColors(){return this._useColors}set useColors(x){this._useColors=x,this.setFloat("grlUseColors",ux.BooleanToNumber(x))}get colorsSampling(){return this._colorsSampling}set colorsSampling(x){this._colorsSampling=x}get visibility(){return this._visibility}set visibility(x){this._visibility=x,this.setFloat("grlVisibility",x)}get useDash(){return this._useDash}set useDash(x){this._useDash=x,this.setFloat("grlUseDash",ux.BooleanToNumber(x))}get dashOffset(){return this._dashOffset}set dashOffset(x){this._dashOffset=x,this.setFloat("grlDashOffset",x)}get dashRatio(){return this._dashRatio}set dashRatio(x){this._dashRatio=x,this.setFloat("grlDashRatio",x)}get dashCount(){return this._dashCount}set dashCount(x){this._dashCount=x,this._dashArray=1/x,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(x){this._sizeAttenuation=x,this.setFloat("grlSizeAttenuation",ux.BooleanToNumber(x))}get color(){return this._color}set color(x){this.setColor(x)}setColor(x){x=x??tx.DEFAULT_COLOR,this._color=x,this.setColor3("grlColor",x)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(x){this._colorsDistributionType=x,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(x){this._colorMode=x,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(x){this._resolution=x,this.setVector2("grlResolution",x),this.setFloat("grlAspect",x.x/x.y)}serialize(){const x=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(O.Ax=this._colors),x.greasedLineMaterialOptions=O,x}parse(x,O,Q){var X;const Z=x.greasedLineMaterialOptions;null===(X=this._colorsTexture)||void 0===X||X.dispose(),Z.color&&(this.color=Z.color),Z.colorDistributionType&&(this.colorsDistributionType=Z.colorDistributionType),Z.colorsSampling&&(this.colorsSampling=Z.colorsSampling),Z.colorMode&&(this.colorMode=Z.colorMode),Z.useColors&&(this.useColors=Z.useColors),Z.visibility&&(this.visibility=Z.visibility),Z.useDash&&(this.useDash=Z.useDash),Z.dashCount&&(this.dashCount=Z.dashCount),Z.dashRatio&&(this.dashRatio=Z.dashRatio),Z.dashOffset&&(this.dashOffset=Z.dashOffset),Z.width&&(this.width=Z.width),Z.sizeAttenuation&&(this.sizeAttenuation=Z.sizeAttenuation),Z.resolution&&(this.resolution=Z.resolution),Z.Ax?this.colorsTexture=ux.CreateColorsTexture(`${this.name}-colors-texture`,Z.Ax,this.colorsSampling,this.kx()):this.colorsTexture=ux.PrepareEmptyColorsTexture(O),this._cameraFacing=Z.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Wx,yx,Ix;Dx.ForceGLSL=!1,function(x){x[x.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",x[x.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Wx||(Wx={})),function(x){x[x.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",x[x.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",x[x.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(yx||(yx={})),function(x){x[x.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",x[x.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",x[x.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",x[x.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",x[x.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Ix||(Ix={}));class rx extends gx.b{constructor(x,O,Q){super(x,O,null,null,!1,!1),this.name=x,this._options=Q,this._lazy=!1,this._updatable=!1,this._engine=O.getEngine(),this._lazy=Q.lazy??!1,this._updatable=Q.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=Q.colorPointers??[],this._widths=Q.widths??new Array(Q.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(x){let O=0;for(const X of this._points)O+=X.length;const Q=O/3*2-this._widths.length;for(let X=0;X<Q;X++)this._widths.push(x)}updateLazy(){var x,O;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(x=this._options.ribbonOptions)||void 0===x?void 0:x.smoothShading),!this.bx&&this.refreshBoundingInfo(),null===(O=this.greasedLineMaterial)||void 0===O||O.updateLazy()}addPoints(x,O){for(const Q of x)this._points.push(Q);this._lazy||this.setPoints(this._points,O)}dispose(x){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(x,O)}isLazy(){return this._lazy}get Ex(){return this._uvs}set Ex(x){this._uvs=x instanceof Float32Array?x:new Float32Array(x),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(x){this.material instanceof Dx&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===x||void 0===x?void 0:x.length)>0),this._offsets=x,this._offsetsBuffer?this._offsetsBuffer.update(x):this._createOffsetsBuffer(x)}get widths(){return this._widths}set widths(x){this._widths=x,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(x)}get colorPointers(){return this._colorPointers}set colorPointers(x){this._colorPointers=x,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(x)}get greasedLineMaterial(){var x,O;if(this.material&&this.material instanceof Dx)return this.material;const Q=null===(x=this.material)||void 0===x||null===(O=x.pluginManager)||void 0===O?void 0:O.getPlugin(fx.GREASED_LINE_MATERIAL_NAME);return Q||void 0}get points(){const x=[];return zx.b.DeepCopy(this._points,x),x}setPoints(x,O){this._points=ux.ConvertPoints(x,(null===O||void 0===O?void 0:O.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==O&&void 0!==O&&O.colorPointers||this._updateColorPointers(),this._setPoints(this._points,O)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Ex:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(x){super.serialize(x),x.type=this.getClassName(),x.lineOptions=this._createLineOptions()}_createVertexBuffers(){let x=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new Ex.d;return O.tx=this._vertexPositions,O.indices=this._indices,O.Ex=this._uvs,x&&(O.ux=[],Ex.d.ComputeNormals(this._vertexPositions,this._indices,O.ux)),O.Fx(this,this._options.updatable),O}_createOffsetsBuffer(x){const O=this._scene.getEngine(),Q=new U.c(O,x,this._updatable,3);this.setVerticesBuffer(Q.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=Q}}class jx{constructor(x,O){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=x,this.wasAddedByNoopNode=O}getIndicesAccessor(x,O,Q,X,Z){var n,V,o,l;return null===(n=this._indicesAccessorMap.get(x))||void 0===n||null===(V=n.get(O))||void 0===V||null===(o=V.get(Q))||void 0===o||null===(l=o.get(X))||void 0===l?void 0:l.get(Z)}setIndicesAccessor(x,O,Q,X,Z,n){let V=this._indicesAccessorMap.get(x);V||(V=new Map,this._indicesAccessorMap.set(x,V));let o=V.get(O);o||(o=new Map,V.set(O,o));let l=o.get(Q);l||(l=new Map,o.set(Q,l));let C=l.get(X);C||(C=new Map,l.set(X,C)),C.set(Z,n)}pushExportedNode(x){this._exportedNodes.has(x)||this._exportedNodes.add(x)}getNodesSet(){return this._exportedNodes}getVertexBufferView(x){return this._vertexBufferViewMap.get(x)}setVertexBufferView(x,O){this._vertexBufferViewMap.set(x,O)}setRemappedBufferView(x,O,Q){this._remappedBufferView.set(x,new Map),this._remappedBufferView.get(x).set(O,Q)}getRemappedBufferView(x,O){var Q;return null===(Q=this._remappedBufferView.get(x))||void 0===Q?void 0:Q.get(O)}getVertexAccessor(x,O,Q){var X,Z;return null===(X=this._vertexAccessorMap.get(x))||void 0===X||null===(Z=X.get(O))||void 0===Z?void 0:Z.get(Q)}setVertexAccessor(x,O,Q,X){let Z=this._vertexAccessorMap.get(x);Z||(Z=new Map,this._vertexAccessorMap.set(x,Z));let n=Z.get(O);n||(n=new Map,Z.set(O,n)),n.set(Q,X)}hasVertexColorAlpha(x){return this._vertexMapColorAlpha.get(x)||!1}setHasVertexColorAlpha(x,O){return this._vertexMapColorAlpha.set(x,O)}getMesh(x){return this._meshMap.get(x)}setMesh(x,O){this._meshMap.set(x,O)}bindMorphDataToMesh(x,O){const Q=this._meshMorphTargetMap.get(x)||[];this._meshMorphTargetMap.set(x,Q),-1===Q.indexOf(O)&&Q.push(O)}getMorphTargetsFromMesh(x){return this._meshMorphTargetMap.get(x)}}class Tx{_ApplyExtension(x,O,Q,X){if(Q>=O.length)return Promise.resolve(x);const Z=X(O[Q],x);return Z?Z.then((async x=>x?await this._ApplyExtension(x,O,Q+1,X):null)):this._ApplyExtension(x,O,Q+1,X)}_ApplyExtensions(x,O){const Q=[];for(const X of Tx._ExtensionNames)Q.push(this._extensions[X]);return this._ApplyExtension(x,Q,0,O)}_extensionsPreExportTextureAsync(x,O,Q){return this._ApplyExtensions(O,((O,X)=>O.preExportTextureAsync&&O.preExportTextureAsync(x,X,Q)))}_extensionsPostExportNodeAsync(x,O,Q,X,Z){return this._ApplyExtensions(O,((O,n)=>O.postExportNodeAsync&&O.postExportNodeAsync(x,n,Q,X,Z,this._bufferManager)))}_extensionsPostExportMaterialAsync(x,O,Q){return this._ApplyExtensions(O,((O,X)=>O.postExportMaterialAsync&&O.postExportMaterialAsync(x,X,Q)))}_extensionsPostExportMaterialAdditionalTextures(x,O,Q){const X=[];for(const Z of Tx._ExtensionNames){const n=this._extensions[Z];n.postExportMaterialAdditionalTextures&&X.push(...n.postExportMaterialAdditionalTextures(x,O,Q))}return X}_extensionsPostExportTextures(x,O,Q){for(const X of Tx._ExtensionNames){const Z=this._extensions[X];Z.postExportTexture&&Z.postExportTexture(x,O,Q)}}_extensionsPostExportMeshPrimitive(x){for(const O of Tx._ExtensionNames){const Q=this._extensions[O];Q.postExportMeshPrimitive&&Q.postExportMeshPrimitive(x,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const x of Tx._ExtensionNames){const O=this._extensions[x];O.preGenerateBinaryAsync&&await O.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(x){for(const O of Tx._ExtensionNames){const Q=this._extensions[O];Q.enabled&&x(Q)}}_extensionsOnExporting(){this._forEachExtensions((x=>{var O,Q,X;x.wasUsed&&((O=this._glTF).extensionsUsed||(O.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(x.name)&&this._glTF.extensionsUsed.push(x.name),x.required&&((Q=this._glTF).extensionsRequired||(Q.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(x.name)&&this._glTF.extensionsRequired.push(x.name)),(X=this._glTF).extensions||(X.extensions={}),x.onExporting&&x.onExporting())}))}_loadExtensions(){for(const x of Tx._ExtensionNames){const O=Tx._ExtensionFactories[x](this);this._extensions[x]=O}}constructor(){let x=arguments.length>0&&void 0!==arguments[0]?arguments[0]:K.c.LastCreatedScene,O=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${a.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new b(this),this._extensions={},this._bufferManager=new Ux,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!x)throw new Error("No scene available to export");this._babylonScene=x,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:x=>{var O;return null===x||void 0===x||null===(O=x.oo)||void 0===O?void 0:O.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...O},this._loadExtensions()}dispose(){for(const x in this._extensions){this._extensions[x].dispose()}}get options(){return this._options}static RegisterExtension(x,O){Tx.UnregisterExtension(x)&&Z.g.Warn(`Extension with the name ${x} already exists`),Tx._ExtensionFactories[x]=O,Tx._ExtensionNames.push(x)}static UnregisterExtension(x){if(!Tx._ExtensionFactories[x])return!1;delete Tx._ExtensionFactories[x];const O=Tx._ExtensionNames.indexOf(x);return-1!==O&&Tx._ExtensionNames.splice(O,1),!0}_generateJSON(x,O,Q){const X={byteLength:x};return X.byteLength&&(this._glTF.buffers=[X]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.RO=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(X.uri=O+".bin"),Q?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(x){const O=await this._generateBinaryAsync();this._extensionsOnExporting();const Q=this._generateJSON(O.byteLength,x,!0),X=new Blob([O],{type:"application/octet-stream"}),Z=x+".gltf",n=x+".bin",V=new C;if(V.files[Z]=Q,V.files[n]=X,this._imageData)for(const o in this._imageData)V.files[o]=new Blob([this._imageData[o].data],{type:this._imageData[o].mimeType});return V}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(x){const O=x%4;return 0===O?O:4-O}async generateGLBAsync(x){this._shouldUseGlb=!0;const O=await this._generateBinaryAsync();this._extensionsOnExporting();const Q=this._generateJSON(O.byteLength),X=x+".glb";let Z,n=Q.length;if("undefined"!==typeof TextEncoder){Z=(new TextEncoder).encode(Q),n=Z.length}const V=this._getPadding(n),o=this._getPadding(O.byteLength),l=28+n+V+O.byteLength+o,U=new lx(l);if(U.writeUInt32(1179937895),U.writeUInt32(2),U.writeUInt32(l),U.writeUInt32(n+V),U.writeUInt32(1313821514),Z)U.writeTypedArray(Z);else{const x="_".charCodeAt(0);for(let O=0;O<n;++O){const X=Q.charCodeAt(O);X!=Q.codePointAt(O)?U.writeUInt8(x):U.writeUInt8(X)}}for(let C=0;C<V;++C)U.writeUInt8(32);U.writeUInt32(O.byteLength+o),U.writeUInt32(5130562),U.writeTypedArray(O);for(let C=0;C<o;++C)U.writeUInt8(0);const L=new C;return L.files[X]=new Blob([U.getOutputData()],{type:"application/octet-stream"}),L}_setNodeTransformation(x,O,Q){if(O.getPivotPoint().equalsWithEpsilon(r,I.e)||Z.g.Warn("Pivot points are not supported in the glTF serializer"),!O.position.equalsWithEpsilon(r,I.e)){const Z=X.j.Oo[0].V(O.position);Q&&P(Z),x.translation=Z.mV()}O.Qo.equalsWithEpsilon(T,I.e)||(x.scale=O.Qo.mV());const n=O.rotationQuaternion||X.g.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);n.equalsWithEpsilon(j,I.e)||(Q&&m(n),x.rotation=n.normalize().mV())}_setCameraTransformation(x,O,Q){if(!O.position.equalsWithEpsilon(r,I.e)){const Z=X.j.Oo[0].V(O.position);Q&&P(Z),x.translation=Z.mV()}const Z=O.rotationQuaternion||X.g.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);Q&&m(Z),this._babylonScene.useRightHandedSystem||w(Z),Z.equalsWithEpsilon(j,I.e)||(x.rotation=Z.mV())}_listAvailableCameras(){for(const x of this._babylonScene.cameras){const O={type:x.mode===hx.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(x.name&&(O.name=x.name),"perspective"===O.type)O.perspective={aspectRatio:x.getEngine().getAspectRatio(x),yfov:x.fovMode===hx.e.FOVMODE_VERTICAL_FIXED?x.fov:x.fov*x.getEngine().getAspectRatio(x),znear:x.lo,zfar:x.maxZ};else if("orthographic"===O.type){const Q=x.orthoLeft&&x.orthoRight?.5*(x.orthoRight-x.orthoLeft):.5*x.getEngine().getRenderWidth(),X=x.orthoBottom&&x.orthoTop?.5*(x.orthoTop-x.orthoBottom):.5*x.getEngine().getRenderHeight();O.orthographic={xmag:Q,ymag:X,znear:x.lo,zfar:x.maxZ}}this._camerasMap.set(x,O)}}_exportAndAssignCameras(){const x=Array.from(this._camerasMap.values());for(const O of x){const x=this._nodesCameraMap.get(O);if(void 0!==x){this._cameras.push(O);for(const O of x)O.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const x of this._babylonScene.skeletons){if(x.bones.length<=0)continue;const O={joints:[]};this._skinMap.set(x,O)}}_exportAndAssignSkeletons(){for(const x of this._babylonScene.skeletons){if(x.bones.length<=0)continue;const O=this._skinMap.get(x);if(void 0==O)continue;const Q={},X=[];let n=-1;for(let Z=0;Z<x.bones.length;++Z){const O=x.bones[Z],X=O.getIndex()??Z;-1!==X&&(Q[X]=O,X>n&&(n=X))}for(let x=0;x<=n;++x){const n=Q[x];X.push(n.getAbsoluteInverseBindMatrix());const V=n.getTransformNode();if(null!==V){const x=this._nodeMap.get(V);V&&null!==x&&void 0!==x?O.joints.push(x):Z.g.Warn("Exporting a bone without a linked transform node is currently unsupported")}else Z.g.Warn("Exporting a bone without a linked transform node is currently unsupported")}const V=this._nodesSkinMap.get(O);if(O.joints.length>0&&void 0!==V){const x=64*X.length,Q=new Float32Array(x/4);X.forEach(((x,O)=>{Q.set(x.m,16*O)}));const Z=this._bufferManager.createBufferView(Q);this._accessors.push(this._bufferManager.createAccessor(Z,"MAT4",5126,X.length)),O.inverseBindMatrices=this._accessors.length-1,this._skins.push(O);for(const O of V)O.skin=this._skins.length-1}}}async _exportSceneAsync(){const x={nodes:[]};if(this._babylonScene.metadata){const O=this._options.metadataSelector(this._babylonScene.metadata);O&&(x.extras=O)}const O=new Array,Q=new Array,X=new Array;for(const o of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Vx(o,this._babylonScene.useRightHandedSystem)?X.push(...o.getChildren()):this._babylonScene.useRightHandedSystem?O.push(o):Q.push(o);this._listAvailableCameras(),this._listAvailableSkeletons();const Z=new jx(!0,!1);x.nodes.push(...await this._exportNodesAsync(Q,Z));const n=new jx(!1,!1);x.nodes.push(...await this._exportNodesAsync(O,n));const V=new jx(!1,!0);x.nodes.push(...await this._exportNodesAsync(X,V)),x.nodes.length&&this._scenes.push(x),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Rx._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Z.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(x){let O=this._shouldExportNodeMap.get(x);return void 0===O&&(O=this._options.shouldExportNode(x),this._shouldExportNodeMap.set(x,O)),O}async _exportNodesAsync(x,O){const Q=new Array;this._exportBuffers(x,O);for(const X of x)await this._exportNodeAsync(X,Q,O);return Q}_collectBuffers(x,O,Q,X,Z){if(this._shouldExportNode(x)&&x instanceof h.c&&x.SV){const n=x.SV.getVertexBuffers();if(n)for(const X in n){if(!H(X))continue;const V=n[X];Z.setHasVertexColorAlpha(V,x.hasVertexAlpha);const o=V._buffer,l=O.get(o)||[];O.set(o,l),-1===l.indexOf(V)&&l.push(V);const C=Q.get(V)||[];Q.set(V,C),-1===C.indexOf(x)&&C.push(x)}const V=x.morphTargetManager;if(V)for(let O=0;O<V.numTargets;O++){const Q=V.getTarget(O),Z=X.get(Q)||[];X.set(Q,Z),-1===Z.indexOf(x)&&Z.push(x)}}for(const n of x.getChildren())this._collectBuffers(n,O,Q,X,Z)}_exportBuffers(x,O){const Q=new Map,X=new Map,Z=new Map;for(const o of x)this._collectBuffers(o,Q,X,Z,O);const n=Array.from(Q.keys());for(const o of n){const x=o.getData();if(!x)throw new Error("Buffer data is not available");const Z=Q.get(o);if(!Z)continue;const n=Z[0].byteStride;if(Z.some((x=>x.byteStride!==n)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const V=Qx(x).slice();for(const O of Z){const x=X.get(O),{byteOffset:Q,byteStride:Z,componentCount:n,type:o,count:l,normalized:C,kind:L}=B(O,x);switch(L){case U.g.NormalKind:case U.g.TangentKind:(0,D.l)(V,Q,Z,n,o,l,C,(x=>{const O=Math.sqrt(x[0]*x[0]+x[1]*x[1]+x[2]*x[2]);if(O>0){const Q=1/O;x[0]*=Q,x[1]*=Q,x[2]*=Q}}));break;case U.g.ColorKind:{const O=x.filter((x=>x.material instanceof Kx.d||null==x.material)).length;if(0==O)break;if(O!=x.length){W.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}o==U.g.UNSIGNED_BYTE&&W.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const X=new M.d,L=new M.h,h=this._babylonScene.getEngine().useExactSrgbConversions;(0,D.l)(V,Q,Z,n,o,l,C,(x=>{3===x.length?(X.NQ(x,0),X.toLinearSpaceToRef(X,h),X.toArray(x,0)):(L.NQ(x,0),L.toLinearSpaceToRef(L,h),L.toArray(x,0))}))}}}if(O.convertToRightHanded){for(const x of Z){const O=X.get(x),{byteOffset:Q,byteStride:Z,componentCount:n,type:o,count:l,normalized:C,kind:L}=B(x,O);switch(L){case U.g.PositionKind:case U.g.NormalKind:case U.g.TangentKind:(0,D.l)(V,Q,Z,n,o,l,C,(x=>{x[0]=-x[0]}))}}O.convertedToRightHandedBuffers.set(o,V)}const l=this._bufferManager.createBufferView(V,n);O.setVertexBufferView(o,l);const C=new Map;for(const O of Z){const x=X.get(O),{kind:Q,totalVertices:Z}=B(O,x);switch(Q){case U.g.MatricesIndicesKind:case U.g.MatricesIndicesExtraKind:if(O.type==U.g.FLOAT){const x=O.getFloatData(Z);null!==x&&C.set(O,x)}}}0!==C.size&&W.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const L=Array.from(C.keys());for(const Q of L){const x=C.get(Q);if(!x)continue;const X=x.some((x=>x>=256)),Z=new(X?Uint16Array:Uint8Array)(x.length);for(let O=0;O<x.length;O++)Z[O]=x[O];const n=this._bufferManager.createBufferView(Z,4*(X?2:1));O.setRemappedBufferView(o,Q,n)}}const V=Array.from(Z.keys());for(const o of V){const x=Z.get(o);if(!x)continue;const Q=sx(o,x[0],this._bufferManager,this._bufferViews,this._accessors,O.convertToRightHanded);for(const X of x)O.bindMorphDataToMesh(X,Q)}}async _exportNodeAsync(x,O,Q){let X=this._nodeMap.get(x);if(void 0!==X)return void(O.includes(X)||O.push(X));const Z=await this._createNodeAsync(x,Q);if(Z){X=this._nodes.length,this._nodes.push(Z),this._nodeMap.set(x,X),Q.pushExportedNode(x),O.push(X);const n={name:"runtime animations",channels:[],samplers:[]},V=[];this._babylonScene.animationGroups.length||(Rx._CreateMorphTargetAnimationFromMorphTargetAnimations(x,n,V,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Q.convertToRightHanded,this._options.shouldExportAnimation),x.animations.length&&Rx._CreateNodeAnimationFromNodeAnimations(x,n,V,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Q.convertToRightHanded,this._options.shouldExportAnimation)),n.channels.length&&n.samplers.length&&this._animations.push(n),V.forEach((x=>{x.channels.length&&x.samplers.length&&this._animations.push(x)}))}const n=Z?[]:O;for(const V of x.getChildren())await this._exportNodeAsync(V,n,Q);Z&&n.length&&(Z.children=n)}async _createNodeAsync(x,O){if(!this._shouldExportNode(x))return null;const Q={};if(x.name&&(Q.name=x.name),x.metadata){const O=this._options.metadataSelector(x.metadata);O&&(Q.extras=O)}if(x instanceof L.c&&(this._setNodeTransformation(Q,x,O.convertToRightHanded),x instanceof h.c)){const Z=x instanceof N.d?x.sourceMesh:x;if(Z.Co&&Z.Co.length>0&&(Q.mesh=await this._exportMeshAsync(Z,O)),x.skeleton){const O=this._skinMap.get(x.skeleton);var X;if(void 0!==O)void 0===this._nodesSkinMap.get(O)&&this._nodesSkinMap.set(O,[]),null===(X=this._nodesSkinMap.get(O))||void 0===X||X.push(Q)}}if(x instanceof y.c){const X=this._camerasMap.get(x);if(X){var Z;void 0===this._nodesCameraMap.get(X)&&this._nodesCameraMap.set(X,[]),this._setCameraTransformation(Q,x,O.convertToRightHanded);const V=x.parent;if(null!==V&&Ox(x,V)){const x=this._nodeMap.get(V);if(void 0!==x){var n;const O=this._nodes[x];return xx(Q,O),null===(n=this._nodesCameraMap.get(X))||void 0===n||n.push(O),null}}null===(Z=this._nodesCameraMap.get(X))||void 0===Z||Z.push(Q)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",Q,x,this._nodeMap,O.convertToRightHanded)?Q:(W.e.Warn(`Not exporting node ${x.name}`),null)}_exportIndices(x,O,Q,X,Z,V,o,l,C){let U=x;C.mode=S(V);const L=o!==n.e.CounterClockWiseSideOrientation,h=!l.wasAddedByNoopNode&&L,N=function(x){switch(x){case n.e.TriangleFillMode:case n.e.TriangleStripDrawMode:case n.e.TriangleFanDrawMode:return!0}return!1}(V)&&h;if(N){if(V===n.e.TriangleStripDrawMode||V===n.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");C.mode=S(V);const o=O?new Uint32Array(X):new Uint16Array(X);if(x)for(let O=0;O+2<X;O+=3)o[O]=x[Q+O]+Z,o[O+1]=x[Q+O+2]+Z,o[O+2]=x[Q+O+1]+Z;else for(let x=0;x+2<X;x+=3)o[x]=x,o[x+1]=x+2,o[x+2]=x+1;U=o}else if(x&&0!==Z){const n=O?new Uint32Array(X):new Uint16Array(X);for(let O=0;O<X;O++)n[O]=x[Q+O]+Z;U=n}if(U){let n=l.getIndicesAccessor(x,Q,X,Z,N);if(void 0===n){const V=function(x,O,Q,X){if(x instanceof Uint16Array||x instanceof Uint32Array)return x;if(x instanceof Int32Array)return new Uint32Array(x.buffer,x.byteOffset,x.length);const Z=x.slice(O,O+Q);return X?new Uint32Array(Z):new Uint16Array(Z)}(U,0,X,O),o=this._bufferManager.createBufferView(V),C=O?5125:5123;this._accessors.push(this._bufferManager.createAccessor(o,"SCALAR",C,X,0)),n=this._accessors.length-1,l.setIndicesAccessor(x,Q,X,Z,N,n)}C.indices=n}}_exportVertexBuffer(x,O,Q,X,Z,n){const V=x.getKind();if(!H(V))return;if(V.startsWith("uv")&&!this._options.exportUnusedUVs&&(!O||!this._materialNeedsUVsSet.has(O)))return;let o=Z.getVertexAccessor(x,Q,X);if(void 0===o){const O=Z.convertedToRightHandedBuffers.get(x._buffer)||x._buffer.getData(),n=V===U.g.PositionKind?function(x,O,Q,X){const{byteOffset:Z,byteStride:n,type:V,normalized:o}=O,l=O.getSize(),C=new Array(l).fill(1/0),U=new Array(l).fill(-1/0);return(0,D.l)(x,Z+Q*n,n,l,V,X*l,o,(x=>{for(let O=0;O<l;O++)C[O]=Math.min(C[O],x[O]),U[O]=Math.max(U[O],x[O])})),{min:C,max:U}}(O,x,Q,X):void 0,l=(V===U.g.MatricesIndicesKind||V===U.g.MatricesIndicesExtraKind)&&x.type===U.g.FLOAT,C=l?U.g.UNSIGNED_BYTE:x.type,L=l?void 0:x.normalized,h=l?Z.getRemappedBufferView(x._buffer,x):Z.getVertexBufferView(x._buffer),N=x.byteOffset+Q*x.byteStride;this._accessors.push(this._bufferManager.createAccessor(h,function(x,O){if(x==U.g.ColorKind)return O?"VEC4":"VEC3";switch(x){case U.g.PositionKind:case U.g.NormalKind:return"VEC3";case U.g.TangentKind:case U.g.MatricesIndicesKind:case U.g.MatricesIndicesExtraKind:case U.g.MatricesWeightsKind:case U.g.MatricesWeightsExtraKind:return"VEC4";case U.g.UVKind:case U.g.UV2Kind:case U.g.UV3Kind:case U.g.UV4Kind:case U.g.UV5Kind:case U.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${x}`)}(V,Z.hasVertexColorAlpha(x)),C,X,N,n,L)),o=this._accessors.length-1,Z.setVertexAccessor(x,Q,X,o)}n.attributes[function(x){switch(x){case U.g.PositionKind:return"POSITION";case U.g.NormalKind:return"NORMAL";case U.g.TangentKind:return"TANGENT";case U.g.ColorKind:return"COLOR_0";case U.g.UVKind:return"TEXCOORD_0";case U.g.UV2Kind:return"TEXCOORD_1";case U.g.UV3Kind:return"TEXCOORD_2";case U.g.UV4Kind:return"TEXCOORD_3";case U.g.UV5Kind:return"TEXCOORD_4";case U.g.UV6Kind:return"TEXCOORD_5";case U.g.MatricesIndicesKind:return"JOINTS_0";case U.g.MatricesIndicesExtraKind:return"JOINTS_1";case U.g.MatricesWeightsKind:return"WEIGHTS_0";case U.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${x}`)}(V)]=o}async _exportMaterialAsync(x,O,Q,X){let Z=this._materialMap.get(x);if(void 0===Z){const X=O&&Object.keys(O).some((x=>x.startsWith("uv")));if((x=x instanceof Nx.e?x.Uo[Q.materialIndex]:x)instanceof ax.d)Z=await this._materialExporter.exportPBRMaterialAsync(x,"image/png",X);else{if(!(x instanceof Kx.d))return void W.e.Warn(`Unsupported material '${x.name}' with type ${x.getClassName()}`);Z=await this._materialExporter.exportStandardMaterialAsync(x,"image/png",X)}this._materialMap.set(x,Z)}X.material=Z}async _exportMeshAsync(x,O){var Q;let X=O.getMesh(x);if(void 0!==X)return X;const Z={primitives:[]};X=this._meshes.length,this._meshes.push(Z),O.setMesh(x,X);const V=x.isUnIndexed?null:x.pV(),o=null===(Q=x.SV)||void 0===Q?void 0:Q.getVertexBuffers(),l=O.getMorphTargetsFromMesh(x),C=x instanceof qx.e,U=x instanceof rx,L=x.Co;if(o&&L&&L.length>0)for(const a of L){const Q={attributes:{}},X=a.Ix()||this._babylonScene.defaultMaterial;if(U){var h,N;const O={name:X.name},Z=x,n=M.d.White(),V=(null===(h=Z.material)||void 0===h?void 0:h.alpha)??1,o=(null===(N=Z.greasedLineMaterial)||void 0===N?void 0:N.color)??n;(!o.equalsWithEpsilon(n,I.e)||V<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...o.mV(),V]}),this._materials.push(O),Q.material=this._materials.length-1}else if(C){const O={name:X.name},Z=x;(!Z.color.equalsWithEpsilon(M.d.White(),I.e)||Z.alpha<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...Z.color.mV(),Z.alpha]}),this._materials.push(O),Q.material=this._materials.length-1}else await this._exportMaterialAsync(X,o,a,Q);const L=C||U?n.e.LineListDrawMode:x.overrideRenderingFillMode??X.fillMode,K=X._getEffectiveOrientation(x);this._exportIndices(V,V?(0,D.e)(V,a.indexCount,a.indexStart,a.verticesStart):a.verticesCount>65535,V?a.indexStart:a.verticesStart,V?a.indexCount:a.verticesCount,-a.verticesStart,L,K,O,Q);for(const x of Object.values(o))this._exportVertexBuffer(x,X,a.verticesStart,a.verticesCount,O,Q);if(l){Q.targets=[];for(const x of l)Q.targets.push(x.attributes)}Z.primitives.push(Q),this._extensionsPostExportMeshPrimitive(Q)}if(l){Z.weights=[],Z.extras||(Z.extras={}),Z.extras.targetNames=[];for(const x of l)Z.weights.push(x.influence),Z.extras.targetNames.push(x.name)}return X}}Tx._ExtensionNames=new Array,Tx._ExtensionFactories={};class ex{static async GLTFAsync(x,O,Q){Q&&Q.exportWithoutWaitingForScene||await x.whenReadyAsync();const X=new Tx(x,Q),Z=await X.generateGLTFAsync(O.replace(/\.[^/.]+$/,""));return X.dispose(),Z}static async GLBAsync(x,O,Q){Q&&Q.exportWithoutWaitingForScene||await x.whenReadyAsync();const X=new Tx(x,Q),Z=await X.generateGLBAsync(O.replace(/\.[^/.]+$/,""));return X.dispose(),Z}}Q(11588);const Bx="EXT_mesh_gpu_instancing";class ix{constructor(x){this.name=Bx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=x}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(x,O,Q,Z,n,V){return await new Promise((x=>{if(O&&Q instanceof gx.b&&Q.hasThinInstances&&this._exporter){this._wasUsed=!0;const x=X.n.Zero(),Z=X.g.Identity(),o=X.n.One(),l=Q.thinInstanceGetWorldMatrices(),C=X.j.Oo[2],U=X.j.Quaternion[1],L=X.j.Oo[3];let h=!1,N=!1,a=!1;const K=new Float32Array(3*Q.Lo),M=new Float32Array(4*Q.Lo),Y=new Float32Array(3*Q.Lo);let g=0;for(const O of l)O.decompose(L,U,C),n&&(P(C),m(U)),K.set(C.mV(),3*g),M.set(U.normalize().mV(),4*g),Y.set(L.mV(),3*g),h=h||!C.equalsWithEpsilon(x),N=N||!U.equalsWithEpsilon(Z),a=a||!L.equalsWithEpsilon(o),g++;const v={attributes:{}};h&&(v.attributes.TRANSLATION=this._buildAccessor(K,"VEC3",Q.Lo,V)),N&&(v.attributes.ROTATION=this._buildAccessor(M,"VEC4",Q.Lo,V)),a&&(v.attributes.SCALE=this._buildAccessor(Y,"VEC3",Q.Lo,V)),O.extensions=O.extensions||{},O.extensions[Bx]=v}x(O)}))}_buildAccessor(x,O,Q,X){const Z=X.createBufferView(x),n=X.createAccessor(Z,O,5126,Q);return this._exporter._accessors.push(n),this._exporter._accessors.length-1}}Tx.RegisterExtension(Bx,(x=>new ix(x)));var Hx=Q(11597),Sx=Q(11608),px=Q(11614),Px=Q(11618);function mx(x){return x===px.c.PositionKind?"POSITION":x===px.c.NormalKind?"NORMAL":x===px.c.ColorKind?"COLOR":x.startsWith(px.c.UVKind)?"TEX_COORD":"GENERIC"}const wx={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class xO extends Hx.b{static get DefaultAvailable(){return(0,Hx.f)(xO.DefaultConfiguration)}static get Default(){return xO._Default??(xO._Default=new xO),xO._Default}static ResetDefault(x){xO._Default&&(x||xO._Default.dispose(),xO._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(x,O){return{module:await(O||DracoEncoderModule)({wasmBinary:x})}}_getWorkerContent(){return`${Sx.i}(${Sx.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:xO.DefaultConfiguration)}async _encodeAsync(x,O,Q){const X=Q?(0,Px.d)(wx,Q):wx;if(this._workerPoolPromise){const Q=await this._workerPoolPromise;return await new Promise(((Z,n)=>{Q.push(((Q,V)=>{const o=x=>{Q.removeEventListener("error",o),Q.removeEventListener("message",l),n(x),V()},l=x=>{"encodeMeshDone"===x.data.id&&(Q.removeEventListener("error",o),Q.removeEventListener("message",l),Z(x.data.encodedMeshData),V())};Q.addEventListener("error",o),Q.addEventListener("message",l);const C=[];for(const O of x)C.push(O.data.buffer);O&&C.push(O.buffer),Q.postMessage({id:"encodeMesh",attributes:x,indices:O,options:X},C)}))}))}if(this._modulePromise){const Q=await this._modulePromise;return(0,Sx.i)(Q.module,x,O,X)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(x,O){if(0==x.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");x instanceof gx.b&&x.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===O||void 0===O?void 0:O.method)&&(W.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),O.method="MESH_SEQUENTIAL_ENCODING");const Q=function(x){let O=x.pV(void 0,!0);return!O||O instanceof Uint32Array||O instanceof Uint16Array||(O=((0,D.e)(O,O.length)?Uint32Array:Uint16Array).from(O)),O}(x),X=function(x,O){const Q=[];for(const X of x.getVerticesDataKinds()){if(null!==O&&void 0!==O&&O.includes(X)){if(X===px.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const Z=x.getVertexBuffer(X),n=Z.getSize(),V=(0,D.u)(Z.getData(),n,Z.type,Z.byteOffset,Z.byteStride,Z.normalized,x.getTotalVertices(),!0);Q.push({kind:X,dracoName:mx(X),size:n,data:V})}return Q}(x,null===O||void 0===O?void 0:O.excludedAttributes);return await this._encodeAsync(X,Q,O)}}xO.DefaultConfiguration={wasmUrl:`${Z.g._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${Z.g._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${Z.g._DefaultCdnUrl}/draco_encoder.js`},xO._Default=null;const OO="KHR_draco_mesh_compression";class QO{get wasUsed(){return this._wasUsed}constructor(x){this.name=OO,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===x.options.meshCompressionMethod&&xO.DefaultAvailable}dispose(){}postExportMeshPrimitive(x,O,Q){if(!this.enabled)return;if(4!==x.mode&&5!==x.mode)return void W.e.Warn("Cannot compress primitive with mode "+x.mode+".");const X=[],Z=[];let n=null;if(void 0!==x.indices){const V=Q[x.indices],o=O.getBufferView(V);n=O.getData(o).slice(),X.push(o),Z.push(V)}const V=[];for(const[U,L]of Object.entries(x.attributes)){const x=Q[L],n=O.getBufferView(x),l=i(x.type),C=(0,D.u)(O.getData(n),l,x.componentType,x.byteOffset||0,n.byteStride||(0,D.q)(x.componentType)*l,x.normalized||!1,x.count,!0);V.push({kind:U,dracoName:(o=U,"POSITION"===o?"POSITION":"NORMAL"===o?"NORMAL":o.startsWith("COLOR")?"COLOR":o.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:i(x.type),data:C}),X.push(n),Z.push(x)}var o;const l={method:x.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},C=xO.Default._encodeAsync(V,n,l).then((Q=>{if(!Q)return void W.e.Error("Draco encoding failed for primitive.");const n={bufferView:-1,attributes:Q.attributeIds},V=O.createBufferView(Q.data);O.setBufferView(n,V);for(const x of X)this._bufferViewsUsed.add(x);for(const x of Z)this._accessorsUsed.add(x);x.extensions||(x.extensions={}),x.extensions[OO]=n})).catch((x=>{W.e.Error("Draco encoding failed for primitive: "+x)}));this._encodePromises.push(C),this._wasUsed=!0}async preGenerateBinaryAsync(x){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((O=>{x.getPropertiesWithBufferView(O).every((x=>this._accessorsUsed.has(x)))&&x.removeBufferView(O)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Tx.RegisterExtension(OO,(x=>new QO(x)));var XO=Q(11621);const ZO="KHR_lights_punctual",nO={name:"",color:[1,1,1],ho:1,range:Number.MAX_VALUE},VO={innerConeAngle:0,outerConeAngle:Math.PI/4},oO=X.n.Backward();class lO{constructor(x){this.name=ZO,this.enabled=!0,this.required=!1,this._exporter=x}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[ZO]=this._lights}async postExportNodeAsync(x,O,Q,Z,n){return await new Promise((V=>{if(!(Q instanceof vx.c))return void V(O);const o=Q.getTypeID()==vx.c.LIGHTTYPEID_POINTLIGHT?"point":Q.getTypeID()==vx.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":Q.getTypeID()==vx.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!o||!(Q instanceof XO.c))return W.e.Warn(`${x}: Light ${Q.name} is not supported in ${ZO}`),void V(O);if(Q.falloffType!==vx.c.FALLOFF_GLTF&&W.e.Warn(`${x}: Light falloff for ${Q.name} does not match the ${ZO} specification!`),!Q.position.equalsToFloats(0,0,0)){const x=X.j.Oo[0].V(Q.position);n&&P(x),O.translation=x.mV()}if("point"!==o){const x=Q.direction.normalizeToRef(X.j.Oo[0]);n&&P(x);const Z=X.g.FromUnitVectorsToRef(oO,x,X.j.Quaternion[0]);X.g.IsIdentity(Z)||(O.rotation=Z.mV())}const l={type:o,name:Q.name,color:Q.No.mV(),ho:Q.ho,range:Q.range};if(Xx(l,nO),"spot"===o){const x=Q;l.spot={innerConeAngle:x.innerAngle/2,outerConeAngle:x.angle/2},Xx(l.spot,VO)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(l);const C={IV:this._lights.lights.length-1},U=Q.parent;if(U&&Ox(Q,U)){const x=Z.get(U);if(x){const Q=this._exporter._nodes[x];return xx(O,Q),Q.extensions||(Q.extensions={}),Q.extensions[ZO]=C,void V(null)}}O.extensions||(O.extensions={}),O.extensions[ZO]=C,V(O)}))}}Tx.RegisterExtension(ZO,(x=>new lO(x)));var CO=Q(11415);const UO="KHR_materials_anisotropy";class LO{constructor(x){this.name=UO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=x}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(x,O,Q){const X=[];return Q instanceof CO.b&&Q.anisotropy.isEnabled&&!Q.anisotropy.legacy?(Q.anisotropy.texture&&X.push(Q.anisotropy.texture),X):[]}postExportMaterialAsync(x,O,Q){return new Promise((x=>{if(Q instanceof CO.b){if(!Q.anisotropy.isEnabled||Q.anisotropy.legacy)return void x(O);this._wasUsed=!0,O.extensions=O.extensions||{};const X=this._exporter._materialExporter.getTextureInfo(Q.anisotropy.texture),Z={anisotropyStrength:Q.anisotropy.ho,anisotropyRotation:Q.anisotropy.angle,anisotropyTexture:X??void 0};null!==Z.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(Q),O.extensions[UO]=Z}x(O)}))}}Tx.RegisterExtension(UO,(x=>new LO(x)));const hO="KHR_materials_clearcoat";class NO{constructor(x){this.name=hO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=x}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(x,O,Q){const X=[];return Q instanceof CO.b&&Q.clearCoat.isEnabled?(Q.clearCoat.texture&&X.push(Q.clearCoat.texture),!Q.clearCoat.useRoughnessFromMainTexture&&Q.clearCoat.textureRoughness&&X.push(Q.clearCoat.textureRoughness),Q.clearCoat.bumpTexture&&X.push(Q.clearCoat.bumpTexture),X):[]}postExportMaterialAsync(x,O,Q){return new Promise((x=>{if(Q instanceof CO.b){if(!Q.clearCoat.isEnabled)return void x(O);this._wasUsed=!0,O.extensions=O.extensions||{};const X=this._exporter._materialExporter.getTextureInfo(Q.clearCoat.texture);let n;n=Q.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(Q.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(Q.clearCoat.textureRoughness),Q.clearCoat.isTintEnabled&&Z.g.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${Q.name}`),Q.clearCoat.remapF0OnInterfaceChange&&Z.g.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${Q.name}`);const V=this._exporter._materialExporter.getTextureInfo(Q.clearCoat.bumpTexture),o={clearcoatFactor:Q.clearCoat.ho,clearcoatTexture:X??void 0,clearcoatRoughnessFactor:Q.clearCoat.roughness,clearcoatRoughnessTexture:n??void 0,clearcoatNormalTexture:V??void 0};null===o.clearcoatTexture&&null===o.clearcoatRoughnessTexture&&null===o.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Q),O.extensions[hO]=o}x(O)}))}}Tx.RegisterExtension(hO,(x=>new NO(x)));const aO="KHR_materials_diffuse_transmission";function KO(x,O){const Q=O.subSurface;let X=null;return Q.translucencyIntensityTexture?X=Q.translucencyIntensityTexture:Q.thicknessTexture&&Q.useMaskFromThicknessTexture&&(X=Q.thicknessTexture),X&&!Q.useGltfStyleTextures?(W.e.Warn(`${x}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${O.name}`,1),null):X}class MO{constructor(x){this.name=aO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=x}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(x,O,Q){const X=[];if(Q instanceof ax.d&&this._isExtensionEnabled(Q)){const O=KO(x,Q);return O&&X.push(O),Q.subSurface.translucencyColorTexture&&X.push(Q.subSurface.translucencyColorTexture),X}return X}_isExtensionEnabled(x){if(x.unlit)return!1;const O=x.subSurface;return!!O.isTranslucencyEnabled&&(!x.unlit&&!O.useAlbedoToTintTranslucency&&O.useGltfStyleTextures&&1===O.volumeIndexOfRefraction&&0===O.minimumThickness&&0===O.maximumThickness)}postExportMaterialAsync(x,O,Q){return new Promise((X=>{if(Q instanceof ax.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const X=Q.subSurface,Z=KO(x,Q),n=0==X.translucencyIntensity?void 0:X.translucencyIntensity,V=this._exporter._materialExporter.getTextureInfo(Z)??void 0,o=!X.translucencyColor||X.translucencyColor.equalsFloats(1,1,1)?void 0:X.translucencyColor.mV(),l=this._exporter._materialExporter.getTextureInfo(X.translucencyColorTexture)??void 0,C={diffuseTransmissionFactor:n,diffuseTransmissionTexture:V,diffuseTransmissionColorFactor:o,diffuseTransmissionColorTexture:l};(V||l)&&this._exporter._materialNeedsUVsSet.add(Q),O.extensions=O.extensions||{},O.extensions[aO]=C}X(O)}))}}Tx.RegisterExtension(aO,(x=>new MO(x)));const YO="KHR_materials_dispersion";class gO{constructor(){this.name=YO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(x){if(x.unlit)return!1;const O=x.subSurface;return!(!O.isRefractionEnabled&&!O.isDispersionEnabled)}postExportMaterialAsync(x,O,Q){return new Promise((x=>{if(Q instanceof ax.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const x={dispersion:Q.subSurface.dispersion};O.extensions=O.extensions||{},O.extensions[YO]=x}x(O)}))}}Tx.RegisterExtension(YO,(()=>new gO));const vO="KHR_materials_emissive_strength";class RO{constructor(){this.name=vO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(x,O,Q){return await new Promise((x=>{if(!(Q instanceof ax.d))return x(O);const X=Q.emissiveColor.mV(),Z=Math.max(...X);if(Z>1){this._wasUsed=!0,O.extensions||(O.extensions={});const x={emissiveStrength:Z},X=Q.emissiveColor.scale(1/x.emissiveStrength);O.emissiveFactor=X.mV(),O.extensions[vO]=x}return x(O)}))}}Tx.RegisterExtension(vO,(x=>new RO));const sO="KHR_materials_ior";class qO{constructor(){this.name=sO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(x){return!x.unlit&&(void 0!=x.indexOfRefraction&&1.5!=x.indexOfRefraction)}postExportMaterialAsync(x,O,Q){return new Promise((x=>{if(Q instanceof ax.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const x={ior:Q.indexOfRefraction};O.extensions=O.extensions||{},O.extensions[sO]=x}x(O)}))}}Tx.RegisterExtension(sO,(x=>new qO));const GO="KHR_materials_iridescence";class kO{constructor(x){this.name=GO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=x}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(x,O,Q){const X=[];return Q instanceof CO.b&&Q.iridescence.isEnabled?(Q.iridescence.texture&&X.push(Q.iridescence.texture),Q.iridescence.thicknessTexture&&Q.iridescence.thicknessTexture!==Q.iridescence.texture&&X.push(Q.iridescence.thicknessTexture),X):[]}postExportMaterialAsync(x,O,Q){return new Promise((x=>{if(Q instanceof CO.b){if(!Q.iridescence.isEnabled)return void x(O);this._wasUsed=!0,O.extensions=O.extensions||{};const X=this._exporter._materialExporter.getTextureInfo(Q.iridescence.texture),Z=this._exporter._materialExporter.getTextureInfo(Q.iridescence.thicknessTexture),n={iridescenceFactor:Q.iridescence.ho,iridescenceIor:Q.iridescence.indexOfRefraction,iridescenceThicknessMinimum:Q.iridescence.minimumThickness,iridescenceThicknessMaximum:Q.iridescence.maximumThickness,iridescenceTexture:X??void 0,iridescenceThicknessTexture:Z??void 0};null===n.iridescenceTexture&&null===n.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(Q),O.extensions[GO]=n}x(O)}))}}Tx.RegisterExtension(GO,(x=>new kO(x)));const JO="KHR_materials_sheen";class tO{constructor(x){this.name=JO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=x}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(x,O,Q){return Q instanceof ax.d&&Q.sheen.isEnabled&&Q.sheen.texture?[Q.sheen.texture]:[]}async postExportMaterialAsync(x,O,Q){return await new Promise((x=>{if(Q instanceof ax.d){if(!Q.sheen.isEnabled)return void x(O);this._wasUsed=!0,null==O.extensions&&(O.extensions={});const X={sheenColorFactor:Q.sheen.color.mV(),sheenRoughnessFactor:Q.sheen.roughness??0};null===X.sheenColorTexture&&null===X.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Q),Q.sheen.texture&&(X.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(Q.sheen.texture)??void 0),Q.sheen.textureRoughness&&!Q.sheen.useRoughnessFromMainTexture?X.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Q.sheen.textureRoughness)??void 0:Q.sheen.texture&&Q.sheen.useRoughnessFromMainTexture&&(X.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Q.sheen.texture)??void 0),O.extensions[JO]=X}x(O)}))}}Tx.RegisterExtension(JO,(x=>new tO(x)));const cO="KHR_materials_specular";class dO{constructor(x){this.name=cO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=x}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(x,O,Q){const X=[];return Q instanceof ax.d&&this._isExtensionEnabled(Q)?(Q.metallicReflectanceTexture&&X.push(Q.metallicReflectanceTexture),Q.reflectanceTexture&&X.push(Q.reflectanceTexture),X):X}_isExtensionEnabled(x){return!x.unlit&&(void 0!=x.metallicF0Factor&&1!=x.metallicF0Factor||void 0!=x.metallicReflectanceColor&&!x.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(x))}_hasTexturesExtension(x){return null!=x.metallicReflectanceTexture||null!=x.reflectanceTexture}postExportMaterialAsync(x,O,Q){return new Promise((x=>{if(Q instanceof ax.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0,O.extensions=O.extensions||{};const x=this._exporter._materialExporter.getTextureInfo(Q.metallicReflectanceTexture)??void 0,X=this._exporter._materialExporter.getTextureInfo(Q.reflectanceTexture)??void 0,Z={specularFactor:1==Q.metallicF0Factor?void 0:Q.metallicF0Factor,specularTexture:x,specularColorFactor:Q.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:Q.metallicReflectanceColor.mV(),specularColorTexture:X};this._hasTexturesExtension(Q)&&this._exporter._materialNeedsUVsSet.add(Q),O.extensions[cO]=Z}x(O)}))}}Tx.RegisterExtension(cO,(x=>new dO(x)));const uO="KHR_materials_transmission";class AO{constructor(x){this.name=uO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=x}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(x,O,Q){const X=[];return Q instanceof ax.d&&this._isExtensionEnabled(Q)?(Q.subSurface.thicknessTexture&&X.push(Q.subSurface.thicknessTexture),X):X}_isExtensionEnabled(x){if(x.unlit)return!1;const O=x.subSurface;return O.isRefractionEnabled&&void 0!=O.refractionIntensity&&0!=O.refractionIntensity||this._hasTexturesExtension(x)}_hasTexturesExtension(x){return null!=x.subSurface.refractionIntensityTexture}async postExportMaterialAsync(x,O,Q){if(Q instanceof ax.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const X=Q.subSurface,Z={transmissionFactor:0===X.refractionIntensity?void 0:X.refractionIntensity};if(this._hasTexturesExtension(Q)&&this._exporter._materialNeedsUVsSet.add(Q),X.refractionIntensityTexture)if(X.useGltfStyleTextures){const x=await this._exporter._materialExporter.exportTextureAsync(X.refractionIntensityTexture,"image/png");x&&(Z.transmissionTexture=x)}else W.e.Warn(`${x}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);O.extensions||(O.extensions={}),O.extensions[uO]=Z}return O}}Tx.RegisterExtension(uO,(x=>new AO(x)));const fO="KHR_materials_unlit";class EO{constructor(){this.name=fO,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(x,O,Q){return new Promise((x=>{let X=!1;Q instanceof ax.d?X=Q.unlit:Q instanceof Kx.d&&(X=Q.disableLighting),X&&(this._wasUsed=!0,null==O.extensions&&(O.extensions={}),O.extensions[fO]={}),x(O)}))}}Tx.RegisterExtension(fO,(()=>new EO));const zO="KHR_materials_volume";class FO{constructor(x){this.name=zO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=x}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(x,O,Q){const X=[];return Q instanceof ax.d&&this._isExtensionEnabled(Q)?(Q.subSurface.thicknessTexture&&X.push(Q.subSurface.thicknessTexture),X):X}_isExtensionEnabled(x){if(x.unlit)return!1;const O=x.subSurface;return!(!O.isRefractionEnabled&&!O.isTranslucencyEnabled)&&(void 0!=O.maximumThickness&&0!=O.maximumThickness||void 0!=O.tintColorAtDistance&&O.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=O.tintColor&&O.tintColor!=M.d.White()||this._hasTexturesExtension(x))}_hasTexturesExtension(x){return null!=x.subSurface.thicknessTexture}postExportMaterialAsync(x,O,Q){return new Promise((x=>{if(Q instanceof ax.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const x=Q.subSurface,X={thicknessFactor:0==x.maximumThickness?void 0:x.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(x.thicknessTexture)??void 0,attenuationDistance:x.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:x.tintColorAtDistance,attenuationColor:x.tintColor.equalsFloats(1,1,1)?void 0:x.tintColor.mV()};this._hasTexturesExtension(Q)&&this._exporter._materialNeedsUVsSet.add(Q),O.extensions=O.extensions||{},O.extensions[zO]=X}x(O)}))}}Tx.RegisterExtension(zO,(x=>new FO(x)));const bO="EXT_materials_diffuse_roughness";class DO{constructor(x){this.name=bO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=x}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(x,O,Q){const X=[];return Q instanceof CO.b&&Q._baseDiffuseRoughness?(Q._baseDiffuseRoughnessTexture&&X.push(Q._baseDiffuseRoughnessTexture),X):[]}postExportMaterialAsync(x,O,Q){return new Promise((x=>{if(Q instanceof CO.b){if(!Q._baseDiffuseRoughness)return void x(O);this._wasUsed=!0,O.extensions=O.extensions||{};const X=this._exporter._materialExporter.getTextureInfo(Q._baseDiffuseRoughnessTexture),Z={diffuseRoughnessFactor:Q._baseDiffuseRoughness,diffuseRoughnessTexture:X??void 0};null!==Z.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(Q),O.extensions[bO]=Z}x(O)}))}}Tx.RegisterExtension(bO,(x=>new DO(x)));const WO="KHR_texture_transform";class yO{constructor(){this.name=WO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(x,O,Q){if(Q.kx()||Z.g.Warn(`${x}: /*@__KEY__*/"scene" is not defined for Babylon texture ${Q.name}!`),(0!==Q.uAng||0!==Q.vAng)&&(Z.g.Warn(`${x}: Texture ${Q.name} with rotation in the u or v axis is not supported in glTF.`),0!==Q.uRotationCenter||0!==Q.vRotationCenter))return;const X={};let n=!1;if(0===Q.uOffset&&0===Q.vOffset||(X.offset=[Q.uOffset,Q.vOffset],n=!0),1===Q.uScale&&1===Q.vScale||(X.scale=[Q.uScale,Q.vScale],n=!0),0!==Q.wAng){if(0!==Q.uRotationCenter||0!==Q.vRotationCenter){if(Q.homogeneousRotationInUVTransform&&Q.uScale!==Q.vScale)return void Z.g.Warn(`${x}: Texture ${Q.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${WO}.`);Z.g.Warn(`${x}: Texture ${Q.name} with non-origin rotation center will be exported using an adjusted offset with ${WO}.`),X.offset=function(x){const{uOffset:O,vOffset:Q,uRotationCenter:X,vRotationCenter:Z,uScale:n,vScale:V,wAng:o}=x,l=Math.cos(o),C=Math.sin(o),U=X*n,L=Z*V;return[O+(U*(1-l)+L*C),Q+(L*(1-l)-U*C)]}(Q)}X.rotation=-Q.wAng,n=!0}0!==Q.coordinatesIndex&&(X.texCoord=Q.coordinatesIndex,n=!0),n&&(this._wasUsed=!0,O.extensions||(O.extensions={}),O.extensions[WO]=X)}}Tx.RegisterExtension(WO,(()=>new yO));class IO{static CreateSTL(x){let O=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",Z=arguments.length>3&&void 0!==arguments[3]&&arguments[3],n=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],V=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],l=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const C=function(x,O,Q){const Z=[3*x[Q],3*x[Q+1],3*x[Q+2]],n=[new X.n(O[Z[0]],O[Z[0]+2],O[Z[0]+1]),new X.n(O[Z[1]],O[Z[1]+2],O[Z[1]+1]),new X.n(O[Z[2]],O[Z[2]+2],O[Z[2]+1])],V=n[0].hQ(n[1]),o=n[2].hQ(n[1]);return{v:n,n:X.n.Cross(o,V).normalize()}},L=function(x,O,Q,X){return O=h(x,O,Q.x,X),O=h(x,O,Q.y,X),h(x,O,Q.z,X)},h=function(x,O,Q,X){return x.setFloat32(O,Q,X),O+4},a=function(x){if(o){let O=x;x instanceof N.d&&(O=x.sourceMesh);const Q=O.getVerticesData(U.g.PositionKind,!0,!0);if(!Q)return[];const Z=X.n.Zero();let n;for(n=0;n<Q.length;n+=3)X.n.TransformCoordinatesFromFloatsToRef(Q[n],Q[n+1],Q[n+2],x.HV(!0),Z).toArray(Q,n);return Q}return x.getVerticesData(U.g.PositionKind)||[]};o&&(V=!0);let K="",M=0,Y=0;if(Z){for(let Q=0;Q<x.length;Q++){const O=x[Q].pV();M+=O?O.length/3:0}const O=new ArrayBuffer(84+50*M);K=new DataView(O),Y+=80,K.setUint32(Y,M,n),Y+=4}else l||(K="solid stlmesh\r\n");for(let X=0;X<x.length;X++){const O=x[X];!Z&&l&&(K+="solid "+O.name+"\r\n"),!V&&O instanceof gx.b&&O.bakeCurrentTransformIntoVertices();const Q=a(O),o=O.pV()||[];for(let x=0;x<o.length;x+=3){const O=C(o,Q,x);Z?(Y=L(K,Y,O.n,n),Y=L(K,Y,O.v[0],n),Y=L(K,Y,O.v[1],n),Y=L(K,Y,O.v[2],n),Y+=2):(K+="\tfacet normal "+O.n.x+" "+O.n.y+" "+O.n.z+"\r\n",K+="\t\touter loop\r\n",K+="\t\t\tvertex "+O.v[0].x+" "+O.v[0].y+" "+O.v[0].z+"\r\n",K+="\t\t\tvertex "+O.v[1].x+" "+O.v[1].y+" "+O.v[1].z+"\r\n",K+="\t\t\tvertex "+O.v[2].x+" "+O.v[2].y+" "+O.v[2].z+"\r\n",K+="\t\tendloop\r\n",K+="\tendfacet\r\n")}!Z&&l&&(K+="endsolid "+name+"\r\n")}if(Z||l||(K+="endsolid stlmesh"),O){const x=document.createElement("a"),O=new Blob([K],{type:"application/octet-stream"});x.href=window.URL.createObjectURL(O),x.download=Q+".stl",x.click()}return K}}function rO(x,O){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const X=[];for(let Z=0;Z<x.length/Q;Z++){const n=x[Z*Q],V=x[Z*Q+1],o=x[Z*Q+2];X.push(`(${n.toPrecision(O.precision)}, ${V.toPrecision(O.precision)}, ${o.toPrecision(O.precision)})`)}return X.join(", ")}function jO(x,O){const Q=[];for(let X=0;X<x.length/2;X++){const Z=x[2*X],n=x[2*X+1];Q.push(`(${Z.toPrecision(O.precision)}, ${(1-n).toPrecision(O.precision)})`)}return Q.join(", ")}function TO(x,O){const Q=x.getVerticesData(U.g.PositionKind),X=x.getVerticesData(U.g.NormalKind);if(Q&&X)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(x){var O;const Q=null!==(O=x.pV())&&void 0!==O&&O.length?x.getTotalIndices():x.getTotalVertices();return Array(Q/3).fill(3).join(", ")}(x)}]\n\t\tint[] faceVertexIndices = [${function(x){const O=x.pV(),Q=[];if(null!==O)for(let X=0;X<O.length;X++)Q.push(O[X]);else{const O=x.getTotalVertices();for(let x=0;x<O;x++)Q.push(x)}return Q.join(", ")}(x)}]\n\t\tnormal3f[] normals = [${rO(X,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${rO(Q,O)}]\n        ${function(x,O){let Q="";for(let Z=0;Z<4;Z++){const X=Z>0?Z:"",n=x.getVerticesData(U.g.UVKind+(X?X+1:""));n&&(Q+=`\n\t\ttexCoord2f[] primvars:st${X} = [${jO(n,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const X=x.getVerticesData(U.g.ColorKind);return X&&(Q+=`\n\tcolor3f[] primvars:displayColor = [${rO(X,O,X.length/x.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),Q}(x,O)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function eO(x,O){return`\n        def "Geometry"\n        {\n        ${TO(x,O)}\n        }\n        `}function BO(x){let O='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return O+=x,fflate.strToU8(O)}function iO(x){const O=x.m;return`( ${HO(O,0)}, ${HO(O,4)}, ${HO(O,8)}, ${HO(O,12)} )`}function HO(x,O){return`(${x[O+0]}, ${x[O+1]}, ${x[O+2]}, ${x[O+3]})`}function SO(x){const O="Object_"+x.uniqueId,Q=function(x){const O=x.getWorldMatrix().clone(),Q=x.kx().useRightHandedSystem;if(!Q){let X=x.parent;for(;X;){if(Vx(X,Q)){O.multiplyToRef(X.getWorldMatrix().invert(),O);break}X=X.parent}}return O.determinant()<0&&Z.g.Warn(`Exporting mesh ${x.name} with negative scale. Result may look incorrect in destination engine.`),O}(x),X=iO(Q);return`def Xform "${O}" (\n\tprepend references = @./geometries/Geometry_${x.SV.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${X}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${x.material.uniqueId}>\n}\n\n`}function pO(x){switch(x){case G.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case G.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case G.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function PO(x){return`(${x.x}, ${x.y})`}function mO(x){return`(${x.r}, ${x.g}, ${x.b})`}function wO(x,O,Q,Z,n,V){const o=x.getInternalTexture().uniqueId+"_"+x.invertY;n[o]=x;const l=x.coordinatesIndex>0?"st"+x.coordinatesIndex:"st",C=new X.l(x.uScale,x.vScale),U=new X.l(x.uOffset,x.vOffset),L=x.wAng,h=Math.sin(L),N=Math.cos(L);return U.y=1-U.y-C.y,U.x+=h*C.x,U.y+=(1-N)*C.y,`\n    def Shader "PrimvarReader_${Q}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${l}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${Q}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${O.uniqueId}/PrimvarReader_${Q}.outputs:result>\n        float inputs:rotation = ${(L*(180/Math.PI)).toFixed(V.precision)}\n        float2 inputs:scale = ${PO(C)}\n        float2 inputs:translation = ${PO(U)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${x.uniqueId}_${Q}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${o}.png@\n        float2 inputs:st.connect = </Materials/Material_${O.uniqueId}/Transform2d_${Q}.outputs:result>\n        ${Z?"float4 inputs:scale = "+function(x){return`(${x.r}, ${x.g}, ${x.b}, 1.0)`}(Z):""}\n        token inputs:sourceColorSpace = "${x.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${pO(x.wrapU)}"\n        token inputs:wrapT = "${pO(x.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${O.needAlphaBlending()?"float outputs:a":""}\n    }`}function xQ(x,O,Q){const X="\t\t\t",Z=[],n=[],{diffuseMap:V,No:o,alphaCutOff:l,emissiveMap:C,emissive:U,normalMap:L,roughnessMap:h,roughnessChannel:N,roughness:a,metalnessMap:K,metalnessChannel:Y,metalness:g,aoMap:v,aoMapChannel:R,aoMapIntensity:s,alphaMap:q,ior:G,clearCoatEnabled:k,clearCoat:J,clearCoatMap:t,clearCoatRoughness:c,clearCoatRoughnessMap:d}=function(x){const O={diffuseMap:null,No:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return x instanceof Kx.d?{...O,diffuseMap:x.diffuseTexture,No:x.diffuseColor,alphaCutOff:x.alphaCutOff,emissiveMap:x.emissiveTexture,emissive:x.emissiveColor,roughness:1,alphaMap:x.opacityTexture}:x instanceof CO.b?{...O,diffuseMap:x._albedoTexture,No:x._albedoColor,alphaCutOff:x._alphaCutOff,emissiveMap:x._emissiveTexture,emissive:x._emissiveColor,normalMap:x._bumpTexture,roughnessMap:x._metallicTexture,roughnessChannel:x._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:x._roughness??1,metalnessMap:x._metallicTexture,metalnessChannel:x._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:x._metallic??0,aoMap:x._ambientTexture,aoMapChannel:x._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:x._ambientTextureStrength,alphaMap:x._opacityTexture,ior:x.subSurface.indexOfRefraction,clearCoatEnabled:x.clearCoat.isEnabled,clearCoat:x.clearCoat.ho,clearCoatMap:x.clearCoat.texture,clearCoatRoughness:x.clearCoat.roughness,clearCoatRoughnessMap:x.clearCoat.useRoughnessFromMainTexture?x.clearCoat.texture:x.clearCoat.textureRoughness}:O}(x);return null!==V?(Z.push(`${X}color3f inputs:diffuseColor.connect = </Materials/Material_${x.uniqueId}/Texture_${V.uniqueId}_diffuse.outputs:rgb>`),x.needAlphaBlending()?Z.push(`${X}float inputs:opacity.connect = </Materials/Material_${x.uniqueId}/Texture_${V.uniqueId}_diffuse.outputs:a>`):x.needAlphaTesting()&&(Z.push(`${X}float inputs:opacity.connect = </Materials/Material_${x.uniqueId}/Texture_${V.uniqueId}_diffuse.outputs:a>`),Z.push(`${X}float inputs:opacityThreshold = ${l}`)),n.push(wO(V,x,"diffuse",o,O,Q))):Z.push(`${X}color3f inputs:diffuseColor = ${mO(o||M.d.White())}`),null!==C?(Z.push(`${X}color3f inputs:emissiveColor.connect = </Materials/Material_${x.uniqueId}/Texture_${C.uniqueId}_emissive.outputs:rgb>`),n.push(wO(C,x,"emissive",U,O,Q))):U&&U.toLuminance()>0&&Z.push(`${X}color3f inputs:emissiveColor = ${mO(U)}`),null!==L&&(Z.push(`${X}normal3f inputs:normal.connect = </Materials/Material_${x.uniqueId}/Texture_${L.uniqueId}_normal.outputs:rgb>`),n.push(wO(L,x,"QQ",null,O,Q))),null!==v&&(Z.push(`${X}float inputs:occlusion.connect = </Materials/Material_${x.uniqueId}/Texture_${v.uniqueId}_occlusion.outputs:${R}>`),n.push(wO(v,x,"occlusion",new M.d(s,s,s),O,Q))),null!==h?(Z.push(`${X}float inputs:roughness.connect = </Materials/Material_${x.uniqueId}/Texture_${h.uniqueId}_roughness.outputs:${N}>`),n.push(wO(h,x,"roughness",new M.d(a,a,a),O,Q))):Z.push(`${X}float inputs:roughness = ${a}`),null!==K?(Z.push(`${X}float inputs:metallic.connect = </Materials/Material_${x.uniqueId}/Texture_${K.uniqueId}_metallic.outputs:${Y}>`),n.push(wO(K,x,"metallic",new M.d(g,g,g),O,Q))):Z.push(`${X}float inputs:metallic = ${g}`),null!==q?(Z.push(`${X}float inputs:opacity.connect = </Materials/Material_${x.uniqueId}/Texture_${q.uniqueId}_opacity.outputs:r>`),Z.push(`${X}float inputs:opacityThreshold = 0.0001`),n.push(wO(q,x,"opacity",null,O,Q))):Z.push(`${X}float inputs:opacity = ${x.alpha}`),k&&(null!==t?(Z.push(`${X}float inputs:clearcoat.connect = </Materials/Material_${x.uniqueId}/Texture_${t.uniqueId}_clearcoat.outputs:r>`),n.push(wO(t,x,"clearcoat",new M.d(J,J,J),O,Q))):Z.push(`${X}float inputs:clearcoat = ${J}`),null!==d?(Z.push(`${X}float inputs:clearcoatRoughness.connect = </Materials/Material_${x.uniqueId}/Texture_${d.uniqueId}_clearcoatRoughness.outputs:g>`),n.push(wO(d,x,"clearcoatRoughness",new M.d(c,c,c),O,Q))):Z.push(`${X}float inputs:clearcoatRoughness = ${c}`)),Z.push(`${X}float inputs:ior = ${G}`),`\n\tdef Material "Material_${x.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${Z.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${x.uniqueId}/PreviewSurface.outputs:surface>\n\n${n.join("\n")}\n\n\t}\n`}async function OQ(x,O,Q){const n={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...O};"undefined"===typeof fflate&&await Z.g.LoadScriptAsync(n.fflateUrl);const V={};V[n.modelFileName]=null;let o='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';o+=function(x){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===x.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${x.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${x.planeAnchoringAlignment}"`:""}\n            `}(n);const l={};for(const X of x.meshes){if(0===X.getTotalVertices())continue;const x=X,O=x.SV,C=x.material;if(!C||!O||Q&&!Q(x))continue;if(-1!==["ao","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(C.getClassName())){const Q="geometries/Geometry_"+O.uniqueId+".usda";if(!(Q in V)){const x=eO(O,n);V[Q]=BO(x)}C.uniqueId in l||(l[C.uniqueId]=C),o+=SO(x)}else Z.g.Warn("USDZExportAsync does not support this material type: "+C.getClassName())}x.activeCamera&&n.exportCamera&&(o+=function(x,O){const Q="Camera_"+x.uniqueId,Z=iO(X.c.RotationY(Math.PI).multiply(x.getWorldMatrix()));if(x.mode===G.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${Q}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${Z}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${x.lo.toPrecision(O.precision)}, ${x.maxZ.toPrecision(O.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(x.orthoLeft||1)+Math.abs(x.orthoRight||1))).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(x.orthoTop||1)+Math.abs(x.orthoBottom||1))).toPrecision(O.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const X=x.getEngine().getAspectRatio(x),n=O.cameraSensorWidth||35;return`def Camera "${Q}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${Z}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${x.lo.toPrecision(O.precision)}, ${x.maxZ.toPrecision(O.precision)})\n\t\t\tfloat focalLength = ${(n/(2*Math.tan(.5*x.fov))).toPrecision(O.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(n*X).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(n/X).toPrecision(O.precision)}            \n\t\t}\n\t\n\t`}}(x.activeCamera,n)),o+="\n            }\n        }\n    }";const C={};o+=function(x,O,Q){const X=[];for(const Z in x){const n=x[Z];X.push(xQ(n,O,Q))}return`\n    def "Materials"\n{\n${X.join("")}\n}\n\n`}(l,C,n),V[n.modelFileName]=fflate.strToU8(o);for(const X in C){const x=C[X],O=x.getSize(),Q=await x.readPixels();if(!Q)throw new Error("Texture data is not available");const Z=await k.DumpTools.DumpDataAsync(O.width,O.height,Q,"image/png",void 0,!1,!0);V[`textures/Texture_${X}.png`]=new Uint8Array(Z).slice()}let U=0;for(const X in V){const x=V[X];if(!x)continue;U+=34+X.length;const O=63&U;if(4!==O){const Q=new Uint8Array(64-O);V[X]=[x,{extra:{12345:Q}}]}U=x.length}return fflate.zipSync(V,{level:0})}}}]);