"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10342:(G,D,N)=>{N.r(D),N.d(D,{_HDRTextureLoader:()=>v});var T=N(1009);class o{static ConvertPanoramaToCubemap(G,D,N,T){let o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!G)throw"ConvertPanoramaToCubemap: input cannot be null";if(G.length!=D*N*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(T,this.FACE_FRONT,G,D,N,o),back:this.CreateCubemapTexture(T,this.FACE_BACK,G,D,N,o),left:this.CreateCubemapTexture(T,this.FACE_LEFT,G,D,N,o),right:this.CreateCubemapTexture(T,this.FACE_RIGHT,G,D,N,o),up:this.CreateCubemapTexture(T,this.FACE_UP,G,D,N,o),down:this.CreateCubemapTexture(T,this.FACE_DOWN,G,D,N,o),size:T,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(G,D,N,T,o){let Z=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const n=new ArrayBuffer(G*G*4*3),C=new Float32Array(n),P=Z?Math.max(1,Math.round(T/4/G)):1,r=1/P,v=r*r,q=D[1].Jc(D[0]).scale(r/G),g=D[3].Jc(D[2]).scale(r/G),X=1/G;let W=0;for(let j=0;j<G;j++)for(let Z=0;Z<P;Z++){let Z=D[0],n=D[2];for(let D=0;D<G;D++)for(let r=0;r<P;r++){const P=n.Jc(Z).scale(W).add(Z);P.normalize();const r=this.CalcProjectionSpherical(P,N,T,o);C[j*G*3+3*D+0]+=r.r*v,C[j*G*3+3*D+1]+=r.g*v,C[j*G*3+3*D+2]+=r.b*v,Z=Z.add(q),n=n.add(g)}W+=X*r}return C}static CalcProjectionSpherical(G,D,N,T){let o=Math.atan2(G.z,G.x);const Z=Math.acos(G.y);for(;o<-Math.PI;)o+=2*Math.PI;for(;o>Math.PI;)o-=2*Math.PI;let n=o/Math.PI;const C=Z/Math.PI;n=.5*n+.5;let P=Math.round(n*N);P<0?P=0:P>=N&&(P=N-1);let r=Math.round(C*T);r<0?r=0:r>=T&&(r=T-1);const v=T-r-1;return{r:D[v*N*3+3*P+0],g:D[v*N*3+3*P+1],b:D[v*N*3+3*P+2]}}}function Z(G,D,N,T,o,Z){o>0?(o=function(G,D){return D>1023?G*Math.pow(2,1023)*Math.pow(2,D-1023):D<-1074?G*Math.pow(2,-1074)*Math.pow(2,D+1074):G*Math.pow(2,D)}(1,o-136),G[Z+0]=D*o,G[Z+1]=N*o,G[Z+2]=T*o):(G[Z+0]=0,G[Z+1]=0,G[Z+2]=0)}function n(G,D){let N="",T="";for(let o=D;o<G.length-D&&(T=String.fromCharCode(G[o]),"\n"!=T);o++)N+=T;return N}function C(G){let D=0,N=0,T=n(G,0);if("#"!=T[0]||"?"!=T[1])throw"Bad HDR Format.";let o=!1,Z=!1,C=0;do{C+=T.length+1,T=n(G,C),"FORMAT=32-bit_rle_rgbe"==T?Z=!0:0==T.length&&(o=!0)}while(!o);if(!Z)throw"HDR Bad header format, unsupported FORMAT";C+=T.length+1,T=n(G,C);const P=/^-Y (.*) \+X (.*)$/g.exec(T);if(!P||P.length<3)throw"HDR Bad header format, no size";if(N=parseInt(P[2]),D=parseInt(P[1]),N<8||N>32767)throw"HDR Bad header format, unsupported size";return C+=T.length+1,{height:D,width:N,dataPosition:C}}function P(G,D){return function(G,D){let N=D.height;const T=D.width;let o,n,C,P,v,q=D.dataPosition,g=0,X=0,W=0;const j=new ArrayBuffer(4*T),Y=new Uint8Array(j),y=new ArrayBuffer(D.width*D.height*4*3),h=new Float32Array(y);for(;N>0;){if(o=G[q++],n=G[q++],C=G[q++],P=G[q++],2!=o||2!=n||128&C||D.width<8||D.width>32767)return r(G,D);if((C<<8|P)!=T)throw"HDR Bad header format, wrong scan line width";for(g=0,W=0;W<4;W++)for(X=(W+1)*T;g<X;)if(o=G[q++],n=G[q++],o>128){if(v=o-128,0==v||v>X-g)throw"HDR Bad Format, bad scanline data (run)";for(;v-- >0;)Y[g++]=n}else{if(v=o,0==v||v>X-g)throw"HDR Bad Format, bad scanline data (non-run)";if(Y[g++]=n,--v>0)for(let D=0;D<v;D++)Y[g++]=G[q++]}for(W=0;W<T;W++)o=Y[W],n=Y[W+T],C=Y[W+2*T],P=Y[W+3*T],Z(h,o,n,C,P,(D.height-N)*T*3+3*W);N--}return h}(G,D)}function r(G,D){let N=D.height;const T=D.width;let o,n,C,P,r,v=D.dataPosition;const q=new ArrayBuffer(D.width*D.height*4*3),g=new Float32Array(q);for(;N>0;){for(r=0;r<D.width;r++)o=G[v++],n=G[v++],C=G[v++],P=G[v++],Z(g,o,n,C,P,(D.height-N)*T*3+3*r);N--}return g}o.FACE_LEFT=[new T.s(-1,-1,-1),new T.s(1,-1,-1),new T.s(-1,1,-1),new T.s(1,1,-1)],o.FACE_RIGHT=[new T.s(1,-1,1),new T.s(-1,-1,1),new T.s(1,1,1),new T.s(-1,1,1)],o.FACE_FRONT=[new T.s(1,-1,-1),new T.s(1,-1,1),new T.s(1,1,-1),new T.s(1,1,1)],o.FACE_BACK=[new T.s(-1,-1,1),new T.s(-1,-1,-1),new T.s(-1,1,1),new T.s(-1,1,-1)],o.FACE_DOWN=[new T.s(1,1,-1),new T.s(1,1,1),new T.s(-1,1,-1),new T.s(-1,1,1)],o.FACE_UP=[new T.s(-1,-1,-1),new T.s(-1,-1,1),new T.s(1,-1,-1),new T.s(1,-1,1)];class v{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(G,D,N){const T=new Uint8Array(G.buffer,G.byteOffset,G.byteLength),o=C(T),Z=P(T,o),n=o.width*o.height,r=new Float32Array(4*n);for(let C=0;C<n;C+=1)r[4*C]=Z[3*C],r[4*C+1]=Z[3*C+1],r[4*C+2]=Z[3*C+2],r[4*C+3]=1;N(o.width,o.height,D.generateMipMaps,!1,(()=>{const G=D.getEngine();D.type=1,D.format=5,D._gammaSpace=!1,G._uploadDataToTextureDirectly(D,r)}))}}}}]);