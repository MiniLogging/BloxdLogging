"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{2422:(J,T,b)=>{b.r(T),b.d(T,{_BasisTextureLoader:()=>u});var q,t=b(505),j=b(2319),B=b(615);function Y(){const J=0,T=1,b=2,q=3,t=6,j=8,B=9,Y=10,C=14;let F=null;function A(J,T,b,q,t){const j=J.getImageTranscodedSizeInBytes(T,b,q);let B=new Uint8Array(j);if(!J.transcodeImage(B,T,b,q,1,0))return null;if(t){B=function(J,T,b,q){const t=new Uint16Array(4),j=new Uint16Array(b*q),B=b/4,Y=q/4;for(let C=0;C<Y;C++)for(let q=0;q<B;q++){const Y=T+8*(C*B+q);t[0]=J[Y]|J[Y+1]<<8,t[1]=J[Y+2]|J[Y+3]<<8,t[2]=(2*(31&t[0])+1*(31&t[1]))/3|(2*(2016&t[0])+1*(2016&t[1]))/3&2016|(2*(63488&t[0])+1*(63488&t[1]))/3&63488,t[3]=(2*(31&t[1])+1*(31&t[0]))/3|(2*(2016&t[1])+1*(2016&t[0]))/3&2016|(2*(63488&t[1])+1*(63488&t[0]))/3&63488;for(let T=0;T<4;T++){const B=J[Y+4+T];let F=(4*C+T)*b+4*q;j[F++]=t[3&B],j[F++]=t[B>>2&3],j[F++]=t[B>>4&3],j[F++]=t[B>>6&3]}}return j}(B,0,J.getImageWidth(T,b)+3&-4,J.getImageHeight(T,b)+3&-4)}return B}onmessage=a=>{if("init"===a.data.action){if(a.data.url)try{importScripts(a.data.url)}catch(P){postMessage({action:"error",error:P})}F||(F=BASIS({wasmBinary:a.data.wasmBinary})),null!==F&&F.then((J=>{BASIS=J,J.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===a.data.action){const F=a.data.config,P=a.data.imageData,v=new BASIS.BasisFile(P),G=function(J){const T=J.getHasAlpha(),b=J.getNumImages(),q=[];for(let t=0;t<b;t++){const T={levels:[]},b=J.getNumLevels(t);for(let q=0;q<b;q++){const b={width:J.getImageWidth(t,q),height:J.getImageHeight(t,q)};T.levels.push(b)}q.push(T)}return{Fj:T,images:q}}(v);let x=a.data.ignoreSupportedFormats?null:function(F,A){let a=null;F.supportedCompressionFormats&&(a=F.supportedCompressionFormats.astc?Y:F.supportedCompressionFormats.bc7?t:F.supportedCompressionFormats.s3tc?A.Fj?q:b:F.supportedCompressionFormats.pvrtc?A.Fj?B:j:F.supportedCompressionFormats.etc2?T:F.supportedCompressionFormats.etc1?J:C);return a}(a.data.config,G),I=!1;null===x&&(I=!0,x=G.Fj?q:b);let u=!0;v.startTranscoding()||(u=!1);const U=[];for(let J=0;J<G.images.length&&u;J++){const T=G.images[J];if(void 0===F.loadSingleImage||F.loadSingleImage===J){let b=T.levels.length;!1===F.loadMipmapLevels&&(b=1);for(let q=0;q<b;q++){const b=T.levels[q],t=A(v,J,q,x,I);if(!t){u=!1;break}b.transcodedPixels=t,U.push(b.transcodedPixels.buffer)}}}v.close(),v.delete(),I&&(x=-1),u?postMessage({action:"transcode",success:u,id:a.data.id,fileInfo:G,format:x},U):postMessage({action:"transcode",success:u,id:a.data.id})}}}!function(J){J[J.cTFETC1=0]="cTFETC1",J[J.cTFETC2=1]="cTFETC2",J[J.cTFBC1=2]="cTFBC1",J[J.cTFBC3=3]="cTFBC3",J[J.cTFBC4=4]="cTFBC4",J[J.cTFBC5=5]="cTFBC5",J[J.cTFBC7=6]="cTFBC7",J[J.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",J[J.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",J[J.cTFASTC_4x4=10]="cTFASTC_4x4",J[J.cTFATC_RGB=11]="cTFATC_RGB",J[J.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",J[J.cTFRGBA32=13]="cTFRGBA32",J[J.cTFRGB565=14]="cTFRGB565",J[J.cTFBGR565=15]="cTFBGR565",J[J.cTFRGBA4444=16]="cTFRGBA4444",J[J.cTFFXT1_RGB=17]="cTFFXT1_RGB",J[J.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",J[J.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",J[J.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",J[J.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(q||(q={}));const C={JSModuleURL:`${t.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${t.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let F=null,A=null,a=0;const P=async()=>(F||(F=new Promise(((J,T)=>{A?J(A):t.e.LoadFileAsync(t.e.GetBabylonScriptURL(C.WasmModuleURL)).then((b=>{if("function"!==typeof URL)return T("Basis transcoder requires an environment with a URL constructor");const q=URL.createObjectURL(new Blob([`(${Y})()`],{type:"application/javascript"}));A=new Worker(q),async function(J,T,b){return await new Promise(((q,j)=>{const B=T=>{"init"===T.data.action?(J.removeEventListener("message",B),q(J)):"error"===T.data.action&&j(T.data.error||"error initializing worker")};J.addEventListener("message",B),J.postMessage({action:"init",url:b?t.e.GetBabylonScriptURL(b):void 0,wasmBinary:T},[T])}))}(A,b,C.JSModuleURL).then(J,T)})).catch(T)}))),await F),v=async(J,T)=>{const b=J instanceof ArrayBuffer?new Uint8Array(J):J;return await new Promise(((J,q)=>{P().then((()=>{const t=a++,j=T=>{"transcode"===T.data.action&&T.data.id===t&&(A.removeEventListener("message",j),T.data.success?J(T.data):q("Transcode is not supported on this device"))};A.addEventListener("message",j);const B=new Uint8Array(b.byteLength);B.set(new Uint8Array(b.buffer,b.byteOffset,b.byteLength)),A.postMessage({action:"transcode",id:t,imageData:B,config:T,ignoreSupportedFormats:false},[B.buffer])}),(J=>{q(J)}))}))},G=(J,T)=>{var b;let q=null===(b=T._gl)||void 0===b?void 0:b.TEXTURE_2D;var t;J.isCube&&(q=null===(t=T._gl)||void 0===t?void 0:t.TEXTURE_CUBE_MAP);T._bindTextureDirectly(q,J,!0)},x=(J,T)=>{const b=J.getEngine();for(let Y=0;Y<T.fileInfo.images.length;Y++){const C=T.fileInfo.images[Y].levels[0];if(J._invertVScale=J.invertY,-1===T.format||T.format===q.cTFRGB565)if(J.type=10,J.format=4,!b._features.basisNeedsPOT||Math.log2(C.width)%1===0&&Math.log2(C.height)%1===0)J._invertVScale=!J.invertY,J.width=C.width+3&-4,J.height=C.height+3&-4,J.samplingMode=2,G(J,b),b._uploadDataToTextureDirectly(J,new Uint16Array(C.transcodedPixels.buffer),Y,0,4,!0);else{const T=new B.d(b,2);J._invertVScale=J.invertY,T.type=10,T.format=4,T.width=C.width+3&-4,T.height=C.height+3&-4,G(T,b),b._uploadDataToTextureDirectly(T,new Uint16Array(C.transcodedPixels.buffer),Y,0,4,!0),b._rescaleTexture(T,J,b.scenes[0],b._getInternalFormat(4),(()=>{b._releaseTexture(T),G(J,b)}))}else{J.width=C.width,J.height=C.height,J.generateMipMaps=T.fileInfo.images[Y].levels.length>1;const q=I.GetInternalFormatFromBasisFormat(T.format,b);J.format=q,G(J,b);const B=T.fileInfo.images[Y].levels;for(let T=0;T<B.length;T++){const t=B[T];b._uploadCompressedDataToTextureDirectly(J,q,t.width,t.height,t.transcodedPixels,Y,T)}!b._features.basisNeedsPOT||Math.log2(J.width)%1===0&&Math.log2(J.height)%1===0||(t.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),J._cachedWrapU=j.b.CLAMP_ADDRESSMODE,J._cachedWrapV=j.b.CLAMP_ADDRESSMODE)}}},I={JSModuleURL:C.JSModuleURL,WasmModuleURL:C.WasmModuleURL,GetInternalFormatFromBasisFormat:(J,T)=>{let b;switch(J){case q.cTFETC1:b=36196;break;case q.cTFBC1:b=33776;break;case q.cTFBC4:b=33779;break;case q.cTFASTC_4x4:b=37808;break;case q.cTFETC2:b=37496;break;case q.cTFBC7:b=36492}if(void 0===b)throw"The chosen Basis transcoder format is not currently supported";return b},TranscodeAsync:v,LoadTextureFromTranscodeResult:x};Object.defineProperty(I,"JSModuleURL",{get:function(){return C.JSModuleURL},set:function(J){C.JSModuleURL=J}}),Object.defineProperty(I,"WasmModuleURL",{get:function(){return C.WasmModuleURL},set:function(J){C.WasmModuleURL=J}});class u{constructor(){this.supportCascades=!1}loadCubeData(J,T,b,q,j){if(Array.isArray(J))return;const B=T.getEngine().getCaps(),Y={supportedCompressionFormats:{etc1:!!B.etc1,s3tc:!!B.s3tc,pvrtc:!!B.pvrtc,etc2:!!B.etc2,astc:!!B.astc,bc7:!!B.bptc}};v(J,Y).then((J=>{const b=J.fileInfo.images[0].levels.length>1&&T.generateMipMaps;x(T,J),T.getEngine()._setCubeMapTextureParams(T,b),T.isReady=!0,T.onLoadedObservable.notifyObservers(T),T.onLoadedObservable.clear(),q&&q()})).catch((J=>{t.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),T.isReady=!0,j&&j(J)}))}loadData(J,T,b){const q=T.getEngine().getCaps(),j={supportedCompressionFormats:{etc1:!!q.etc1,s3tc:!!q.s3tc,pvrtc:!!q.pvrtc,etc2:!!q.etc2,astc:!!q.astc,bc7:!!q.bptc}};v(J,j).then((J=>{const q=J.fileInfo.images[0].levels[0],t=J.fileInfo.images[0].levels.length>1&&T.generateMipMaps;b(q.width,q.height,t,-1!==J.format,(()=>{x(T,J)}))})).catch((J=>{t.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),t.e.Warn(`Failed to transcode Basis file: ${J}`),b(0,0,!1,!1,(()=>{}),!0)}))}}}}]);