"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{2403:(A,X,s)=>{s.r(X),s.d(X,{_BasisTextureLoader:()=>R});var N,f=s(456),E=s(2281),g=s(592);function K(){const A=0,X=1,s=2,N=3,f=6,E=8,g=9,K=10,r=14;let i=null;function Y(A,X,s,N,f){const E=A.getImageTranscodedSizeInBytes(X,s,N);let g=new Uint8Array(E);if(!A.transcodeImage(g,X,s,N,1,0))return null;if(f){g=function(A,X,s,N){const f=new Uint16Array(4),E=new Uint16Array(s*N),g=s/4,K=N/4;for(let r=0;r<K;r++)for(let N=0;N<g;N++){const K=X+8*(r*g+N);f[0]=A[K]|A[K+1]<<8,f[1]=A[K+2]|A[K+3]<<8,f[2]=(2*(31&f[0])+1*(31&f[1]))/3|(2*(2016&f[0])+1*(2016&f[1]))/3&2016|(2*(63488&f[0])+1*(63488&f[1]))/3&63488,f[3]=(2*(31&f[1])+1*(31&f[0]))/3|(2*(2016&f[1])+1*(2016&f[0]))/3&2016|(2*(63488&f[1])+1*(63488&f[0]))/3&63488;for(let X=0;X<4;X++){const g=A[K+4+X];let i=(4*r+X)*s+4*N;E[i++]=f[3&g],E[i++]=f[g>>2&3],E[i++]=f[g>>4&3],E[i++]=f[g>>6&3]}}return E}(g,0,A.getImageWidth(X,s)+3&-4,A.getImageHeight(X,s)+3&-4)}return g}onmessage=v=>{if("init"===v.data.action){if(v.data.url)try{importScripts(v.data.url)}catch(c){postMessage({action:"error",error:c})}i||(i=BASIS({wasmBinary:v.data.wasmBinary})),null!==i&&i.then((A=>{BASIS=A,A.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===v.data.action){const i=v.data.config,c=v.data.imageData,M=new BASIS.BasisFile(c),d=function(A){const X=A.getHasAlpha(),s=A.getNumImages(),N=[];for(let f=0;f<s;f++){const X={levels:[]},s=A.getNumLevels(f);for(let N=0;N<s;N++){const s={width:A.getImageWidth(f,N),height:A.getImageHeight(f,N)};X.levels.push(s)}N.push(X)}return{Ej:X,images:N}}(M);let Q=v.data.ignoreSupportedFormats?null:function(i,Y){let v=null;i.supportedCompressionFormats&&(v=i.supportedCompressionFormats.astc?K:i.supportedCompressionFormats.bc7?f:i.supportedCompressionFormats.s3tc?Y.Ej?N:s:i.supportedCompressionFormats.pvrtc?Y.Ej?g:E:i.supportedCompressionFormats.etc2?X:i.supportedCompressionFormats.etc1?A:r);return v}(v.data.config,d),w=!1;null===Q&&(w=!0,Q=d.Ej?N:s);let R=!0;M.startTranscoding()||(R=!1);const C=[];for(let A=0;A<d.images.length&&R;A++){const X=d.images[A];if(void 0===i.loadSingleImage||i.loadSingleImage===A){let s=X.levels.length;!1===i.loadMipmapLevels&&(s=1);for(let N=0;N<s;N++){const s=X.levels[N],f=Y(M,A,N,Q,w);if(!f){R=!1;break}s.transcodedPixels=f,C.push(s.transcodedPixels.buffer)}}}M.close(),M.delete(),w&&(Q=-1),R?postMessage({action:"transcode",success:R,id:v.data.id,fileInfo:d,format:Q},C):postMessage({action:"transcode",success:R,id:v.data.id})}}}!function(A){A[A.cTFETC1=0]="cTFETC1",A[A.cTFETC2=1]="cTFETC2",A[A.cTFBC1=2]="cTFBC1",A[A.cTFBC3=3]="cTFBC3",A[A.cTFBC4=4]="cTFBC4",A[A.cTFBC5=5]="cTFBC5",A[A.cTFBC7=6]="cTFBC7",A[A.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",A[A.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",A[A.cTFASTC_4x4=10]="cTFASTC_4x4",A[A.cTFATC_RGB=11]="cTFATC_RGB",A[A.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",A[A.cTFRGBA32=13]="cTFRGBA32",A[A.cTFRGB565=14]="cTFRGB565",A[A.cTFBGR565=15]="cTFBGR565",A[A.cTFRGBA4444=16]="cTFRGBA4444",A[A.cTFFXT1_RGB=17]="cTFFXT1_RGB",A[A.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",A[A.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",A[A.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",A[A.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(N||(N={}));const r={JSModuleURL:`${f.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${f.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let i=null,Y=null,v=0;const c=async()=>(i||(i=new Promise(((A,X)=>{Y?A(Y):f.d.LoadFileAsync(f.d.GetBabylonScriptURL(r.WasmModuleURL)).then((s=>{if("function"!==typeof URL)return X("Basis transcoder requires an environment with a URL constructor");const N=URL.createObjectURL(new Blob([`(${K})()`],{type:"application/javascript"}));Y=new Worker(N),async function(A,X,s){return await new Promise(((N,E)=>{const g=X=>{"init"===X.data.action?(A.removeEventListener("message",g),N(A)):"error"===X.data.action&&E(X.data.error||"error initializing worker")};A.addEventListener("message",g),A.postMessage({action:"init",url:s?f.d.GetBabylonScriptURL(s):void 0,wasmBinary:X},[X])}))}(Y,s,r.JSModuleURL).then(A,X)})).catch(X)}))),await i),M=async(A,X)=>{const s=A instanceof ArrayBuffer?new Uint8Array(A):A;return await new Promise(((A,N)=>{c().then((()=>{const f=v++,E=X=>{"transcode"===X.data.action&&X.data.id===f&&(Y.removeEventListener("message",E),X.data.success?A(X.data):N("Transcode is not supported on this device"))};Y.addEventListener("message",E);const g=new Uint8Array(s.byteLength);g.set(new Uint8Array(s.buffer,s.byteOffset,s.byteLength)),Y.postMessage({action:"transcode",id:f,imageData:g,config:X,ignoreSupportedFormats:false},[g.buffer])}),(A=>{N(A)}))}))},d=(A,X)=>{var s;let N=null===(s=X._gl)||void 0===s?void 0:s.TEXTURE_2D;var f;A.isCube&&(N=null===(f=X._gl)||void 0===f?void 0:f.TEXTURE_CUBE_MAP);X._bindTextureDirectly(N,A,!0)},Q=(A,X)=>{const s=A.getEngine();for(let K=0;K<X.fileInfo.images.length;K++){const r=X.fileInfo.images[K].levels[0];if(A._invertVScale=A.invertY,-1===X.format||X.format===N.cTFRGB565)if(A.type=10,A.format=4,!s._features.basisNeedsPOT||Math.log2(r.width)%1===0&&Math.log2(r.height)%1===0)A._invertVScale=!A.invertY,A.width=r.width+3&-4,A.height=r.height+3&-4,A.samplingMode=2,d(A,s),s._uploadDataToTextureDirectly(A,new Uint16Array(r.transcodedPixels.buffer),K,0,4,!0);else{const X=new g.b(s,2);A._invertVScale=A.invertY,X.type=10,X.format=4,X.width=r.width+3&-4,X.height=r.height+3&-4,d(X,s),s._uploadDataToTextureDirectly(X,new Uint16Array(r.transcodedPixels.buffer),K,0,4,!0),s._rescaleTexture(X,A,s.scenes[0],s._getInternalFormat(4),(()=>{s._releaseTexture(X),d(A,s)}))}else{A.width=r.width,A.height=r.height,A.generateMipMaps=X.fileInfo.images[K].levels.length>1;const N=w.GetInternalFormatFromBasisFormat(X.format,s);A.format=N,d(A,s);const g=X.fileInfo.images[K].levels;for(let X=0;X<g.length;X++){const f=g[X];s._uploadCompressedDataToTextureDirectly(A,N,f.width,f.height,f.transcodedPixels,K,X)}!s._features.basisNeedsPOT||Math.log2(A.width)%1===0&&Math.log2(A.height)%1===0||(f.d.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),A._cachedWrapU=E.d.CLAMP_ADDRESSMODE,A._cachedWrapV=E.d.CLAMP_ADDRESSMODE)}}},w={JSModuleURL:r.JSModuleURL,WasmModuleURL:r.WasmModuleURL,GetInternalFormatFromBasisFormat:(A,X)=>{let s;switch(A){case N.cTFETC1:s=36196;break;case N.cTFBC1:s=33776;break;case N.cTFBC4:s=33779;break;case N.cTFASTC_4x4:s=37808;break;case N.cTFETC2:s=37496;break;case N.cTFBC7:s=36492}if(void 0===s)throw"The chosen Basis transcoder format is not currently supported";return s},TranscodeAsync:M,LoadTextureFromTranscodeResult:Q};Object.defineProperty(w,"JSModuleURL",{get:function(){return r.JSModuleURL},set:function(A){r.JSModuleURL=A}}),Object.defineProperty(w,"WasmModuleURL",{get:function(){return r.WasmModuleURL},set:function(A){r.WasmModuleURL=A}});class R{constructor(){this.supportCascades=!1}loadCubeData(A,X,s,N,E){if(Array.isArray(A))return;const g=X.getEngine().getCaps(),K={supportedCompressionFormats:{etc1:!!g.etc1,s3tc:!!g.s3tc,pvrtc:!!g.pvrtc,etc2:!!g.etc2,astc:!!g.astc,bc7:!!g.bptc}};M(A,K).then((A=>{const s=A.fileInfo.images[0].levels.length>1&&X.generateMipMaps;Q(X,A),X.getEngine()._setCubeMapTextureParams(X,s),X.isReady=!0,X.onLoadedObservable.notifyObservers(X),X.onLoadedObservable.clear(),N&&N()})).catch((A=>{f.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),X.isReady=!0,E&&E(A)}))}loadData(A,X,s){const N=X.getEngine().getCaps(),E={supportedCompressionFormats:{etc1:!!N.etc1,s3tc:!!N.s3tc,pvrtc:!!N.pvrtc,etc2:!!N.etc2,astc:!!N.astc,bc7:!!N.bptc}};M(A,E).then((A=>{const N=A.fileInfo.images[0].levels[0],f=A.fileInfo.images[0].levels.length>1&&X.generateMipMaps;s(N.width,N.height,f,-1!==A.format,(()=>{Q(X,A)}))})).catch((A=>{f.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),f.d.Warn(`Failed to transcode Basis file: ${A}`),s(0,0,!1,!1,(()=>{}),!0)}))}}}}]);