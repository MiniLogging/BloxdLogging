"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10687:(t,b,Y)=>{Y.r(b),Y.d(b,{_HDRTextureLoader:()=>U});var o=Y(1019);class x{static ConvertPanoramaToCubemap(t,b,Y,o){let x=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!t)throw"ConvertPanoramaToCubemap: input cannot be null";if(t.length!=b*Y*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(o,this.FACE_FRONT,t,b,Y,x),back:this.CreateCubemapTexture(o,this.FACE_BACK,t,b,Y,x),left:this.CreateCubemapTexture(o,this.FACE_LEFT,t,b,Y,x),right:this.CreateCubemapTexture(o,this.FACE_RIGHT,t,b,Y,x),up:this.CreateCubemapTexture(o,this.FACE_UP,t,b,Y,x),down:this.CreateCubemapTexture(o,this.FACE_DOWN,t,b,Y,x),size:o,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(t,b,Y,o,x){let F=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const r=new ArrayBuffer(t*t*4*3),R=new Float32Array(r),d=F?Math.max(1,Math.round(o/4/t)):1,E=1/d,U=E*E,C=b[1].fd(b[0]).scale(E/t),p=b[3].fd(b[2]).scale(E/t),W=1/t;let T=0;for(let y=0;y<t;y++)for(let F=0;F<d;F++){let F=b[0],r=b[2];for(let b=0;b<t;b++)for(let E=0;E<d;E++){const d=r.fd(F).scale(T).add(F);d.normalize();const E=this.CalcProjectionSpherical(d,Y,o,x);R[y*t*3+3*b+0]+=E.r*U,R[y*t*3+3*b+1]+=E.g*U,R[y*t*3+3*b+2]+=E.b*U,F=F.add(C),r=r.add(p)}T+=W*E}return R}static CalcProjectionSpherical(t,b,Y,o){let x=Math.atan2(t.z,t.x);const F=Math.acos(t.y);for(;x<-Math.PI;)x+=2*Math.PI;for(;x>Math.PI;)x-=2*Math.PI;let r=x/Math.PI;const R=F/Math.PI;r=.5*r+.5;let d=Math.round(r*Y);d<0?d=0:d>=Y&&(d=Y-1);let E=Math.round(R*o);E<0?E=0:E>=o&&(E=o-1);const U=o-E-1;return{r:b[U*Y*3+3*d+0],g:b[U*Y*3+3*d+1],b:b[U*Y*3+3*d+2]}}}function F(t,b,Y,o,x,F){x>0?(x=function(t,b){return b>1023?t*Math.pow(2,1023)*Math.pow(2,b-1023):b<-1074?t*Math.pow(2,-1074)*Math.pow(2,b+1074):t*Math.pow(2,b)}(1,x-136),t[F+0]=b*x,t[F+1]=Y*x,t[F+2]=o*x):(t[F+0]=0,t[F+1]=0,t[F+2]=0)}function r(t,b){let Y="",o="";for(let x=b;x<t.length-b&&(o=String.fromCharCode(t[x]),"\n"!=o);x++)Y+=o;return Y}function R(t){let b=0,Y=0,o=r(t,0);if("#"!=o[0]||"?"!=o[1])throw"Bad HDR Format.";let x=!1,F=!1,R=0;do{R+=o.length+1,o=r(t,R),"FORMAT=32-bit_rle_rgbe"==o?F=!0:0==o.length&&(x=!0)}while(!x);if(!F)throw"HDR Bad header format, unsupported FORMAT";R+=o.length+1,o=r(t,R);const d=/^-Y (.*) \+X (.*)$/g.exec(o);if(!d||d.length<3)throw"HDR Bad header format, no size";if(Y=parseInt(d[2]),b=parseInt(d[1]),Y<8||Y>32767)throw"HDR Bad header format, unsupported size";return R+=o.length+1,{height:b,width:Y,dataPosition:R}}function d(t,b){return function(t,b){let Y=b.height;const o=b.width;let x,r,R,d,U,C=b.dataPosition,p=0,W=0,T=0;const y=new ArrayBuffer(4*o),v=new Uint8Array(y),B=new ArrayBuffer(b.width*b.height*4*3),J=new Float32Array(B);for(;Y>0;){if(x=t[C++],r=t[C++],R=t[C++],d=t[C++],2!=x||2!=r||128&R||b.width<8||b.width>32767)return E(t,b);if((R<<8|d)!=o)throw"HDR Bad header format, wrong scan line width";for(p=0,T=0;T<4;T++)for(W=(T+1)*o;p<W;)if(x=t[C++],r=t[C++],x>128){if(U=x-128,0==U||U>W-p)throw"HDR Bad Format, bad scanline data (run)";for(;U-- >0;)v[p++]=r}else{if(U=x,0==U||U>W-p)throw"HDR Bad Format, bad scanline data (non-run)";if(v[p++]=r,--U>0)for(let b=0;b<U;b++)v[p++]=t[C++]}for(T=0;T<o;T++)x=v[T],r=v[T+o],R=v[T+2*o],d=v[T+3*o],F(J,x,r,R,d,(b.height-Y)*o*3+3*T);Y--}return J}(t,b)}function E(t,b){let Y=b.height;const o=b.width;let x,r,R,d,E,U=b.dataPosition;const C=new ArrayBuffer(b.width*b.height*4*3),p=new Float32Array(C);for(;Y>0;){for(E=0;E<b.width;E++)x=t[U++],r=t[U++],R=t[U++],d=t[U++],F(p,x,r,R,d,(b.height-Y)*o*3+3*E);Y--}return p}x.FACE_LEFT=[new o.l(-1,-1,-1),new o.l(1,-1,-1),new o.l(-1,1,-1),new o.l(1,1,-1)],x.FACE_RIGHT=[new o.l(1,-1,1),new o.l(-1,-1,1),new o.l(1,1,1),new o.l(-1,1,1)],x.FACE_FRONT=[new o.l(1,-1,-1),new o.l(1,-1,1),new o.l(1,1,-1),new o.l(1,1,1)],x.FACE_BACK=[new o.l(-1,-1,1),new o.l(-1,-1,-1),new o.l(-1,1,1),new o.l(-1,1,-1)],x.FACE_DOWN=[new o.l(1,1,-1),new o.l(1,1,1),new o.l(-1,1,-1),new o.l(-1,1,1)],x.FACE_UP=[new o.l(-1,-1,-1),new o.l(-1,-1,1),new o.l(1,-1,-1),new o.l(1,-1,1)];class U{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(t,b,Y){const o=new Uint8Array(t.buffer,t.byteOffset,t.byteLength),x=R(o),F=d(o,x),r=x.width*x.height,E=new Float32Array(4*r);for(let R=0;R<r;R+=1)E[4*R]=F[3*R],E[4*R+1]=F[3*R+1],E[4*R+2]=F[3*R+2],E[4*R+3]=1;Y(x.width,x.height,b.generateMipMaps,!1,(()=>{const t=b.getEngine();b.type=1,b.format=5,b._gammaSpace=!1,t._uploadDataToTextureDirectly(b,E)}))}}}}]);