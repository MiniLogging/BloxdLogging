"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{10704:(V,n,O)=>{O.r(n),O.d(n,{_HDRTextureLoader:()=>M});var H=O(1023);class g{static ConvertPanoramaToCubemap(V,n,O,H){let g=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!V)throw"ConvertPanoramaToCubemap: input cannot be null";if(V.length!=n*O*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(H,this.FACE_FRONT,V,n,O,g),back:this.CreateCubemapTexture(H,this.FACE_BACK,V,n,O,g),left:this.CreateCubemapTexture(H,this.FACE_LEFT,V,n,O,g),right:this.CreateCubemapTexture(H,this.FACE_RIGHT,V,n,O,g),up:this.CreateCubemapTexture(H,this.FACE_UP,V,n,O,g),down:this.CreateCubemapTexture(H,this.FACE_DOWN,V,n,O,g),size:H,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(V,n,O,H,g){let f=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const x=new ArrayBuffer(V*V*4*3),c=new Float32Array(x),e=f?Math.max(1,Math.round(H/4/V)):1,U=1/e,M=U*U,p=n[1].pd(n[0]).scale(U/V),j=n[3].pd(n[2]).scale(U/V),i=1/V;let A=0;for(let S=0;S<V;S++)for(let f=0;f<e;f++){let f=n[0],x=n[2];for(let n=0;n<V;n++)for(let U=0;U<e;U++){const e=x.pd(f).scale(A).add(f);e.normalize();const U=this.CalcProjectionSpherical(e,O,H,g);c[S*V*3+3*n+0]+=U.r*M,c[S*V*3+3*n+1]+=U.g*M,c[S*V*3+3*n+2]+=U.b*M,f=f.add(p),x=x.add(j)}A+=i*U}return c}static CalcProjectionSpherical(V,n,O,H){let g=Math.atan2(V.z,V.x);const f=Math.acos(V.y);for(;g<-Math.PI;)g+=2*Math.PI;for(;g>Math.PI;)g-=2*Math.PI;let x=g/Math.PI;const c=f/Math.PI;x=.5*x+.5;let e=Math.round(x*O);e<0?e=0:e>=O&&(e=O-1);let U=Math.round(c*H);U<0?U=0:U>=H&&(U=H-1);const M=H-U-1;return{r:n[M*O*3+3*e+0],g:n[M*O*3+3*e+1],b:n[M*O*3+3*e+2]}}}function f(V,n,O,H,g,f){g>0?(g=function(V,n){return n>1023?V*Math.pow(2,1023)*Math.pow(2,n-1023):n<-1074?V*Math.pow(2,-1074)*Math.pow(2,n+1074):V*Math.pow(2,n)}(1,g-136),V[f+0]=n*g,V[f+1]=O*g,V[f+2]=H*g):(V[f+0]=0,V[f+1]=0,V[f+2]=0)}function x(V,n){let O="",H="";for(let g=n;g<V.length-n&&(H=String.fromCharCode(V[g]),"\n"!=H);g++)O+=H;return O}function c(V){let n=0,O=0,H=x(V,0);if("#"!=H[0]||"?"!=H[1])throw"Bad HDR Format.";let g=!1,f=!1,c=0;do{c+=H.length+1,H=x(V,c),"FORMAT=32-bit_rle_rgbe"==H?f=!0:0==H.length&&(g=!0)}while(!g);if(!f)throw"HDR Bad header format, unsupported FORMAT";c+=H.length+1,H=x(V,c);const e=/^-Y (.*) \+X (.*)$/g.exec(H);if(!e||e.length<3)throw"HDR Bad header format, no size";if(O=parseInt(e[2]),n=parseInt(e[1]),O<8||O>32767)throw"HDR Bad header format, unsupported size";return c+=H.length+1,{height:n,width:O,dataPosition:c}}function e(V,n){return function(V,n){let O=n.height;const H=n.width;let g,x,c,e,M,p=n.dataPosition,j=0,i=0,A=0;const S=new ArrayBuffer(4*H),B=new Uint8Array(S),X=new ArrayBuffer(n.width*n.height*4*3),a=new Float32Array(X);for(;O>0;){if(g=V[p++],x=V[p++],c=V[p++],e=V[p++],2!=g||2!=x||128&c||n.width<8||n.width>32767)return U(V,n);if((c<<8|e)!=H)throw"HDR Bad header format, wrong scan line width";for(j=0,A=0;A<4;A++)for(i=(A+1)*H;j<i;)if(g=V[p++],x=V[p++],g>128){if(M=g-128,0==M||M>i-j)throw"HDR Bad Format, bad scanline data (run)";for(;M-- >0;)B[j++]=x}else{if(M=g,0==M||M>i-j)throw"HDR Bad Format, bad scanline data (non-run)";if(B[j++]=x,--M>0)for(let n=0;n<M;n++)B[j++]=V[p++]}for(A=0;A<H;A++)g=B[A],x=B[A+H],c=B[A+2*H],e=B[A+3*H],f(a,g,x,c,e,(n.height-O)*H*3+3*A);O--}return a}(V,n)}function U(V,n){let O=n.height;const H=n.width;let g,x,c,e,U,M=n.dataPosition;const p=new ArrayBuffer(n.width*n.height*4*3),j=new Float32Array(p);for(;O>0;){for(U=0;U<n.width;U++)g=V[M++],x=V[M++],c=V[M++],e=V[M++],f(j,g,x,c,e,(n.height-O)*H*3+3*U);O--}return j}g.FACE_LEFT=[new H.j(-1,-1,-1),new H.j(1,-1,-1),new H.j(-1,1,-1),new H.j(1,1,-1)],g.FACE_RIGHT=[new H.j(1,-1,1),new H.j(-1,-1,1),new H.j(1,1,1),new H.j(-1,1,1)],g.FACE_FRONT=[new H.j(1,-1,-1),new H.j(1,-1,1),new H.j(1,1,-1),new H.j(1,1,1)],g.FACE_BACK=[new H.j(-1,-1,1),new H.j(-1,-1,-1),new H.j(-1,1,1),new H.j(-1,1,-1)],g.FACE_DOWN=[new H.j(1,1,-1),new H.j(1,1,1),new H.j(-1,1,-1),new H.j(-1,1,1)],g.FACE_UP=[new H.j(-1,-1,-1),new H.j(-1,-1,1),new H.j(1,-1,-1),new H.j(1,-1,1)];class M{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(V,n,O){const H=new Uint8Array(V.buffer,V.byteOffset,V.byteLength),g=c(H),f=e(H,g),x=g.width*g.height,U=new Float32Array(4*x);for(let c=0;c<x;c+=1)U[4*c]=f[3*c],U[4*c+1]=f[3*c+1],U[4*c+2]=f[3*c+2],U[4*c+3]=1;O(g.width,g.height,n.generateMipMaps,!1,(()=>{const V=n.getEngine();n.type=1,n.format=5,n._gammaSpace=!1,V._uploadDataToTextureDirectly(n,U)}))}}}}]);