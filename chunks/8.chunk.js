"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{2585:(P,Q,O)=>{O.r(Q),O.d(Q,{_BasisTextureLoader:()=>r});var b,F=O(545),g=O(2460),m=O(673);function q(){const P=0,Q=1,O=2,b=3,F=6,g=8,m=9,q=10,R=14;let X=null;function C(P,Q,O,b,F){const g=P.getImageTranscodedSizeInBytes(Q,O,b);let m=new Uint8Array(g);if(!P.transcodeImage(m,Q,O,b,1,0))return null;if(F){m=function(P,Q,O,b){const F=new Uint16Array(4),g=new Uint16Array(O*b),m=O/4,q=b/4;for(let R=0;R<q;R++)for(let b=0;b<m;b++){const q=Q+8*(R*m+b);F[0]=P[q]|P[q+1]<<8,F[1]=P[q+2]|P[q+3]<<8,F[2]=(2*(31&F[0])+1*(31&F[1]))/3|(2*(2016&F[0])+1*(2016&F[1]))/3&2016|(2*(63488&F[0])+1*(63488&F[1]))/3&63488,F[3]=(2*(31&F[1])+1*(31&F[0]))/3|(2*(2016&F[1])+1*(2016&F[0]))/3&2016|(2*(63488&F[1])+1*(63488&F[0]))/3&63488;for(let Q=0;Q<4;Q++){const m=P[q+4+Q];let X=(4*R+Q)*O+4*b;g[X++]=F[3&m],g[X++]=F[m>>2&3],g[X++]=F[m>>4&3],g[X++]=F[m>>6&3]}}return g}(m,0,P.getImageWidth(Q,O)+3&-4,P.getImageHeight(Q,O)+3&-4)}return m}onmessage=L=>{if("init"===L.data.action){if(L.data.url)try{importScripts(L.data.url)}catch(G){postMessage({action:"error",error:G})}X||(X=BASIS({wasmBinary:L.data.wasmBinary})),null!==X&&X.then((P=>{BASIS=P,P.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===L.data.action){const X=L.data.config,G=L.data.imageData,A=new BASIS.BasisFile(G),j=function(P){const Q=P.getHasAlpha(),O=P.getNumImages(),b=[];for(let F=0;F<O;F++){const Q={levels:[]},O=P.getNumLevels(F);for(let b=0;b<O;b++){const O={width:P.getImageWidth(F,b),height:P.getImageHeight(F,b)};Q.levels.push(O)}b.push(Q)}return{wi:Q,images:b}}(A);let w=L.data.ignoreSupportedFormats?null:function(X,C){let L=null;X.supportedCompressionFormats&&(L=X.supportedCompressionFormats.astc?q:X.supportedCompressionFormats.bc7?F:X.supportedCompressionFormats.s3tc?C.wi?b:O:X.supportedCompressionFormats.pvrtc?C.wi?m:g:X.supportedCompressionFormats.etc2?Q:X.supportedCompressionFormats.etc1?P:R);return L}(L.data.config,j),W=!1;null===w&&(W=!0,w=j.wi?b:O);let r=!0;A.startTranscoding()||(r=!1);const K=[];for(let P=0;P<j.images.length&&r;P++){const Q=j.images[P];if(void 0===X.loadSingleImage||X.loadSingleImage===P){let O=Q.levels.length;!1===X.loadMipmapLevels&&(O=1);for(let b=0;b<O;b++){const O=Q.levels[b],F=C(A,P,b,w,W);if(!F){r=!1;break}O.transcodedPixels=F,K.push(O.transcodedPixels.buffer)}}}A.close(),A.delete(),W&&(w=-1),r?postMessage({action:"transcode",success:r,id:L.data.id,fileInfo:j,format:w},K):postMessage({action:"transcode",success:r,id:L.data.id})}}}!function(P){P[P.cTFETC1=0]="cTFETC1",P[P.cTFETC2=1]="cTFETC2",P[P.cTFBC1=2]="cTFBC1",P[P.cTFBC3=3]="cTFBC3",P[P.cTFBC4=4]="cTFBC4",P[P.cTFBC5=5]="cTFBC5",P[P.cTFBC7=6]="cTFBC7",P[P.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",P[P.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",P[P.cTFASTC_4x4=10]="cTFASTC_4x4",P[P.cTFATC_RGB=11]="cTFATC_RGB",P[P.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",P[P.cTFRGBA32=13]="cTFRGBA32",P[P.cTFRGB565=14]="cTFRGB565",P[P.cTFBGR565=15]="cTFBGR565",P[P.cTFRGBA4444=16]="cTFRGBA4444",P[P.cTFFXT1_RGB=17]="cTFFXT1_RGB",P[P.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",P[P.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",P[P.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",P[P.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(b||(b={}));const R={JSModuleURL:`${F.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${F.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let X=null,C=null,L=0;const G=async()=>(X||(X=new Promise(((P,Q)=>{C?P(C):F.d.LoadFileAsync(F.d.GetBabylonScriptURL(R.WasmModuleURL)).then((O=>{if("function"!==typeof URL)return Q("Basis transcoder requires an environment with a URL constructor");const b=URL.createObjectURL(new Blob([`(${q})()`],{type:"application/javascript"}));C=new Worker(b),async function(P,Q,O){return await new Promise(((b,g)=>{const m=Q=>{"init"===Q.data.action?(P.removeEventListener("message",m),b(P)):"error"===Q.data.action&&g(Q.data.error||"error initializing worker")};P.addEventListener("message",m),P.postMessage({action:"init",url:O?F.d.GetBabylonScriptURL(O):void 0,wasmBinary:Q},[Q])}))}(C,O,R.JSModuleURL).then(P,Q)})).catch(Q)}))),await X),A=async(P,Q)=>{const O=P instanceof ArrayBuffer?new Uint8Array(P):P;return await new Promise(((P,b)=>{G().then((()=>{const F=L++,g=Q=>{"transcode"===Q.data.action&&Q.data.id===F&&(C.removeEventListener("message",g),Q.data.success?P(Q.data):b("Transcode is not supported on this device"))};C.addEventListener("message",g);const m=new Uint8Array(O.byteLength);m.set(new Uint8Array(O.buffer,O.byteOffset,O.byteLength)),C.postMessage({action:"transcode",id:F,imageData:m,config:Q,ignoreSupportedFormats:false},[m.buffer])}),(P=>{b(P)}))}))},j=(P,Q)=>{var O;let b=null===(O=Q._gl)||void 0===O?void 0:O.TEXTURE_2D;var F;P.isCube&&(b=null===(F=Q._gl)||void 0===F?void 0:F.TEXTURE_CUBE_MAP);Q._bindTextureDirectly(b,P,!0)},w=(P,Q)=>{const O=P.getEngine();for(let q=0;q<Q.fileInfo.images.length;q++){const R=Q.fileInfo.images[q].levels[0];if(P._invertVScale=P.invertY,-1===Q.format||Q.format===b.cTFRGB565)if(P.type=10,P.format=4,!O._features.basisNeedsPOT||Math.log2(R.width)%1===0&&Math.log2(R.height)%1===0)P._invertVScale=!P.invertY,P.width=R.width+3&-4,P.height=R.height+3&-4,P.samplingMode=2,j(P,O),O._uploadDataToTextureDirectly(P,new Uint16Array(R.transcodedPixels.buffer),q,0,4,!0);else{const Q=new m.b(O,2);P._invertVScale=P.invertY,Q.type=10,Q.format=4,Q.width=R.width+3&-4,Q.height=R.height+3&-4,j(Q,O),O._uploadDataToTextureDirectly(Q,new Uint16Array(R.transcodedPixels.buffer),q,0,4,!0),O._rescaleTexture(Q,P,O.scenes[0],O._getInternalFormat(4),(()=>{O._releaseTexture(Q),j(P,O)}))}else{P.width=R.width,P.height=R.height,P.generateMipMaps=Q.fileInfo.images[q].levels.length>1;const b=W.GetInternalFormatFromBasisFormat(Q.format,O);P.format=b,j(P,O);const m=Q.fileInfo.images[q].levels;for(let Q=0;Q<m.length;Q++){const F=m[Q];O._uploadCompressedDataToTextureDirectly(P,b,F.width,F.height,F.transcodedPixels,q,Q)}!O._features.basisNeedsPOT||Math.log2(P.width)%1===0&&Math.log2(P.height)%1===0||(F.d.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),P._cachedWrapU=g.c.CLAMP_ADDRESSMODE,P._cachedWrapV=g.c.CLAMP_ADDRESSMODE)}}},W={JSModuleURL:R.JSModuleURL,WasmModuleURL:R.WasmModuleURL,GetInternalFormatFromBasisFormat:(P,Q)=>{let O;switch(P){case b.cTFETC1:O=36196;break;case b.cTFBC1:O=33776;break;case b.cTFBC4:O=33779;break;case b.cTFASTC_4x4:O=37808;break;case b.cTFETC2:O=37496;break;case b.cTFBC7:O=36492}if(void 0===O)throw"The chosen Basis transcoder format is not currently supported";return O},TranscodeAsync:A,LoadTextureFromTranscodeResult:w};Object.defineProperty(W,"JSModuleURL",{get:function(){return R.JSModuleURL},set:function(P){R.JSModuleURL=P}}),Object.defineProperty(W,"WasmModuleURL",{get:function(){return R.WasmModuleURL},set:function(P){R.WasmModuleURL=P}});class r{constructor(){this.supportCascades=!1}loadCubeData(P,Q,O,b,g){if(Array.isArray(P))return;const m=Q.getEngine().getCaps(),q={supportedCompressionFormats:{etc1:!!m.etc1,s3tc:!!m.s3tc,pvrtc:!!m.pvrtc,etc2:!!m.etc2,astc:!!m.astc,bc7:!!m.bptc}};A(P,q).then((P=>{const O=P.fileInfo.images[0].levels.length>1&&Q.generateMipMaps;w(Q,P),Q.getEngine()._setCubeMapTextureParams(Q,O),Q.isReady=!0,Q.onLoadedObservable.notifyObservers(Q),Q.onLoadedObservable.clear(),b&&b()})).catch((P=>{F.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Q.isReady=!0,g&&g(P)}))}loadData(P,Q,O){const b=Q.getEngine().getCaps(),g={supportedCompressionFormats:{etc1:!!b.etc1,s3tc:!!b.s3tc,pvrtc:!!b.pvrtc,etc2:!!b.etc2,astc:!!b.astc,bc7:!!b.bptc}};A(P,g).then((P=>{const b=P.fileInfo.images[0].levels[0],F=P.fileInfo.images[0].levels.length>1&&Q.generateMipMaps;O(b.width,b.height,F,-1!==P.format,(()=>{w(Q,P)}))})).catch((P=>{F.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),F.d.Warn(`Failed to transcode Basis file: ${P}`),O(0,0,!1,!1,(()=>{}),!0)}))}}}}]);