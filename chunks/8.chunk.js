"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[8],{2513:(Q,X,C)=>{C.r(X),C.d(X,{_BasisTextureLoader:()=>z});var l,h=C(487),M=C(2397),f=C(594);function O(){const Q=0,X=1,C=2,l=3,h=6,M=8,f=9,O=10,m=14;let W=null;function U(Q,X,C,l,h){const M=Q.getImageTranscodedSizeInBytes(X,C,l);let f=new Uint8Array(M);if(!Q.transcodeImage(f,X,C,l,1,0))return null;if(h){f=function(Q,X,C,l){const h=new Uint16Array(4),M=new Uint16Array(C*l),f=C/4,O=l/4;for(let m=0;m<O;m++)for(let l=0;l<f;l++){const O=X+8*(m*f+l);h[0]=Q[O]|Q[O+1]<<8,h[1]=Q[O+2]|Q[O+3]<<8,h[2]=(2*(31&h[0])+1*(31&h[1]))/3|(2*(2016&h[0])+1*(2016&h[1]))/3&2016|(2*(63488&h[0])+1*(63488&h[1]))/3&63488,h[3]=(2*(31&h[1])+1*(31&h[0]))/3|(2*(2016&h[1])+1*(2016&h[0]))/3&2016|(2*(63488&h[1])+1*(63488&h[0]))/3&63488;for(let X=0;X<4;X++){const f=Q[O+4+X];let W=(4*m+X)*C+4*l;M[W++]=h[3&f],M[W++]=h[f>>2&3],M[W++]=h[f>>4&3],M[W++]=h[f>>6&3]}}return M}(f,0,Q.getImageWidth(X,C)+3&-4,Q.getImageHeight(X,C)+3&-4)}return f}onmessage=L=>{if("init"===L.data.action){if(L.data.url)try{importScripts(L.data.url)}catch(w){postMessage({action:"error",error:w})}W||(W=BASIS({wasmBinary:L.data.wasmBinary})),null!==W&&W.then((Q=>{BASIS=Q,Q.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===L.data.action){const W=L.data.config,w=L.data.imageData,i=new BASIS.BasisFile(w),a=function(Q){const X=Q.getHasAlpha(),C=Q.getNumImages(),l=[];for(let h=0;h<C;h++){const X={levels:[]},C=Q.getNumLevels(h);for(let l=0;l<C;l++){const C={width:Q.getImageWidth(h,l),height:Q.getImageHeight(h,l)};X.levels.push(C)}l.push(X)}return{mi:X,images:l}}(i);let F=L.data.ignoreSupportedFormats?null:function(W,U){let L=null;W.supportedCompressionFormats&&(L=W.supportedCompressionFormats.astc?O:W.supportedCompressionFormats.bc7?h:W.supportedCompressionFormats.s3tc?U.mi?l:C:W.supportedCompressionFormats.pvrtc?U.mi?f:M:W.supportedCompressionFormats.etc2?X:W.supportedCompressionFormats.etc1?Q:m);return L}(L.data.config,a),s=!1;null===F&&(s=!0,F=a.mi?l:C);let z=!0;i.startTranscoding()||(z=!1);const x=[];for(let Q=0;Q<a.images.length&&z;Q++){const X=a.images[Q];if(void 0===W.loadSingleImage||W.loadSingleImage===Q){let C=X.levels.length;!1===W.loadMipmapLevels&&(C=1);for(let l=0;l<C;l++){const C=X.levels[l],h=U(i,Q,l,F,s);if(!h){z=!1;break}C.transcodedPixels=h,x.push(C.transcodedPixels.buffer)}}}i.close(),i.delete(),s&&(F=-1),z?postMessage({action:"transcode",success:z,id:L.data.id,fileInfo:a,format:F},x):postMessage({action:"transcode",success:z,id:L.data.id})}}}!function(Q){Q[Q.cTFETC1=0]="cTFETC1",Q[Q.cTFETC2=1]="cTFETC2",Q[Q.cTFBC1=2]="cTFBC1",Q[Q.cTFBC3=3]="cTFBC3",Q[Q.cTFBC4=4]="cTFBC4",Q[Q.cTFBC5=5]="cTFBC5",Q[Q.cTFBC7=6]="cTFBC7",Q[Q.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",Q[Q.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",Q[Q.cTFASTC_4x4=10]="cTFASTC_4x4",Q[Q.cTFATC_RGB=11]="cTFATC_RGB",Q[Q.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",Q[Q.cTFRGBA32=13]="cTFRGBA32",Q[Q.cTFRGB565=14]="cTFRGB565",Q[Q.cTFBGR565=15]="cTFBGR565",Q[Q.cTFRGBA4444=16]="cTFRGBA4444",Q[Q.cTFFXT1_RGB=17]="cTFFXT1_RGB",Q[Q.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",Q[Q.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",Q[Q.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",Q[Q.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(l||(l={}));const m={JSModuleURL:`${h.i._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${h.i._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let W=null,U=null,L=0;const w=async()=>(W||(W=new Promise(((Q,X)=>{U?Q(U):h.i.LoadFileAsync(h.i.GetBabylonScriptURL(m.WasmModuleURL)).then((C=>{if("function"!==typeof URL)return X("Basis transcoder requires an environment with a URL constructor");const l=URL.createObjectURL(new Blob([`(${O})()`],{type:"application/javascript"}));U=new Worker(l),async function(Q,X,C){return await new Promise(((l,M)=>{const f=X=>{"init"===X.data.action?(Q.removeEventListener("message",f),l(Q)):"error"===X.data.action&&M(X.data.error||"error initializing worker")};Q.addEventListener("message",f),Q.postMessage({action:"init",url:C?h.i.GetBabylonScriptURL(C):void 0,wasmBinary:X},[X])}))}(U,C,m.JSModuleURL).then(Q,X)})).catch(X)}))),await W),i=async(Q,X)=>{const C=Q instanceof ArrayBuffer?new Uint8Array(Q):Q;return await new Promise(((Q,l)=>{w().then((()=>{const h=L++,M=X=>{"transcode"===X.data.action&&X.data.id===h&&(U.removeEventListener("message",M),X.data.success?Q(X.data):l("Transcode is not supported on this device"))};U.addEventListener("message",M);const f=new Uint8Array(C.byteLength);f.set(new Uint8Array(C.buffer,C.byteOffset,C.byteLength)),U.postMessage({action:"transcode",id:h,imageData:f,config:X,ignoreSupportedFormats:false},[f.buffer])}),(Q=>{l(Q)}))}))},a=(Q,X)=>{var C;let l=null===(C=X._gl)||void 0===C?void 0:C.TEXTURE_2D;var h;Q.isCube&&(l=null===(h=X._gl)||void 0===h?void 0:h.TEXTURE_CUBE_MAP);X._bindTextureDirectly(l,Q,!0)},F=(Q,X)=>{const C=Q.getEngine();for(let O=0;O<X.fileInfo.images.length;O++){const m=X.fileInfo.images[O].levels[0];if(Q._invertVScale=Q.invertY,-1===X.format||X.format===l.cTFRGB565)if(Q.type=10,Q.format=4,!C._features.basisNeedsPOT||Math.log2(m.width)%1===0&&Math.log2(m.height)%1===0)Q._invertVScale=!Q.invertY,Q.width=m.width+3&-4,Q.height=m.height+3&-4,Q.samplingMode=2,a(Q,C),C._uploadDataToTextureDirectly(Q,new Uint16Array(m.transcodedPixels.buffer),O,0,4,!0);else{const X=new f.d(C,2);Q._invertVScale=Q.invertY,X.type=10,X.format=4,X.width=m.width+3&-4,X.height=m.height+3&-4,a(X,C),C._uploadDataToTextureDirectly(X,new Uint16Array(m.transcodedPixels.buffer),O,0,4,!0),C._rescaleTexture(X,Q,C.scenes[0],C._getInternalFormat(4),(()=>{C._releaseTexture(X),a(Q,C)}))}else{Q.width=m.width,Q.height=m.height,Q.generateMipMaps=X.fileInfo.images[O].levels.length>1;const l=s.GetInternalFormatFromBasisFormat(X.format,C);Q.format=l,a(Q,C);const f=X.fileInfo.images[O].levels;for(let X=0;X<f.length;X++){const h=f[X];C._uploadCompressedDataToTextureDirectly(Q,l,h.width,h.height,h.transcodedPixels,O,X)}!C._features.basisNeedsPOT||Math.log2(Q.width)%1===0&&Math.log2(Q.height)%1===0||(h.i.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),Q._cachedWrapU=M.e.CLAMP_ADDRESSMODE,Q._cachedWrapV=M.e.CLAMP_ADDRESSMODE)}}},s={JSModuleURL:m.JSModuleURL,WasmModuleURL:m.WasmModuleURL,GetInternalFormatFromBasisFormat:(Q,X)=>{let C;switch(Q){case l.cTFETC1:C=36196;break;case l.cTFBC1:C=33776;break;case l.cTFBC4:C=33779;break;case l.cTFASTC_4x4:C=37808;break;case l.cTFETC2:C=37496;break;case l.cTFBC7:C=36492}if(void 0===C)throw"The chosen Basis transcoder format is not currently supported";return C},TranscodeAsync:i,LoadTextureFromTranscodeResult:F};Object.defineProperty(s,"JSModuleURL",{get:function(){return m.JSModuleURL},set:function(Q){m.JSModuleURL=Q}}),Object.defineProperty(s,"WasmModuleURL",{get:function(){return m.WasmModuleURL},set:function(Q){m.WasmModuleURL=Q}});class z{constructor(){this.supportCascades=!1}loadCubeData(Q,X,C,l,M){if(Array.isArray(Q))return;const f=X.getEngine().getCaps(),O={supportedCompressionFormats:{etc1:!!f.etc1,s3tc:!!f.s3tc,pvrtc:!!f.pvrtc,etc2:!!f.etc2,astc:!!f.astc,bc7:!!f.bptc}};i(Q,O).then((Q=>{const C=Q.fileInfo.images[0].levels.length>1&&X.generateMipMaps;F(X,Q),X.getEngine()._setCubeMapTextureParams(X,C),X.isReady=!0,X.onLoadedObservable.notifyObservers(X),X.onLoadedObservable.clear(),l&&l()})).catch((Q=>{h.i.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),X.isReady=!0,M&&M(Q)}))}loadData(Q,X,C){const l=X.getEngine().getCaps(),M={supportedCompressionFormats:{etc1:!!l.etc1,s3tc:!!l.s3tc,pvrtc:!!l.pvrtc,etc2:!!l.etc2,astc:!!l.astc,bc7:!!l.bptc}};i(Q,M).then((Q=>{const l=Q.fileInfo.images[0].levels[0],h=Q.fileInfo.images[0].levels.length>1&&X.generateMipMaps;C(l.width,l.height,h,-1!==Q.format,(()=>{F(X,Q)}))})).catch((Q=>{h.i.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),h.i.Warn(`Failed to transcode Basis file: ${Q}`),C(0,0,!1,!1,(()=>{}),!0)}))}}}}]);