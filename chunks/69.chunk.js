"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[69],{14411:(w,p,e)=>{e.r(p),e.d(p,{FlowGraphAngleBetweenBlock:()=>t,FlowGraphAxisAngleFromQuaternionBlock:()=>l,FlowGraphConjugateBlock:()=>i,FlowGraphCrossBlock:()=>s,FlowGraphDotBlock:()=>c,FlowGraphLengthBlock:()=>K,FlowGraphNormalizeBlock:()=>y,FlowGraphQuaternionFromAxisAngleBlock:()=>n,FlowGraphQuaternionFromDirectionsBlock:()=>N,FlowGraphRotate2DBlock:()=>O,FlowGraphRotate3DBlock:()=>a,FlowGraphTransformBlock:()=>z,FlowGraphTransformCoordinatesBlock:()=>M});var r=e(12893),I=e(12872),d=e(11038),f=e(14400),q=e(14404),E=e(11023),j=e(12905),X=e(12529);const k="cachedOperationAxis",m="cachedOperationAngle",J="cachedExecutionId";class K extends q.e{constructor(w){super(I.c,I.o,(w=>this._polymorphicLength(w)),"FlowGraphLengthBlock",w)}_polymorphicLength(w){switch((0,j.i)(w)){case"Vector2":case"ne":case"Vector4":case"Quaternion":return w.length();default:throw new Error(`Cannot compute length of value ${w}`)}}}(0,d.d)("FlowGraphLengthBlock",K);class y extends q.e{constructor(w){super(I.c,I.c,(w=>this._polymorphicNormalize(w)),"FlowGraphNormalizeBlock",w)}_polymorphicNormalize(w){var p;let e;switch((0,j.i)(w)){case"Vector2":case"ne":case"Vector4":case"Quaternion":if(e=w.normalizeToNew(),null!==(p=this.config)&&void 0!==p&&p.nanOnZeroLength){0===w.length()&&e.Pe(NaN)}return e;default:throw new Error(`Cannot normalize value ${w}`)}}}(0,d.d)("FlowGraphNormalizeBlock",y);class c extends f.e{constructor(w){super(I.c,I.c,I.o,((w,p)=>this._polymorphicDot(w,p)),"FlowGraphDotBlock",w)}_polymorphicDot(w,p){switch((0,j.i)(w)){case"Vector2":case"ne":case"Vector4":case"Quaternion":return w.dot(p);default:throw new Error(`Cannot get dot product of ${w} and ${p}`)}}}(0,d.d)("FlowGraphDotBlock",c);class s extends f.e{constructor(w){super(I.z,I.z,I.z,((w,p)=>E.k.Cross(w,p)),"FlowGraphCrossBlock",w)}}(0,d.d)("FlowGraphCrossBlock",s);class O extends f.e{constructor(w){super(I.v,I.o,I.v,((w,p)=>w.rotate(p)),"FlowGraphRotate2DBlock",w)}}(0,d.d)("FlowGraphRotate2DBlock",O);class a extends f.e{constructor(w){super(I.z,I.p,I.z,((w,p)=>w.applyRotationQuaternion(p)),"FlowGraphRotate3DBlock",w)}}function A(w,p){switch((0,j.i)(w)){case"Vector2":case"ne":return p.transformVector(w);case"Vector4":return new E.o(w.x*p.m[0]+w.y*p.m[1]+w.z*p.m[2]+w.w*p.m[3],w.x*p.m[4]+w.y*p.m[5]+w.z*p.m[6]+w.w*p.m[7],w.x*p.m[8]+w.y*p.m[9]+w.z*p.m[10]+w.w*p.m[11],w.x*p.m[12]+w.y*p.m[13]+w.z*p.m[14]+w.w*p.m[15]);default:throw new Error(`Cannot transform value ${w}`)}}(0,d.d)("FlowGraphRotate3DBlock",a);class z extends f.e{constructor(w){const p=(null===w||void 0===w?void 0:w.vectorType)||"ne",e="Vector2"===p?"Matrix2D":"ne"===p?"Matrix3D":"Matrix";super((0,I.L)(p),(0,I.L)(e),(0,I.L)(p),A,"FlowGraphTransformVectorBlock",w)}}(0,d.d)("FlowGraphTransformVectorBlock",z);class M extends f.e{constructor(w){super(I.z,I.i,I.z,((w,p)=>E.k.TransformCoordinates(w,p)),"FlowGraphTransformCoordinatesBlock",w)}}(0,d.d)("FlowGraphTransformCoordinatesBlock",M);class i extends q.e{constructor(w){super(I.p,I.p,(w=>w.conjugate()),"FlowGraphConjugateBlock",w)}}(0,d.d)("FlowGraphConjugateBlock",i);class t extends f.e{constructor(w){super(I.p,I.p,I.o,((w,p)=>(0,X.d)(w,p)),"FlowGraphAngleBetweenBlock",w)}}(0,d.d)("FlowGraphAngleBetweenBlock",t);class n extends f.e{constructor(w){super(I.z,I.o,I.p,((w,p)=>E.c.RotationAxis(w,p)),"FlowGraphQuaternionFromAxisAngleBlock",w)}}(0,d.d)("FlowGraphQuaternionFromAxisAngleBlock",n);class l extends r.e{constructor(w){super(w),this.a=this.registerDataInput("a",I.p),this.axis=this.registerDataOutput("axis",I.z),this.angle=this.registerDataOutput("angle",I.o),this.isValid=this.registerDataOutput("isValid",I.g)}_updateOutputs(w){const p=w._getExecutionVariable(this,J,-1),e=w._getExecutionVariable(this,k,null),r=w._getExecutionVariable(this,m,null);if(void 0!==e&&null!==e&&void 0!==r&&null!==r&&p===w.executionId)this.axis.setValue(e,w),this.angle.setValue(r,w);else try{const{axis:p,angle:e}=this.a.getValue(w).toAxisAngle();w._setExecutionVariable(this,k,p),w._setExecutionVariable(this,m,e),w._setExecutionVariable(this,J,w.executionId),this.axis.setValue(p,w),this.angle.setValue(e,w),this.isValid.setValue(!0,w)}catch(I){this.isValid.setValue(!1,w)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,d.d)("FlowGraphAxisAngleFromQuaternionBlock",l);class N extends f.e{constructor(w){super(I.z,I.z,I.p,((w,p)=>(0,X.h)(w,p)),"FlowGraphQuaternionFromDirectionsBlock",w)}}},14400:(w,p,e)=>{e.d(p,{e:()=>I});var r=e(14402);class I extends r.c{constructor(w,p,e,r,I,d){super(e,d),this._operation=r,this._className=I,this.a=this.registerDataInput("a",w),this.b=this.registerDataInput("b",p)}_doOperation(w){const p=this.a.getValue(w),e=this.b.getValue(w);return this._operation(p,e)}getClassName(){return this._className}}},14402:(w,p,e)=>{e.d(p,{c:()=>q});var r=e(12893),I=e(12872);const d="cachedOperationValue",f="cachedExecutionId";class q extends r.e{constructor(w,p){super(p),this.value=this.registerDataOutput("value",w),this.isValid=this.registerDataOutput("isValid",I.g)}_updateOutputs(w){const p=w._getExecutionVariable(this,f,-1),e=w._getExecutionVariable(this,d,null);if(void 0!==e&&null!==e&&p===w.executionId)this.isValid.setValue(!0,w),this.value.setValue(e,w);else try{const p=this._doOperation(w);if(void 0===p||null===p)return void this.isValid.setValue(!1,w);w._setExecutionVariable(this,d,p),w._setExecutionVariable(this,f,w.executionId),this.value.setValue(p,w),this.isValid.setValue(!0,w)}catch(r){this.isValid.setValue(!1,w)}}}},14404:(w,p,e)=>{e.d(p,{e:()=>I});var r=e(14402);class I extends r.c{constructor(w,p,e,r,I){super(p,I),this._operation=e,this._className=r,this.a=this.registerDataInput("a",w)}_doOperation(w){return this._operation(this.a.getValue(w))}getClassName(){return this._className}}}}]);