"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[69],{14107:(q,c,U)=>{U.r(c),U.d(c,{FlowGraphAngleBetweenBlock:()=>i,FlowGraphAxisAngleFromQuaternionBlock:()=>v,FlowGraphConjugateBlock:()=>C,FlowGraphCrossBlock:()=>o,FlowGraphDotBlock:()=>h,FlowGraphLengthBlock:()=>H,FlowGraphNormalizeBlock:()=>b,FlowGraphQuaternionFromAxisAngleBlock:()=>F,FlowGraphQuaternionFromDirectionsBlock:()=>Y,FlowGraphRotate2DBlock:()=>a,FlowGraphRotate3DBlock:()=>p,FlowGraphTransformBlock:()=>I,FlowGraphTransformCoordinatesBlock:()=>t});var J=U(12667),Q=U(12648),s=U(10850),g=U(14093),X=U(14105),n=U(10833),W=U(12677),D=U(12354);const u="cachedOperationAxis",K="cachedOperationAngle",r="cachedExecutionId";class H extends X.c{constructor(q){super(Q.c,Q.t,(q=>this._polymorphicLength(q)),"FlowGraphLengthBlock",q)}_polymorphicLength(q){switch((0,W.l)(q)){case"Vector2":case"hc":case"Vector4":case"Quaternion":return q.length();default:throw new Error(`Cannot compute length of value ${q}`)}}}(0,s.f)("FlowGraphLengthBlock",H);class b extends X.c{constructor(q){super(Q.c,Q.c,(q=>this._polymorphicNormalize(q)),"FlowGraphNormalizeBlock",q)}_polymorphicNormalize(q){var c;let U;switch((0,W.l)(q)){case"Vector2":case"hc":case"Vector4":case"Quaternion":if(U=q.normalizeToNew(),null!==(c=this.config)&&void 0!==c&&c.nanOnZeroLength){0===q.length()&&U.tc(NaN)}return U;default:throw new Error(`Cannot normalize value ${q}`)}}}(0,s.f)("FlowGraphNormalizeBlock",b);class h extends g.e{constructor(q){super(Q.c,Q.c,Q.t,((q,c)=>this._polymorphicDot(q,c)),"FlowGraphDotBlock",q)}_polymorphicDot(q,c){switch((0,W.l)(q)){case"Vector2":case"hc":case"Vector4":case"Quaternion":return q.dot(c);default:throw new Error(`Cannot get dot product of ${q} and ${c}`)}}}(0,s.f)("FlowGraphDotBlock",h);class o extends g.e{constructor(q){super(Q.G,Q.G,Q.G,((q,c)=>n.p.Cross(q,c)),"FlowGraphCrossBlock",q)}}(0,s.f)("FlowGraphCrossBlock",o);class a extends g.e{constructor(q){super(Q.C,Q.t,Q.C,((q,c)=>q.rotate(c)),"FlowGraphRotate2DBlock",q)}}(0,s.f)("FlowGraphRotate2DBlock",a);class p extends g.e{constructor(q){super(Q.G,Q.v,Q.G,((q,c)=>q.applyRotationQuaternion(c)),"FlowGraphRotate3DBlock",q)}}function R(q,c){switch((0,W.l)(q)){case"Vector2":case"hc":return c.transformVector(q);case"Vector4":return new n.q(q.x*c.m[0]+q.y*c.m[1]+q.z*c.m[2]+q.w*c.m[3],q.x*c.m[4]+q.y*c.m[5]+q.z*c.m[6]+q.w*c.m[7],q.x*c.m[8]+q.y*c.m[9]+q.z*c.m[10]+q.w*c.m[11],q.x*c.m[12]+q.y*c.m[13]+q.z*c.m[14]+q.w*c.m[15]);default:throw new Error(`Cannot transform value ${q}`)}}(0,s.f)("FlowGraphRotate3DBlock",p);class I extends g.e{constructor(q){const c=(null===q||void 0===q?void 0:q.vectorType)||"hc",U="Vector2"===c?"Matrix2D":"hc"===c?"Matrix3D":"Matrix";super((0,Q.S)(c),(0,Q.S)(U),(0,Q.S)(c),R,"FlowGraphTransformVectorBlock",q)}}(0,s.f)("FlowGraphTransformVectorBlock",I);class t extends g.e{constructor(q){super(Q.G,Q.j,Q.G,((q,c)=>n.p.TransformCoordinates(q,c)),"FlowGraphTransformCoordinatesBlock",q)}}(0,s.f)("FlowGraphTransformCoordinatesBlock",t);class C extends X.c{constructor(q){super(Q.v,Q.v,(q=>q.conjugate()),"FlowGraphConjugateBlock",q)}}(0,s.f)("FlowGraphConjugateBlock",C);class i extends g.e{constructor(q){super(Q.v,Q.v,Q.t,((q,c)=>(0,D.e)(q,c)),"FlowGraphAngleBetweenBlock",q)}}(0,s.f)("FlowGraphAngleBetweenBlock",i);class F extends g.e{constructor(q){super(Q.G,Q.t,Q.v,((q,c)=>n.g.RotationAxis(q,c)),"FlowGraphQuaternionFromAxisAngleBlock",q)}}(0,s.f)("FlowGraphQuaternionFromAxisAngleBlock",F);class v extends J.c{constructor(q){super(q),this.a=this.registerDataInput("a",Q.v),this.axis=this.registerDataOutput("axis",Q.G),this.angle=this.registerDataOutput("angle",Q.t),this.isValid=this.registerDataOutput("isValid",Q.e)}_updateOutputs(q){const c=q._getExecutionVariable(this,r,-1),U=q._getExecutionVariable(this,u,null),J=q._getExecutionVariable(this,K,null);if(void 0!==U&&null!==U&&void 0!==J&&null!==J&&c===q.executionId)this.axis.setValue(U,q),this.angle.setValue(J,q);else try{const{axis:c,angle:U}=this.a.getValue(q).toAxisAngle();q._setExecutionVariable(this,u,c),q._setExecutionVariable(this,K,U),q._setExecutionVariable(this,r,q.executionId),this.axis.setValue(c,q),this.angle.setValue(U,q),this.isValid.setValue(!0,q)}catch(Q){this.isValid.setValue(!1,q)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,s.f)("FlowGraphAxisAngleFromQuaternionBlock",v);class Y extends g.e{constructor(q){super(Q.G,Q.G,Q.v,((q,c)=>(0,D.f)(q,c)),"FlowGraphQuaternionFromDirectionsBlock",q)}}},14093:(q,c,U)=>{U.d(c,{e:()=>Q});var J=U(14099);class Q extends J.d{constructor(q,c,U,J,Q,s){super(U,s),this._operation=J,this._className=Q,this.a=this.registerDataInput("a",q),this.b=this.registerDataInput("b",c)}_doOperation(q){const c=this.a.getValue(q),U=this.b.getValue(q);return this._operation(c,U)}getClassName(){return this._className}}},14099:(q,c,U)=>{U.d(c,{d:()=>X});var J=U(12667),Q=U(12648);const s="cachedOperationValue",g="cachedExecutionId";class X extends J.c{constructor(q,c){super(c),this.value=this.registerDataOutput("value",q),this.isValid=this.registerDataOutput("isValid",Q.e)}_updateOutputs(q){const c=q._getExecutionVariable(this,g,-1),U=q._getExecutionVariable(this,s,null);if(void 0!==U&&null!==U&&c===q.executionId)this.isValid.setValue(!0,q),this.value.setValue(U,q);else try{const c=this._doOperation(q);if(void 0===c||null===c)return void this.isValid.setValue(!1,q);q._setExecutionVariable(this,s,c),q._setExecutionVariable(this,g,q.executionId),this.value.setValue(c,q),this.isValid.setValue(!0,q)}catch(J){this.isValid.setValue(!1,q)}}}},14105:(q,c,U)=>{U.d(c,{c:()=>Q});var J=U(14099);class Q extends J.d{constructor(q,c,U,J,Q){super(c,Q),this._operation=U,this._className=J,this.a=this.registerDataInput("a",q)}_doOperation(q){return this._operation(this.a.getValue(q))}getClassName(){return this._className}}}}]);