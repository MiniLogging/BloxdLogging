"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[69],{14e3:(z,u,Y)=>{Y.r(u),Y.d(u,{FlowGraphAngleBetweenBlock:()=>i,FlowGraphAxisAngleFromQuaternionBlock:()=>Q,FlowGraphConjugateBlock:()=>v,FlowGraphCrossBlock:()=>o,FlowGraphDotBlock:()=>h,FlowGraphLengthBlock:()=>C,FlowGraphNormalizeBlock:()=>K,FlowGraphQuaternionFromAxisAngleBlock:()=>X,FlowGraphQuaternionFromDirectionsBlock:()=>V,FlowGraphRotate2DBlock:()=>d,FlowGraphRotate3DBlock:()=>t,FlowGraphTransformBlock:()=>Z,FlowGraphTransformCoordinatesBlock:()=>s});var H=Y(12549),E=Y(12531),J=Y(10918),l=Y(13977),T=Y(13992),b=Y(10903),L=Y(12565),D=Y(12225);const g="cachedOperationAxis",M="cachedOperationAngle",q="cachedExecutionId";class C extends T.e{constructor(z){super(E.e,E.p,(z=>this._polymorphicLength(z)),"FlowGraphLengthBlock",z)}_polymorphicLength(z){switch((0,L.i)(z)){case"Vector2":case"Pl":case"Vector4":case"Quaternion":return z.length();default:throw new Error(`Cannot compute length of value ${z}`)}}}(0,J.d)("FlowGraphLengthBlock",C);class K extends T.e{constructor(z){super(E.e,E.e,(z=>this._polymorphicNormalize(z)),"FlowGraphNormalizeBlock",z)}_polymorphicNormalize(z){var u;let Y;switch((0,L.i)(z)){case"Vector2":case"Pl":case"Vector4":case"Quaternion":if(Y=z.normalizeToNew(),null!==(u=this.config)&&void 0!==u&&u.nanOnZeroLength){0===z.length()&&Y.Bl(NaN)}return Y;default:throw new Error(`Cannot normalize value ${z}`)}}}(0,J.d)("FlowGraphNormalizeBlock",K);class h extends l.e{constructor(z){super(E.e,E.e,E.p,((z,u)=>this._polymorphicDot(z,u)),"FlowGraphDotBlock",z)}_polymorphicDot(z,u){switch((0,L.i)(z)){case"Vector2":case"Pl":case"Vector4":case"Quaternion":return z.dot(u);default:throw new Error(`Cannot get dot product of ${z} and ${u}`)}}}(0,J.d)("FlowGraphDotBlock",h);class o extends l.e{constructor(z){super(E.x,E.x,E.x,((z,u)=>b.p.Cross(z,u)),"FlowGraphCrossBlock",z)}}(0,J.d)("FlowGraphCrossBlock",o);class d extends l.e{constructor(z){super(E.w,E.p,E.w,((z,u)=>z.rotate(u)),"FlowGraphRotate2DBlock",z)}}(0,J.d)("FlowGraphRotate2DBlock",d);class t extends l.e{constructor(z){super(E.x,E.r,E.x,((z,u)=>z.applyRotationQuaternion(u)),"FlowGraphRotate3DBlock",z)}}function W(z,u){switch((0,L.i)(z)){case"Vector2":case"Pl":return u.transformVector(z);case"Vector4":return new b.t(z.x*u.m[0]+z.y*u.m[1]+z.z*u.m[2]+z.w*u.m[3],z.x*u.m[4]+z.y*u.m[5]+z.z*u.m[6]+z.w*u.m[7],z.x*u.m[8]+z.y*u.m[9]+z.z*u.m[10]+z.w*u.m[11],z.x*u.m[12]+z.y*u.m[13]+z.z*u.m[14]+z.w*u.m[15]);default:throw new Error(`Cannot transform value ${z}`)}}(0,J.d)("FlowGraphRotate3DBlock",t);class Z extends l.e{constructor(z){const u=(null===z||void 0===z?void 0:z.vectorType)||"Pl",Y="Vector2"===u?"Matrix2D":"Pl"===u?"Matrix3D":"Matrix";super((0,E.K)(u),(0,E.K)(Y),(0,E.K)(u),W,"FlowGraphTransformVectorBlock",z)}}(0,J.d)("FlowGraphTransformVectorBlock",Z);class s extends l.e{constructor(z){super(E.x,E.i,E.x,((z,u)=>b.p.TransformCoordinates(z,u)),"FlowGraphTransformCoordinatesBlock",z)}}(0,J.d)("FlowGraphTransformCoordinatesBlock",s);class v extends T.e{constructor(z){super(E.r,E.r,(z=>z.conjugate()),"FlowGraphConjugateBlock",z)}}(0,J.d)("FlowGraphConjugateBlock",v);class i extends l.e{constructor(z){super(E.r,E.r,E.p,((z,u)=>(0,D.e)(z,u)),"FlowGraphAngleBetweenBlock",z)}}(0,J.d)("FlowGraphAngleBetweenBlock",i);class X extends l.e{constructor(z){super(E.x,E.p,E.r,((z,u)=>b.f.RotationAxis(z,u)),"FlowGraphQuaternionFromAxisAngleBlock",z)}}(0,J.d)("FlowGraphQuaternionFromAxisAngleBlock",X);class Q extends H.b{constructor(z){super(z),this.a=this.registerDataInput("a",E.r),this.axis=this.registerDataOutput("axis",E.x),this.angle=this.registerDataOutput("angle",E.p),this.isValid=this.registerDataOutput("isValid",E.f)}_updateOutputs(z){const u=z._getExecutionVariable(this,q,-1),Y=z._getExecutionVariable(this,g,null),H=z._getExecutionVariable(this,M,null);if(void 0!==Y&&null!==Y&&void 0!==H&&null!==H&&u===z.executionId)this.axis.setValue(Y,z),this.angle.setValue(H,z);else try{const{axis:u,angle:Y}=this.a.getValue(z).toAxisAngle();z._setExecutionVariable(this,g,u),z._setExecutionVariable(this,M,Y),z._setExecutionVariable(this,q,z.executionId),this.axis.setValue(u,z),this.angle.setValue(Y,z),this.isValid.setValue(!0,z)}catch(E){this.isValid.setValue(!1,z)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,J.d)("FlowGraphAxisAngleFromQuaternionBlock",Q);class V extends l.e{constructor(z){super(E.x,E.x,E.r,((z,u)=>(0,D.h)(z,u)),"FlowGraphQuaternionFromDirectionsBlock",z)}}},13977:(z,u,Y)=>{Y.d(u,{e:()=>E});var H=Y(13983);class E extends H.e{constructor(z,u,Y,H,E,J){super(Y,J),this._operation=H,this._className=E,this.a=this.registerDataInput("a",z),this.b=this.registerDataInput("b",u)}_doOperation(z){const u=this.a.getValue(z),Y=this.b.getValue(z);return this._operation(u,Y)}getClassName(){return this._className}}},13983:(z,u,Y)=>{Y.d(u,{e:()=>T});var H=Y(12549),E=Y(12531);const J="cachedOperationValue",l="cachedExecutionId";class T extends H.b{constructor(z,u){super(u),this.value=this.registerDataOutput("value",z),this.isValid=this.registerDataOutput("isValid",E.f)}_updateOutputs(z){const u=z._getExecutionVariable(this,l,-1),Y=z._getExecutionVariable(this,J,null);if(void 0!==Y&&null!==Y&&u===z.executionId)this.isValid.setValue(!0,z),this.value.setValue(Y,z);else try{const u=this._doOperation(z);if(void 0===u||null===u)return void this.isValid.setValue(!1,z);z._setExecutionVariable(this,J,u),z._setExecutionVariable(this,l,z.executionId),this.value.setValue(u,z),this.isValid.setValue(!0,z)}catch(H){this.isValid.setValue(!1,z)}}}},13992:(z,u,Y)=>{Y.d(u,{e:()=>E});var H=Y(13983);class E extends H.e{constructor(z,u,Y,H,E){super(u,E),this._operation=Y,this._className=H,this.a=this.registerDataInput("a",z)}_doOperation(z){return this._operation(this.a.getValue(z))}getClassName(){return this._className}}}}]);