"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[69],{14550:(G,V,W)=>{W.r(V),W.d(V,{FlowGraphAngleBetweenBlock:()=>H,FlowGraphAxisAngleFromQuaternionBlock:()=>D,FlowGraphConjugateBlock:()=>u,FlowGraphCrossBlock:()=>B,FlowGraphDotBlock:()=>g,FlowGraphLengthBlock:()=>t,FlowGraphNormalizeBlock:()=>Y,FlowGraphQuaternionFromAxisAngleBlock:()=>n,FlowGraphQuaternionFromDirectionsBlock:()=>i,FlowGraphRotate2DBlock:()=>S,FlowGraphRotate3DBlock:()=>p,FlowGraphTransformBlock:()=>r,FlowGraphTransformCoordinatesBlock:()=>y});var J=W(13093),R=W(13071),d=W(11159),k=W(14533),z=W(14544),X=W(11136),P=W(13104),A=W(12752);const x="cachedOperationAxis",q="cachedOperationAngle",L="cachedExecutionId";class t extends z.e{constructor(G){super(R.b,R.r,(G=>this._polymorphicLength(G)),"FlowGraphLengthBlock",G)}_polymorphicLength(G){switch((0,P.k)(G)){case"Vector2":case"ed":case"Vector4":case"Quaternion":return G.length();default:throw new Error(`Cannot compute length of value ${G}`)}}}(0,d.d)("FlowGraphLengthBlock",t);class Y extends z.e{constructor(G){super(R.b,R.b,(G=>this._polymorphicNormalize(G)),"FlowGraphNormalizeBlock",G)}_polymorphicNormalize(G){var V;let W;switch((0,P.k)(G)){case"Vector2":case"ed":case"Vector4":case"Quaternion":if(W=G.normalizeToNew(),null!==(V=this.config)&&void 0!==V&&V.nanOnZeroLength){0===G.length()&&W.Ud(NaN)}return W;default:throw new Error(`Cannot normalize value ${G}`)}}}(0,d.d)("FlowGraphNormalizeBlock",Y);class g extends k.c{constructor(G){super(R.b,R.b,R.r,((G,V)=>this._polymorphicDot(G,V)),"FlowGraphDotBlock",G)}_polymorphicDot(G,V){switch((0,P.k)(G)){case"Vector2":case"ed":case"Vector4":case"Quaternion":return G.dot(V);default:throw new Error(`Cannot get dot product of ${G} and ${V}`)}}}(0,d.d)("FlowGraphDotBlock",g);class B extends k.c{constructor(G){super(R.x,R.x,R.x,((G,V)=>X.o.Cross(G,V)),"FlowGraphCrossBlock",G)}}(0,d.d)("FlowGraphCrossBlock",B);class S extends k.c{constructor(G){super(R.w,R.r,R.w,((G,V)=>G.rotate(V)),"FlowGraphRotate2DBlock",G)}}(0,d.d)("FlowGraphRotate2DBlock",S);class p extends k.c{constructor(G){super(R.x,R.s,R.x,((G,V)=>G.applyRotationQuaternion(V)),"FlowGraphRotate3DBlock",G)}}function b(G,V){switch((0,P.k)(G)){case"Vector2":case"ed":return V.transformVector(G);case"Vector4":return new X.q(G.x*V.m[0]+G.y*V.m[1]+G.z*V.m[2]+G.w*V.m[3],G.x*V.m[4]+G.y*V.m[5]+G.z*V.m[6]+G.w*V.m[7],G.x*V.m[8]+G.y*V.m[9]+G.z*V.m[10]+G.w*V.m[11],G.x*V.m[12]+G.y*V.m[13]+G.z*V.m[14]+G.w*V.m[15]);default:throw new Error(`Cannot transform value ${G}`)}}(0,d.d)("FlowGraphRotate3DBlock",p);class r extends k.c{constructor(G){const V=(null===G||void 0===G?void 0:G.vectorType)||"ed",W="Vector2"===V?"Matrix2D":"ed"===V?"Matrix3D":"Matrix";super((0,R.I)(V),(0,R.I)(W),(0,R.I)(V),b,"FlowGraphTransformVectorBlock",G)}}(0,d.d)("FlowGraphTransformVectorBlock",r);class y extends k.c{constructor(G){super(R.x,R.l,R.x,((G,V)=>X.o.TransformCoordinates(G,V)),"FlowGraphTransformCoordinatesBlock",G)}}(0,d.d)("FlowGraphTransformCoordinatesBlock",y);class u extends z.e{constructor(G){super(R.s,R.s,(G=>G.conjugate()),"FlowGraphConjugateBlock",G)}}(0,d.d)("FlowGraphConjugateBlock",u);class H extends k.c{constructor(G){super(R.s,R.s,R.r,((G,V)=>(0,A.c)(G,V)),"FlowGraphAngleBetweenBlock",G)}}(0,d.d)("FlowGraphAngleBetweenBlock",H);class n extends k.c{constructor(G){super(R.x,R.r,R.s,((G,V)=>X.g.RotationAxis(G,V)),"FlowGraphQuaternionFromAxisAngleBlock",G)}}(0,d.d)("FlowGraphQuaternionFromAxisAngleBlock",n);class D extends J.c{constructor(G){super(G),this.a=this.registerDataInput("a",R.s),this.axis=this.registerDataOutput("axis",R.x),this.angle=this.registerDataOutput("angle",R.r),this.isValid=this.registerDataOutput("isValid",R.d)}_updateOutputs(G){const V=G._getExecutionVariable(this,L,-1),W=G._getExecutionVariable(this,x,null),J=G._getExecutionVariable(this,q,null);if(void 0!==W&&null!==W&&void 0!==J&&null!==J&&V===G.executionId)this.axis.setValue(W,G),this.angle.setValue(J,G);else try{const{axis:V,angle:W}=this.a.getValue(G).toAxisAngle();G._setExecutionVariable(this,x,V),G._setExecutionVariable(this,q,W),G._setExecutionVariable(this,L,G.executionId),this.axis.setValue(V,G),this.angle.setValue(W,G),this.isValid.setValue(!0,G)}catch(R){this.isValid.setValue(!1,G)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,d.d)("FlowGraphAxisAngleFromQuaternionBlock",D);class i extends k.c{constructor(G){super(R.x,R.x,R.s,((G,V)=>(0,A.f)(G,V)),"FlowGraphQuaternionFromDirectionsBlock",G)}}},14533:(G,V,W)=>{W.d(V,{c:()=>R});var J=W(14535);class R extends J.c{constructor(G,V,W,J,R,d){super(W,d),this._operation=J,this._className=R,this.a=this.registerDataInput("a",G),this.b=this.registerDataInput("b",V)}_doOperation(G){const V=this.a.getValue(G),W=this.b.getValue(G);return this._operation(V,W)}getClassName(){return this._className}}},14535:(G,V,W)=>{W.d(V,{c:()=>z});var J=W(13093),R=W(13071);const d="cachedOperationValue",k="cachedExecutionId";class z extends J.c{constructor(G,V){super(V),this.value=this.registerDataOutput("value",G),this.isValid=this.registerDataOutput("isValid",R.d)}_updateOutputs(G){const V=G._getExecutionVariable(this,k,-1),W=G._getExecutionVariable(this,d,null);if(void 0!==W&&null!==W&&V===G.executionId)this.isValid.setValue(!0,G),this.value.setValue(W,G);else try{const V=this._doOperation(G);if(void 0===V||null===V)return void this.isValid.setValue(!1,G);G._setExecutionVariable(this,d,V),G._setExecutionVariable(this,k,G.executionId),this.value.setValue(V,G),this.isValid.setValue(!0,G)}catch(J){this.isValid.setValue(!1,G)}}}},14544:(G,V,W)=>{W.d(V,{e:()=>R});var J=W(14535);class R extends J.c{constructor(G,V,W,J,R){super(V,R),this._operation=W,this._className=J,this.a=this.registerDataInput("a",G)}_doOperation(G){return this._operation(this.a.getValue(G))}getClassName(){return this._className}}}}]);