"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[69],{14218:(x,O,Q)=>{Q.r(O),Q.d(O,{FlowGraphAngleBetweenBlock:()=>k,FlowGraphAxisAngleFromQuaternionBlock:()=>t,FlowGraphConjugateBlock:()=>G,FlowGraphCrossBlock:()=>Y,FlowGraphDotBlock:()=>M,FlowGraphLengthBlock:()=>a,FlowGraphNormalizeBlock:()=>K,FlowGraphQuaternionFromAxisAngleBlock:()=>J,FlowGraphQuaternionFromDirectionsBlock:()=>c,FlowGraphRotate2DBlock:()=>g,FlowGraphRotate3DBlock:()=>v,FlowGraphTransformBlock:()=>s,FlowGraphTransformCoordinatesBlock:()=>q});var X=Q(12726),Z=Q(12707),n=Q(10866),V=Q(14205),o=Q(14216),l=Q(10849),C=Q(12730),U=Q(12365);const L="cachedOperationAxis",h="cachedOperationAngle",N="cachedExecutionId";class a extends o.e{constructor(x){super(Z.d,Z.q,(x=>this._polymorphicLength(x)),"FlowGraphLengthBlock",x)}_polymorphicLength(x){switch((0,C.o)(x)){case"Vector2":case"Oo":case"Vector4":case"Quaternion":return x.length();default:throw new Error(`Cannot compute length of value ${x}`)}}}(0,n.d)("FlowGraphLengthBlock",a);class K extends o.e{constructor(x){super(Z.d,Z.d,(x=>this._polymorphicNormalize(x)),"FlowGraphNormalizeBlock",x)}_polymorphicNormalize(x){var O;let Q;switch((0,C.o)(x)){case"Vector2":case"Oo":case"Vector4":case"Quaternion":if(Q=x.normalizeToNew(),null!==(O=this.config)&&void 0!==O&&O.nanOnZeroLength){0===x.length()&&Q.Zo(NaN)}return Q;default:throw new Error(`Cannot normalize value ${x}`)}}}(0,n.d)("FlowGraphNormalizeBlock",K);class M extends V.e{constructor(x){super(Z.d,Z.d,Z.q,((x,O)=>this._polymorphicDot(x,O)),"FlowGraphDotBlock",x)}_polymorphicDot(x,O){switch((0,C.o)(x)){case"Vector2":case"Oo":case"Vector4":case"Quaternion":return x.dot(O);default:throw new Error(`Cannot get dot product of ${x} and ${O}`)}}}(0,n.d)("FlowGraphDotBlock",M);class Y extends V.e{constructor(x){super(Z.A,Z.A,Z.A,((x,O)=>l.n.Cross(x,O)),"FlowGraphCrossBlock",x)}}(0,n.d)("FlowGraphCrossBlock",Y);class g extends V.e{constructor(x){super(Z.y,Z.q,Z.y,((x,O)=>x.rotate(O)),"FlowGraphRotate2DBlock",x)}}(0,n.d)("FlowGraphRotate2DBlock",g);class v extends V.e{constructor(x){super(Z.A,Z.t,Z.A,((x,O)=>x.applyRotationQuaternion(O)),"FlowGraphRotate3DBlock",x)}}function R(x,O){switch((0,C.o)(x)){case"Vector2":case"Oo":return O.transformVector(x);case"Vector4":return new l.o(x.x*O.m[0]+x.y*O.m[1]+x.z*O.m[2]+x.w*O.m[3],x.x*O.m[4]+x.y*O.m[5]+x.z*O.m[6]+x.w*O.m[7],x.x*O.m[8]+x.y*O.m[9]+x.z*O.m[10]+x.w*O.m[11],x.x*O.m[12]+x.y*O.m[13]+x.z*O.m[14]+x.w*O.m[15]);default:throw new Error(`Cannot transform value ${x}`)}}(0,n.d)("FlowGraphRotate3DBlock",v);class s extends V.e{constructor(x){const O=(null===x||void 0===x?void 0:x.vectorType)||"Oo",Q="Vector2"===O?"Matrix2D":"Oo"===O?"Matrix3D":"Matrix";super((0,Z.G)(O),(0,Z.G)(Q),(0,Z.G)(O),R,"FlowGraphTransformVectorBlock",x)}}(0,n.d)("FlowGraphTransformVectorBlock",s);class q extends V.e{constructor(x){super(Z.A,Z.j,Z.A,((x,O)=>l.n.TransformCoordinates(x,O)),"FlowGraphTransformCoordinatesBlock",x)}}(0,n.d)("FlowGraphTransformCoordinatesBlock",q);class G extends o.e{constructor(x){super(Z.t,Z.t,(x=>x.conjugate()),"FlowGraphConjugateBlock",x)}}(0,n.d)("FlowGraphConjugateBlock",G);class k extends V.e{constructor(x){super(Z.t,Z.t,Z.q,((x,O)=>(0,U.d)(x,O)),"FlowGraphAngleBetweenBlock",x)}}(0,n.d)("FlowGraphAngleBetweenBlock",k);class J extends V.e{constructor(x){super(Z.A,Z.q,Z.t,((x,O)=>l.g.RotationAxis(x,O)),"FlowGraphQuaternionFromAxisAngleBlock",x)}}(0,n.d)("FlowGraphQuaternionFromAxisAngleBlock",J);class t extends X.d{constructor(x){super(x),this.a=this.registerDataInput("a",Z.t),this.axis=this.registerDataOutput("axis",Z.A),this.angle=this.registerDataOutput("angle",Z.q),this.isValid=this.registerDataOutput("isValid",Z.g)}_updateOutputs(x){const O=x._getExecutionVariable(this,N,-1),Q=x._getExecutionVariable(this,L,null),X=x._getExecutionVariable(this,h,null);if(void 0!==Q&&null!==Q&&void 0!==X&&null!==X&&O===x.executionId)this.axis.setValue(Q,x),this.angle.setValue(X,x);else try{const{axis:O,angle:Q}=this.a.getValue(x).toAxisAngle();x._setExecutionVariable(this,L,O),x._setExecutionVariable(this,h,Q),x._setExecutionVariable(this,N,x.executionId),this.axis.setValue(O,x),this.angle.setValue(Q,x),this.isValid.setValue(!0,x)}catch(Z){this.isValid.setValue(!1,x)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,n.d)("FlowGraphAxisAngleFromQuaternionBlock",t);class c extends V.e{constructor(x){super(Z.A,Z.A,Z.t,((x,O)=>(0,U.h)(x,O)),"FlowGraphQuaternionFromDirectionsBlock",x)}}},14205:(x,O,Q)=>{Q.d(O,{e:()=>Z});var X=Q(14213);class Z extends X.d{constructor(x,O,Q,X,Z,n){super(Q,n),this._operation=X,this._className=Z,this.a=this.registerDataInput("a",x),this.b=this.registerDataInput("b",O)}_doOperation(x){const O=this.a.getValue(x),Q=this.b.getValue(x);return this._operation(O,Q)}getClassName(){return this._className}}},14213:(x,O,Q)=>{Q.d(O,{d:()=>o});var X=Q(12726),Z=Q(12707);const n="cachedOperationValue",V="cachedExecutionId";class o extends X.d{constructor(x,O){super(O),this.value=this.registerDataOutput("value",x),this.isValid=this.registerDataOutput("isValid",Z.g)}_updateOutputs(x){const O=x._getExecutionVariable(this,V,-1),Q=x._getExecutionVariable(this,n,null);if(void 0!==Q&&null!==Q&&O===x.executionId)this.isValid.setValue(!0,x),this.value.setValue(Q,x);else try{const O=this._doOperation(x);if(void 0===O||null===O)return void this.isValid.setValue(!1,x);x._setExecutionVariable(this,n,O),x._setExecutionVariable(this,V,x.executionId),this.value.setValue(O,x),this.isValid.setValue(!0,x)}catch(X){this.isValid.setValue(!1,x)}}}},14216:(x,O,Q)=>{Q.d(O,{e:()=>Z});var X=Q(14213);class Z extends X.d{constructor(x,O,Q,X,Z){super(O,Z),this._operation=Q,this._className=X,this.a=this.registerDataInput("a",x)}_doOperation(x){return this._operation(this.a.getValue(x))}getClassName(){return this._className}}}}]);