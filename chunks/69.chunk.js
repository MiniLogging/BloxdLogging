"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[69],{14280:(s,Z,o)=>{o.r(Z),o.d(Z,{FlowGraphAngleBetweenBlock:()=>N,FlowGraphAxisAngleFromQuaternionBlock:()=>V,FlowGraphConjugateBlock:()=>i,FlowGraphCrossBlock:()=>A,FlowGraphDotBlock:()=>f,FlowGraphLengthBlock:()=>Y,FlowGraphNormalizeBlock:()=>b,FlowGraphQuaternionFromAxisAngleBlock:()=>L,FlowGraphQuaternionFromDirectionsBlock:()=>g,FlowGraphRotate2DBlock:()=>d,FlowGraphRotate3DBlock:()=>U,FlowGraphTransformBlock:()=>H,FlowGraphTransformCoordinatesBlock:()=>F});var t=o(12802),j=o(12775),S=o(10916),a=o(14265),O=o(14273),v=o(10900),G=o(12816),B=o(12454);const Q="cachedOperationAxis",D="cachedOperationAngle",z="cachedExecutionId";class Y extends O.b{constructor(s){super(j.d,j.w,(s=>this._polymorphicLength(s)),"FlowGraphLengthBlock",s)}_polymorphicLength(s){switch((0,G.i)(s)){case"Vector2":case"sO":case"Vector4":case"Quaternion":return s.length();default:throw new Error(`Cannot compute length of value ${s}`)}}}(0,S.f)("FlowGraphLengthBlock",Y);class b extends O.b{constructor(s){super(j.d,j.d,(s=>this._polymorphicNormalize(s)),"FlowGraphNormalizeBlock",s)}_polymorphicNormalize(s){var Z;let o;switch((0,G.i)(s)){case"Vector2":case"sO":case"Vector4":case"Quaternion":if(o=s.normalizeToNew(),null!==(Z=this.config)&&void 0!==Z&&Z.nanOnZeroLength){0===s.length()&&o.tO(NaN)}return o;default:throw new Error(`Cannot normalize value ${s}`)}}}(0,S.f)("FlowGraphNormalizeBlock",b);class f extends a.e{constructor(s){super(j.d,j.d,j.w,((s,Z)=>this._polymorphicDot(s,Z)),"FlowGraphDotBlock",s)}_polymorphicDot(s,Z){switch((0,G.i)(s)){case"Vector2":case"sO":case"Vector4":case"Quaternion":return s.dot(Z);default:throw new Error(`Cannot get dot product of ${s} and ${Z}`)}}}(0,S.f)("FlowGraphDotBlock",f);class A extends a.e{constructor(s){super(j.H,j.H,j.H,((s,Z)=>v.n.Cross(s,Z)),"FlowGraphCrossBlock",s)}}(0,S.f)("FlowGraphCrossBlock",A);class d extends a.e{constructor(s){super(j.E,j.w,j.E,((s,Z)=>s.rotate(Z)),"FlowGraphRotate2DBlock",s)}}(0,S.f)("FlowGraphRotate2DBlock",d);class U extends a.e{constructor(s){super(j.H,j.x,j.H,((s,Z)=>s.applyRotationQuaternion(Z)),"FlowGraphRotate3DBlock",s)}}function u(s,Z){switch((0,G.i)(s)){case"Vector2":case"sO":return Z.transformVector(s);case"Vector4":return new v.p(s.x*Z.m[0]+s.y*Z.m[1]+s.z*Z.m[2]+s.w*Z.m[3],s.x*Z.m[4]+s.y*Z.m[5]+s.z*Z.m[6]+s.w*Z.m[7],s.x*Z.m[8]+s.y*Z.m[9]+s.z*Z.m[10]+s.w*Z.m[11],s.x*Z.m[12]+s.y*Z.m[13]+s.z*Z.m[14]+s.w*Z.m[15]);default:throw new Error(`Cannot transform value ${s}`)}}(0,S.f)("FlowGraphRotate3DBlock",U);class H extends a.e{constructor(s){const Z=(null===s||void 0===s?void 0:s.vectorType)||"sO",o="Vector2"===Z?"Matrix2D":"sO"===Z?"Matrix3D":"Matrix";super((0,j.U)(Z),(0,j.U)(o),(0,j.U)(Z),u,"FlowGraphTransformVectorBlock",s)}}(0,S.f)("FlowGraphTransformVectorBlock",H);class F extends a.e{constructor(s){super(j.H,j.n,j.H,((s,Z)=>v.n.TransformCoordinates(s,Z)),"FlowGraphTransformCoordinatesBlock",s)}}(0,S.f)("FlowGraphTransformCoordinatesBlock",F);class i extends O.b{constructor(s){super(j.x,j.x,(s=>s.conjugate()),"FlowGraphConjugateBlock",s)}}(0,S.f)("FlowGraphConjugateBlock",i);class N extends a.e{constructor(s){super(j.x,j.x,j.w,((s,Z)=>(0,B.d)(s,Z)),"FlowGraphAngleBetweenBlock",s)}}(0,S.f)("FlowGraphAngleBetweenBlock",N);class L extends a.e{constructor(s){super(j.H,j.w,j.x,((s,Z)=>v.e.RotationAxis(s,Z)),"FlowGraphQuaternionFromAxisAngleBlock",s)}}(0,S.f)("FlowGraphQuaternionFromAxisAngleBlock",L);class V extends t.e{constructor(s){super(s),this.a=this.registerDataInput("a",j.x),this.axis=this.registerDataOutput("axis",j.H),this.angle=this.registerDataOutput("angle",j.w),this.isValid=this.registerDataOutput("isValid",j.g)}_updateOutputs(s){const Z=s._getExecutionVariable(this,z,-1),o=s._getExecutionVariable(this,Q,null),t=s._getExecutionVariable(this,D,null);if(void 0!==o&&null!==o&&void 0!==t&&null!==t&&Z===s.executionId)this.axis.setValue(o,s),this.angle.setValue(t,s);else try{const{axis:Z,angle:o}=this.a.getValue(s).toAxisAngle();s._setExecutionVariable(this,Q,Z),s._setExecutionVariable(this,D,o),s._setExecutionVariable(this,z,s.executionId),this.axis.setValue(Z,s),this.angle.setValue(o,s),this.isValid.setValue(!0,s)}catch(j){this.isValid.setValue(!1,s)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,S.f)("FlowGraphAxisAngleFromQuaternionBlock",V);class g extends a.e{constructor(s){super(j.H,j.H,j.x,((s,Z)=>(0,B.g)(s,Z)),"FlowGraphQuaternionFromDirectionsBlock",s)}}},14265:(s,Z,o)=>{o.d(Z,{e:()=>j});var t=o(14271);class j extends t.e{constructor(s,Z,o,t,j,S){super(o,S),this._operation=t,this._className=j,this.a=this.registerDataInput("a",s),this.b=this.registerDataInput("b",Z)}_doOperation(s){const Z=this.a.getValue(s),o=this.b.getValue(s);return this._operation(Z,o)}getClassName(){return this._className}}},14271:(s,Z,o)=>{o.d(Z,{e:()=>O});var t=o(12802),j=o(12775);const S="cachedOperationValue",a="cachedExecutionId";class O extends t.e{constructor(s,Z){super(Z),this.value=this.registerDataOutput("value",s),this.isValid=this.registerDataOutput("isValid",j.g)}_updateOutputs(s){const Z=s._getExecutionVariable(this,a,-1),o=s._getExecutionVariable(this,S,null);if(void 0!==o&&null!==o&&Z===s.executionId)this.isValid.setValue(!0,s),this.value.setValue(o,s);else try{const Z=this._doOperation(s);if(void 0===Z||null===Z)return void this.isValid.setValue(!1,s);s._setExecutionVariable(this,S,Z),s._setExecutionVariable(this,a,s.executionId),this.value.setValue(Z,s),this.isValid.setValue(!0,s)}catch(t){this.isValid.setValue(!1,s)}}}},14273:(s,Z,o)=>{o.d(Z,{b:()=>j});var t=o(14271);class j extends t.e{constructor(s,Z,o,t,j){super(Z,j),this._operation=o,this._className=t,this.a=this.registerDataInput("a",s)}_doOperation(s){return this._operation(this.a.getValue(s))}getClassName(){return this._className}}}}]);