"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[69],{14137:(h,d,m)=>{m.r(d),m.d(d,{FlowGraphAngleBetweenBlock:()=>i,FlowGraphAxisAngleFromQuaternionBlock:()=>F,FlowGraphConjugateBlock:()=>y,FlowGraphCrossBlock:()=>B,FlowGraphDotBlock:()=>L,FlowGraphLengthBlock:()=>R,FlowGraphNormalizeBlock:()=>Z,FlowGraphQuaternionFromAxisAngleBlock:()=>g,FlowGraphQuaternionFromDirectionsBlock:()=>f,FlowGraphRotate2DBlock:()=>V,FlowGraphRotate3DBlock:()=>v,FlowGraphTransformBlock:()=>T,FlowGraphTransformCoordinatesBlock:()=>o});var j=m(12687),A=m(12671),b=m(11080),w=m(14121),a=m(14128),D=m(11058),S=m(12695),M=m(12356);const q="cachedOperationAxis",E="cachedOperationAngle",I="cachedExecutionId";class R extends a.b{constructor(h){super(A.e,A.y,(h=>this._polymorphicLength(h)),"FlowGraphLengthBlock",h)}_polymorphicLength(h){switch((0,S.l)(h)){case"Vector2":case"Qd":case"Vector4":case"Quaternion":return h.length();default:throw new Error(`Cannot compute length of value ${h}`)}}}(0,b.i)("FlowGraphLengthBlock",R);class Z extends a.b{constructor(h){super(A.e,A.e,(h=>this._polymorphicNormalize(h)),"FlowGraphNormalizeBlock",h)}_polymorphicNormalize(h){var d;let m;switch((0,S.l)(h)){case"Vector2":case"Qd":case"Vector4":case"Quaternion":if(m=h.normalizeToNew(),null!==(d=this.config)&&void 0!==d&&d.nanOnZeroLength){0===h.length()&&m.sd(NaN)}return m;default:throw new Error(`Cannot normalize value ${h}`)}}}(0,b.i)("FlowGraphNormalizeBlock",Z);class L extends w.b{constructor(h){super(A.e,A.e,A.y,((h,d)=>this._polymorphicDot(h,d)),"FlowGraphDotBlock",h)}_polymorphicDot(h,d){switch((0,S.l)(h)){case"Vector2":case"Qd":case"Vector4":case"Quaternion":return h.dot(d);default:throw new Error(`Cannot get dot product of ${h} and ${d}`)}}}(0,b.i)("FlowGraphDotBlock",L);class B extends w.b{constructor(h){super(A.E,A.E,A.E,((h,d)=>D.i.Cross(h,d)),"FlowGraphCrossBlock",h)}}(0,b.i)("FlowGraphCrossBlock",B);class V extends w.b{constructor(h){super(A.D,A.y,A.D,((h,d)=>h.rotate(d)),"FlowGraphRotate2DBlock",h)}}(0,b.i)("FlowGraphRotate2DBlock",V);class v extends w.b{constructor(h){super(A.E,A.z,A.E,((h,d)=>h.applyRotationQuaternion(d)),"FlowGraphRotate3DBlock",h)}}function C(h,d){switch((0,S.l)(h)){case"Vector2":case"Qd":return d.transformVector(h);case"Vector4":return new D.m(h.x*d.m[0]+h.y*d.m[1]+h.z*d.m[2]+h.w*d.m[3],h.x*d.m[4]+h.y*d.m[5]+h.z*d.m[6]+h.w*d.m[7],h.x*d.m[8]+h.y*d.m[9]+h.z*d.m[10]+h.w*d.m[11],h.x*d.m[12]+h.y*d.m[13]+h.z*d.m[14]+h.w*d.m[15]);default:throw new Error(`Cannot transform value ${h}`)}}(0,b.i)("FlowGraphRotate3DBlock",v);class T extends w.b{constructor(h){const d=(null===h||void 0===h?void 0:h.vectorType)||"Qd",m="Vector2"===d?"Matrix2D":"Qd"===d?"Matrix3D":"Matrix";super((0,A.M)(d),(0,A.M)(m),(0,A.M)(d),C,"FlowGraphTransformVectorBlock",h)}}(0,b.i)("FlowGraphTransformVectorBlock",T);class o extends w.b{constructor(h){super(A.E,A.m,A.E,((h,d)=>D.i.TransformCoordinates(h,d)),"FlowGraphTransformCoordinatesBlock",h)}}(0,b.i)("FlowGraphTransformCoordinatesBlock",o);class y extends a.b{constructor(h){super(A.z,A.z,(h=>h.conjugate()),"FlowGraphConjugateBlock",h)}}(0,b.i)("FlowGraphConjugateBlock",y);class i extends w.b{constructor(h){super(A.z,A.z,A.y,((h,d)=>(0,M.d)(h,d)),"FlowGraphAngleBetweenBlock",h)}}(0,b.i)("FlowGraphAngleBetweenBlock",i);class g extends w.b{constructor(h){super(A.E,A.y,A.z,((h,d)=>D.c.RotationAxis(h,d)),"FlowGraphQuaternionFromAxisAngleBlock",h)}}(0,b.i)("FlowGraphQuaternionFromAxisAngleBlock",g);class F extends j.d{constructor(h){super(h),this.a=this.registerDataInput("a",A.z),this.axis=this.registerDataOutput("axis",A.E),this.angle=this.registerDataOutput("angle",A.y),this.isValid=this.registerDataOutput("isValid",A.f)}_updateOutputs(h){const d=h._getExecutionVariable(this,I,-1),m=h._getExecutionVariable(this,q,null),j=h._getExecutionVariable(this,E,null);if(void 0!==m&&null!==m&&void 0!==j&&null!==j&&d===h.executionId)this.axis.setValue(m,h),this.angle.setValue(j,h);else try{const{axis:d,angle:m}=this.a.getValue(h).toAxisAngle();h._setExecutionVariable(this,q,d),h._setExecutionVariable(this,E,m),h._setExecutionVariable(this,I,h.executionId),this.axis.setValue(d,h),this.angle.setValue(m,h),this.isValid.setValue(!0,h)}catch(A){this.isValid.setValue(!1,h)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,b.i)("FlowGraphAxisAngleFromQuaternionBlock",F);class f extends w.b{constructor(h){super(A.E,A.E,A.z,((h,d)=>(0,M.e)(h,d)),"FlowGraphQuaternionFromDirectionsBlock",h)}}},14121:(h,d,m)=>{m.d(d,{b:()=>A});var j=m(14124);class A extends j.d{constructor(h,d,m,j,A,b){super(m,b),this._operation=j,this._className=A,this.a=this.registerDataInput("a",h),this.b=this.registerDataInput("b",d)}_doOperation(h){const d=this.a.getValue(h),m=this.b.getValue(h);return this._operation(d,m)}getClassName(){return this._className}}},14124:(h,d,m)=>{m.d(d,{d:()=>a});var j=m(12687),A=m(12671);const b="cachedOperationValue",w="cachedExecutionId";class a extends j.d{constructor(h,d){super(d),this.value=this.registerDataOutput("value",h),this.isValid=this.registerDataOutput("isValid",A.f)}_updateOutputs(h){const d=h._getExecutionVariable(this,w,-1),m=h._getExecutionVariable(this,b,null);if(void 0!==m&&null!==m&&d===h.executionId)this.isValid.setValue(!0,h),this.value.setValue(m,h);else try{const d=this._doOperation(h);if(void 0===d||null===d)return void this.isValid.setValue(!1,h);h._setExecutionVariable(this,b,d),h._setExecutionVariable(this,w,h.executionId),this.value.setValue(d,h),this.isValid.setValue(!0,h)}catch(j){this.isValid.setValue(!1,h)}}}},14128:(h,d,m)=>{m.d(d,{b:()=>A});var j=m(14124);class A extends j.d{constructor(h,d,m,j,A){super(d,A),this._operation=m,this._className=j,this.a=this.registerDataInput("a",h)}_doOperation(h){return this._operation(this.a.getValue(h))}getClassName(){return this._className}}}}]);