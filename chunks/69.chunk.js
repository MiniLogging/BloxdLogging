"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[69],{14182:(q,f,j)=>{j.r(f),j.d(f,{FlowGraphAngleBetweenBlock:()=>Z,FlowGraphAxisAngleFromQuaternionBlock:()=>T,FlowGraphConjugateBlock:()=>e,FlowGraphCrossBlock:()=>O,FlowGraphDotBlock:()=>t,FlowGraphLengthBlock:()=>D,FlowGraphNormalizeBlock:()=>i,FlowGraphQuaternionFromAxisAngleBlock:()=>I,FlowGraphQuaternionFromDirectionsBlock:()=>W,FlowGraphRotate2DBlock:()=>N,FlowGraphRotate3DBlock:()=>w,FlowGraphTransformBlock:()=>s,FlowGraphTransformCoordinatesBlock:()=>S});var d=j(12726),g=j(12709),h=j(10965),L=j(14165),Q=j(14179),H=j(10941),r=j(12740),u=j(12406);const X="cachedOperationAxis",z="cachedOperationAngle",B="cachedExecutionId";class D extends Q.c{constructor(q){super(g.c,g.o,(q=>this._polymorphicLength(q)),"FlowGraphLengthBlock",q)}_polymorphicLength(q){switch((0,r.h)(q)){case"Vector2":case"kf":case"Vector4":case"Quaternion":return q.length();default:throw new Error(`Cannot compute length of value ${q}`)}}}(0,h.f)("FlowGraphLengthBlock",D);class i extends Q.c{constructor(q){super(g.c,g.c,(q=>this._polymorphicNormalize(q)),"FlowGraphNormalizeBlock",q)}_polymorphicNormalize(q){var f;let j;switch((0,r.h)(q)){case"Vector2":case"kf":case"Vector4":case"Quaternion":if(j=q.normalizeToNew(),null!==(f=this.config)&&void 0!==f&&f.nanOnZeroLength){0===q.length()&&j.cf(NaN)}return j;default:throw new Error(`Cannot normalize value ${q}`)}}}(0,h.f)("FlowGraphNormalizeBlock",i);class t extends L.b{constructor(q){super(g.c,g.c,g.o,((q,f)=>this._polymorphicDot(q,f)),"FlowGraphDotBlock",q)}_polymorphicDot(q,f){switch((0,r.h)(q)){case"Vector2":case"kf":case"Vector4":case"Quaternion":return q.dot(f);default:throw new Error(`Cannot get dot product of ${q} and ${f}`)}}}(0,h.f)("FlowGraphDotBlock",t);class O extends L.b{constructor(q){super(g.u,g.u,g.u,((q,f)=>H.j.Cross(q,f)),"FlowGraphCrossBlock",q)}}(0,h.f)("FlowGraphCrossBlock",O);class N extends L.b{constructor(q){super(g.t,g.o,g.t,((q,f)=>q.rotate(f)),"FlowGraphRotate2DBlock",q)}}(0,h.f)("FlowGraphRotate2DBlock",N);class w extends L.b{constructor(q){super(g.u,g.p,g.u,((q,f)=>q.applyRotationQuaternion(f)),"FlowGraphRotate3DBlock",q)}}function E(q,f){switch((0,r.h)(q)){case"Vector2":case"kf":return f.transformVector(q);case"Vector4":return new H.m(q.x*f.m[0]+q.y*f.m[1]+q.z*f.m[2]+q.w*f.m[3],q.x*f.m[4]+q.y*f.m[5]+q.z*f.m[6]+q.w*f.m[7],q.x*f.m[8]+q.y*f.m[9]+q.z*f.m[10]+q.w*f.m[11],q.x*f.m[12]+q.y*f.m[13]+q.z*f.m[14]+q.w*f.m[15]);default:throw new Error(`Cannot transform value ${q}`)}}(0,h.f)("FlowGraphRotate3DBlock",w);class s extends L.b{constructor(q){const f=(null===q||void 0===q?void 0:q.vectorType)||"kf",j="Vector2"===f?"Matrix2D":"kf"===f?"Matrix3D":"Matrix";super((0,g.D)(f),(0,g.D)(j),(0,g.D)(f),E,"FlowGraphTransformVectorBlock",q)}}(0,h.f)("FlowGraphTransformVectorBlock",s);class S extends L.b{constructor(q){super(g.u,g.g,g.u,((q,f)=>H.j.TransformCoordinates(q,f)),"FlowGraphTransformCoordinatesBlock",q)}}(0,h.f)("FlowGraphTransformCoordinatesBlock",S);class e extends Q.c{constructor(q){super(g.p,g.p,(q=>q.conjugate()),"FlowGraphConjugateBlock",q)}}(0,h.f)("FlowGraphConjugateBlock",e);class Z extends L.b{constructor(q){super(g.p,g.p,g.o,((q,f)=>(0,u.c)(q,f)),"FlowGraphAngleBetweenBlock",q)}}(0,h.f)("FlowGraphAngleBetweenBlock",Z);class I extends L.b{constructor(q){super(g.u,g.o,g.p,((q,f)=>H.e.RotationAxis(q,f)),"FlowGraphQuaternionFromAxisAngleBlock",q)}}(0,h.f)("FlowGraphQuaternionFromAxisAngleBlock",I);class T extends d.e{constructor(q){super(q),this.a=this.registerDataInput("a",g.p),this.axis=this.registerDataOutput("axis",g.u),this.angle=this.registerDataOutput("angle",g.o),this.isValid=this.registerDataOutput("isValid",g.d)}_updateOutputs(q){const f=q._getExecutionVariable(this,B,-1),j=q._getExecutionVariable(this,X,null),d=q._getExecutionVariable(this,z,null);if(void 0!==j&&null!==j&&void 0!==d&&null!==d&&f===q.executionId)this.axis.setValue(j,q),this.angle.setValue(d,q);else try{const{axis:f,angle:j}=this.a.getValue(q).toAxisAngle();q._setExecutionVariable(this,X,f),q._setExecutionVariable(this,z,j),q._setExecutionVariable(this,B,q.executionId),this.axis.setValue(f,q),this.angle.setValue(j,q),this.isValid.setValue(!0,q)}catch(g){this.isValid.setValue(!1,q)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,h.f)("FlowGraphAxisAngleFromQuaternionBlock",T);class W extends L.b{constructor(q){super(g.u,g.u,g.p,((q,f)=>(0,u.g)(q,f)),"FlowGraphQuaternionFromDirectionsBlock",q)}}},14165:(q,f,j)=>{j.d(f,{b:()=>g});var d=j(14173);class g extends d.d{constructor(q,f,j,d,g,h){super(j,h),this._operation=d,this._className=g,this.a=this.registerDataInput("a",q),this.b=this.registerDataInput("b",f)}_doOperation(q){const f=this.a.getValue(q),j=this.b.getValue(q);return this._operation(f,j)}getClassName(){return this._className}}},14173:(q,f,j)=>{j.d(f,{d:()=>Q});var d=j(12726),g=j(12709);const h="cachedOperationValue",L="cachedExecutionId";class Q extends d.e{constructor(q,f){super(f),this.value=this.registerDataOutput("value",q),this.isValid=this.registerDataOutput("isValid",g.d)}_updateOutputs(q){const f=q._getExecutionVariable(this,L,-1),j=q._getExecutionVariable(this,h,null);if(void 0!==j&&null!==j&&f===q.executionId)this.isValid.setValue(!0,q),this.value.setValue(j,q);else try{const f=this._doOperation(q);if(void 0===f||null===f)return void this.isValid.setValue(!1,q);q._setExecutionVariable(this,h,f),q._setExecutionVariable(this,L,q.executionId),this.value.setValue(f,q),this.isValid.setValue(!0,q)}catch(d){this.isValid.setValue(!1,q)}}}},14179:(q,f,j)=>{j.d(f,{c:()=>g});var d=j(14173);class g extends d.d{constructor(q,f,j,d,g){super(f,g),this._operation=j,this._className=d,this.a=this.registerDataInput("a",q)}_doOperation(q){return this._operation(this.a.getValue(q))}getClassName(){return this._className}}}}]);