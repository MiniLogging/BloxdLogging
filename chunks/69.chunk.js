"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[69],{14438:(V,I,m)=>{m.r(I),m.d(I,{FlowGraphAngleBetweenBlock:()=>H,FlowGraphAxisAngleFromQuaternionBlock:()=>z,FlowGraphConjugateBlock:()=>c,FlowGraphCrossBlock:()=>D,FlowGraphDotBlock:()=>t,FlowGraphLengthBlock:()=>v,FlowGraphNormalizeBlock:()=>N,FlowGraphQuaternionFromAxisAngleBlock:()=>y,FlowGraphQuaternionFromDirectionsBlock:()=>Z,FlowGraphRotate2DBlock:()=>b,FlowGraphRotate3DBlock:()=>T,FlowGraphTransformBlock:()=>x,FlowGraphTransformCoordinatesBlock:()=>S});var C=m(12921),l=m(12899),s=m(11048),F=m(14422),k=m(14429),j=m(11040),E=m(12926),K=m(12573);const Y="cachedOperationAxis",X="cachedOperationAngle",O="cachedExecutionId";class v extends k.d{constructor(V){super(l.b,l.r,(V=>this._polymorphicLength(V)),"FlowGraphLengthBlock",V)}_polymorphicLength(V){switch((0,E.h)(V)){case"Vector2":case"LF":case"Vector4":case"Quaternion":return V.length();default:throw new Error(`Cannot compute length of value ${V}`)}}}(0,s.h)("FlowGraphLengthBlock",v);class N extends k.d{constructor(V){super(l.b,l.b,(V=>this._polymorphicNormalize(V)),"FlowGraphNormalizeBlock",V)}_polymorphicNormalize(V){var I;let m;switch((0,E.h)(V)){case"Vector2":case"LF":case"Vector4":case"Quaternion":if(m=V.normalizeToNew(),null!==(I=this.config)&&void 0!==I&&I.nanOnZeroLength){0===V.length()&&m.mk(NaN)}return m;default:throw new Error(`Cannot normalize value ${V}`)}}}(0,s.h)("FlowGraphNormalizeBlock",N);class t extends F.d{constructor(V){super(l.b,l.b,l.r,((V,I)=>this._polymorphicDot(V,I)),"FlowGraphDotBlock",V)}_polymorphicDot(V,I){switch((0,E.h)(V)){case"Vector2":case"LF":case"Vector4":case"Quaternion":return V.dot(I);default:throw new Error(`Cannot get dot product of ${V} and ${I}`)}}}(0,s.h)("FlowGraphDotBlock",t);class D extends F.d{constructor(V){super(l.B,l.B,l.B,((V,I)=>j.m.Cross(V,I)),"FlowGraphCrossBlock",V)}}(0,s.h)("FlowGraphCrossBlock",D);class b extends F.d{constructor(V){super(l.x,l.r,l.x,((V,I)=>V.rotate(I)),"FlowGraphRotate2DBlock",V)}}(0,s.h)("FlowGraphRotate2DBlock",b);class T extends F.d{constructor(V){super(l.B,l.s,l.B,((V,I)=>V.applyRotationQuaternion(I)),"FlowGraphRotate3DBlock",V)}}function n(V,I){switch((0,E.h)(V)){case"Vector2":case"LF":return I.transformVector(V);case"Vector4":return new j.n(V.x*I.m[0]+V.y*I.m[1]+V.z*I.m[2]+V.w*I.m[3],V.x*I.m[4]+V.y*I.m[5]+V.z*I.m[6]+V.w*I.m[7],V.x*I.m[8]+V.y*I.m[9]+V.z*I.m[10]+V.w*I.m[11],V.x*I.m[12]+V.y*I.m[13]+V.z*I.m[14]+V.w*I.m[15]);default:throw new Error(`Cannot transform value ${V}`)}}(0,s.h)("FlowGraphRotate3DBlock",T);class x extends F.d{constructor(V){const I=(null===V||void 0===V?void 0:V.vectorType)||"LF",m="Vector2"===I?"Matrix2D":"LF"===I?"Matrix3D":"Matrix";super((0,l.I)(I),(0,l.I)(m),(0,l.I)(I),n,"FlowGraphTransformVectorBlock",V)}}(0,s.h)("FlowGraphTransformVectorBlock",x);class S extends F.d{constructor(V){super(l.B,l.j,l.B,((V,I)=>j.m.TransformCoordinates(V,I)),"FlowGraphTransformCoordinatesBlock",V)}}(0,s.h)("FlowGraphTransformCoordinatesBlock",S);class c extends k.d{constructor(V){super(l.s,l.s,(V=>V.conjugate()),"FlowGraphConjugateBlock",V)}}(0,s.h)("FlowGraphConjugateBlock",c);class H extends F.d{constructor(V){super(l.s,l.s,l.r,((V,I)=>(0,K.d)(V,I)),"FlowGraphAngleBetweenBlock",V)}}(0,s.h)("FlowGraphAngleBetweenBlock",H);class y extends F.d{constructor(V){super(l.B,l.r,l.s,((V,I)=>j.e.RotationAxis(V,I)),"FlowGraphQuaternionFromAxisAngleBlock",V)}}(0,s.h)("FlowGraphQuaternionFromAxisAngleBlock",y);class z extends C.e{constructor(V){super(V),this.a=this.registerDataInput("a",l.s),this.axis=this.registerDataOutput("axis",l.B),this.angle=this.registerDataOutput("angle",l.r),this.isValid=this.registerDataOutput("isValid",l.d)}_updateOutputs(V){const I=V._getExecutionVariable(this,O,-1),m=V._getExecutionVariable(this,Y,null),C=V._getExecutionVariable(this,X,null);if(void 0!==m&&null!==m&&void 0!==C&&null!==C&&I===V.executionId)this.axis.setValue(m,V),this.angle.setValue(C,V);else try{const{axis:I,angle:m}=this.a.getValue(V).toAxisAngle();V._setExecutionVariable(this,Y,I),V._setExecutionVariable(this,X,m),V._setExecutionVariable(this,O,V.executionId),this.axis.setValue(I,V),this.angle.setValue(m,V),this.isValid.setValue(!0,V)}catch(l){this.isValid.setValue(!1,V)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,s.h)("FlowGraphAxisAngleFromQuaternionBlock",z);class Z extends F.d{constructor(V){super(l.B,l.B,l.s,((V,I)=>(0,K.e)(V,I)),"FlowGraphQuaternionFromDirectionsBlock",V)}}},14422:(V,I,m)=>{m.d(I,{d:()=>l});var C=m(14427);class l extends C.e{constructor(V,I,m,C,l,s){super(m,s),this._operation=C,this._className=l,this.a=this.registerDataInput("a",V),this.b=this.registerDataInput("b",I)}_doOperation(V){const I=this.a.getValue(V),m=this.b.getValue(V);return this._operation(I,m)}getClassName(){return this._className}}},14427:(V,I,m)=>{m.d(I,{e:()=>k});var C=m(12921),l=m(12899);const s="cachedOperationValue",F="cachedExecutionId";class k extends C.e{constructor(V,I){super(I),this.value=this.registerDataOutput("value",V),this.isValid=this.registerDataOutput("isValid",l.d)}_updateOutputs(V){const I=V._getExecutionVariable(this,F,-1),m=V._getExecutionVariable(this,s,null);if(void 0!==m&&null!==m&&I===V.executionId)this.isValid.setValue(!0,V),this.value.setValue(m,V);else try{const I=this._doOperation(V);if(void 0===I||null===I)return void this.isValid.setValue(!1,V);V._setExecutionVariable(this,s,I),V._setExecutionVariable(this,F,V.executionId),this.value.setValue(I,V),this.isValid.setValue(!0,V)}catch(C){this.isValid.setValue(!1,V)}}}},14429:(V,I,m)=>{m.d(I,{d:()=>l});var C=m(14427);class l extends C.e{constructor(V,I,m,C,l){super(I,l),this._operation=m,this._className=C,this.a=this.registerDataInput("a",V)}_doOperation(V){return this._operation(this.a.getValue(V))}getClassName(){return this._className}}}}]);