"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[69],{14378:(Z,c,L)=>{L.r(c),L.d(c,{FlowGraphAngleBetweenBlock:()=>h,FlowGraphAxisAngleFromQuaternionBlock:()=>D,FlowGraphConjugateBlock:()=>X,FlowGraphCrossBlock:()=>w,FlowGraphDotBlock:()=>O,FlowGraphLengthBlock:()=>x,FlowGraphNormalizeBlock:()=>q,FlowGraphQuaternionFromAxisAngleBlock:()=>B,FlowGraphQuaternionFromDirectionsBlock:()=>e,FlowGraphRotate2DBlock:()=>M,FlowGraphRotate3DBlock:()=>P,FlowGraphTransformBlock:()=>o,FlowGraphTransformCoordinatesBlock:()=>u});var k=L(12846),N=L(12825),R=L(11012),G=L(14358),V=L(14370),p=L(10993),J=L(12858),z=L(12529);const i="cachedOperationAxis",t="cachedOperationAngle",E="cachedExecutionId";class x extends V.d{constructor(Z){super(N.e,N.t,(Z=>this._polymorphicLength(Z)),"FlowGraphLengthBlock",Z)}_polymorphicLength(Z){switch((0,J.l)(Z)){case"Vector2":case"Mc":case"Vector4":case"Quaternion":return Z.length();default:throw new Error(`Cannot compute length of value ${Z}`)}}}(0,R.g)("FlowGraphLengthBlock",x);class q extends V.d{constructor(Z){super(N.e,N.e,(Z=>this._polymorphicNormalize(Z)),"FlowGraphNormalizeBlock",Z)}_polymorphicNormalize(Z){var c;let L;switch((0,J.l)(Z)){case"Vector2":case"Mc":case"Vector4":case"Quaternion":if(L=Z.normalizeToNew(),null!==(c=this.config)&&void 0!==c&&c.nanOnZeroLength){0===Z.length()&&L.uc(NaN)}return L;default:throw new Error(`Cannot normalize value ${Z}`)}}}(0,R.g)("FlowGraphNormalizeBlock",q);class O extends G.d{constructor(Z){super(N.e,N.e,N.t,((Z,c)=>this._polymorphicDot(Z,c)),"FlowGraphDotBlock",Z)}_polymorphicDot(Z,c){switch((0,J.l)(Z)){case"Vector2":case"Mc":case"Vector4":case"Quaternion":return Z.dot(c);default:throw new Error(`Cannot get dot product of ${Z} and ${c}`)}}}(0,R.g)("FlowGraphDotBlock",O);class w extends G.d{constructor(Z){super(N.A,N.A,N.A,((Z,c)=>p.h.Cross(Z,c)),"FlowGraphCrossBlock",Z)}}(0,R.g)("FlowGraphCrossBlock",w);class M extends G.d{constructor(Z){super(N.z,N.t,N.z,((Z,c)=>Z.rotate(c)),"FlowGraphRotate2DBlock",Z)}}(0,R.g)("FlowGraphRotate2DBlock",M);class P extends G.d{constructor(Z){super(N.A,N.u,N.A,((Z,c)=>Z.applyRotationQuaternion(c)),"FlowGraphRotate3DBlock",Z)}}function j(Z,c){switch((0,J.l)(Z)){case"Vector2":case"Mc":return c.transformVector(Z);case"Vector4":return new p.j(Z.x*c.m[0]+Z.y*c.m[1]+Z.z*c.m[2]+Z.w*c.m[3],Z.x*c.m[4]+Z.y*c.m[5]+Z.z*c.m[6]+Z.w*c.m[7],Z.x*c.m[8]+Z.y*c.m[9]+Z.z*c.m[10]+Z.w*c.m[11],Z.x*c.m[12]+Z.y*c.m[13]+Z.z*c.m[14]+Z.w*c.m[15]);default:throw new Error(`Cannot transform value ${Z}`)}}(0,R.g)("FlowGraphRotate3DBlock",P);class o extends G.d{constructor(Z){const c=(null===Z||void 0===Z?void 0:Z.vectorType)||"Mc",L="Vector2"===c?"Matrix2D":"Mc"===c?"Matrix3D":"Matrix";super((0,N.H)(c),(0,N.H)(L),(0,N.H)(c),j,"FlowGraphTransformVectorBlock",Z)}}(0,R.g)("FlowGraphTransformVectorBlock",o);class u extends G.d{constructor(Z){super(N.A,N.m,N.A,((Z,c)=>p.h.TransformCoordinates(Z,c)),"FlowGraphTransformCoordinatesBlock",Z)}}(0,R.g)("FlowGraphTransformCoordinatesBlock",u);class X extends V.d{constructor(Z){super(N.u,N.u,(Z=>Z.conjugate()),"FlowGraphConjugateBlock",Z)}}(0,R.g)("FlowGraphConjugateBlock",X);class h extends G.d{constructor(Z){super(N.u,N.u,N.t,((Z,c)=>(0,z.c)(Z,c)),"FlowGraphAngleBetweenBlock",Z)}}(0,R.g)("FlowGraphAngleBetweenBlock",h);class B extends G.d{constructor(Z){super(N.A,N.t,N.u,((Z,c)=>p.c.RotationAxis(Z,c)),"FlowGraphQuaternionFromAxisAngleBlock",Z)}}(0,R.g)("FlowGraphQuaternionFromAxisAngleBlock",B);class D extends k.c{constructor(Z){super(Z),this.a=this.registerDataInput("a",N.u),this.axis=this.registerDataOutput("axis",N.A),this.angle=this.registerDataOutput("angle",N.t),this.isValid=this.registerDataOutput("isValid",N.g)}_updateOutputs(Z){const c=Z._getExecutionVariable(this,E,-1),L=Z._getExecutionVariable(this,i,null),k=Z._getExecutionVariable(this,t,null);if(void 0!==L&&null!==L&&void 0!==k&&null!==k&&c===Z.executionId)this.axis.setValue(L,Z),this.angle.setValue(k,Z);else try{const{axis:c,angle:L}=this.a.getValue(Z).toAxisAngle();Z._setExecutionVariable(this,i,c),Z._setExecutionVariable(this,t,L),Z._setExecutionVariable(this,E,Z.executionId),this.axis.setValue(c,Z),this.angle.setValue(L,Z),this.isValid.setValue(!0,Z)}catch(N){this.isValid.setValue(!1,Z)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,R.g)("FlowGraphAxisAngleFromQuaternionBlock",D);class e extends G.d{constructor(Z){super(N.A,N.A,N.u,((Z,c)=>(0,z.g)(Z,c)),"FlowGraphQuaternionFromDirectionsBlock",Z)}}},14358:(Z,c,L)=>{L.d(c,{d:()=>N});var k=L(14364);class N extends k.d{constructor(Z,c,L,k,N,R){super(L,R),this._operation=k,this._className=N,this.a=this.registerDataInput("a",Z),this.b=this.registerDataInput("b",c)}_doOperation(Z){const c=this.a.getValue(Z),L=this.b.getValue(Z);return this._operation(c,L)}getClassName(){return this._className}}},14364:(Z,c,L)=>{L.d(c,{d:()=>V});var k=L(12846),N=L(12825);const R="cachedOperationValue",G="cachedExecutionId";class V extends k.c{constructor(Z,c){super(c),this.value=this.registerDataOutput("value",Z),this.isValid=this.registerDataOutput("isValid",N.g)}_updateOutputs(Z){const c=Z._getExecutionVariable(this,G,-1),L=Z._getExecutionVariable(this,R,null);if(void 0!==L&&null!==L&&c===Z.executionId)this.isValid.setValue(!0,Z),this.value.setValue(L,Z);else try{const c=this._doOperation(Z);if(void 0===c||null===c)return void this.isValid.setValue(!1,Z);Z._setExecutionVariable(this,R,c),Z._setExecutionVariable(this,G,Z.executionId),this.value.setValue(c,Z),this.isValid.setValue(!0,Z)}catch(k){this.isValid.setValue(!1,Z)}}}},14370:(Z,c,L)=>{L.d(c,{d:()=>N});var k=L(14364);class N extends k.d{constructor(Z,c,L,k,N){super(c,N),this._operation=L,this._className=k,this.a=this.registerDataInput("a",Z)}_doOperation(Z){return this._operation(this.a.getValue(Z))}getClassName(){return this._className}}}}]);