"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10706:(C,M,x)=>{x.r(M),x.d(M,{_TGATextureLoader:()=>S});var f=x(1078);function T(C){let M=0;return{id_length:C[M++],colormap_type:C[M++],image_type:C[M++],colormap_index:C[M++]|C[M++]<<8,colormap_length:C[M++]|C[M++]<<8,colormap_size:C[M++],origin:[C[M++]|C[M++]<<8,C[M++]|C[M++]<<8],width:C[M++]|C[M++]<<8,height:C[M++]|C[M++]<<8,pixel_size:C[M++],flags:C[M++]}}function z(C,M){if(M.length<19)return void f.e.Error("Unable to load TGA file - Not enough data to contain header");let x=18;const z=T(M);if(z.id_length+x>M.length)return void f.e.Error("Unable to load TGA file - Not enough data");x+=z.id_length;let S,m=!1,Q=!1,V=!1;switch(z.image_type){case 9:m=!0;case 1:Q=!0;break;case 10:m=!0;case 2:break;case 11:m=!0;case 3:V=!0}const y=z.pixel_size>>3,U=z.width*z.height*y;let O,d,D,o,L,t,A;if(Q&&(O=M.subarray(x,x+=z.colormap_length*(z.colormap_size>>3))),m){let C,f,T;S=new Uint8Array(U);let z=0;const s=new Uint8Array(y);for(;x<U&&z<U;)if(C=M[x++],f=1+(127&C),128&C){for(T=0;T<y;++T)s[T]=M[x++];for(T=0;T<f;++T)S.set(s,z+T*y);z+=y*f}else{for(f*=y,T=0;T<f;++T)S[z+T]=M[x++];z+=f}}else S=M.subarray(x,x+=Q?z.width*z.height:U);switch((48&z.flags)>>4){default:case 2:d=0,o=1,A=z.width,D=0,L=1,t=z.height;break;case 0:d=0,o=1,A=z.width,D=z.height-1,L=-1,t=-1;break;case 3:d=z.width-1,o=-1,A=-1,D=0,L=1,t=z.height;break;case 1:d=z.width-1,o=-1,A=-1,D=z.height-1,L=-1,t=-1}const H="_getImageData"+(V?"Grey":"")+z.pixel_size+"bits",j=s[H](z,O,S,D,L,t,d,o,A);C.getEngine()._uploadDataToTextureDirectly(C,j)}const s={GetTGAHeader:T,UploadContent:z,_getImageData8bits:function(C,M,x,f,T,z,s,S,m){const Q=x,V=M,y=C.width,U=C.height;let O,d,D,o=0;const L=new Uint8Array(y*U*4);for(D=f;D!==z;D+=T)for(d=s;d!==m;d+=S,o++)O=Q[o],L[4*(d+y*D)+3]=255,L[4*(d+y*D)+2]=V[3*O+0],L[4*(d+y*D)+1]=V[3*O+1],L[4*(d+y*D)+0]=V[3*O+2];return L},_getImageData16bits:function(C,M,x,f,T,z,s,S,m){const Q=x,V=C.width,y=C.height;let U,O,d,D=0;const o=new Uint8Array(V*y*4);for(d=f;d!==z;d+=T)for(O=s;O!==m;O+=S,D+=2){U=Q[D+0]+(Q[D+1]<<8);const C=255*((31744&U)>>10)/31|0,M=255*((992&U)>>5)/31|0,x=255*(31&U)/31|0;o[4*(O+V*d)+0]=C,o[4*(O+V*d)+1]=M,o[4*(O+V*d)+2]=x,o[4*(O+V*d)+3]=32768&U?0:255}return o},_getImageData24bits:function(C,M,x,f,T,z,s,S,m){const Q=x,V=C.width,y=C.height;let U,O,d=0;const D=new Uint8Array(V*y*4);for(O=f;O!==z;O+=T)for(U=s;U!==m;U+=S,d+=3)D[4*(U+V*O)+3]=255,D[4*(U+V*O)+2]=Q[d+0],D[4*(U+V*O)+1]=Q[d+1],D[4*(U+V*O)+0]=Q[d+2];return D},_getImageData32bits:function(C,M,x,f,T,z,s,S,m){const Q=x,V=C.width,y=C.height;let U,O,d=0;const D=new Uint8Array(V*y*4);for(O=f;O!==z;O+=T)for(U=s;U!==m;U+=S,d+=4)D[4*(U+V*O)+2]=Q[d+0],D[4*(U+V*O)+1]=Q[d+1],D[4*(U+V*O)+0]=Q[d+2],D[4*(U+V*O)+3]=Q[d+3];return D},_getImageDataGrey8bits:function(C,M,x,f,T,z,s,S,m){const Q=x,V=C.width,y=C.height;let U,O,d,D=0;const o=new Uint8Array(V*y*4);for(d=f;d!==z;d+=T)for(O=s;O!==m;O+=S,D++)U=Q[D],o[4*(O+V*d)+0]=U,o[4*(O+V*d)+1]=U,o[4*(O+V*d)+2]=U,o[4*(O+V*d)+3]=255;return o},_getImageDataGrey16bits:function(C,M,x,f,T,z,s,S,m){const Q=x,V=C.width,y=C.height;let U,O,d=0;const D=new Uint8Array(V*y*4);for(O=f;O!==z;O+=T)for(U=s;U!==m;U+=S,d+=2)D[4*(U+V*O)+0]=Q[d+0],D[4*(U+V*O)+1]=Q[d+0],D[4*(U+V*O)+2]=Q[d+0],D[4*(U+V*O)+3]=Q[d+1];return D}};class S{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(C,M,x){const f=new Uint8Array(C.buffer,C.byteOffset,C.byteLength),s=T(f);x(s.width,s.height,M.generateMipMaps,!1,(()=>{z(M,f)}))}}}}]);