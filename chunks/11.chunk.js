"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10287:(f,Q,H)=>{H.r(Q),H.d(Q,{_TGATextureLoader:()=>K});var X=H(1092);function i(f){let Q=0;return{id_length:f[Q++],colormap_type:f[Q++],image_type:f[Q++],colormap_index:f[Q++]|f[Q++]<<8,colormap_length:f[Q++]|f[Q++]<<8,colormap_size:f[Q++],origin:[f[Q++]|f[Q++]<<8,f[Q++]|f[Q++]<<8],width:f[Q++]|f[Q++]<<8,height:f[Q++]|f[Q++]<<8,pixel_size:f[Q++],flags:f[Q++]}}function S(f,Q){if(Q.length<19)return void X.b.Error("Unable to load TGA file - Not enough data to contain header");let H=18;const S=i(Q);if(S.id_length+H>Q.length)return void X.b.Error("Unable to load TGA file - Not enough data");H+=S.id_length;let K,Z=!1,B=!1,N=!1;switch(S.image_type){case 9:Z=!0;case 1:B=!0;break;case 10:Z=!0;case 2:break;case 11:Z=!0;case 3:N=!0}const J=S.pixel_size>>3,g=S.width*S.height*J;let z,v,Y,O,n,e,G;if(B&&(z=Q.subarray(H,H+=S.colormap_length*(S.colormap_size>>3))),Z){let f,X,i;K=new Uint8Array(g);let S=0;const x=new Uint8Array(J);for(;H<g&&S<g;)if(f=Q[H++],X=1+(127&f),128&f){for(i=0;i<J;++i)x[i]=Q[H++];for(i=0;i<X;++i)K.set(x,S+i*J);S+=J*X}else{for(X*=J,i=0;i<X;++i)K[S+i]=Q[H++];S+=X}}else K=Q.subarray(H,H+=B?S.width*S.height:g);switch((48&S.flags)>>4){default:case 2:v=0,O=1,G=S.width,Y=0,n=1,e=S.height;break;case 0:v=0,O=1,G=S.width,Y=S.height-1,n=-1,e=-1;break;case 3:v=S.width-1,O=-1,G=-1,Y=0,n=1,e=S.height;break;case 1:v=S.width-1,O=-1,G=-1,Y=S.height-1,n=-1,e=-1}const I="_getImageData"+(N?"Grey":"")+S.pixel_size+"bits",l=x[I](S,z,K,Y,n,e,v,O,G);f.getEngine()._uploadDataToTextureDirectly(f,l)}const x={GetTGAHeader:i,UploadContent:S,_getImageData8bits:function(f,Q,H,X,i,S,x,K,Z){const B=H,N=Q,J=f.width,g=f.height;let z,v,Y,O=0;const n=new Uint8Array(J*g*4);for(Y=X;Y!==S;Y+=i)for(v=x;v!==Z;v+=K,O++)z=B[O],n[4*(v+J*Y)+3]=255,n[4*(v+J*Y)+2]=N[3*z+0],n[4*(v+J*Y)+1]=N[3*z+1],n[4*(v+J*Y)+0]=N[3*z+2];return n},_getImageData16bits:function(f,Q,H,X,i,S,x,K,Z){const B=H,N=f.width,J=f.height;let g,z,v,Y=0;const O=new Uint8Array(N*J*4);for(v=X;v!==S;v+=i)for(z=x;z!==Z;z+=K,Y+=2){g=B[Y+0]+(B[Y+1]<<8);const f=255*((31744&g)>>10)/31|0,Q=255*((992&g)>>5)/31|0,H=255*(31&g)/31|0;O[4*(z+N*v)+0]=f,O[4*(z+N*v)+1]=Q,O[4*(z+N*v)+2]=H,O[4*(z+N*v)+3]=32768&g?0:255}return O},_getImageData24bits:function(f,Q,H,X,i,S,x,K,Z){const B=H,N=f.width,J=f.height;let g,z,v=0;const Y=new Uint8Array(N*J*4);for(z=X;z!==S;z+=i)for(g=x;g!==Z;g+=K,v+=3)Y[4*(g+N*z)+3]=255,Y[4*(g+N*z)+2]=B[v+0],Y[4*(g+N*z)+1]=B[v+1],Y[4*(g+N*z)+0]=B[v+2];return Y},_getImageData32bits:function(f,Q,H,X,i,S,x,K,Z){const B=H,N=f.width,J=f.height;let g,z,v=0;const Y=new Uint8Array(N*J*4);for(z=X;z!==S;z+=i)for(g=x;g!==Z;g+=K,v+=4)Y[4*(g+N*z)+2]=B[v+0],Y[4*(g+N*z)+1]=B[v+1],Y[4*(g+N*z)+0]=B[v+2],Y[4*(g+N*z)+3]=B[v+3];return Y},_getImageDataGrey8bits:function(f,Q,H,X,i,S,x,K,Z){const B=H,N=f.width,J=f.height;let g,z,v,Y=0;const O=new Uint8Array(N*J*4);for(v=X;v!==S;v+=i)for(z=x;z!==Z;z+=K,Y++)g=B[Y],O[4*(z+N*v)+0]=g,O[4*(z+N*v)+1]=g,O[4*(z+N*v)+2]=g,O[4*(z+N*v)+3]=255;return O},_getImageDataGrey16bits:function(f,Q,H,X,i,S,x,K,Z){const B=H,N=f.width,J=f.height;let g,z,v=0;const Y=new Uint8Array(N*J*4);for(z=X;z!==S;z+=i)for(g=x;g!==Z;g+=K,v+=2)Y[4*(g+N*z)+0]=B[v+0],Y[4*(g+N*z)+1]=B[v+0],Y[4*(g+N*z)+2]=B[v+0],Y[4*(g+N*z)+3]=B[v+1];return Y}};class K{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(f,Q,H){const X=new Uint8Array(f.buffer,f.byteOffset,f.byteLength),x=i(X);H(x.width,x.height,Q.generateMipMaps,!1,(()=>{S(Q,X)}))}}}}]);