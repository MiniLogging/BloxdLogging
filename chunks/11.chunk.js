"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10722:(V,n,O)=>{O.r(n),O.d(n,{_TGATextureLoader:()=>c});var H=O(1118);function g(V){let n=0;return{id_length:V[n++],colormap_type:V[n++],image_type:V[n++],colormap_index:V[n++]|V[n++]<<8,colormap_length:V[n++]|V[n++]<<8,colormap_size:V[n++],origin:[V[n++]|V[n++]<<8,V[n++]|V[n++]<<8],width:V[n++]|V[n++]<<8,height:V[n++]|V[n++]<<8,pixel_size:V[n++],flags:V[n++]}}function f(V,n){if(n.length<19)return void H.b.Error("Unable to load TGA file - Not enough data to contain header");let O=18;const f=g(n);if(f.id_length+O>n.length)return void H.b.Error("Unable to load TGA file - Not enough data");O+=f.id_length;let c,e=!1,U=!1,M=!1;switch(f.image_type){case 9:e=!0;case 1:U=!0;break;case 10:e=!0;case 2:break;case 11:e=!0;case 3:M=!0}const p=f.pixel_size>>3,j=f.width*f.height*p;let i,A,S,B,X,a,q;if(U&&(i=n.subarray(O,O+=f.colormap_length*(f.colormap_size>>3))),e){let V,H,g;c=new Uint8Array(j);let f=0;const x=new Uint8Array(p);for(;O<j&&f<j;)if(V=n[O++],H=1+(127&V),128&V){for(g=0;g<p;++g)x[g]=n[O++];for(g=0;g<H;++g)c.set(x,f+g*p);f+=p*H}else{for(H*=p,g=0;g<H;++g)c[f+g]=n[O++];f+=H}}else c=n.subarray(O,O+=U?f.width*f.height:j);switch((48&f.flags)>>4){default:case 2:A=0,B=1,q=f.width,S=0,X=1,a=f.height;break;case 0:A=0,B=1,q=f.width,S=f.height-1,X=-1,a=-1;break;case 3:A=f.width-1,B=-1,q=-1,S=0,X=1,a=f.height;break;case 1:A=f.width-1,B=-1,q=-1,S=f.height-1,X=-1,a=-1}const G="_getImageData"+(M?"Grey":"")+f.pixel_size+"bits",W=x[G](f,i,c,S,X,a,A,B,q);V.getEngine()._uploadDataToTextureDirectly(V,W)}const x={GetTGAHeader:g,UploadContent:f,_getImageData8bits:function(V,n,O,H,g,f,x,c,e){const U=O,M=n,p=V.width,j=V.height;let i,A,S,B=0;const X=new Uint8Array(p*j*4);for(S=H;S!==f;S+=g)for(A=x;A!==e;A+=c,B++)i=U[B],X[4*(A+p*S)+3]=255,X[4*(A+p*S)+2]=M[3*i+0],X[4*(A+p*S)+1]=M[3*i+1],X[4*(A+p*S)+0]=M[3*i+2];return X},_getImageData16bits:function(V,n,O,H,g,f,x,c,e){const U=O,M=V.width,p=V.height;let j,i,A,S=0;const B=new Uint8Array(M*p*4);for(A=H;A!==f;A+=g)for(i=x;i!==e;i+=c,S+=2){j=U[S+0]+(U[S+1]<<8);const V=255*((31744&j)>>10)/31|0,n=255*((992&j)>>5)/31|0,O=255*(31&j)/31|0;B[4*(i+M*A)+0]=V,B[4*(i+M*A)+1]=n,B[4*(i+M*A)+2]=O,B[4*(i+M*A)+3]=32768&j?0:255}return B},_getImageData24bits:function(V,n,O,H,g,f,x,c,e){const U=O,M=V.width,p=V.height;let j,i,A=0;const S=new Uint8Array(M*p*4);for(i=H;i!==f;i+=g)for(j=x;j!==e;j+=c,A+=3)S[4*(j+M*i)+3]=255,S[4*(j+M*i)+2]=U[A+0],S[4*(j+M*i)+1]=U[A+1],S[4*(j+M*i)+0]=U[A+2];return S},_getImageData32bits:function(V,n,O,H,g,f,x,c,e){const U=O,M=V.width,p=V.height;let j,i,A=0;const S=new Uint8Array(M*p*4);for(i=H;i!==f;i+=g)for(j=x;j!==e;j+=c,A+=4)S[4*(j+M*i)+2]=U[A+0],S[4*(j+M*i)+1]=U[A+1],S[4*(j+M*i)+0]=U[A+2],S[4*(j+M*i)+3]=U[A+3];return S},_getImageDataGrey8bits:function(V,n,O,H,g,f,x,c,e){const U=O,M=V.width,p=V.height;let j,i,A,S=0;const B=new Uint8Array(M*p*4);for(A=H;A!==f;A+=g)for(i=x;i!==e;i+=c,S++)j=U[S],B[4*(i+M*A)+0]=j,B[4*(i+M*A)+1]=j,B[4*(i+M*A)+2]=j,B[4*(i+M*A)+3]=255;return B},_getImageDataGrey16bits:function(V,n,O,H,g,f,x,c,e){const U=O,M=V.width,p=V.height;let j,i,A=0;const S=new Uint8Array(M*p*4);for(i=H;i!==f;i+=g)for(j=x;j!==e;j+=c,A+=2)S[4*(j+M*i)+0]=U[A+0],S[4*(j+M*i)+1]=U[A+0],S[4*(j+M*i)+2]=U[A+0],S[4*(j+M*i)+3]=U[A+1];return S}};class c{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(V,n,O){const H=new Uint8Array(V.buffer,V.byteOffset,V.byteLength),x=g(H);O(x.width,x.height,n.generateMipMaps,!1,(()=>{f(n,H)}))}}}}]);