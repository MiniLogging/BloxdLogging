"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10883:(v,T,X)=>{X.r(T),X.d(T,{_TGATextureLoader:()=>A});var O=X(1103);function u(v){let T=0;return{id_length:v[T++],colormap_type:v[T++],image_type:v[T++],colormap_index:v[T++]|v[T++]<<8,colormap_length:v[T++]|v[T++]<<8,colormap_size:v[T++],origin:[v[T++]|v[T++]<<8,v[T++]|v[T++]<<8],width:v[T++]|v[T++]<<8,height:v[T++]|v[T++]<<8,pixel_size:v[T++],flags:v[T++]}}function B(v,T){if(T.length<19)return void O.d.Error("Unable to load TGA file - Not enough data to contain header");let X=18;const B=u(T);if(B.id_length+X>T.length)return void O.d.Error("Unable to load TGA file - Not enough data");X+=B.id_length;let A,x=!1,f=!1,M=!1;switch(B.image_type){case 9:x=!0;case 1:f=!0;break;case 10:x=!0;case 2:break;case 11:x=!0;case 3:M=!0}const H=B.pixel_size>>3,n=B.width*B.height*H;let V,D,s,F,k,b,l;if(f&&(V=T.subarray(X,X+=B.colormap_length*(B.colormap_size>>3))),x){let v,O,u;A=new Uint8Array(n);let B=0;const m=new Uint8Array(H);for(;X<n&&B<n;)if(v=T[X++],O=1+(127&v),128&v){for(u=0;u<H;++u)m[u]=T[X++];for(u=0;u<O;++u)A.set(m,B+u*H);B+=H*O}else{for(O*=H,u=0;u<O;++u)A[B+u]=T[X++];B+=O}}else A=T.subarray(X,X+=f?B.width*B.height:n);switch((48&B.flags)>>4){default:case 2:D=0,F=1,l=B.width,s=0,k=1,b=B.height;break;case 0:D=0,F=1,l=B.width,s=B.height-1,k=-1,b=-1;break;case 3:D=B.width-1,F=-1,l=-1,s=0,k=1,b=B.height;break;case 1:D=B.width-1,F=-1,l=-1,s=B.height-1,k=-1,b=-1}const Q="_getImageData"+(M?"Grey":"")+B.pixel_size+"bits",K=m[Q](B,V,A,s,k,b,D,F,l);v.getEngine()._uploadDataToTextureDirectly(v,K)}const m={GetTGAHeader:u,UploadContent:B,_getImageData8bits:function(v,T,X,O,u,B,m,A,x){const f=X,M=T,H=v.width,n=v.height;let V,D,s,F=0;const k=new Uint8Array(H*n*4);for(s=O;s!==B;s+=u)for(D=m;D!==x;D+=A,F++)V=f[F],k[4*(D+H*s)+3]=255,k[4*(D+H*s)+2]=M[3*V+0],k[4*(D+H*s)+1]=M[3*V+1],k[4*(D+H*s)+0]=M[3*V+2];return k},_getImageData16bits:function(v,T,X,O,u,B,m,A,x){const f=X,M=v.width,H=v.height;let n,V,D,s=0;const F=new Uint8Array(M*H*4);for(D=O;D!==B;D+=u)for(V=m;V!==x;V+=A,s+=2){n=f[s+0]+(f[s+1]<<8);const v=255*((31744&n)>>10)/31|0,T=255*((992&n)>>5)/31|0,X=255*(31&n)/31|0;F[4*(V+M*D)+0]=v,F[4*(V+M*D)+1]=T,F[4*(V+M*D)+2]=X,F[4*(V+M*D)+3]=32768&n?0:255}return F},_getImageData24bits:function(v,T,X,O,u,B,m,A,x){const f=X,M=v.width,H=v.height;let n,V,D=0;const s=new Uint8Array(M*H*4);for(V=O;V!==B;V+=u)for(n=m;n!==x;n+=A,D+=3)s[4*(n+M*V)+3]=255,s[4*(n+M*V)+2]=f[D+0],s[4*(n+M*V)+1]=f[D+1],s[4*(n+M*V)+0]=f[D+2];return s},_getImageData32bits:function(v,T,X,O,u,B,m,A,x){const f=X,M=v.width,H=v.height;let n,V,D=0;const s=new Uint8Array(M*H*4);for(V=O;V!==B;V+=u)for(n=m;n!==x;n+=A,D+=4)s[4*(n+M*V)+2]=f[D+0],s[4*(n+M*V)+1]=f[D+1],s[4*(n+M*V)+0]=f[D+2],s[4*(n+M*V)+3]=f[D+3];return s},_getImageDataGrey8bits:function(v,T,X,O,u,B,m,A,x){const f=X,M=v.width,H=v.height;let n,V,D,s=0;const F=new Uint8Array(M*H*4);for(D=O;D!==B;D+=u)for(V=m;V!==x;V+=A,s++)n=f[s],F[4*(V+M*D)+0]=n,F[4*(V+M*D)+1]=n,F[4*(V+M*D)+2]=n,F[4*(V+M*D)+3]=255;return F},_getImageDataGrey16bits:function(v,T,X,O,u,B,m,A,x){const f=X,M=v.width,H=v.height;let n,V,D=0;const s=new Uint8Array(M*H*4);for(V=O;V!==B;V+=u)for(n=m;n!==x;n+=A,D+=2)s[4*(n+M*V)+0]=f[D+0],s[4*(n+M*V)+1]=f[D+0],s[4*(n+M*V)+2]=f[D+0],s[4*(n+M*V)+3]=f[D+1];return s}};class A{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(v,T,X){const O=new Uint8Array(v.buffer,v.byteOffset,v.byteLength),m=u(O);X(m.width,m.height,T.generateMipMaps,!1,(()=>{B(T,O)}))}}}}]);