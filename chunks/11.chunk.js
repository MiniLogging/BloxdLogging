"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{11151:(L,i,P)=>{P.r(i),P.d(i,{_TGATextureLoader:()=>w});var D=P(1098);function V(L){let i=0;return{id_length:L[i++],colormap_type:L[i++],image_type:L[i++],colormap_index:L[i++]|L[i++]<<8,colormap_length:L[i++]|L[i++]<<8,colormap_size:L[i++],origin:[L[i++]|L[i++]<<8,L[i++]|L[i++]<<8],width:L[i++]|L[i++]<<8,height:L[i++]|L[i++]<<8,pixel_size:L[i++],flags:L[i++]}}function M(L,i){if(i.length<19)return void D.d.Error("Unable to load TGA file - Not enough data to contain header");let P=18;const M=V(i);if(M.id_length+P>i.length)return void D.d.Error("Unable to load TGA file - Not enough data");P+=M.id_length;let w,O=!1,U=!1,C=!1;switch(M.image_type){case 9:O=!0;case 1:U=!0;break;case 10:O=!0;case 2:break;case 11:O=!0;case 3:C=!0}const T=M.pixel_size>>3,c=M.width*M.height*T;let r,F,S,q,H,j,B;if(U&&(r=i.subarray(P,P+=M.colormap_length*(M.colormap_size>>3))),O){let L,D,V;w=new Uint8Array(c);let M=0;const a=new Uint8Array(T);for(;P<c&&M<c;)if(L=i[P++],D=1+(127&L),128&L){for(V=0;V<T;++V)a[V]=i[P++];for(V=0;V<D;++V)w.set(a,M+V*T);M+=T*D}else{for(D*=T,V=0;V<D;++V)w[M+V]=i[P++];M+=D}}else w=i.subarray(P,P+=U?M.width*M.height:c);switch((48&M.flags)>>4){default:case 2:F=0,q=1,B=M.width,S=0,H=1,j=M.height;break;case 0:F=0,q=1,B=M.width,S=M.height-1,H=-1,j=-1;break;case 3:F=M.width-1,q=-1,B=-1,S=0,H=1,j=M.height;break;case 1:F=M.width-1,q=-1,B=-1,S=M.height-1,H=-1,j=-1}const u="_getImageData"+(C?"Grey":"")+M.pixel_size+"bits",p=a[u](M,r,w,S,H,j,F,q,B);L.getEngine()._uploadDataToTextureDirectly(L,p)}const a={GetTGAHeader:V,UploadContent:M,_getImageData8bits:function(L,i,P,D,V,M,a,w,O){const U=P,C=i,T=L.width,c=L.height;let r,F,S,q=0;const H=new Uint8Array(T*c*4);for(S=D;S!==M;S+=V)for(F=a;F!==O;F+=w,q++)r=U[q],H[4*(F+T*S)+3]=255,H[4*(F+T*S)+2]=C[3*r+0],H[4*(F+T*S)+1]=C[3*r+1],H[4*(F+T*S)+0]=C[3*r+2];return H},_getImageData16bits:function(L,i,P,D,V,M,a,w,O){const U=P,C=L.width,T=L.height;let c,r,F,S=0;const q=new Uint8Array(C*T*4);for(F=D;F!==M;F+=V)for(r=a;r!==O;r+=w,S+=2){c=U[S+0]+(U[S+1]<<8);const L=255*((31744&c)>>10)/31|0,i=255*((992&c)>>5)/31|0,P=255*(31&c)/31|0;q[4*(r+C*F)+0]=L,q[4*(r+C*F)+1]=i,q[4*(r+C*F)+2]=P,q[4*(r+C*F)+3]=32768&c?0:255}return q},_getImageData24bits:function(L,i,P,D,V,M,a,w,O){const U=P,C=L.width,T=L.height;let c,r,F=0;const S=new Uint8Array(C*T*4);for(r=D;r!==M;r+=V)for(c=a;c!==O;c+=w,F+=3)S[4*(c+C*r)+3]=255,S[4*(c+C*r)+2]=U[F+0],S[4*(c+C*r)+1]=U[F+1],S[4*(c+C*r)+0]=U[F+2];return S},_getImageData32bits:function(L,i,P,D,V,M,a,w,O){const U=P,C=L.width,T=L.height;let c,r,F=0;const S=new Uint8Array(C*T*4);for(r=D;r!==M;r+=V)for(c=a;c!==O;c+=w,F+=4)S[4*(c+C*r)+2]=U[F+0],S[4*(c+C*r)+1]=U[F+1],S[4*(c+C*r)+0]=U[F+2],S[4*(c+C*r)+3]=U[F+3];return S},_getImageDataGrey8bits:function(L,i,P,D,V,M,a,w,O){const U=P,C=L.width,T=L.height;let c,r,F,S=0;const q=new Uint8Array(C*T*4);for(F=D;F!==M;F+=V)for(r=a;r!==O;r+=w,S++)c=U[S],q[4*(r+C*F)+0]=c,q[4*(r+C*F)+1]=c,q[4*(r+C*F)+2]=c,q[4*(r+C*F)+3]=255;return q},_getImageDataGrey16bits:function(L,i,P,D,V,M,a,w,O){const U=P,C=L.width,T=L.height;let c,r,F=0;const S=new Uint8Array(C*T*4);for(r=D;r!==M;r+=V)for(c=a;c!==O;c+=w,F+=2)S[4*(c+C*r)+0]=U[F+0],S[4*(c+C*r)+1]=U[F+0],S[4*(c+C*r)+2]=U[F+0],S[4*(c+C*r)+3]=U[F+1];return S}};class w{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(L,i,P){const D=new Uint8Array(L.buffer,L.byteOffset,L.byteLength),a=V(D);P(a.width,a.height,i.generateMipMaps,!1,(()=>{M(i,D)}))}}}}]);