"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10270:(B,q,C)=>{C.r(q),C.d(q,{_TGATextureLoader:()=>D});var v=C(1040);function m(B){let q=0;return{id_length:B[q++],colormap_type:B[q++],image_type:B[q++],colormap_index:B[q++]|B[q++]<<8,colormap_length:B[q++]|B[q++]<<8,colormap_size:B[q++],origin:[B[q++]|B[q++]<<8,B[q++]|B[q++]<<8],width:B[q++]|B[q++]<<8,height:B[q++]|B[q++]<<8,pixel_size:B[q++],flags:B[q++]}}function O(B,q){if(q.length<19)return void v.d.Error("Unable to load TGA file - Not enough data to contain header");let C=18;const O=m(q);if(O.id_length+C>q.length)return void v.d.Error("Unable to load TGA file - Not enough data");C+=O.id_length;let D,R=!1,T=!1,l=!1;switch(O.image_type){case 9:R=!0;case 1:T=!0;break;case 10:R=!0;case 2:break;case 11:R=!0;case 3:l=!0}const z=O.pixel_size>>3,W=O.width*O.height*z;let Z,G,y,e,U,s,A;if(T&&(Z=q.subarray(C,C+=O.colormap_length*(O.colormap_size>>3))),R){let B,v,m;D=new Uint8Array(W);let O=0;const S=new Uint8Array(z);for(;C<W&&O<W;)if(B=q[C++],v=1+(127&B),128&B){for(m=0;m<z;++m)S[m]=q[C++];for(m=0;m<v;++m)D.set(S,O+m*z);O+=z*v}else{for(v*=z,m=0;m<v;++m)D[O+m]=q[C++];O+=v}}else D=q.subarray(C,C+=T?O.width*O.height:W);switch((48&O.flags)>>4){default:case 2:G=0,e=1,A=O.width,y=0,U=1,s=O.height;break;case 0:G=0,e=1,A=O.width,y=O.height-1,U=-1,s=-1;break;case 3:G=O.width-1,e=-1,A=-1,y=0,U=1,s=O.height;break;case 1:G=O.width-1,e=-1,A=-1,y=O.height-1,U=-1,s=-1}const r="_getImageData"+(l?"Grey":"")+O.pixel_size+"bits",X=S[r](O,Z,D,y,U,s,G,e,A);B.getEngine()._uploadDataToTextureDirectly(B,X)}const S={GetTGAHeader:m,UploadContent:O,_getImageData8bits:function(B,q,C,v,m,O,S,D,R){const T=C,l=q,z=B.width,W=B.height;let Z,G,y,e=0;const U=new Uint8Array(z*W*4);for(y=v;y!==O;y+=m)for(G=S;G!==R;G+=D,e++)Z=T[e],U[4*(G+z*y)+3]=255,U[4*(G+z*y)+2]=l[3*Z+0],U[4*(G+z*y)+1]=l[3*Z+1],U[4*(G+z*y)+0]=l[3*Z+2];return U},_getImageData16bits:function(B,q,C,v,m,O,S,D,R){const T=C,l=B.width,z=B.height;let W,Z,G,y=0;const e=new Uint8Array(l*z*4);for(G=v;G!==O;G+=m)for(Z=S;Z!==R;Z+=D,y+=2){W=T[y+0]+(T[y+1]<<8);const B=255*((31744&W)>>10)/31|0,q=255*((992&W)>>5)/31|0,C=255*(31&W)/31|0;e[4*(Z+l*G)+0]=B,e[4*(Z+l*G)+1]=q,e[4*(Z+l*G)+2]=C,e[4*(Z+l*G)+3]=32768&W?0:255}return e},_getImageData24bits:function(B,q,C,v,m,O,S,D,R){const T=C,l=B.width,z=B.height;let W,Z,G=0;const y=new Uint8Array(l*z*4);for(Z=v;Z!==O;Z+=m)for(W=S;W!==R;W+=D,G+=3)y[4*(W+l*Z)+3]=255,y[4*(W+l*Z)+2]=T[G+0],y[4*(W+l*Z)+1]=T[G+1],y[4*(W+l*Z)+0]=T[G+2];return y},_getImageData32bits:function(B,q,C,v,m,O,S,D,R){const T=C,l=B.width,z=B.height;let W,Z,G=0;const y=new Uint8Array(l*z*4);for(Z=v;Z!==O;Z+=m)for(W=S;W!==R;W+=D,G+=4)y[4*(W+l*Z)+2]=T[G+0],y[4*(W+l*Z)+1]=T[G+1],y[4*(W+l*Z)+0]=T[G+2],y[4*(W+l*Z)+3]=T[G+3];return y},_getImageDataGrey8bits:function(B,q,C,v,m,O,S,D,R){const T=C,l=B.width,z=B.height;let W,Z,G,y=0;const e=new Uint8Array(l*z*4);for(G=v;G!==O;G+=m)for(Z=S;Z!==R;Z+=D,y++)W=T[y],e[4*(Z+l*G)+0]=W,e[4*(Z+l*G)+1]=W,e[4*(Z+l*G)+2]=W,e[4*(Z+l*G)+3]=255;return e},_getImageDataGrey16bits:function(B,q,C,v,m,O,S,D,R){const T=C,l=B.width,z=B.height;let W,Z,G=0;const y=new Uint8Array(l*z*4);for(Z=v;Z!==O;Z+=m)for(W=S;W!==R;W+=D,G+=2)y[4*(W+l*Z)+0]=T[G+0],y[4*(W+l*Z)+1]=T[G+0],y[4*(W+l*Z)+2]=T[G+0],y[4*(W+l*Z)+3]=T[G+1];return y}};class D{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(B,q,C){const v=new Uint8Array(B.buffer,B.byteOffset,B.byteLength),S=m(v);C(S.width,S.height,q.generateMipMaps,!1,(()=>{O(q,v)}))}}}}]);