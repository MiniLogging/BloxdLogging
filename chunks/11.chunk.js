"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[11],{12989:(I,x,L)=>{L.d(x,{e:()=>Y,h:()=>G,l:()=>F,m:()=>X});const F=1/2.2,X=2.2,G=(1+Math.sqrt(5))/2,Y=.001},13001:(I,x,L)=>{function F(I){return parseInt(I.toString().replace(/\W/g,""))}function X(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(I-x)<=L}function G(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return I<x-F||I>L+F}function Y(I,x){return I===x?I:Math.random()*(x-I)+I}function p(I,x,L){return I+(x-I)*L}function B(I,x,L){let F=H(x-I,360);return F>180&&(F-=360),I+F*e(L)}function l(I,x,L){let F=0;return F=I!=x?e((L-I)/(x-I)):0,F}function W(I,x,L,F,X){const G=X*X,Y=X*G;return I*(2*Y-3*G+1)+L*(-2*Y+3*G)+x*(Y-2*G+X)+F*(Y-G)}function Q(I,x,L,F,X){const G=X*X;return 6*(G-X)*I+(3*G-4*X+1)*x+6*(-G+X)*L+(3*G-2*X)*F}function e(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(L,Math.max(x,I))}function g(I){return I-=2*Math.PI*Math.floor((I+Math.PI)/(2*Math.PI))}function v(I){const x=I.toString(16);return I<=15?("0"+x).toUpperCase():x.toUpperCase()}function z(I){if(Math.log2)return Math.floor(Math.log2(I));if(I<0)return NaN;if(0===I)return-1/0;let x=0;if(I<1){for(;I<1;)x++,I*=2;x=-x}else if(I>1)for(;I>1;)x++,I=Math.floor(I/2);return x}function H(I,x){return I-Math.floor(I/x)*x}function s(I,x,L){return(I-x)/(L-x)}function U(I,x,L){return I*(L-x)+x}function q(I,x){let L=H(x-I,360);return L>180&&(L-=360),L}function y(I,x){const L=H(I,2*x);return x-Math.abs(L-x)}function T(I,x,L){let F=e(L);return F=-2*F*F*F+3*F*F,x*F+I*(1-F)}function Z(I,x,L){let F=0;return F=Math.abs(x-I)<=L?x:I+Math.sign(x-I)*L,F}function t(I,x,L){const F=q(I,x);let X=0;return X=-L<F&&F<L?x:Z(I,x=I+F,L),X}function f(I,x,L){return(I-x)/(L-x)}function R(I,x,L){return(L-x)*I+x}function n(I,x){const L=I%x;return 0===L?x:n(x,L)}L.r(x),L.d(x,{Clamp:()=>e,DeltaAngle:()=>q,Denormalize:()=>U,ExtractAsInt:()=>F,Hermite:()=>W,Hermite1stDerivative:()=>Q,HighestCommonFactor:()=>n,ILog2:()=>z,InverseLerp:()=>l,Lerp:()=>p,LerpAngle:()=>B,MoveTowards:()=>Z,MoveTowardsAngle:()=>t,Normalize:()=>s,NormalizeRadians:()=>g,OutsideRange:()=>G,PercentToRange:()=>R,PingPong:()=>y,RandomRange:()=>Y,RangeToPercent:()=>f,Repeat:()=>H,SmoothStep:()=>T,ToHex:()=>v,WithinEpsilon:()=>X})},12996:(I,x,L)=>{function F(I,x){const L=[];for(let F=0;F<I;++F)L.push(x());return L}function X(I,x){return F(I,x)}L.d(x,{c:()=>F,d:()=>X,f:()=>Y});const G=["push","splice","pop","shift","unshift"];function Y(I,x){const L=G.map((L=>function(I,x,L){const F=I[x];if("function"!==typeof F)return null;const X=function(){const F=I.length,G=X.previous.apply(I,arguments);return L(x,F),G};return F.next=X,X.previous=F,I[x]=X,()=>{const L=X.previous;if(!L)return;const F=X.next;F?(L.next=F,F.previous=L):(L.next=void 0,I[x]=L),X.next=void 0,X.previous=void 0}}(I,L,x)));return()=>{for(const I of L)null===I||void 0===I||I()}}},12938:(I,x,L)=>{L.d(x,{b:()=>G,d:()=>X});const F={};function X(I,x){F[I]=x}function G(I){return F[I]}}}]);