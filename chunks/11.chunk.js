"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10882:(Q,z,I)=>{I.r(z),I.d(z,{_TGATextureLoader:()=>e});var P=I(1066);function w(Q){let z=0;return{id_length:Q[z++],colormap_type:Q[z++],image_type:Q[z++],colormap_index:Q[z++]|Q[z++]<<8,colormap_length:Q[z++]|Q[z++]<<8,colormap_size:Q[z++],origin:[Q[z++]|Q[z++]<<8,Q[z++]|Q[z++]<<8],width:Q[z++]|Q[z++]<<8,height:Q[z++]|Q[z++]<<8,pixel_size:Q[z++],flags:Q[z++]}}function T(Q,z){if(z.length<19)return void P.b.Error("Unable to load TGA file - Not enough data to contain header");let I=18;const T=w(z);if(T.id_length+I>z.length)return void P.b.Error("Unable to load TGA file - Not enough data");I+=T.id_length;let e,m=!1,f=!1,j=!1;switch(T.image_type){case 9:m=!0;case 1:f=!0;break;case 10:m=!0;case 2:break;case 11:m=!0;case 3:j=!0}const D=T.pixel_size>>3,k=T.width*T.height*D;let s,J,l,X,n,d,K;if(f&&(s=z.subarray(I,I+=T.colormap_length*(T.colormap_size>>3))),m){let Q,P,w;e=new Uint8Array(k);let T=0;const A=new Uint8Array(D);for(;I<k&&T<k;)if(Q=z[I++],P=1+(127&Q),128&Q){for(w=0;w<D;++w)A[w]=z[I++];for(w=0;w<P;++w)e.set(A,T+w*D);T+=D*P}else{for(P*=D,w=0;w<P;++w)e[T+w]=z[I++];T+=P}}else e=z.subarray(I,I+=f?T.width*T.height:k);switch((48&T.flags)>>4){default:case 2:J=0,X=1,K=T.width,l=0,n=1,d=T.height;break;case 0:J=0,X=1,K=T.width,l=T.height-1,n=-1,d=-1;break;case 3:J=T.width-1,X=-1,K=-1,l=0,n=1,d=T.height;break;case 1:J=T.width-1,X=-1,K=-1,l=T.height-1,n=-1,d=-1}const N="_getImageData"+(j?"Grey":"")+T.pixel_size+"bits",q=A[N](T,s,e,l,n,d,J,X,K);Q.getEngine()._uploadDataToTextureDirectly(Q,q)}const A={GetTGAHeader:w,UploadContent:T,_getImageData8bits:function(Q,z,I,P,w,T,A,e,m){const f=I,j=z,D=Q.width,k=Q.height;let s,J,l,X=0;const n=new Uint8Array(D*k*4);for(l=P;l!==T;l+=w)for(J=A;J!==m;J+=e,X++)s=f[X],n[4*(J+D*l)+3]=255,n[4*(J+D*l)+2]=j[3*s+0],n[4*(J+D*l)+1]=j[3*s+1],n[4*(J+D*l)+0]=j[3*s+2];return n},_getImageData16bits:function(Q,z,I,P,w,T,A,e,m){const f=I,j=Q.width,D=Q.height;let k,s,J,l=0;const X=new Uint8Array(j*D*4);for(J=P;J!==T;J+=w)for(s=A;s!==m;s+=e,l+=2){k=f[l+0]+(f[l+1]<<8);const Q=255*((31744&k)>>10)/31|0,z=255*((992&k)>>5)/31|0,I=255*(31&k)/31|0;X[4*(s+j*J)+0]=Q,X[4*(s+j*J)+1]=z,X[4*(s+j*J)+2]=I,X[4*(s+j*J)+3]=32768&k?0:255}return X},_getImageData24bits:function(Q,z,I,P,w,T,A,e,m){const f=I,j=Q.width,D=Q.height;let k,s,J=0;const l=new Uint8Array(j*D*4);for(s=P;s!==T;s+=w)for(k=A;k!==m;k+=e,J+=3)l[4*(k+j*s)+3]=255,l[4*(k+j*s)+2]=f[J+0],l[4*(k+j*s)+1]=f[J+1],l[4*(k+j*s)+0]=f[J+2];return l},_getImageData32bits:function(Q,z,I,P,w,T,A,e,m){const f=I,j=Q.width,D=Q.height;let k,s,J=0;const l=new Uint8Array(j*D*4);for(s=P;s!==T;s+=w)for(k=A;k!==m;k+=e,J+=4)l[4*(k+j*s)+2]=f[J+0],l[4*(k+j*s)+1]=f[J+1],l[4*(k+j*s)+0]=f[J+2],l[4*(k+j*s)+3]=f[J+3];return l},_getImageDataGrey8bits:function(Q,z,I,P,w,T,A,e,m){const f=I,j=Q.width,D=Q.height;let k,s,J,l=0;const X=new Uint8Array(j*D*4);for(J=P;J!==T;J+=w)for(s=A;s!==m;s+=e,l++)k=f[l],X[4*(s+j*J)+0]=k,X[4*(s+j*J)+1]=k,X[4*(s+j*J)+2]=k,X[4*(s+j*J)+3]=255;return X},_getImageDataGrey16bits:function(Q,z,I,P,w,T,A,e,m){const f=I,j=Q.width,D=Q.height;let k,s,J=0;const l=new Uint8Array(j*D*4);for(s=P;s!==T;s+=w)for(k=A;k!==m;k+=e,J+=2)l[4*(k+j*s)+0]=f[J+0],l[4*(k+j*s)+1]=f[J+0],l[4*(k+j*s)+2]=f[J+0],l[4*(k+j*s)+3]=f[J+1];return l}};class e{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(Q,z,I){const P=new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength),A=w(P);I(A.width,A.height,z.generateMipMaps,!1,(()=>{T(z,P)}))}}}}]);