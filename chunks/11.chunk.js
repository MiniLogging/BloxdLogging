"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10968:(D,j,W)=>{W.r(j),W.d(j,{_TGATextureLoader:()=>O});var Q=W(1083);function C(D){let j=0;return{id_length:D[j++],colormap_type:D[j++],image_type:D[j++],colormap_index:D[j++]|D[j++]<<8,colormap_length:D[j++]|D[j++]<<8,colormap_size:D[j++],origin:[D[j++]|D[j++]<<8,D[j++]|D[j++]<<8],width:D[j++]|D[j++]<<8,height:D[j++]|D[j++]<<8,pixel_size:D[j++],flags:D[j++]}}function k(D,j){if(j.length<19)return void Q.b.Error("Unable to load TGA file - Not enough data to contain header");let W=18;const k=C(j);if(k.id_length+W>j.length)return void Q.b.Error("Unable to load TGA file - Not enough data");W+=k.id_length;let O,E=!1,f=!1,F=!1;switch(k.image_type){case 9:E=!0;case 1:f=!0;break;case 10:E=!0;case 2:break;case 11:E=!0;case 3:F=!0}const Z=k.pixel_size>>3,P=k.width*k.height*Z;let X,x,R,V,U,g,N;if(f&&(X=j.subarray(W,W+=k.colormap_length*(k.colormap_size>>3))),E){let D,Q,C;O=new Uint8Array(P);let k=0;const M=new Uint8Array(Z);for(;W<P&&k<P;)if(D=j[W++],Q=1+(127&D),128&D){for(C=0;C<Z;++C)M[C]=j[W++];for(C=0;C<Q;++C)O.set(M,k+C*Z);k+=Z*Q}else{for(Q*=Z,C=0;C<Q;++C)O[k+C]=j[W++];k+=Q}}else O=j.subarray(W,W+=f?k.width*k.height:P);switch((48&k.flags)>>4){default:case 2:x=0,V=1,N=k.width,R=0,U=1,g=k.height;break;case 0:x=0,V=1,N=k.width,R=k.height-1,U=-1,g=-1;break;case 3:x=k.width-1,V=-1,N=-1,R=0,U=1,g=k.height;break;case 1:x=k.width-1,V=-1,N=-1,R=k.height-1,U=-1,g=-1}const G="_getImageData"+(F?"Grey":"")+k.pixel_size+"bits",K=M[G](k,X,O,R,U,g,x,V,N);D.getEngine()._uploadDataToTextureDirectly(D,K)}const M={GetTGAHeader:C,UploadContent:k,_getImageData8bits:function(D,j,W,Q,C,k,M,O,E){const f=W,F=j,Z=D.width,P=D.height;let X,x,R,V=0;const U=new Uint8Array(Z*P*4);for(R=Q;R!==k;R+=C)for(x=M;x!==E;x+=O,V++)X=f[V],U[4*(x+Z*R)+3]=255,U[4*(x+Z*R)+2]=F[3*X+0],U[4*(x+Z*R)+1]=F[3*X+1],U[4*(x+Z*R)+0]=F[3*X+2];return U},_getImageData16bits:function(D,j,W,Q,C,k,M,O,E){const f=W,F=D.width,Z=D.height;let P,X,x,R=0;const V=new Uint8Array(F*Z*4);for(x=Q;x!==k;x+=C)for(X=M;X!==E;X+=O,R+=2){P=f[R+0]+(f[R+1]<<8);const D=255*((31744&P)>>10)/31|0,j=255*((992&P)>>5)/31|0,W=255*(31&P)/31|0;V[4*(X+F*x)+0]=D,V[4*(X+F*x)+1]=j,V[4*(X+F*x)+2]=W,V[4*(X+F*x)+3]=32768&P?0:255}return V},_getImageData24bits:function(D,j,W,Q,C,k,M,O,E){const f=W,F=D.width,Z=D.height;let P,X,x=0;const R=new Uint8Array(F*Z*4);for(X=Q;X!==k;X+=C)for(P=M;P!==E;P+=O,x+=3)R[4*(P+F*X)+3]=255,R[4*(P+F*X)+2]=f[x+0],R[4*(P+F*X)+1]=f[x+1],R[4*(P+F*X)+0]=f[x+2];return R},_getImageData32bits:function(D,j,W,Q,C,k,M,O,E){const f=W,F=D.width,Z=D.height;let P,X,x=0;const R=new Uint8Array(F*Z*4);for(X=Q;X!==k;X+=C)for(P=M;P!==E;P+=O,x+=4)R[4*(P+F*X)+2]=f[x+0],R[4*(P+F*X)+1]=f[x+1],R[4*(P+F*X)+0]=f[x+2],R[4*(P+F*X)+3]=f[x+3];return R},_getImageDataGrey8bits:function(D,j,W,Q,C,k,M,O,E){const f=W,F=D.width,Z=D.height;let P,X,x,R=0;const V=new Uint8Array(F*Z*4);for(x=Q;x!==k;x+=C)for(X=M;X!==E;X+=O,R++)P=f[R],V[4*(X+F*x)+0]=P,V[4*(X+F*x)+1]=P,V[4*(X+F*x)+2]=P,V[4*(X+F*x)+3]=255;return V},_getImageDataGrey16bits:function(D,j,W,Q,C,k,M,O,E){const f=W,F=D.width,Z=D.height;let P,X,x=0;const R=new Uint8Array(F*Z*4);for(X=Q;X!==k;X+=C)for(P=M;P!==E;P+=O,x+=2)R[4*(P+F*X)+0]=f[x+0],R[4*(P+F*X)+1]=f[x+0],R[4*(P+F*X)+2]=f[x+0],R[4*(P+F*X)+3]=f[x+1];return R}};class O{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(D,j,W){const Q=new Uint8Array(D.buffer,D.byteOffset,D.byteLength),M=C(Q);W(M.width,M.height,j.generateMipMaps,!1,(()=>{k(j,Q)}))}}}}]);