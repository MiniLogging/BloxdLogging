"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10137:(V,H,t)=>{t.r(H),t.d(H,{_TGATextureLoader:()=>m});var I=t(1023);function Z(V){let H=0;return{id_length:V[H++],colormap_type:V[H++],image_type:V[H++],colormap_index:V[H++]|V[H++]<<8,colormap_length:V[H++]|V[H++]<<8,colormap_size:V[H++],origin:[V[H++]|V[H++]<<8,V[H++]|V[H++]<<8],width:V[H++]|V[H++]<<8,height:V[H++]|V[H++]<<8,pixel_size:V[H++],flags:V[H++]}}function h(V,H){if(H.length<19)return void I.c.Error("Unable to load TGA file - Not enough data to contain header");let t=18;const h=Z(H);if(h.id_length+t>H.length)return void I.c.Error("Unable to load TGA file - Not enough data");t+=h.id_length;let m,K=!1,E=!1,d=!1;switch(h.image_type){case 9:K=!0;case 1:E=!0;break;case 10:K=!0;case 2:break;case 11:K=!0;case 3:d=!0}const a=h.pixel_size>>3,J=h.width*h.height*a;let O,C,S,v,Q,e,W;if(E&&(O=H.subarray(t,t+=h.colormap_length*(h.colormap_size>>3))),K){let V,I,Z;m=new Uint8Array(J);let h=0;const f=new Uint8Array(a);for(;t<J&&h<J;)if(V=H[t++],I=1+(127&V),128&V){for(Z=0;Z<a;++Z)f[Z]=H[t++];for(Z=0;Z<I;++Z)m.set(f,h+Z*a);h+=a*I}else{for(I*=a,Z=0;Z<I;++Z)m[h+Z]=H[t++];h+=I}}else m=H.subarray(t,t+=E?h.width*h.height:J);switch((48&h.flags)>>4){default:case 2:C=0,v=1,W=h.width,S=0,Q=1,e=h.height;break;case 0:C=0,v=1,W=h.width,S=h.height-1,Q=-1,e=-1;break;case 3:C=h.width-1,v=-1,W=-1,S=0,Q=1,e=h.height;break;case 1:C=h.width-1,v=-1,W=-1,S=h.height-1,Q=-1,e=-1}const c="_getImageData"+(d?"Grey":"")+h.pixel_size+"bits",o=f[c](h,O,m,S,Q,e,C,v,W);V.getEngine()._uploadDataToTextureDirectly(V,o)}const f={GetTGAHeader:Z,UploadContent:h,_getImageData8bits:function(V,H,t,I,Z,h,f,m,K){const E=t,d=H,a=V.width,J=V.height;let O,C,S,v=0;const Q=new Uint8Array(a*J*4);for(S=I;S!==h;S+=Z)for(C=f;C!==K;C+=m,v++)O=E[v],Q[4*(C+a*S)+3]=255,Q[4*(C+a*S)+2]=d[3*O+0],Q[4*(C+a*S)+1]=d[3*O+1],Q[4*(C+a*S)+0]=d[3*O+2];return Q},_getImageData16bits:function(V,H,t,I,Z,h,f,m,K){const E=t,d=V.width,a=V.height;let J,O,C,S=0;const v=new Uint8Array(d*a*4);for(C=I;C!==h;C+=Z)for(O=f;O!==K;O+=m,S+=2){J=E[S+0]+(E[S+1]<<8);const V=255*((31744&J)>>10)/31|0,H=255*((992&J)>>5)/31|0,t=255*(31&J)/31|0;v[4*(O+d*C)+0]=V,v[4*(O+d*C)+1]=H,v[4*(O+d*C)+2]=t,v[4*(O+d*C)+3]=32768&J?0:255}return v},_getImageData24bits:function(V,H,t,I,Z,h,f,m,K){const E=t,d=V.width,a=V.height;let J,O,C=0;const S=new Uint8Array(d*a*4);for(O=I;O!==h;O+=Z)for(J=f;J!==K;J+=m,C+=3)S[4*(J+d*O)+3]=255,S[4*(J+d*O)+2]=E[C+0],S[4*(J+d*O)+1]=E[C+1],S[4*(J+d*O)+0]=E[C+2];return S},_getImageData32bits:function(V,H,t,I,Z,h,f,m,K){const E=t,d=V.width,a=V.height;let J,O,C=0;const S=new Uint8Array(d*a*4);for(O=I;O!==h;O+=Z)for(J=f;J!==K;J+=m,C+=4)S[4*(J+d*O)+2]=E[C+0],S[4*(J+d*O)+1]=E[C+1],S[4*(J+d*O)+0]=E[C+2],S[4*(J+d*O)+3]=E[C+3];return S},_getImageDataGrey8bits:function(V,H,t,I,Z,h,f,m,K){const E=t,d=V.width,a=V.height;let J,O,C,S=0;const v=new Uint8Array(d*a*4);for(C=I;C!==h;C+=Z)for(O=f;O!==K;O+=m,S++)J=E[S],v[4*(O+d*C)+0]=J,v[4*(O+d*C)+1]=J,v[4*(O+d*C)+2]=J,v[4*(O+d*C)+3]=255;return v},_getImageDataGrey16bits:function(V,H,t,I,Z,h,f,m,K){const E=t,d=V.width,a=V.height;let J,O,C=0;const S=new Uint8Array(d*a*4);for(O=I;O!==h;O+=Z)for(J=f;J!==K;J+=m,C+=2)S[4*(J+d*O)+0]=E[C+0],S[4*(J+d*O)+1]=E[C+0],S[4*(J+d*O)+2]=E[C+0],S[4*(J+d*O)+3]=E[C+1];return S}};class m{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(V,H,t){const I=new Uint8Array(V.buffer,V.byteOffset,V.byteLength),f=Z(I);t(f.width,f.height,H.generateMipMaps,!1,(()=>{h(H,I)}))}}}}]);