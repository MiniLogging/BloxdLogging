"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10649:(p,O,E)=>{E.r(O),E.d(O,{_TGATextureLoader:()=>a});var e=E(1065);function x(p){let O=0;return{id_length:p[O++],colormap_type:p[O++],image_type:p[O++],colormap_index:p[O++]|p[O++]<<8,colormap_length:p[O++]|p[O++]<<8,colormap_size:p[O++],origin:[p[O++]|p[O++]<<8,p[O++]|p[O++]<<8],width:p[O++]|p[O++]<<8,height:p[O++]|p[O++]<<8,pixel_size:p[O++],flags:p[O++]}}function F(p,O){if(O.length<19)return void e.b.Error("Unable to load TGA file - Not enough data to contain header");let E=18;const F=x(O);if(F.id_length+E>O.length)return void e.b.Error("Unable to load TGA file - Not enough data");E+=F.id_length;let a,Y=!1,B=!1,s=!1;switch(F.image_type){case 9:Y=!0;case 1:B=!0;break;case 10:Y=!0;case 2:break;case 11:Y=!0;case 3:s=!0}const D=F.pixel_size>>3,Z=F.width*F.height*D;let m,h,T,A,H,t,r;if(B&&(m=O.subarray(E,E+=F.colormap_length*(F.colormap_size>>3))),Y){let p,e,x;a=new Uint8Array(Z);let F=0;const q=new Uint8Array(D);for(;E<Z&&F<Z;)if(p=O[E++],e=1+(127&p),128&p){for(x=0;x<D;++x)q[x]=O[E++];for(x=0;x<e;++x)a.set(q,F+x*D);F+=D*e}else{for(e*=D,x=0;x<e;++x)a[F+x]=O[E++];F+=e}}else a=O.subarray(E,E+=B?F.width*F.height:Z);switch((48&F.flags)>>4){default:case 2:h=0,A=1,r=F.width,T=0,H=1,t=F.height;break;case 0:h=0,A=1,r=F.width,T=F.height-1,H=-1,t=-1;break;case 3:h=F.width-1,A=-1,r=-1,T=0,H=1,t=F.height;break;case 1:h=F.width-1,A=-1,r=-1,T=F.height-1,H=-1,t=-1}const Q="_getImageData"+(s?"Grey":"")+F.pixel_size+"bits",W=q[Q](F,m,a,T,H,t,h,A,r);p.getEngine()._uploadDataToTextureDirectly(p,W)}const q={GetTGAHeader:x,UploadContent:F,_getImageData8bits:function(p,O,E,e,x,F,q,a,Y){const B=E,s=O,D=p.width,Z=p.height;let m,h,T,A=0;const H=new Uint8Array(D*Z*4);for(T=e;T!==F;T+=x)for(h=q;h!==Y;h+=a,A++)m=B[A],H[4*(h+D*T)+3]=255,H[4*(h+D*T)+2]=s[3*m+0],H[4*(h+D*T)+1]=s[3*m+1],H[4*(h+D*T)+0]=s[3*m+2];return H},_getImageData16bits:function(p,O,E,e,x,F,q,a,Y){const B=E,s=p.width,D=p.height;let Z,m,h,T=0;const A=new Uint8Array(s*D*4);for(h=e;h!==F;h+=x)for(m=q;m!==Y;m+=a,T+=2){Z=B[T+0]+(B[T+1]<<8);const p=255*((31744&Z)>>10)/31|0,O=255*((992&Z)>>5)/31|0,E=255*(31&Z)/31|0;A[4*(m+s*h)+0]=p,A[4*(m+s*h)+1]=O,A[4*(m+s*h)+2]=E,A[4*(m+s*h)+3]=32768&Z?0:255}return A},_getImageData24bits:function(p,O,E,e,x,F,q,a,Y){const B=E,s=p.width,D=p.height;let Z,m,h=0;const T=new Uint8Array(s*D*4);for(m=e;m!==F;m+=x)for(Z=q;Z!==Y;Z+=a,h+=3)T[4*(Z+s*m)+3]=255,T[4*(Z+s*m)+2]=B[h+0],T[4*(Z+s*m)+1]=B[h+1],T[4*(Z+s*m)+0]=B[h+2];return T},_getImageData32bits:function(p,O,E,e,x,F,q,a,Y){const B=E,s=p.width,D=p.height;let Z,m,h=0;const T=new Uint8Array(s*D*4);for(m=e;m!==F;m+=x)for(Z=q;Z!==Y;Z+=a,h+=4)T[4*(Z+s*m)+2]=B[h+0],T[4*(Z+s*m)+1]=B[h+1],T[4*(Z+s*m)+0]=B[h+2],T[4*(Z+s*m)+3]=B[h+3];return T},_getImageDataGrey8bits:function(p,O,E,e,x,F,q,a,Y){const B=E,s=p.width,D=p.height;let Z,m,h,T=0;const A=new Uint8Array(s*D*4);for(h=e;h!==F;h+=x)for(m=q;m!==Y;m+=a,T++)Z=B[T],A[4*(m+s*h)+0]=Z,A[4*(m+s*h)+1]=Z,A[4*(m+s*h)+2]=Z,A[4*(m+s*h)+3]=255;return A},_getImageDataGrey16bits:function(p,O,E,e,x,F,q,a,Y){const B=E,s=p.width,D=p.height;let Z,m,h=0;const T=new Uint8Array(s*D*4);for(m=e;m!==F;m+=x)for(Z=q;Z!==Y;Z+=a,h+=2)T[4*(Z+s*m)+0]=B[h+0],T[4*(Z+s*m)+1]=B[h+0],T[4*(Z+s*m)+2]=B[h+0],T[4*(Z+s*m)+3]=B[h+1];return T}};class a{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(p,O,E){const e=new Uint8Array(p.buffer,p.byteOffset,p.byteLength),q=x(e);E(q.width,q.height,O.generateMipMaps,!1,(()=>{F(O,e)}))}}}}]);