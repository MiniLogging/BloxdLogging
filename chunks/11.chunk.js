"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10385:(R,N,q)=>{q.r(N),q.d(N,{_TGATextureLoader:()=>G});var w=q(1056);function u(R){let N=0;return{id_length:R[N++],colormap_type:R[N++],image_type:R[N++],colormap_index:R[N++]|R[N++]<<8,colormap_length:R[N++]|R[N++]<<8,colormap_size:R[N++],origin:[R[N++]|R[N++]<<8,R[N++]|R[N++]<<8],width:R[N++]|R[N++]<<8,height:R[N++]|R[N++]<<8,pixel_size:R[N++],flags:R[N++]}}function M(R,N){if(N.length<19)return void w.e.Error("Unable to load TGA file - Not enough data to contain header");let q=18;const M=u(N);if(M.id_length+q>N.length)return void w.e.Error("Unable to load TGA file - Not enough data");q+=M.id_length;let G,J=!1,y=!1,a=!1;switch(M.image_type){case 9:J=!0;case 1:y=!0;break;case 10:J=!0;case 2:break;case 11:J=!0;case 3:a=!0}const j=M.pixel_size>>3,F=M.width*M.height*j;let S,H,W,k,C,e,K;if(y&&(S=N.subarray(q,q+=M.colormap_length*(M.colormap_size>>3))),J){let R,w,u;G=new Uint8Array(F);let M=0;const v=new Uint8Array(j);for(;q<F&&M<F;)if(R=N[q++],w=1+(127&R),128&R){for(u=0;u<j;++u)v[u]=N[q++];for(u=0;u<w;++u)G.set(v,M+u*j);M+=j*w}else{for(w*=j,u=0;u<w;++u)G[M+u]=N[q++];M+=w}}else G=N.subarray(q,q+=y?M.width*M.height:F);switch((48&M.flags)>>4){default:case 2:H=0,k=1,K=M.width,W=0,C=1,e=M.height;break;case 0:H=0,k=1,K=M.width,W=M.height-1,C=-1,e=-1;break;case 3:H=M.width-1,k=-1,K=-1,W=0,C=1,e=M.height;break;case 1:H=M.width-1,k=-1,K=-1,W=M.height-1,C=-1,e=-1}const r="_getImageData"+(a?"Grey":"")+M.pixel_size+"bits",Z=v[r](M,S,G,W,C,e,H,k,K);R.getEngine()._uploadDataToTextureDirectly(R,Z)}const v={GetTGAHeader:u,UploadContent:M,_getImageData8bits:function(R,N,q,w,u,M,v,G,J){const y=q,a=N,j=R.width,F=R.height;let S,H,W,k=0;const C=new Uint8Array(j*F*4);for(W=w;W!==M;W+=u)for(H=v;H!==J;H+=G,k++)S=y[k],C[4*(H+j*W)+3]=255,C[4*(H+j*W)+2]=a[3*S+0],C[4*(H+j*W)+1]=a[3*S+1],C[4*(H+j*W)+0]=a[3*S+2];return C},_getImageData16bits:function(R,N,q,w,u,M,v,G,J){const y=q,a=R.width,j=R.height;let F,S,H,W=0;const k=new Uint8Array(a*j*4);for(H=w;H!==M;H+=u)for(S=v;S!==J;S+=G,W+=2){F=y[W+0]+(y[W+1]<<8);const R=255*((31744&F)>>10)/31|0,N=255*((992&F)>>5)/31|0,q=255*(31&F)/31|0;k[4*(S+a*H)+0]=R,k[4*(S+a*H)+1]=N,k[4*(S+a*H)+2]=q,k[4*(S+a*H)+3]=32768&F?0:255}return k},_getImageData24bits:function(R,N,q,w,u,M,v,G,J){const y=q,a=R.width,j=R.height;let F,S,H=0;const W=new Uint8Array(a*j*4);for(S=w;S!==M;S+=u)for(F=v;F!==J;F+=G,H+=3)W[4*(F+a*S)+3]=255,W[4*(F+a*S)+2]=y[H+0],W[4*(F+a*S)+1]=y[H+1],W[4*(F+a*S)+0]=y[H+2];return W},_getImageData32bits:function(R,N,q,w,u,M,v,G,J){const y=q,a=R.width,j=R.height;let F,S,H=0;const W=new Uint8Array(a*j*4);for(S=w;S!==M;S+=u)for(F=v;F!==J;F+=G,H+=4)W[4*(F+a*S)+2]=y[H+0],W[4*(F+a*S)+1]=y[H+1],W[4*(F+a*S)+0]=y[H+2],W[4*(F+a*S)+3]=y[H+3];return W},_getImageDataGrey8bits:function(R,N,q,w,u,M,v,G,J){const y=q,a=R.width,j=R.height;let F,S,H,W=0;const k=new Uint8Array(a*j*4);for(H=w;H!==M;H+=u)for(S=v;S!==J;S+=G,W++)F=y[W],k[4*(S+a*H)+0]=F,k[4*(S+a*H)+1]=F,k[4*(S+a*H)+2]=F,k[4*(S+a*H)+3]=255;return k},_getImageDataGrey16bits:function(R,N,q,w,u,M,v,G,J){const y=q,a=R.width,j=R.height;let F,S,H=0;const W=new Uint8Array(a*j*4);for(S=w;S!==M;S+=u)for(F=v;F!==J;F+=G,H+=2)W[4*(F+a*S)+0]=y[H+0],W[4*(F+a*S)+1]=y[H+0],W[4*(F+a*S)+2]=y[H+0],W[4*(F+a*S)+3]=y[H+1];return W}};class G{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(R,N,q){const w=new Uint8Array(R.buffer,R.byteOffset,R.byteLength),v=u(w);q(v.width,v.height,N.generateMipMaps,!1,(()=>{M(N,w)}))}}}}]);