"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10354:(G,D,N)=>{N.r(D),N.d(D,{_TGATextureLoader:()=>C});var T=N(1105);function o(G){let D=0;return{id_length:G[D++],colormap_type:G[D++],image_type:G[D++],colormap_index:G[D++]|G[D++]<<8,colormap_length:G[D++]|G[D++]<<8,colormap_size:G[D++],origin:[G[D++]|G[D++]<<8,G[D++]|G[D++]<<8],width:G[D++]|G[D++]<<8,height:G[D++]|G[D++]<<8,pixel_size:G[D++],flags:G[D++]}}function Z(G,D){if(D.length<19)return void T.d.Error("Unable to load TGA file - Not enough data to contain header");let N=18;const Z=o(D);if(Z.id_length+N>D.length)return void T.d.Error("Unable to load TGA file - Not enough data");N+=Z.id_length;let C,P=!1,r=!1,v=!1;switch(Z.image_type){case 9:P=!0;case 1:r=!0;break;case 10:P=!0;case 2:break;case 11:P=!0;case 3:v=!0}const q=Z.pixel_size>>3,g=Z.width*Z.height*q;let X,W,j,Y,y,h,m;if(r&&(X=D.subarray(N,N+=Z.colormap_length*(Z.colormap_size>>3))),P){let G,T,o;C=new Uint8Array(g);let Z=0;const n=new Uint8Array(q);for(;N<g&&Z<g;)if(G=D[N++],T=1+(127&G),128&G){for(o=0;o<q;++o)n[o]=D[N++];for(o=0;o<T;++o)C.set(n,Z+o*q);Z+=q*T}else{for(T*=q,o=0;o<T;++o)C[Z+o]=D[N++];Z+=T}}else C=D.subarray(N,N+=r?Z.width*Z.height:g);switch((48&Z.flags)>>4){default:case 2:W=0,Y=1,m=Z.width,j=0,y=1,h=Z.height;break;case 0:W=0,Y=1,m=Z.width,j=Z.height-1,y=-1,h=-1;break;case 3:W=Z.width-1,Y=-1,m=-1,j=0,y=1,h=Z.height;break;case 1:W=Z.width-1,Y=-1,m=-1,j=Z.height-1,y=-1,h=-1}const R="_getImageData"+(v?"Grey":"")+Z.pixel_size+"bits",L=n[R](Z,X,C,j,y,h,W,Y,m);G.getEngine()._uploadDataToTextureDirectly(G,L)}const n={GetTGAHeader:o,UploadContent:Z,_getImageData8bits:function(G,D,N,T,o,Z,n,C,P){const r=N,v=D,q=G.width,g=G.height;let X,W,j,Y=0;const y=new Uint8Array(q*g*4);for(j=T;j!==Z;j+=o)for(W=n;W!==P;W+=C,Y++)X=r[Y],y[4*(W+q*j)+3]=255,y[4*(W+q*j)+2]=v[3*X+0],y[4*(W+q*j)+1]=v[3*X+1],y[4*(W+q*j)+0]=v[3*X+2];return y},_getImageData16bits:function(G,D,N,T,o,Z,n,C,P){const r=N,v=G.width,q=G.height;let g,X,W,j=0;const Y=new Uint8Array(v*q*4);for(W=T;W!==Z;W+=o)for(X=n;X!==P;X+=C,j+=2){g=r[j+0]+(r[j+1]<<8);const G=255*((31744&g)>>10)/31|0,D=255*((992&g)>>5)/31|0,N=255*(31&g)/31|0;Y[4*(X+v*W)+0]=G,Y[4*(X+v*W)+1]=D,Y[4*(X+v*W)+2]=N,Y[4*(X+v*W)+3]=32768&g?0:255}return Y},_getImageData24bits:function(G,D,N,T,o,Z,n,C,P){const r=N,v=G.width,q=G.height;let g,X,W=0;const j=new Uint8Array(v*q*4);for(X=T;X!==Z;X+=o)for(g=n;g!==P;g+=C,W+=3)j[4*(g+v*X)+3]=255,j[4*(g+v*X)+2]=r[W+0],j[4*(g+v*X)+1]=r[W+1],j[4*(g+v*X)+0]=r[W+2];return j},_getImageData32bits:function(G,D,N,T,o,Z,n,C,P){const r=N,v=G.width,q=G.height;let g,X,W=0;const j=new Uint8Array(v*q*4);for(X=T;X!==Z;X+=o)for(g=n;g!==P;g+=C,W+=4)j[4*(g+v*X)+2]=r[W+0],j[4*(g+v*X)+1]=r[W+1],j[4*(g+v*X)+0]=r[W+2],j[4*(g+v*X)+3]=r[W+3];return j},_getImageDataGrey8bits:function(G,D,N,T,o,Z,n,C,P){const r=N,v=G.width,q=G.height;let g,X,W,j=0;const Y=new Uint8Array(v*q*4);for(W=T;W!==Z;W+=o)for(X=n;X!==P;X+=C,j++)g=r[j],Y[4*(X+v*W)+0]=g,Y[4*(X+v*W)+1]=g,Y[4*(X+v*W)+2]=g,Y[4*(X+v*W)+3]=255;return Y},_getImageDataGrey16bits:function(G,D,N,T,o,Z,n,C,P){const r=N,v=G.width,q=G.height;let g,X,W=0;const j=new Uint8Array(v*q*4);for(X=T;X!==Z;X+=o)for(g=n;g!==P;g+=C,W+=2)j[4*(g+v*X)+0]=r[W+0],j[4*(g+v*X)+1]=r[W+0],j[4*(g+v*X)+2]=r[W+0],j[4*(g+v*X)+3]=r[W+1];return j}};class C{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(G,D,N){const T=new Uint8Array(G.buffer,G.byteOffset,G.byteLength),n=o(T);N(n.width,n.height,D.generateMipMaps,!1,(()=>{Z(D,T)}))}}}}]);