"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{11188:(Z,x,F)=>{F.d(x,{e:()=>Y,h:()=>f,j:()=>u,l:()=>G});const u=1/2.2,G=2.2,f=(1+Math.sqrt(5))/2,Y=.001},11194:(Z,x,F)=>{function u(Z){return parseInt(Z.toString().replace(/\W/g,""))}function G(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Z-x)<=F}function f(Z,x,F){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Z<x-u||Z>F+u}function Y(Z,x){return Z===x?Z:Math.random()*(x-Z)+Z}function j(Z,x,F){return Z+(x-Z)*F}function d(Z,x,F){let u=k(x-Z,360);return u>180&&(u-=360),Z+u*s(F)}function t(Z,x,F){let u=0;return u=Z!=x?s((F-Z)/(x-Z)):0,u}function o(Z,x,F,u,G){const f=G*G,Y=G*f;return Z*(2*Y-3*f+1)+F*(-2*Y+3*f)+x*(Y-2*f+G)+u*(Y-f)}function c(Z,x,F,u,G){const f=G*G;return 6*(f-G)*Z+(3*f-4*G+1)*x+6*(-f+G)*F+(3*f-2*G)*u}function s(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(F,Math.max(x,Z))}function J(Z){return Z-=2*Math.PI*Math.floor((Z+Math.PI)/(2*Math.PI))}function p(Z){const x=Z.toString(16);return Z<=15?("0"+x).toUpperCase():x.toUpperCase()}function U(Z){if(Math.log2)return Math.floor(Math.log2(Z));if(Z<0)return NaN;if(0===Z)return-1/0;let x=0;if(Z<1){for(;Z<1;)x++,Z*=2;x=-x}else if(Z>1)for(;Z>1;)x++,Z=Math.floor(Z/2);return x}function k(Z,x){return Z-Math.floor(Z/x)*x}function M(Z,x,F){return(Z-x)/(F-x)}function m(Z,x,F){return Z*(F-x)+x}function C(Z,x){let F=k(x-Z,360);return F>180&&(F-=360),F}function L(Z,x){const F=k(Z,2*x);return x-Math.abs(F-x)}function H(Z,x,F){let u=s(F);return u=-2*u*u*u+3*u*u,x*u+Z*(1-u)}function S(Z,x,F){let u=0;return u=Math.abs(x-Z)<=F?x:Z+Math.sign(x-Z)*F,u}function K(Z,x,F){const u=C(Z,x);let G=0;return G=-F<u&&u<F?x:S(Z,x=Z+u,F),G}function y(Z,x,F){return(Z-x)/(F-x)}function q(Z,x,F){return(F-x)*Z+x}function R(Z,x){const F=Z%x;return 0===F?x:R(x,F)}F.r(x),F.d(x,{Clamp:()=>s,DeltaAngle:()=>C,Denormalize:()=>m,ExtractAsInt:()=>u,Hermite:()=>o,Hermite1stDerivative:()=>c,HighestCommonFactor:()=>R,ILog2:()=>U,InverseLerp:()=>t,Lerp:()=>j,LerpAngle:()=>d,MoveTowards:()=>S,MoveTowardsAngle:()=>K,Normalize:()=>M,NormalizeRadians:()=>J,OutsideRange:()=>f,PercentToRange:()=>q,PingPong:()=>L,RandomRange:()=>Y,RangeToPercent:()=>y,Repeat:()=>k,SmoothStep:()=>H,ToHex:()=>p,WithinEpsilon:()=>G})},11192:(Z,x,F)=>{function u(Z,x){const F=[];for(let u=0;u<Z;++u)F.push(x());return F}function G(Z,x){return u(Z,x)}F.d(x,{b:()=>u,d:()=>G,e:()=>Y});const f=["push","splice","pop","shift","unshift"];function Y(Z,x){const F=f.map((F=>function(Z,x,F){const u=Z[x];if("function"!==typeof u)return null;const G=function(){const u=Z.length,f=G.previous.apply(Z,arguments);return F(x,u),f};return u.next=G,G.previous=u,Z[x]=G,()=>{const F=G.previous;if(!F)return;const u=G.next;u?(F.next=u,u.previous=F):(F.next=void 0,Z[x]=F),G.next=void 0,G.previous=void 0}}(Z,F,x)));return()=>{for(const Z of F)null===Z||void 0===Z||Z()}}},11136:(Z,x,F)=>{F.d(x,{e:()=>f,g:()=>G});const u={};function G(Z,x){u[Z]=x}function f(Z){return u[Z]}}}]);