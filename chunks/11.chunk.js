"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{11013:(T,z,X)=>{X.r(z),X.d(z,{_TGATextureLoader:()=>y});var b=X(1065);function F(T){let z=0;return{id_length:T[z++],colormap_type:T[z++],image_type:T[z++],colormap_index:T[z++]|T[z++]<<8,colormap_length:T[z++]|T[z++]<<8,colormap_size:T[z++],origin:[T[z++]|T[z++]<<8,T[z++]|T[z++]<<8],width:T[z++]|T[z++]<<8,height:T[z++]|T[z++]<<8,pixel_size:T[z++],flags:T[z++]}}function A(T,z){if(z.length<19)return void b.e.Error("Unable to load TGA file - Not enough data to contain header");let X=18;const A=F(z);if(A.id_length+X>z.length)return void b.e.Error("Unable to load TGA file - Not enough data");X+=A.id_length;let y,E=!1,v=!1,k=!1;switch(A.image_type){case 9:E=!0;case 1:v=!0;break;case 10:E=!0;case 2:break;case 11:E=!0;case 3:k=!0}const L=A.pixel_size>>3,D=A.width*A.height*L;let c,p,H,U,s,x,K;if(v&&(c=z.subarray(X,X+=A.colormap_length*(A.colormap_size>>3))),E){let T,b,F;y=new Uint8Array(D);let A=0;const u=new Uint8Array(L);for(;X<D&&A<D;)if(T=z[X++],b=1+(127&T),128&T){for(F=0;F<L;++F)u[F]=z[X++];for(F=0;F<b;++F)y.set(u,A+F*L);A+=L*b}else{for(b*=L,F=0;F<b;++F)y[A+F]=z[X++];A+=b}}else y=z.subarray(X,X+=v?A.width*A.height:D);switch((48&A.flags)>>4){default:case 2:p=0,U=1,K=A.width,H=0,s=1,x=A.height;break;case 0:p=0,U=1,K=A.width,H=A.height-1,s=-1,x=-1;break;case 3:p=A.width-1,U=-1,K=-1,H=0,s=1,x=A.height;break;case 1:p=A.width-1,U=-1,K=-1,H=A.height-1,s=-1,x=-1}const d="_getImageData"+(k?"Grey":"")+A.pixel_size+"bits",N=u[d](A,c,y,H,s,x,p,U,K);T.getEngine()._uploadDataToTextureDirectly(T,N)}const u={GetTGAHeader:F,UploadContent:A,_getImageData8bits:function(T,z,X,b,F,A,u,y,E){const v=X,k=z,L=T.width,D=T.height;let c,p,H,U=0;const s=new Uint8Array(L*D*4);for(H=b;H!==A;H+=F)for(p=u;p!==E;p+=y,U++)c=v[U],s[4*(p+L*H)+3]=255,s[4*(p+L*H)+2]=k[3*c+0],s[4*(p+L*H)+1]=k[3*c+1],s[4*(p+L*H)+0]=k[3*c+2];return s},_getImageData16bits:function(T,z,X,b,F,A,u,y,E){const v=X,k=T.width,L=T.height;let D,c,p,H=0;const U=new Uint8Array(k*L*4);for(p=b;p!==A;p+=F)for(c=u;c!==E;c+=y,H+=2){D=v[H+0]+(v[H+1]<<8);const T=255*((31744&D)>>10)/31|0,z=255*((992&D)>>5)/31|0,X=255*(31&D)/31|0;U[4*(c+k*p)+0]=T,U[4*(c+k*p)+1]=z,U[4*(c+k*p)+2]=X,U[4*(c+k*p)+3]=32768&D?0:255}return U},_getImageData24bits:function(T,z,X,b,F,A,u,y,E){const v=X,k=T.width,L=T.height;let D,c,p=0;const H=new Uint8Array(k*L*4);for(c=b;c!==A;c+=F)for(D=u;D!==E;D+=y,p+=3)H[4*(D+k*c)+3]=255,H[4*(D+k*c)+2]=v[p+0],H[4*(D+k*c)+1]=v[p+1],H[4*(D+k*c)+0]=v[p+2];return H},_getImageData32bits:function(T,z,X,b,F,A,u,y,E){const v=X,k=T.width,L=T.height;let D,c,p=0;const H=new Uint8Array(k*L*4);for(c=b;c!==A;c+=F)for(D=u;D!==E;D+=y,p+=4)H[4*(D+k*c)+2]=v[p+0],H[4*(D+k*c)+1]=v[p+1],H[4*(D+k*c)+0]=v[p+2],H[4*(D+k*c)+3]=v[p+3];return H},_getImageDataGrey8bits:function(T,z,X,b,F,A,u,y,E){const v=X,k=T.width,L=T.height;let D,c,p,H=0;const U=new Uint8Array(k*L*4);for(p=b;p!==A;p+=F)for(c=u;c!==E;c+=y,H++)D=v[H],U[4*(c+k*p)+0]=D,U[4*(c+k*p)+1]=D,U[4*(c+k*p)+2]=D,U[4*(c+k*p)+3]=255;return U},_getImageDataGrey16bits:function(T,z,X,b,F,A,u,y,E){const v=X,k=T.width,L=T.height;let D,c,p=0;const H=new Uint8Array(k*L*4);for(c=b;c!==A;c+=F)for(D=u;D!==E;D+=y,p+=2)H[4*(D+k*c)+0]=v[p+0],H[4*(D+k*c)+1]=v[p+0],H[4*(D+k*c)+2]=v[p+0],H[4*(D+k*c)+3]=v[p+1];return H}};class y{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(T,z,X){const b=new Uint8Array(T.buffer,T.byteOffset,T.byteLength),u=F(b);X(u.width,u.height,z.generateMipMaps,!1,(()=>{A(z,b)}))}}}}]);