"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10442:(A,I,y)=>{y.r(I),y.d(I,{_TGATextureLoader:()=>d});var X=y(1098);function F(A){let I=0;return{id_length:A[I++],colormap_type:A[I++],image_type:A[I++],colormap_index:A[I++]|A[I++]<<8,colormap_length:A[I++]|A[I++]<<8,colormap_size:A[I++],origin:[A[I++]|A[I++]<<8,A[I++]|A[I++]<<8],width:A[I++]|A[I++]<<8,height:A[I++]|A[I++]<<8,pixel_size:A[I++],flags:A[I++]}}function M(A,I){if(I.length<19)return void X.e.Error("Unable to load TGA file - Not enough data to contain header");let y=18;const M=F(I);if(M.id_length+y>I.length)return void X.e.Error("Unable to load TGA file - Not enough data");y+=M.id_length;let d,V=!1,k=!1,U=!1;switch(M.image_type){case 9:V=!0;case 1:k=!0;break;case 10:V=!0;case 2:break;case 11:V=!0;case 3:U=!0}const P=M.pixel_size>>3,f=M.width*M.height*P;let z,l,u,K,x,t,N;if(k&&(z=I.subarray(y,y+=M.colormap_length*(M.colormap_size>>3))),V){let A,X,F;d=new Uint8Array(f);let M=0;const g=new Uint8Array(P);for(;y<f&&M<f;)if(A=I[y++],X=1+(127&A),128&A){for(F=0;F<P;++F)g[F]=I[y++];for(F=0;F<X;++F)d.set(g,M+F*P);M+=P*X}else{for(X*=P,F=0;F<X;++F)d[M+F]=I[y++];M+=X}}else d=I.subarray(y,y+=k?M.width*M.height:f);switch((48&M.flags)>>4){default:case 2:l=0,K=1,N=M.width,u=0,x=1,t=M.height;break;case 0:l=0,K=1,N=M.width,u=M.height-1,x=-1,t=-1;break;case 3:l=M.width-1,K=-1,N=-1,u=0,x=1,t=M.height;break;case 1:l=M.width-1,K=-1,N=-1,u=M.height-1,x=-1,t=-1}const R="_getImageData"+(U?"Grey":"")+M.pixel_size+"bits",Z=g[R](M,z,d,u,x,t,l,K,N);A.getEngine()._uploadDataToTextureDirectly(A,Z)}const g={GetTGAHeader:F,UploadContent:M,_getImageData8bits:function(A,I,y,X,F,M,g,d,V){const k=y,U=I,P=A.width,f=A.height;let z,l,u,K=0;const x=new Uint8Array(P*f*4);for(u=X;u!==M;u+=F)for(l=g;l!==V;l+=d,K++)z=k[K],x[4*(l+P*u)+3]=255,x[4*(l+P*u)+2]=U[3*z+0],x[4*(l+P*u)+1]=U[3*z+1],x[4*(l+P*u)+0]=U[3*z+2];return x},_getImageData16bits:function(A,I,y,X,F,M,g,d,V){const k=y,U=A.width,P=A.height;let f,z,l,u=0;const K=new Uint8Array(U*P*4);for(l=X;l!==M;l+=F)for(z=g;z!==V;z+=d,u+=2){f=k[u+0]+(k[u+1]<<8);const A=255*((31744&f)>>10)/31|0,I=255*((992&f)>>5)/31|0,y=255*(31&f)/31|0;K[4*(z+U*l)+0]=A,K[4*(z+U*l)+1]=I,K[4*(z+U*l)+2]=y,K[4*(z+U*l)+3]=32768&f?0:255}return K},_getImageData24bits:function(A,I,y,X,F,M,g,d,V){const k=y,U=A.width,P=A.height;let f,z,l=0;const u=new Uint8Array(U*P*4);for(z=X;z!==M;z+=F)for(f=g;f!==V;f+=d,l+=3)u[4*(f+U*z)+3]=255,u[4*(f+U*z)+2]=k[l+0],u[4*(f+U*z)+1]=k[l+1],u[4*(f+U*z)+0]=k[l+2];return u},_getImageData32bits:function(A,I,y,X,F,M,g,d,V){const k=y,U=A.width,P=A.height;let f,z,l=0;const u=new Uint8Array(U*P*4);for(z=X;z!==M;z+=F)for(f=g;f!==V;f+=d,l+=4)u[4*(f+U*z)+2]=k[l+0],u[4*(f+U*z)+1]=k[l+1],u[4*(f+U*z)+0]=k[l+2],u[4*(f+U*z)+3]=k[l+3];return u},_getImageDataGrey8bits:function(A,I,y,X,F,M,g,d,V){const k=y,U=A.width,P=A.height;let f,z,l,u=0;const K=new Uint8Array(U*P*4);for(l=X;l!==M;l+=F)for(z=g;z!==V;z+=d,u++)f=k[u],K[4*(z+U*l)+0]=f,K[4*(z+U*l)+1]=f,K[4*(z+U*l)+2]=f,K[4*(z+U*l)+3]=255;return K},_getImageDataGrey16bits:function(A,I,y,X,F,M,g,d,V){const k=y,U=A.width,P=A.height;let f,z,l=0;const u=new Uint8Array(U*P*4);for(z=X;z!==M;z+=F)for(f=g;f!==V;f+=d,l+=2)u[4*(f+U*z)+0]=k[l+0],u[4*(f+U*z)+1]=k[l+0],u[4*(f+U*z)+2]=k[l+0],u[4*(f+U*z)+3]=k[l+1];return u}};class d{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(A,I,y){const X=new Uint8Array(A.buffer,A.byteOffset,A.byteLength),g=F(X);y(g.width,g.height,I.generateMipMaps,!1,(()=>{M(I,X)}))}}}}]);