"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[11],{10409:(d,m,g)=>{g.r(m),g.d(m,{_TGATextureLoader:()=>z});var V=g(1102);function u(d){let m=0;return{id_length:d[m++],colormap_type:d[m++],image_type:d[m++],colormap_index:d[m++]|d[m++]<<8,colormap_length:d[m++]|d[m++]<<8,colormap_size:d[m++],origin:[d[m++]|d[m++]<<8,d[m++]|d[m++]<<8],width:d[m++]|d[m++]<<8,height:d[m++]|d[m++]<<8,pixel_size:d[m++],flags:d[m++]}}function D(d,m){if(m.length<19)return void V.c.Error("Unable to load TGA file - Not enough data to contain header");let g=18;const D=u(m);if(D.id_length+g>m.length)return void V.c.Error("Unable to load TGA file - Not enough data");g+=D.id_length;let z,s=!1,U=!1,X=!1;switch(D.image_type){case 9:s=!0;case 1:U=!0;break;case 10:s=!0;case 2:break;case 11:s=!0;case 3:X=!0}const Y=D.pixel_size>>3,Q=D.width*D.height*Y;let B,i,C,L,O,R,J;if(U&&(B=m.subarray(g,g+=D.colormap_length*(D.colormap_size>>3))),s){let d,V,u;z=new Uint8Array(Q);let D=0;const j=new Uint8Array(Y);for(;g<Q&&D<Q;)if(d=m[g++],V=1+(127&d),128&d){for(u=0;u<Y;++u)j[u]=m[g++];for(u=0;u<V;++u)z.set(j,D+u*Y);D+=Y*V}else{for(V*=Y,u=0;u<V;++u)z[D+u]=m[g++];D+=V}}else z=m.subarray(g,g+=U?D.width*D.height:Q);switch((48&D.flags)>>4){default:case 2:i=0,L=1,J=D.width,C=0,O=1,R=D.height;break;case 0:i=0,L=1,J=D.width,C=D.height-1,O=-1,R=-1;break;case 3:i=D.width-1,L=-1,J=-1,C=0,O=1,R=D.height;break;case 1:i=D.width-1,L=-1,J=-1,C=D.height-1,O=-1,R=-1}const c="_getImageData"+(X?"Grey":"")+D.pixel_size+"bits",A=j[c](D,B,z,C,O,R,i,L,J);d.getEngine()._uploadDataToTextureDirectly(d,A)}const j={GetTGAHeader:u,UploadContent:D,_getImageData8bits:function(d,m,g,V,u,D,j,z,s){const U=g,X=m,Y=d.width,Q=d.height;let B,i,C,L=0;const O=new Uint8Array(Y*Q*4);for(C=V;C!==D;C+=u)for(i=j;i!==s;i+=z,L++)B=U[L],O[4*(i+Y*C)+3]=255,O[4*(i+Y*C)+2]=X[3*B+0],O[4*(i+Y*C)+1]=X[3*B+1],O[4*(i+Y*C)+0]=X[3*B+2];return O},_getImageData16bits:function(d,m,g,V,u,D,j,z,s){const U=g,X=d.width,Y=d.height;let Q,B,i,C=0;const L=new Uint8Array(X*Y*4);for(i=V;i!==D;i+=u)for(B=j;B!==s;B+=z,C+=2){Q=U[C+0]+(U[C+1]<<8);const d=255*((31744&Q)>>10)/31|0,m=255*((992&Q)>>5)/31|0,g=255*(31&Q)/31|0;L[4*(B+X*i)+0]=d,L[4*(B+X*i)+1]=m,L[4*(B+X*i)+2]=g,L[4*(B+X*i)+3]=32768&Q?0:255}return L},_getImageData24bits:function(d,m,g,V,u,D,j,z,s){const U=g,X=d.width,Y=d.height;let Q,B,i=0;const C=new Uint8Array(X*Y*4);for(B=V;B!==D;B+=u)for(Q=j;Q!==s;Q+=z,i+=3)C[4*(Q+X*B)+3]=255,C[4*(Q+X*B)+2]=U[i+0],C[4*(Q+X*B)+1]=U[i+1],C[4*(Q+X*B)+0]=U[i+2];return C},_getImageData32bits:function(d,m,g,V,u,D,j,z,s){const U=g,X=d.width,Y=d.height;let Q,B,i=0;const C=new Uint8Array(X*Y*4);for(B=V;B!==D;B+=u)for(Q=j;Q!==s;Q+=z,i+=4)C[4*(Q+X*B)+2]=U[i+0],C[4*(Q+X*B)+1]=U[i+1],C[4*(Q+X*B)+0]=U[i+2],C[4*(Q+X*B)+3]=U[i+3];return C},_getImageDataGrey8bits:function(d,m,g,V,u,D,j,z,s){const U=g,X=d.width,Y=d.height;let Q,B,i,C=0;const L=new Uint8Array(X*Y*4);for(i=V;i!==D;i+=u)for(B=j;B!==s;B+=z,C++)Q=U[C],L[4*(B+X*i)+0]=Q,L[4*(B+X*i)+1]=Q,L[4*(B+X*i)+2]=Q,L[4*(B+X*i)+3]=255;return L},_getImageDataGrey16bits:function(d,m,g,V,u,D,j,z,s){const U=g,X=d.width,Y=d.height;let Q,B,i=0;const C=new Uint8Array(X*Y*4);for(B=V;B!==D;B+=u)for(Q=j;Q!==s;Q+=z,i+=2)C[4*(Q+X*B)+0]=U[i+0],C[4*(Q+X*B)+1]=U[i+0],C[4*(Q+X*B)+2]=U[i+0],C[4*(Q+X*B)+3]=U[i+1];return C}};class z{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(d,m,g){const V=new Uint8Array(d.buffer,d.byteOffset,d.byteLength),j=u(V);g(j.width,j.height,m.generateMipMaps,!1,(()=>{D(m,V)}))}}}}]);