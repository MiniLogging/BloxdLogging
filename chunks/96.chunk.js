"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[96],{15700:(U,G,C)=>{C.r(G),C.d(G,{FlowGraphSetDelayBlock:()=>T});var L,X=C(14180),l=C(14134),t=C(12721);!function(U){U[U.INIT=0]="INIT",U[U.STARTED=1]="STARTED",U[U.ENDED=2]="ENDED"}(L||(L={}));class E{constructor(U){var G,C;this.onEachCountObservable=new t.e,this.onTimerAbortedObservable=new t.e,this.onTimerEndedObservable=new t.e,this.onStateChangedObservable=new t.e,this._observer=null,this._breakOnNextTick=!1,this._tick=U=>{const G=Date.now();this._timer=G-this._startTime;const C={startTime:this._startTime,currentTime:G,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,hC:U},L=this._breakOnNextTick||this._breakCondition(C);L||this._timer>=this._timeToEnd?this._stop(C,L):this.onEachCountObservable.notifyObservers(C)},this._setState(0),this._contextObservable=U.contextObservable,this._observableParameters=null!==(G=U.observableParameters)&&void 0!==G?G:{},this._breakCondition=null!==(C=U.breakCondition)&&void 0!==C?C:()=>!1,this._timeToEnd=U.timeout,U.onEnded&&this.onTimerEndedObservable.add(U.onEnded),U.yT&&this.onEachCountObservable.add(U.yT),U.onAborted&&this.onTimerAbortedObservable.add(U.onAborted)}set breakCondition(U){this._breakCondition=U}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=U,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(U){this._state=U,this.onStateChangedObservable.notifyObservers(this._state)}_stop(U){let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),G?this.onTimerAbortedObservable.notifyObservers(U):this.onTimerEndedObservable.notifyObservers(U)}}var K=C(12731),P=C(12850),O=C(14130);class T extends X.b{constructor(U){super(U),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",l.y),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",l.k,new O.c(-1))}_preparePendingTasks(U){const G=this.duration.getValue(U);if(G<0||isNaN(G)||!isFinite(G))return this._reportError(U,"Invalid duration in SetDelay block");if(U._getGlobalContextVariable("activeDelays",0)>=T.MaxParallelDelayCount)return this._reportError(U,"Max parallel delays reached");const C=U._getGlobalContextVariable("lastDelayIndex",-1),L=U._getExecutionVariable(this,"pendingDelays",[]),X=U.configuration.HG,l=new E({timeout:1e3*G,contextObservable:X.onBeforeRenderObservable,onEnded:()=>this._onEnded(l,U)});l.start();const t=C+1;this.lastDelayIndex.setValue(new O.c(t),U),U._setGlobalContextVariable("lastDelayIndex",t),L[t]=l,U._setExecutionVariable(this,"pendingDelays",L),this._updateGlobalTimers(U)}_cancelPendingTasks(U){const G=U._getExecutionVariable(this,"pendingDelays",[]);for(const C of G)null===C||void 0===C||C.dispose();U._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new O.c(-1),U),this._updateGlobalTimers(U)}_execute(U,G){G!==this.cancel?(this._preparePendingTasks(U),this.out._activateSignal(U)):this._cancelPendingTasks(U)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(U,G){const C=G._getExecutionVariable(this,"pendingDelays",[]),L=C.indexOf(U);-1!==L?C.splice(L,1):K.d.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),G._removePendingBlock(this),this.done._activateSignal(G),this._updateGlobalTimers(G)}_updateGlobalTimers(U){const G=U._getExecutionVariable(this,"pendingDelays",[]),C=U._getGlobalContextVariable("pendingDelays",[]);for(let L=0;L<G.length;L++){if(!G[L])continue;const U=G[L];C[L]&&C[L]!==U?K.d.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):C[L]=U}U._setGlobalContextVariable("pendingDelays",C)}}T.MaxParallelDelayCount=100,(0,P.e)("FlowGraphSetDelayBlock",T)}}]);