"use strict";(self["7c63p8lin4r"]=self["7c63p8lin4r"]||[]).push([[96],{15758:(z,u,U)=>{U.r(u),U.d(u,{FlowGraphSetDelayBlock:()=>d});var J,v=U(14245),f=U(14196),g=U(12756);!function(z){z[z.INIT=0]="INIT",z[z.STARTED=1]="STARTED",z[z.ENDED=2]="ENDED"}(J||(J={}));class w{constructor(z){var u,U;this.onEachCountObservable=new g.e,this.onTimerAbortedObservable=new g.e,this.onTimerEndedObservable=new g.e,this.onStateChangedObservable=new g.e,this._observer=null,this._breakOnNextTick=!1,this._tick=z=>{const u=Date.now();this._timer=u-this._startTime;const U={startTime:this._startTime,currentTime:u,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,rU:z},J=this._breakOnNextTick||this._breakCondition(U);J||this._timer>=this._timeToEnd?this._stop(U,J):this.onEachCountObservable.notifyObservers(U)},this._setState(0),this._contextObservable=z.contextObservable,this._observableParameters=null!==(u=z.observableParameters)&&void 0!==u?u:{},this._breakCondition=null!==(U=z.breakCondition)&&void 0!==U?U:()=>!1,this._timeToEnd=z.timeout,z.onEnded&&this.onTimerEndedObservable.add(z.onEnded),z.sd&&this.onEachCountObservable.add(z.sd),z.onAborted&&this.onTimerAbortedObservable.add(z.onAborted)}set breakCondition(z){this._breakCondition=z}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=z,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(z){this._state=z,this.onStateChangedObservable.notifyObservers(this._state)}_stop(z){let u=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),u?this.onTimerAbortedObservable.notifyObservers(z):this.onTimerEndedObservable.notifyObservers(z)}}var P=U(12760),R=U(12875),S=U(14192);class d extends v.e{constructor(z){super(z),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",f.x),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",f.l,new S.e(-1))}_preparePendingTasks(z){const u=this.duration.getValue(z);if(u<0||isNaN(u)||!isFinite(u))return this._reportError(z,"Invalid duration in SetDelay block");if(z._getGlobalContextVariable("activeDelays",0)>=d.MaxParallelDelayCount)return this._reportError(z,"Max parallel delays reached");const U=z._getGlobalContextVariable("lastDelayIndex",-1),J=z._getExecutionVariable(this,"pendingDelays",[]),v=z.configuration.ru,f=new w({timeout:1e3*u,contextObservable:v.onBeforeRenderObservable,onEnded:()=>this._onEnded(f,z)});f.start();const g=U+1;this.lastDelayIndex.setValue(new S.e(g),z),z._setGlobalContextVariable("lastDelayIndex",g),J[g]=f,z._setExecutionVariable(this,"pendingDelays",J),this._updateGlobalTimers(z)}_cancelPendingTasks(z){const u=z._getExecutionVariable(this,"pendingDelays",[]);for(const U of u)null===U||void 0===U||U.dispose();z._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new S.e(-1),z),this._updateGlobalTimers(z)}_execute(z,u){u!==this.cancel?(this._preparePendingTasks(z),this.out._activateSignal(z)):this._cancelPendingTasks(z)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(z,u){const U=u._getExecutionVariable(this,"pendingDelays",[]),J=U.indexOf(z);-1!==J?U.splice(J,1):P.d.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),u._removePendingBlock(this),this.done._activateSignal(u),this._updateGlobalTimers(u)}_updateGlobalTimers(z){const u=z._getExecutionVariable(this,"pendingDelays",[]),U=z._getGlobalContextVariable("pendingDelays",[]);for(let J=0;J<u.length;J++){if(!u[J])continue;const z=u[J];U[J]&&U[J]!==z?P.d.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):U[J]=z}z._setGlobalContextVariable("pendingDelays",U)}}d.MaxParallelDelayCount=100,(0,R.f)("FlowGraphSetDelayBlock",d)}}]);