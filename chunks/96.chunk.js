"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[96],{14352:(g,w,q)=>{q.r(w),q.d(w,{FlowGraphSetDelayBlock:()=>m});var R,o=q(12877),r=q(12836),S=q(10998);!function(g){g[g.INIT=0]="INIT",g[g.STARTED=1]="STARTED",g[g.ENDED=2]="ENDED"}(R||(R={}));class i{constructor(g){this.onEachCountObservable=new S.b,this.onTimerAbortedObservable=new S.b,this.onTimerEndedObservable=new S.b,this.onStateChangedObservable=new S.b,this._observer=null,this._breakOnNextTick=!1,this._tick=g=>{const w=Date.now();this._timer=w-this._startTime;const q={startTime:this._startTime,currentTime:w,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:g},R=this._breakOnNextTick||this._breakCondition(q);R||this._timer>=this._timeToEnd?this._stop(q,R):this.onEachCountObservable.notifyObservers(q)},this._setState(0),this._contextObservable=g.contextObservable,this._observableParameters=g.observableParameters??{},this._breakCondition=g.breakCondition??(()=>!1),this._timeToEnd=g.timeout,g.onEnded&&this.onTimerEndedObservable.add(g.onEnded),g.Vt&&this.onEachCountObservable.add(g.Vt),g.onAborted&&this.onTimerAbortedObservable.add(g.onAborted)}set breakCondition(g){this._breakCondition=g}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=g,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(g){this._state=g,this.onStateChangedObservable.notifyObservers(this._state)}_stop(g){let w=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),w?this.onTimerAbortedObservable.notifyObservers(g):this.onTimerEndedObservable.notifyObservers(g)}}var T=q(11011),z=q(11128),t=q(12828);class m extends o.b{constructor(g){super(g),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",r.w),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",r.l,new t.b(-1))}_preparePendingTasks(g){const w=this.duration.getValue(g);if(w<0||isNaN(w)||!isFinite(w))return this._reportError(g,"Invalid duration in SetDelay block");if(g._getGlobalContextVariable("activeDelays",0)>=m.MaxParallelDelayCount)return this._reportError(g,"Max parallel delays reached");const q=g._getGlobalContextVariable("lastDelayIndex",-1),R=g._getExecutionVariable(this,"pendingDelays",[]),o=g.configuration.Aw,r=new i({timeout:1e3*w,contextObservable:o.onBeforeRenderObservable,onEnded:()=>this._onEnded(r,g)});r.start();const S=q+1;this.lastDelayIndex.setValue(new t.b(S),g),g._setGlobalContextVariable("lastDelayIndex",S),R[S]=r,g._setExecutionVariable(this,"pendingDelays",R),this._updateGlobalTimers(g)}_cancelPendingTasks(g){const w=g._getExecutionVariable(this,"pendingDelays",[]);for(const q of w)null===q||void 0===q||q.dispose();g._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new t.b(-1),g),this._updateGlobalTimers(g)}_execute(g,w){w!==this.cancel?(this._preparePendingTasks(g),this.out._activateSignal(g)):this._cancelPendingTasks(g)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(g,w){const q=w._getExecutionVariable(this,"pendingDelays",[]),R=q.indexOf(g);-1!==R?q.splice(R,1):T.d.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),w._removePendingBlock(this),this.done._activateSignal(w),this._updateGlobalTimers(w)}_updateGlobalTimers(g){const w=g._getExecutionVariable(this,"pendingDelays",[]),q=g._getGlobalContextVariable("pendingDelays",[]);for(let R=0;R<w.length;R++){if(!w[R])continue;const g=w[R];q[R]&&q[R]!==g?T.d.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):q[R]=g}g._setGlobalContextVariable("pendingDelays",q)}}m.MaxParallelDelayCount=100,(0,z.g)("FlowGraphSetDelayBlock",m)}}]);