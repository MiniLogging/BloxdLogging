"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[96],{15907:(L,U,x)=>{x.r(U),x.d(U,{FlowGraphSetDelayBlock:()=>h});var mL,p=x(14396),G=x(14348),F=x(12391);!function(L){L[L.INIT=0]="INIT",L[L.STARTED=1]="STARTED",L[L.ENDED=2]="ENDED"}(mL||(mL={}));class a{constructor(L){this.onEachCountObservable=new F.c,this.onTimerAbortedObservable=new F.c,this.onTimerEndedObservable=new F.c,this.onStateChangedObservable=new F.c,this._observer=null,this._breakOnNextTick=!1,this._tick=L=>{const U=Date.now();this._timer=U-this._startTime;const x={startTime:this._startTime,currentTime:U,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,Hx:L},mL=this._breakOnNextTick||this._breakCondition(x);mL||this._timer>=this._timeToEnd?this._stop(x,mL):this.onEachCountObservable.notifyObservers(x)},this._setState(0),this._contextObservable=L.contextObservable,this._observableParameters=L.observableParameters??{},this._breakCondition=L.breakCondition??(()=>!1),this._timeToEnd=L.timeout,L.onEnded&&this.onTimerEndedObservable.add(L.onEnded),L.Tr&&this.onEachCountObservable.add(L.Tr),L.onAborted&&this.onTimerAbortedObservable.add(L.onAborted)}set breakCondition(L){this._breakCondition=L}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=L,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(L){this._state=L,this.onStateChangedObservable.notifyObservers(this._state)}_stop(L){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),U?this.onTimerAbortedObservable.notifyObservers(L):this.onTimerEndedObservable.notifyObservers(L)}}var o=x(12406),A=x(12547),r=x(14343);class h extends p.c{constructor(L){super(L),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",G.u),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",G.i,new r.b(-1))}_preparePendingTasks(L){const U=this.duration.getValue(L);if(U<0||isNaN(U)||!isFinite(U))return this._reportError(L,"Invalid duration in SetDelay block");if(L._getGlobalContextVariable("activeDelays",0)>=h.MaxParallelDelayCount)return this._reportError(L,"Max parallel delays reached");const x=L._getGlobalContextVariable("lastDelayIndex",-1),mL=L._getExecutionVariable(this,"pendingDelays",[]),p=L.configuration.VU,G=new a({timeout:1e3*U,contextObservable:p.onBeforeRenderObservable,onEnded:()=>this._onEnded(G,L)});G.start();const F=x+1;this.lastDelayIndex.setValue(new r.b(F),L),L._setGlobalContextVariable("lastDelayIndex",F),mL[F]=G,L._setExecutionVariable(this,"pendingDelays",mL),this._updateGlobalTimers(L)}_cancelPendingTasks(L){const U=L._getExecutionVariable(this,"pendingDelays",[]);for(const x of U)null===x||void 0===x||x.dispose();L._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new r.b(-1),L),this._updateGlobalTimers(L)}_execute(L,U){U!==this.cancel?(this._preparePendingTasks(L),this.out._activateSignal(L)):this._cancelPendingTasks(L)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(L,U){const x=U._getExecutionVariable(this,"pendingDelays",[]),mL=x.indexOf(L);-1!==mL?x.splice(mL,1):o.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),U._removePendingBlock(this),this.done._activateSignal(U),this._updateGlobalTimers(U)}_updateGlobalTimers(L){const U=L._getExecutionVariable(this,"pendingDelays",[]),x=L._getGlobalContextVariable("pendingDelays",[]);for(let mL=0;mL<U.length;mL++){if(!U[mL])continue;const L=U[mL];x[mL]&&x[mL]!==L?o.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):x[mL]=L}L._setGlobalContextVariable("pendingDelays",x)}}h.MaxParallelDelayCount=100,(0,A.d)("FlowGraphSetDelayBlock",h)}}]);