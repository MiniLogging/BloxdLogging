"use strict";(self["80dd64vgxnn"]=self["80dd64vgxnn"]||[]).push([[96],{15848:(mm,o,u)=>{u.r(o),u.d(o,{FlowGraphSetDelayBlock:()=>Y});var f,B=u(14299),O=u(14257),r=u(12556);!function(mm){mm[mm.INIT=0]="INIT",mm[mm.STARTED=1]="STARTED",mm[mm.ENDED=2]="ENDED"}(f||(f={}));class w{constructor(mm){this.onEachCountObservable=new r.d,this.onTimerAbortedObservable=new r.d,this.onTimerEndedObservable=new r.d,this.onStateChangedObservable=new r.d,this._observer=null,this._breakOnNextTick=!1,this._tick=mm=>{const o=Date.now();this._timer=o-this._startTime;const u={startTime:this._startTime,currentTime:o,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,Ju:mm},f=this._breakOnNextTick||this._breakCondition(u);f||this._timer>=this._timeToEnd?this._stop(u,f):this.onEachCountObservable.notifyObservers(u)},this._setState(0),this._contextObservable=mm.contextObservable,this._observableParameters=mm.observableParameters??{},this._breakCondition=mm.breakCondition??(()=>!1),this._timeToEnd=mm.timeout,mm.onEnded&&this.onTimerEndedObservable.add(mm.onEnded),mm.WY&&this.onEachCountObservable.add(mm.WY),mm.onAborted&&this.onTimerAbortedObservable.add(mm.onAborted)}set breakCondition(mm){this._breakCondition=mm}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let mm=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=mm,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(mm){this._state=mm,this.onStateChangedObservable.notifyObservers(this._state)}_stop(mm){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),o?this.onTimerAbortedObservable.notifyObservers(mm):this.onTimerEndedObservable.notifyObservers(mm)}}var p=u(12565),K=u(12702),z=u(14255);class Y extends B.c{constructor(mm){super(mm),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",O.r),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",O.j,new z.d(-1))}_preparePendingTasks(mm){const o=this.duration.getValue(mm);if(o<0||isNaN(o)||!isFinite(o))return this._reportError(mm,"Invalid duration in SetDelay block");if(mm._getGlobalContextVariable("activeDelays",0)>=Y.MaxParallelDelayCount)return this._reportError(mm,"Max parallel delays reached");const u=mm._getGlobalContextVariable("lastDelayIndex",-1),f=mm._getExecutionVariable(this,"pendingDelays",[]),B=mm.configuration.bo,O=new w({timeout:1e3*o,contextObservable:B.onBeforeRenderObservable,onEnded:()=>this._onEnded(O,mm)});O.start();const r=u+1;this.lastDelayIndex.setValue(new z.d(r),mm),mm._setGlobalContextVariable("lastDelayIndex",r),f[r]=O,mm._setExecutionVariable(this,"pendingDelays",f),this._updateGlobalTimers(mm)}_cancelPendingTasks(mm){const o=mm._getExecutionVariable(this,"pendingDelays",[]);for(const u of o)null===u||void 0===u||u.dispose();mm._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new z.d(-1),mm),this._updateGlobalTimers(mm)}_execute(mm,o){o!==this.cancel?(this._preparePendingTasks(mm),this.out._activateSignal(mm)):this._cancelPendingTasks(mm)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(mm,o){const u=o._getExecutionVariable(this,"pendingDelays",[]),f=u.indexOf(mm);-1!==f?u.splice(f,1):p.e.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),o._removePendingBlock(this),this.done._activateSignal(o),this._updateGlobalTimers(o)}_updateGlobalTimers(mm){const o=mm._getExecutionVariable(this,"pendingDelays",[]),u=mm._getGlobalContextVariable("pendingDelays",[]);for(let f=0;f<o.length;f++){if(!o[f])continue;const mm=o[f];u[f]&&u[f]!==mm?p.e.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):u[f]=mm}mm._setGlobalContextVariable("pendingDelays",u)}}Y.MaxParallelDelayCount=100,(0,K.c)("FlowGraphSetDelayBlock",Y)}}]);