"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[60],{14385:(V,I,m)=>{m.r(I),m.d(I,{FlowGraphStopAnimationBlock:()=>k});var C=m(12899),l=m(11048),s=m(11085),F=m(12932);class k extends F.c{constructor(V){super(V),this.animationGroup=this.registerDataInput("animationGroup",C.b),this.stopAtFrame=this.registerDataInput("stopAtFrame",C.r,-1)}_preparePendingTasks(V){const I=this.animationGroup.getValue(V),m=this.stopAtFrame.getValue(V)??-1,C=V._getGlobalContextVariable("pendingStopAnimations",[]);C.push({uniqueId:I.uniqueId,stopAtFrame:m}),V._setGlobalContextVariable("pendingStopAnimations",C)}_cancelPendingTasks(V){const I=this.animationGroup.getValue(V),m=V._getGlobalContextVariable("pendingStopAnimations",[]);for(let C=0;C<m.length;C++)if(m[C].uniqueId===I.uniqueId){m.splice(C,1),V._setGlobalContextVariable("pendingStopAnimations",m);break}}_execute(V){const I=this.animationGroup.getValue(V),m=this.stopAtFrame.getValue(V)??-1;return I?isNaN(m)?this._reportError(V,"Invalid stop time."):(m>0?this._startPendingTasks(V):this._stopAnimation(I,V),void this.out._activateSignal(V)):(s.d.Warn("No animation group provided to stop."),this._reportError(V,"No animation group provided to stop."))}_executeOnTick(V){const I=this.animationGroup.getValue(V),m=V._getGlobalContextVariable("pendingStopAnimations",[]);for(let C=0;C<m.length;C++)if(m[C].uniqueId===I.uniqueId&&I.getCurrentFrame()>=m[C].stopAtFrame){this._stopAnimation(I,V),m.splice(C,1),V._setGlobalContextVariable("pendingStopAnimations",m),this.done._activateSignal(V),V._removePendingBlock(this);break}}getClassName(){return"FlowGraphStopAnimationBlock"}_stopAnimation(V,I){const m=I._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),C=m.indexOf(V.uniqueId);-1!==C&&(V.stop(),m.splice(C,1),I._setGlobalContextVariable("currentlyRunningAnimationGroups",m))}}(0,l.h)("FlowGraphStopAnimationBlock",k)}}]);